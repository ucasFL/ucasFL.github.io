[{"title":"无题","date":"2017-12-14T14:10:33.000Z","path":"2017/12/14/One-year/","text":"再过三天，博客就一周年了这一年以来，好像也没能够写出什么有意义的东西也许当时只是觉得一个独立博客大概是一个程序员的标志吧 博客正式上线是 2016 年 12 月 17 日也就是去年四六级考试那天 这一年，博客也发生过许多变化主题从最开始的 yilia 换到了 next今天三月份购买了一个域名从此使用上了独立域名评论系统多次变更上月通过 Cloudflare 将域名上 https… 原本打算在 17 日那天好好写一篇博客来记录一下博客这一年以来的变化却突然改在今天一切都是意料之外而对于博客这一年以来的变化也只是只言片语的带过 最近学习上又遇到了瓶颈很多事情要干但什么也感觉不会什么也做不下去 时隔一周又和女朋友吵架了爱情带给人的不仅仅只有甜蜜还有很多很多包括痛苦 梦碎了梦醒了生活还得继续谁不是被生活赶着走 最近越来越宅越来越不喜欢接触外面的热闹也越来越不会说话连胡说八道都不知道该说什么了 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Xrandr-一个可以设置屏幕分辨率的 Linux 命令","date":"2017-12-09T16:53:10.000Z","path":"2017/12/10/Linux-commands-of-xrandr/","text":"一个可以设置屏幕分辨率的 Linux 命令。 123 xrandr : 显示系统支持的所有分辨率xrandr -s 0 : 设置为系统默认分辨率xrandr -s arg : 设置具体分辨率,如 xrandr -s 1024x768 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"使用 Tensorflow 实现神经网络","date":"2017-11-12T04:09:50.000Z","path":"2017/11/12/an-introduction-to-implementing-neural-networks-using-tensorflow/","text":"简介 如果你一直关注数据科学/机器学习，那么你肯定知道目前深度学习和神经网络非常流行。许多组织/公司都想要雇佣精通深度学习技能的人。从商业竞争到开源项目和支付高额薪水，人们在尝试一切可能的方法来挖掘这一有限的人才。自我驱动的工程师正被汽车工业中的利器所追逐，因为汽车工业正处于近几十年来最大的破坏边缘！ 如果你对深度学习的前景感到兴奋，但还没有开始你的旅途，那么我将会开启你的旅程。从这篇文章开始，我将会写一系列关于深度学习的文章，包括最受欢迎的深度学习库和它们的实现。 在这篇文章中，我将会向你介绍 Tensorflow。读完这篇文章以后，你将会了解神经网络的应用，并且能够使用 TensorFlow 来解决实际生活中的问题。阅读本文前，你需要了解神经网络的基本知识并且对编程比较熟悉。虽然本文中使用的语言是 Python，但我关注得更多的是概念，并且尽可能保持语言的不可知性。 让我们开始吧！ 何时使用神经网络？ 神经网络成为人们的关注点已经有很长的一段时间了。如果你想了解关于神经网络和深度学习的更详细的解释，请阅读这篇文章。它的 “depper” 版本在图像识别、语音和自然语言处理等许多领域都取得了巨大的突破。 最主要的问题是什么时候使用神经网络，什么时候不用？这个领域就像现在的金矿一样，每天都会有许多新的发现。为了成为一个“淘金热”分子，你需要记住下面这些事情： 首先，神经网络需要清晰而详实的数据（主要是大数据）来进行训练。如果把神经网络想象成一个孩子，他首先需要观察他的父母如何走路，然后尝试独立行走，用他的每一步，学会如何来完成一个特定的任务。他可能会跌倒几次，但经过几次失败的尝试，他便学会了如何走路。如果你不让他自己尝试，那么他可能永远也不能学会走路。你给他接触的越多，那么他就会学得越好。 使用神经网络来处理一些复杂的问题，比如图像处理是明智的。神经网络属于一类称为表示学习算法的算法类。这些算法将复杂的问题分解成简单的形式，从而使它们能够理解（或“表示“）。就像你在吃东西的时候，需要先把食物嚼碎，然后才咽下。这比传统（非表示学习）算法更加困难。 什么时候你能够拥有合适的神经网络来解决问题？每个问题都有它的困难之处。所以，数据决定了解决问题的方式。比如，如果问题是序列生成，那么递归神经网络更加合适。然而，如果是图像相关的问题，那么改用卷积神经网络会更好。 最后，但不是不重要，硬件需求对于运行一个深度神经网络模型是至关重要的。神经网络模型在很早之前就有了，但是在近些年才开始活跃起来，主要原因就是计算资源更好，更强大了。如果你想用神经网络来解决现实生活中的问题，请准备购买一些高端的硬件设备。 使用神经网络来解决问题的通常手段 神经网络是一种特殊的机器学习（ML）算法。就像每一个机器学习算法一样，你需要按照通常的机器学习工作流程来进行数据预处理，模型建立和模型评估。为了简单起见，我在下面列出了一个处理神经网络问题的清单： 思考一下，使用神经网络算法来处理该问题是否比用传统算法更好（参考上面章节的清单） 调查一下，待解决的问题使用哪种神经网络更适合 使用你选择的语言/库来定义神经网络结构 将数据转化为正确的格式并进行数据划分 根据你的需要对数据进行预处理 添加数据来增大数据量从而更好的训练模型 将数据”喂给”神经网络进行训练 训练并监测训练过程中的变化和验证数据集的变化 测试你的模型，并将它保存下来以便将来使用 在这篇文章中，我将重点放在图像数据上。所以在开始探讨 TensorFlow 之前，让我们先理解一下图像数据。 图像数据以及常用于解决图像问题的库 图像数据通常以三维数据的形式排序，每一维分别代表高、宽和颜色通道。比如，此时你在你的电脑上截一张图，它将会先转化为一个三维数组，然后再压缩成 .jpeg 或 .png 文件格式。 虽然这些图像对于人类来说很容易理解，但是计算机却很难理解它们。这种现象被称为“语义鸿沟”。我们的大脑能够在几秒钟的时间内看到图像并理解完整的图像，然而，计算机却只是把图像看成一组数字。所以问题是如何向计算机解释图片？ 在早期时候，人们试图将图像分解成机器“可理解”的形式，就像一个模板一样。比如，人脸总是有一种特定的结构，这种结构在每个人中都有一定的保留，例如眼睛、鼻子或脸的形状。但是这种方法很乏味，因为当要识别的对象数量增加时，“模板”就不能保存了。 快速前进到 2012 年，一个深度神经网络赢得了 ImageNet 挑战，这是一个根据自然场景来识别对象的著名挑战。在所有随即到来的 ImageNet 挑战中，它持续占领统治地位，从而证明了用它来解决图像问题的有用性。 所以，人们通常使用哪种语言（库）来解决图像识别问题呢？在一个最近的调查中，我发现绝大多数受欢迎的深度学习库都有 Python 接口，紧跟着的是 Lua、Java 和 Matlab 。下面是一些最受欢迎的库： Caffe DeepLearning4j TensorFlow Theano Torch 现在，你已经知道了一张图像是如何存储的，并且知道了常用的库。下面，让我们来看一下 TensorFlow 能够为我们提供什么。 TensorFlow 是什么？ 我们先看一下官方的定义： “TensorFlow 是一个使用数据流图来进行数值计算的开源软件库。图中的节点表示数学运算，而图中的边表示在节点之间进行传递的多维数据数组（又叫做张量）。灵活的架构允许你在桌面、服务器或移动设备上通过一个单一的 API 使用一个或多个 CPU 或 GPU 部署进行计算。” 如果这听起来很让人迷糊，别担心，下面是我的简单定义：你可以简单的把 TensorFlow 看成一个扭曲的 numpy。如果你过去接触过 numpy，那么理解 TensorFlow 就非常简单了。numpy 和 TensorFlow 之间最主要的区别就是 TensorFLow 使用一种惰性的编程范式。它首先搭建一个把所有操作都定义好了的图，然后，当一个“会话“被调用时，它就会开始”运行“这个图。这个图是可扩展的，只需要改变内部张量（又叫做多维数组）的数据表示即可。构建计算图可以看作是使用 TensorFlow 的主要工作。如果想了解更多关于计算图的数学组成，请阅读这篇文章。 我们很容易把 TensorFlow 归为一个神经网络库，但它不仅仅是这样。的确，它是一个非常强大的神经网络库。但是，它还能够做更多的事情。你可以使用它来构建其他机器学习算法，比如决策树或 K-近邻算法。你可以用它来完成任何你通常用 numpy 来完成的事情。因此它又被形象地称为 “NumPy 类固醇”。 使用 TensorFlow 的优点有： 它具有一个直观的结构。顾名思义它具有”张量流“。你可以轻松的可视化图的每一个部分。 对于分布式计算，很容易在 CPU/GPU 上面进行训练。 平台灵活性。你可以在任何地方运行你的模型，移动设备、服务器或 PC 。 一个典型的 TensorFlow ”流“ 每个库都有自己的”实现细节“，即一种遵循其编码范式的编写方式。例如，在实现 scikit-learn 时，你首先创建一个需要的算法对象，然后构建一个训练模型，进而对测试集进行预测，看起来就像下面这样： 123456 # 定义机器学习算法的 hyperparamtersclf = svm.SVC(gamma=0.001, C=100.)# 训练clf.fit(X, y)# 测试clf.predict(X_test) 正如前面说过的，TensorFlow 遵循一种惰性的编程范式。在 TensorFlow 中运行一个程序的通常工作流如下： 构建一个计算图，它可以是 TensorFlow 支持的任意一种数学操作。 初始化变量，编译之前定义的变量 创建会话，这是魔法开始的地方 在会话中运行图，编译后的图传到会话中，然后会话开始执行 关闭会话 TensorFlow 中使用的几个术语： 1 占位符：一种将数据输入图表的方法 1 feed_dict: 一个将数组传递给计算图的字典 让我们写一个小程序并添加两个数字！ 12345678910111213141516171819 # 导入 TensorFlowimport tensorflow as tf# 搭建计算图a = tf.placeholder(tf.int16)b = tf.placeholder(tf.int16)addition = tf.add(a, b)# 初始化变量init = tf.initialize_all_variables()# 创建会话并运行图with tf.Session() as sess: sess.run(init) print \"Addition: %i\" % sess.run(addition, feed_dict=&#123;a: 2, b: 3&#125;)# 关闭会话sess.close() 在 TensorFlow 中实现神经网络 注意：我们可以使用不同的神经网络结构来解决问题，但为了简单起见，在这儿，我们致力于一个前馈多层感知机的深层实现。 让我们首先记住我们学到的关于神经网络的知识。 一个典型的神经网络实现如下： 定义需要编译的神经网络结构 将数据传输到模型 在后台，数据首先被分成批，以便进行摄取，首先对批数据进行预处理，扩充，然后送入神经网络进行训练 神经网络模型进行增量训练 在特定时间显示准确率 训练过后，保存模型，以便日后再次使用 用新数据测试模型并检查它是如何执行的 在这儿，我们解决深度学习实践问题 - 识别数字。让我们先看一下问题陈述。 这是一个图像识别问题，从一个给定的 28x28 的图像中识别数字。我们将所有图像的一个子集用于训练，剩余部分用于测试模型。首先，下载训练和测试文件。数据集包含一个所有图像的压缩文件，以及名字和训练/测试图像相对应的 train.csv 和 test.csv 文件。在数据集中没有提供任何额外的特征，只提供了 .png 格式的原始图像。 正如你所知道的，我们将使用 TensorFlow 来搭建一个神经网络模型。所以你首先需要在你的系统上安装 TensorFlow。请参考官方安装指南，根据你的系统进行安装。 我们将按照上面描述的步骤来搭建神经网络。首先，使用 Python 2.7 核来创建一个 Jupyter notebook，后续步骤如下： 首先导入所有需要的模块： 1234567 # pylab inlineimport osimport numpy as npimport pandas as pdfrom scipy.misc import imreadfrom sklearn.metrics import accuracy_scoreimport tensorflow as tf 让我们设置一个种子值，从而我们能够控制模型的随机性 123 # To stop potential randomnessseed = 128rng = np.random.RandomState(seed) 第一步是设置目录路径，以便安全保存！ 12345678 root_dir = os.path.abspath('../..')data_dir = os.path.join(root_dir, 'data')sub_dir = os.path.join(root_dir, 'sub')# check for existenceos.path.exists(root_dir)os.path.exists(data_dir)os.path.exists(sub_dir) 现在，让我们读入数据集。数据集是 .csv 文件格式的，并且有一个伴有合适标签的名字。 123456 train = pd.read_csv(os.path.join(data_dir, 'Train', 'train.csv'))test = pd.read_csv(os.path.join(data_dir, 'Test.csv'))sample_submission = pd.read_csv(os.path.join(data_dir, 'Sample_Submission.csv'))train.head() 文件名 标签 0 0.png 4 1 1.png 9 2 2.png 1 3 3.png 7 4 4.png 3 让我们看一下我们的数据长什么样！读取图片并显示： 12345678 img_name = rng.choice(train.filename)filepath = os.path.join(data_dir, 'Train', 'Images', 'train', img_name)img = imread(filepath, flatten=True)pylab.imshow(img, cmap='gray')pylab.axis('off')pylab.show() 上面的图片表示为 numpy 数组，就是下面这样： 为了使数据操作更简单，我们把所有图像存为 numpy 数组： 1234567891011121314151617 temp = []for img_name in train.filename: image_path = os.path.join(data_dir, 'Train', 'Images', 'train', img_name) img = imread(image_path, flatten=True) img = img.astype('float32') temp.append(img) train_x = np.stack(temp)temp = []for img_name in test.filename: image_path = os.path.join(data_dir, 'Train', 'Images', 'test', img_name) img = imread(image_path, flatten=True) img = img.astype('float32') temp.append(img) test_x = np.stack(temp) 因为这是一个典型的机器学习问题，为了测试模型的正常功能，我们需要创建一个验证集。我们将数据按 7:3 分为训练集和验证集。 1234 split_size = int(train_x.shape[0]*0.7)train_x, val_x = train_x[:split_size], train_x[split_size:]train_y, val_y = train.label.values[:split_size], train.label.values[split_size:] 现在，在程序中定义一些我们在后面将会用到的有用函数： 123456789101112131415161718192021222324252627 def dense_to_one_hot(labels_dense, num_classes=10): \"\"\"Convert class labels from scalars to one-hot vectors\"\"\" num_labels = labels_dense.shape[0] index_offset = np.arange(num_labels) * num_classes labels_one_hot = np.zeros((num_labels, num_classes)) labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1 return labels_one_hotdef preproc(unclean_batch_x): \"\"\"Convert values to range 0-1\"\"\" temp_batch = unclean_batch_x / unclean_batch_x.max() return temp_batchdef batch_creator(batch_size, dataset_length, dataset_name): \"\"\"Create batch with random samples and return appropriate format\"\"\" batch_mask = rng.choice(dataset_length, batch_size) batch_x = eval(dataset_name + '_x')[[batch_mask]].reshape(-1, input_num_units) batch_x = preproc(batch_x) if dataset_name == 'train': batch_y = eval(dataset_name).ix[batch_mask, 'label'].values batch_y = dense_to_one_hot(batch_y) return batch_x, batch_y 现在，到了主要部分。让我们首先来定义神经网络的结构。我们定义一个三层神经网络：输入层、隐含层和输出层。输入层和输出层的神经元数目是固定的，因为输入就是一个 28x28 的图像，输出就是一个 10x1 的表示类别的向量。在隐含层中，我们设置 500 个神经元，这个数目可以根据你的需要来设置。同时，我们也需要对其余变量赋值。阅读神经网络基础这篇文章来深入了解它是如何工作的。 123456789101112131415161718192021222324252627 ### set all variables# number of neurons in each layerinput_num_units = 28*28hidden_num_units = 500output_num_units = 10# define placeholdersx = tf.placeholder(tf.float32, [None, input_num_units])y = tf.placeholder(tf.float32, [None, output_num_units])# set remaining variablesepochs = 5batch_size = 128learning_rate = 0.01### define weights and biases of the neural network (refer this article if you don't understand the terminologies)weights = &#123; 'hidden': tf.Variable(tf.random_normal([input_num_units, hidden_num_units], seed=seed)), 'output': tf.Variable(tf.random_normal([hidden_num_units, output_num_units], seed=seed))&#125;biases = &#123; 'hidden': tf.Variable(tf.random_normal([hidden_num_units], seed=seed)), 'output': tf.Variable(tf.random_normal([output_num_units], seed=seed))&#125; 现在，开始创建神经网络计算图： 1234 hidden_layer = tf.add(tf.matmul(x, weights['hidden']), biases['hidden'])hidden_layer = tf.nn.relu(hidden_layer)output_layer = tf.matmul(hidden_layer, weights['output']) + biases['output'] 我们也需要定义神经网络的损失（cost）： 1 cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output_layer, y)) 设置优化算法，比如后向传播算法（BP 算法）。在这儿，我们使用 Adam，这是一个高效的梯度下降算法的变种。在 TensorFlow 中还有许多可用的优化算法（参考这儿） 1 optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost) 定义好神经网络结构之后，初始化所有变量： 1 init = tf.initialize_all_variables() 现在，创建一个会话，在会话中运行我们的神经网络。同时，使用我们已经创建好的验证集来验证我们的模型： 12345678910111213141516171819202122232425262728293031 with tf.Session() as sess: # create initialized variables sess.run(init) ### for each epoch, do: ### for each batch, do: ### create pre-processed batch ### run optimizer by feeding batch ### find cost and reiterate to minimize for epoch in range(epochs): avg_cost = 0 total_batch = int(train.shape[0]/batch_size) for i in range(total_batch): batch_x, batch_y = batch_creator(batch_size, train_x.shape[0], 'train') _, c = sess.run([optimizer, cost], feed_dict = &#123;x: batch_x, y: batch_y&#125;) avg_cost += c / total_batch print \"Epoch:\", (epoch+1), \"cost =\", \"&#123;:.5f&#125;\".format(avg_cost) print \"\\nTraining complete!\" # find predictions on val set pred_temp = tf.equal(tf.argmax(output_layer, 1), tf.argmax(y, 1)) accuracy = tf.reduce_mean(tf.cast(pred_temp, \"float\")) print \"Validation Accuracy:\", accuracy.eval(&#123;x: val_x.reshape(-1, input_num_units), y: dense_to_one_hot(val_y)&#125;) predict = tf.argmax(output_layer, 1) pred = predict.eval(&#123;x: test_x.reshape(-1, input_num_units)&#125;) 上面代码的输出如下： 12345678 Epoch: 1 cost = 8.93566Epoch: 2 cost = 1.82103Epoch: 3 cost = 0.98648Epoch: 4 cost = 0.57141Epoch: 5 cost = 0.44550Training complete!Validation Accuracy: 0.952823 为了使用我们的眼睛来测试模型，让我们来看一些它的预测结果： 123456789101112 img_name = rng.choice(test.filename)filepath = os.path.join(data_dir, 'Train', 'Images', 'test', img_name)img = imread(filepath, flatten=True)test_index = int(img_name.split('.')[0]) - 49000print \"Prediction is: \", pred[test_index]pylab.imshow(img, cmap='gray')pylab.axis('off')pylab.show() Prediction is: 8 我们看到模型的性能非常好。现在我们来创建一个子会话： 12345 sample_submission.filename = test.filename sample_submission.label = predsample_submission.to_csv(os.path.join(sub_dir, 'sub01.csv'), index=False) 到现在，我们就把已经训练好的神经网络保存下来了。 TensorFlow 的局限性 尽管 TensorFlow 很强大，但它依旧是一个低级库，打个比方，你可以把它看出一个机器级语言。但是大多数情况下，你需要模块化和高层次的接口，比如 keras 这样的库便能够提供。 TensorFlow 目前仍然在开发中，因此未来还会有很多令人激动的东西到来。 TensorFlow 依赖于你的硬件配置，硬件配置越高越好。 对于许多语言，TensorFlow 还没有 API. TensorFlow 中还有许多东西需要实现，比如 OpenCL 的支持。 上面提到的内容大多数是站在 TensorFlow 开发者的角度的。他们已经制定了一个路线图来说明将来这个库应该如何发展。 TensorFlow vs. 其他库 TensorFlow 是以和 Theano 和 Torch 相似的原则构建的，都是使用数学计算图。但是由于具有分布式计算的支持，TensorFlow 对于解决复杂的问题表现得更好。同时，由于已经支持 TensorFlow 模型的部署（即开源免费），这使得在工业上使用更加容易，对 Deeplearning4j、H2O 和 Turi 这些商业库造成了竞争威胁。TensorFlow 有 Python、C++ 和 Matlab 的 API，接下来可能将要有对其他语言的支持，比如 Ruby 和 R。所以，TensorFlow 正在试图成为具有普遍语言的机器学习库。 接下来往哪走 你已经看到了如何使用 TensorFlow 来建立一个简单的神经网路。这个代码对于来理解如何开始实现 TensorFlow 是有意义的，所以不要小瞧它。但是请记住现实生活需要解决的问题将会更加复杂，你需要稍微修改一下代码。 上面的许多函数能够被抽象出来，以提供无缝的端到端工作流。如果你使用过 scikit-learn，那么你可能知道一个高级库是如何抽象出底层实现，然后给终端用户提供一个更加简单的接口的。虽然 TensorFlow 已经抽象出了大多数的实现，但高级库正在出现，比如 TF-slim 和 TFlearn 。 有用的资源 TensorFlow 官方仓库 Rajat Monga (TensorFlow 技术引导) “TensorFlow for everyone” 视频 一个专用资源列表](https://github.com/jtoy/awesome-tensorflow/#github-projects) 结束语 我希望你觉得这篇文章很有帮助，现在，是时候来进行更多的练习和阅读了。Good luck！如果你使用一个不同的方法/包/库来实现神经网络，那么我很愿意在评论中跟你互动。如果你有什么建议，也请在评论中告知。为了让自己对神经网络的使用更加熟练，请不要忘记尝试解决我们的深度学习练习问题 - 数字识别。 你可以测试你的技能和知识。查看 Live Competitions，来和世界上最优秀的数据科学家进行比赛。 原文链接：https://www.analyticsvidhya.com/blog/2016/10/an-introduction-to-implementing-neural-networks-using-tensorflow/ 翻译：Flynn var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"在 Linux 中如何通过命令行开启或禁用触摸板","date":"2017-11-02T15:45:10.000Z","path":"2017/11/02/How-to-enable-or-disable-touchpad-in-Linux-with-command-line/","text":"本文将介绍如何在 Linux 中如何使用命令行命令来打开和关闭触摸板。 首先，需要了解一个工具：xinput 12 xinput is a utility to list available input devices, query informationabout a device and change input device settings. 上面是 man 手册对它的描述。 要通过触摸板开启或关闭触摸板，首先要要获取触摸板的设备 ID 和属性。 我们可以可以先通过 xinput --list 命令查看有哪些输入设备。下面的结果是在我的笔记本上的输出： 123456789101112131415 ⎡ Virtual core pointer id=2 [master pointer (3)]⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)]⎜ ↳ PixArt USB Optical Mouse id=10 [slave pointer (2)]⎜ ↳ DELL0767:00 06CB:7E92 Touchpad id=12 [slave pointer (2)]⎜ ↳ SynPS/2 Synaptics TouchPad id=14 [slave pointer (2)]⎣ Virtual core keyboard id=3 [master keyboard (2)] ↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)] ↳ Power Button id=6 [slave keyboard (3)] ↳ Video Bus id=7 [slave keyboard (3)] ↳ Power Button id=8 [slave keyboard (3)] ↳ Sleep Button id=9 [slave keyboard (3)] ↳ Integrated Webcam id=11 [slave keyboard (3)] ↳ AT Translated Set 2 keyboard id=13 [slave keyboard (3)] ↳ Dell WMI hotkeys id=15 [slave keyboard (3)] ↳ DELL Wireless hotkeys id=16 [slave keyboard (3)] 可以看到，第 4 行输出即为触摸板，后面的 id 即为设备号。 下面，查看触摸板的属性： 123 xinput --list-props 12 ＃或xinput --list-props ‘DELL0767:00 06CB:7E92 Touchpad’ 即使用设备 id 或设备名作为后面的参数均可以。 下面是在我的笔记本上的输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 Device 'DELL0767:00 06CB:7E92 Touchpad': Device Enabled (140): 0 Coordinate Transformation Matrix (142): 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000 Device Accel Profile (263): 1 Device Accel Constant Deceleration (264): 2.500000 Device Accel Adaptive Deceleration (265): 1.000000 Device Accel Velocity Scaling (266): 12.500000 Synaptics Edges (288): 49, 1180, 50, 879 Synaptics Finger (289): 25, 30, 0 Synaptics Tap Time (290): 180 Synaptics Tap Move (291): 67 Synaptics Tap Durations (292): 180, 180, 100 Synaptics ClickPad (293): 1 Synaptics Middle Button Timeout (294): 0 Synaptics Two-Finger Pressure (295): 282 Synaptics Two-Finger Width (296): 7 Synaptics Scrolling Distance (297): 30, 30 Synaptics Edge Scrolling (298): 0, 0, 0 Synaptics Two-Finger Scrolling (299): 1, 1 Synaptics Move Speed (300): 1.000000, 1.750000, 0.129870, 0.000000 Synaptics Off (301): 0 Synaptics Locked Drags (302): 0 Synaptics Locked Drags Timeout (303): 5000 Synaptics Tap Action (304): 2, 3, 0, 0, 1, 3, 2 Synaptics Click Action (305): 1, 3, 0 Synaptics Circular Scrolling (306): 0 Synaptics Circular Scrolling Distance (307): 0.100000 Synaptics Circular Scrolling Trigger (308): 0 Synaptics Circular Pad (309): 0 Synaptics Palm Detection (310): 0 Synaptics Palm Dimensions (311): 10, 200 Synaptics Coasting Speed (312): 20.000000, 50.000000 Synaptics Pressure Motion (313): 30, 160 Synaptics Pressure Motion Factor (314): 1.000000, 1.000000 Synaptics Resolution Detect (315): 1 Synaptics Grab Event Device (316): 0 Synaptics Gestures (317): 1 Synaptics Capabilities (318): 1, 0, 0, 1, 1, 0, 0 Synaptics Pad Resolution (319): 12, 12 Synaptics Area (320): 0, 0, 0, 0 Synaptics Soft Button Areas (321): 614, 0, 761, 0, 0, 0, 0, 0 Synaptics Noise Cancellation (322): 7, 7 Device Product ID (258): 1739, 32402 Device Node (259): \"/dev/input/event15\" 可以看到，第一个属性即为触摸板状态：1 表示开启，0 表示关闭，属性编号为 140。 之后，我们可以使用下面的命令来开启或关闭触摸板： 1234 # 开启触摸板xinput set-prop 12 140 1# 关闭触摸板xinput set-prop 12 140 0 其中，设备 ID 和属性编号也可替换为名字。 但是，每次都使用这个命令会比较麻烦，因此，可以通过一个简单的脚本来实现： 123456789101112 #!/bin/bashif [ \"$1\" == \"on\" ]; then xinput set-prop 12 140 1; echo \"Touchpad successfully enabled!\";elif [ \"$1\" == \"off\" ]; then xinput set-prop 12 140 0; echo \"Touchpad successfully disabled!\"else echo \"Please use the program with one of the following arguments:\" echo \" (1) on : enable the touchpad!\" echo \" (2) off : disable the touchpad!\"fi 将该脚本命名为 touchpad ，然后放到 /home/user/bin 目录下。然后，开启或关闭触摸板就很方便了： 1234 # 开启触摸板touchpad on# 关闭触摸板touchpad off 注意，脚本中的设备 ID 和属性编号应和你的笔记本一致，user 为你的用户名。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"记一下那些年使用 Linux 踩过的坑","date":"2017-10-30T11:54:31.000Z","path":"2017/10/30/What-the-fuck-problem-with-Linux/","text":"笔记本上装了双系统：Windows 10 + Ubuntu，刚装好 Ubuntu 不久就重新从 Windows 下分了一个盘挂载到 Ubuntu 下。如今，由于基本不再使用 Windows 系统，准确的说就只在虚拟机上使用一下 QQ、微信。于是，我又从 Windows 下分出一个盘，准备挂载到 Ubuntu 下。然而，却突然启动不进去了，直接进入了 emergency mode，尝试重新启动到默认模式，然后出现下面的错误信息： 1 [ 84.260812] EXT4-fs (sda7): VFS: can&apos;t find ext4 filesystem. 错误信息很直接，说sda7不是ext4文件系统格式。 然后查看分区：fdisk -l，输出如下： 1234567891011121314151617181920212223 Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: gptDisk identifier: A3FE2E3C-3EBC-401D-8BB3-987D9B33F0ECDevice Start End Sectors Size Type/dev/sda1 2048 1026047 1024000 500M EFI System/dev/sda2 1026048 1288191 262144 128M Microsoft reserved/dev/sda3 1288192 284209819 282921628 134.9G Microsoft basic data/dev/sda4 284211200 508033023 223821824 106.7G Microsoft basic data/dev/sda5 508035072 949225471 441190400 210.4G Linux filesystem/dev/sda6 949225472 965793791 16568320 7.9G Linux swap/dev/sda7 965793792 1298845695 333051904 158.8G Microsoft basic data/dev/sda8 1298845696 1718274047 419428352 200G Linux filesystem/dev/sda9 1718276096 1927991295 209715200 100G Microsoft basic datamount -o remount,rw /mount --allchown root:root /usr/bin/sudochmod 4755 /usr/bin/sudo/dev/sda10 1927993344 1928998911 1005568 491M Windows recovery environment/dev/sda11 1928998912 1951117311 22118400 10.6G Windows recovery environment/dev/sda12 1951119360 1953523711 2404352 1.2G Windows recovery environment What ? /dev/sd7 是 Windows 系统的 C 盘，怎么它会在启动的时候挂载呢，而且还是以 ext4 的文件系统格式挂载。想了半天，没发现问题。还好，机智的我赶紧看了一下 /etc/fstab 文件内容： 1234567891011121314 # /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# / was on /dev/sda9 during installationUUID=e3a38d48-680a-49e5-a98f-ae8bb6a37293 / ext4 errors=remount-ro 0 1# /boot/efi was on /dev/sda1 during installationUUID=FE51-6D32 /boot/efi vfat umask=0077 0 1# swap was on /dev/sda10 during installationUUID=c6a51fbb-d72a-4d93-9305-b75aaf6ab1fa none swap sw 0 0dev/sda7 home/fenglv/FILE ext4 defaults 0 1 ？？？原来之前挂载到 Ubuntu 上的盘设备名就是 /dev/sda7 ，添加一个新的分区后设备名变为了 /dev/sda8，现在的 /dev/sda7 对应的就是 Windows 系统的 C 盘。而我没有修改 /etc/fstab ，所以才导致 Linux 系统启动的时候无法将该设备挂载上。 修改之后终于正常启动了。 然而事情并没有结束。之后，sudo 不能使用了，错误信息如下： 123 sudo: error in /etc/sudo.conf, line 0 while loading plugin `sudoers_policy&apos;sudo: /usr/lib/sudo/sudoers.so must be only be writable by ownersudo: fatal error, unable to load plugins 好吧，直接上网查。最后在 askubunntu 上找到了解决办法：启动到 recovery mode ，然后执行下面的命令： 123 mount -o remount,rw /chmod 644 /usr/lib/sudo/sudoers.sochown -R root /usr/lib/sudo 至此，全部问题解决。 问题并没有真的结束（文章更新），之后，virtualbox 不能启动了： 12 VBoxHeadless: Effective UID is not root (euid=1000 egid=1000 uid=1000 gid=1000)VBoxHeadless: Tip! It may help to reinstall VirtualBox. 正确的做法就是按照它的提示把 virtualbox 卸了重新安装。然而，我却去修改/usr/bin的所有者：chown -R root /usr/bin 。这样以后，不但 virtual box 无法启动，sudo 又不能用了，这次的错误信息如下： 1 sudo: /usr/bin/sudo must be owned by uid 0 and have the setuid bit set 最后找到解决办法：再次进入 recovery mode，执行下面命令： 1234 mount -o remount,rw /mount --allchown root:root /usr/bin/sudochmod 4755 /usr/bin/sudo 问题解决。 Linux 的权限问题真让人头疼。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Linux 主机和 Vbox 下的 Windows 虚拟机创建共享文件夹","date":"2017-10-28T06:42:12.000Z","path":"2017/10/28/Linux-host-create-share-folder-with-windows-vbox/","text":"在 Linux 下，难免会使用一些 Windows 的软件，此时其中一个选择就是安装虚拟机。下面将阐述如何在 Linux 主机下创建一个和 VirtualBox 下的 Windows 虚拟机的共享文件夹。 首先确保安装好虚拟机。 第一步，启动虚拟机，点击左上方工具栏 -&gt; 安装增加功能 -&gt; 按照提示安装成功即可。 第一步，打开虚拟机设置 -&gt; 共享文件夹 -&gt; 添加路径 -&gt; 设置共享文件夹名字（假设名字为 Win7，后面会用到。） 第三步，重启虚拟机 -&gt; 打开 cmd -&gt; 输入命令 net use x: \\\\vboxsvr\\Win7 即可。其中 x 为盘符，任意一个未使用的字母均可以，Win7 即为上面设置的共享文件夹名字。 这样，在主机和虚拟机之间就创建了一个共享文件夹。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Python 编程风格","date":"2017-10-26T04:10:08.000Z","path":"2017/10/26/Pythonic-programming-tips/","text":"本文将记录在学习过程掌握/学习到的一些 Python 编程的奇技淫巧，即如何写 Pythonic 的 Python 代码。因此，文章将会持续更新，更新时间不限。由于本人知识有限，文中难免会出现不足或错误的地方。 多变量赋值 变量赋值是编程语言里面最简单的语句之一，通常情况下，我们会这样做： 123 a = 1b = 2c = 3 这样便完成了对三个变量的赋值，但你可以用更简单的方式： 1 a, b, c = 1, 2, 3 元素值交换 在编程过程中，交换两个变量的值是非常常见的。一般情况下，我们会用下面这种方式来交换两个变量的值（尤其是对于第一门语言是C/C++的人来说）： 123 t = aa = bb = t 这种方式是正确的，没有人敢说它不对，但事实上，在 Python 里，你可以有更简单的方式来完成这件事： 1 a, b = b, a 没错，一行语句就够了。 对上面两个技巧的解释：在 Python 中，任何以逗号分隔的对象均被当作元组处理，因此1, 2, 3 实际上就是一个元组(1, 2, 3)，赋值过程可以看成是元组的解包 。交换值也是同样的，它相当于把等号右边的元组解包后赋值给了左边的变量。为了提高代码的可读性，上面的例子可以加上括号： 12 a, b, c = (1, 2, 3)a, b = (b, a) 列表解析 假设 list1 是一个字符串组成的列表，现在，需要把 list1 中的每一个字符串的每一个小写字母找出来，形成一个新的元组。一般情况下，我们可以这样做： 123456 list1 = ['adg', 'Adf', '124']list2 = []for i in list1: for j in i: if j &gt;= 'a' and j &lt;= 'z': list2.append(j) 但实际上，你只需要用一个语句就可以完成这件事： 1 list2 = [j for i in list1 for j in i if j &gt;= 'a' and j &lt;= 'z'] 没错，Python 就是这么简洁。如果把上面的方括号换成圆括号，那么结果返回的就是一个迭代器，可以使用 next() 方法获取元素： 123 list2 = (j for i in list1 for j in i if j &gt;= 'a' and j &lt;= 'z')list2.next() # 返回'a'list2.next() # 返回'd' 收集参数 函数的多个参数可通过一个元组传递，假设有如下函数： 12 def add2(x, y): return x + y 可重新定义为： 1234567 def add2(*params): return params[0] + params[1]#传递参数add2(1, 2)#或tuple1 = (1, 2)add2(*tuple1) 使用双星号则可以传递一个字典： 1234 def with_star(**kwds): print(kwds['name'], ' is ', kwds['age'] ,' years old.')args = &#123;'name' : 'Mrs. GUmby', 'age' : 42&#125;with_star(**args) 使用两个列表创建字典 12345 list1 = [1, 2, 3]list2 = ['a', 'b', 'c']d = dict(zip(list1, list2))list1 == list(d.keys())list2 == list(d.values()) 多态 多态意味着就算不知道变量所引用的对象类型是什么，也可以对它进行操作，看下面的函数： 1234 def add (a, b): return a + badd(1, 2) # 返回３add('ab', 'cd') # 返回'abcd' 很多函数和运算符都是多态的，因此写程序时也应该尽量避免破坏多态，尽量不使用 type, isinstance, issubclass 之类会破坏多态的函数。 多态是 Python 式编程的核心，也被称为 “duck typing”。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Python 速查表","date":"2017-10-07T11:20:55.000Z","path":"2017/10/07/Python-cheat-sheet/","text":"本手册是 Python cheat sheet 的中文翻译版。原作者：Arianne Colton and Sean Chen(data.scientist.info@gmail.com)。 该手册同时位于 GitHub 上，可下载 PDF 版。 惯例 Python 对大小写敏感； Python 的索引从 0 开始（所有编程语言均如此）； Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号。 获取帮助 获取主页帮助： help() 获取函数帮助： help(str.replace) 获取模块帮助： help(re) 模块（亦称库） 模块只是一个简单地以 .py 为后缀的文件。 列出模块内容：dir(module1) 导入模块：import module 调用模块中的函数：module1.func1() 注：import 语句会创建一个新的名字空间，并且在该名字空间内执行 .py 文件中的所有语句。如果你想把模块内容导入到当前名字空间，请使用 from module1 import * 语句。 数值类类型 查看变量的数据类型：type(variable) 六种经常使用的数据类型 int/long：过大的 int 类型会被自动转化为 long 类型。 float：64 位，Python 中没有 double 类型。 bool：真或假。 str：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以 Unicode 编码； 字符串可置于单/双/三引号中； 字符串是字符的序列，因此可以像处理其他序列一样处理字符串； 特殊字符可通过 \\ 或者前缀 r 实现： 1 str1 = r'this\\f?ff' 字符串可通过多种方式格式化： 12 template = '%.2f %s haha $%d';str1 = template % (4.88, 'hola', 2) NoneType(None)：Python null 值（只有 None 对象的一个实例中存在）。 None 不是一个保留关键字，而是 NoneType 的一个唯一实例。 None 通常是可选函数参数的默认值： 1 def func1(a, b, c = None) None 的常见用法： 1 if variable is None : datatime：Python 内建的 datetime 模块提供了 datetime、data 以及 time 类型。 datetime 组合了存储于 date 和 time 中的信息。 123456789101112 #从字符串中创建 datetimedt1 = datetime.strptime('20091031', '%Y%m%d')#获取 date 对象dt1.date()#获取 time 对象dt1.time()#将 datetime 格式化为字符串dt1.strftime('%m/%d/%Y%H:%M')#更改字段值dt2 = dt1.replace(minute = 0, second = 30)#做差, diff 是一个 datetime.timedelta 对象diff = dt1 - dt2 注：Python 中的绝大多数对象都是可变的，只有字符串和元组例外。 数据结构 注：所有的 non-Get 函数调用，比如下面例子中的 list1.sort() 都是原地操作，即不会创建新的对象，除非特别声明。 元组 元组是 Python 中任何类型的对象的一个一维、固定长度、不可变的序列。 123456789101112 #创建元组tup1 = 4, 5, 6 # ortup1 = (6, 7, 8)#创建嵌套元组tup1 = (4, 5, 6), (7, 8)#将序列或迭代器转化为元组tuple([1, 0, 2])#连接元组tup1 + tup2#解包元组a, b, c = tup1 元组应用： 12 #交换两个变量的值a, b = b, a 列表 列表是 Python 中任何类型的对象的一个一维、非固定长度、可变（比如内容可以被修改）的序列。 12345678910111213141516171819202122 #创建列表list1 = [1, 'a', 3]#orlist1 = list(tup1)#连接列表list1 + list2 #orlist1.extend(list2)#追加到列表的末尾list1.append('b')#插入指定位置list1.insert(PosIndex, 'a')#反向插入，即弹出给定位置的值/删除ValueAtIdx = list1.pop(PosIndex)#移除列表中的第一个值, a 必须是列表中第一个值list1.remove('a')#检查成员资格3 in list1 =&gt; True or False#对列表进行排序list1.sort()#按特定方式排序list1.sort(key = len) # 按长度排序 使用 + 连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用 extend() 是更明智的选择； insert 和 append 相比会有更大的开支（时间/空间）； 在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。 内建的 bisect 模块 对一个排序好的列表进行二分查找或插入； bisect.bisect找到元素在列表中的位置，bisect.insort将元素插入到相应位置。用法： 123456 import bisectlist1 = list(range(10))#找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1bisect.bisect(list1, 5)#将 3.5 插入 list1 中合适位置bisect.insort(list1, 3.5) 注：bisect 模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。 针对序列类型的切片 序列类型包括 str、array、tuple、list 等。 用法： 123 list1[start:stop]#如果使用 steplist1(start:stop:step) 注：切片结果包含 start 索引，但不包含 stop 索引；start/stop 索引可以省略，如果省略，则默认为序列从开始到结束，如 list1 == list1[:] 。 step 的应用： 1234 #取出奇数位置的元素list1[::2]#反转字符串str1[::-1] 字典（哈希映射） 1234567891011121314151617 #创建字典dict1 = &#123;'key1': 'value1', 2: [3,2]&#125;#从序列创建字典dict(zip(KeyList, ValueList))#获取/设置/插入元素dict1['key1']dict1['key1'] = 'NewValue'#get 提供默认值dict1.get('key1', DefaultValue)#检查键是否存在'key1' in dict1#获取键列表dict1.keys()#获取值列表dict1.values()#更新值dict1.update(dict2)#dict1 的值被 dict2 替换 如果键不存在，则会出现 KeyError Exception 。 当键不存在时，如果 get()不提供默认值则会返回 None 。 以相同的顺序返回键列表和值列表，但顺序不是特定的，又称极大可能非排序。 有效字典键类型 键必须是不可变的，比如标量类型(int、float、string)或者元组（元组中的所有对象也必须是不可变的）。 这儿涉及的技术术语是 hashability。可以用函数 hash()来检查一个对象是否是可哈希的，比如 hash(&#39;This is a string&#39;) 会返回一个哈希值，而 hash([1,2]) 则会报错（不可哈希）。 集合 一个集合是一些无序且唯一的元素的聚集； 你可以把它看成只有键的字典； 12345678910 #创建集合set([3, 6, 3])#or&#123;3, 6, 3&#125;#子集测试set1.issubset(set2)#超集测试set1.issuperset(set2)#测试两个集合中的元素是否完全相同set1 == set2 集合操作 并（又称或）：set1 | set2 交（又称与）：set1 &amp; set2 差：set1 - set2 对称差（又称异或）：set1 ^ set2 函数 Python 的函数参数传递是通过引用传递。 基本形式 1 def func1(posArg1, keywordArg1 = 1, ..) 注 关键字参数必须跟在位置参数的后面； 默认情况下，Python 不会“延迟求值”，表达式的值会立刻求出来。 函数调用机制 所有函数均位于模块内部作用域。见“模块”部分。 在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组 args 和一个字典 kwargs，然后在函数内部解包。 “函数是对象”的常见用法： 123 def func1(ops = [str.strip, user_define_func, ..], ..): for function in ops: value = function(value) 返回值 如果函数末尾没有 return 语句，则不会返回任何东西。 如果有多个返回值则通过一个元组来实现。 12 return (value1, value2)value1, value2 = func1(..) 匿名函数（又称 LAMBDA 函数） 什么是匿名函数？ 匿名函数是一个只包含一条语句的简单函数。 12 lambda x : x * 2#def func1(x) : return x * 2 匿名函数的应用：’curring’，又称利用已存在函数的部分参数来派生新的函数。 1 ma60 = lambda x : pd.rolling_mean(x, 60) 一些有用的函数（针对数据结构） enumerate() 返回一个序列(i, value)元组，i 是当前 item 的索引。 1 for i, value in enumerate(collection): 应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。 sort()可以从任意序列中返回一个排序好的序列。 1 sorted([2, 1, 3]) =&gt; [1, 2, 3] 应用： 123 sorted(set('abc bcd')) =&gt; [' ','a', 'b', 'c', 'd']# 返回一个字符串排序后无重复的字母序列 zip()函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。 1 zip(seq1, seq2) =&gt; [('seq1_1', 'seq2_1'), (..), ..] zip()可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。 应用：多个序列同时迭代： 1 for i, (a, b) in enumerate(zip(seq1, seq2)): unzip：另一种思考方式是把一些行转化为一些列： 1 seq1, seq2 = zip(zipOutput) reversed() 将一个序列的元素以逆序迭代。 1 list(reversed(range(10))) reversed() 会返回一个迭代器，list() 使之成为一个列表。 控制流 用于 if-else 条件中的操作符： 123456 #检查两个变量是否是相同的对象var1 is var2#检查两个变量是否是不同的对象var1 is not var2#检查两个变量的值是否相等var1 == var2 注：Python 中使用 and、or、not 来组合条件，而不是使用 &amp;&amp;、||、! 。 for循环的常见用法： 1234 #可迭代对象（list、tuple）或迭代器for element in iterator:#如果元素是可以解包的序列for a, b, c in iterator: pass：无操作语句，在不需要进行任何操作的块中使用。 三元表达式，又称简洁的 if-else，基本形式： 1 value = true-expr if condition else false-expr Python 中没有 switch/case 语句，请使用 if/elif。 面向对象编程 对象（object）是 Python 中所有类型的根。 万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个类型（type）。对象变量是一个指向变量在内存中位置的指针。 所有对象均为引用计数。 123456 sys.getrefcount(5) =&gt; xa = 5, b = a#上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5sys.getrefcount(5)=&gt; x + 2del(a); sys.getrefcount(5) =&gt; x + 1 类的基本形式： 123456789101112 class MyObject(object): # 'self' 等价于 Java/C++ 中的 'this' def __init__(self, name): self.name = name def memberFunc1(self, arg1): .. @staticmethod def classFunc2(arg1): ..obj1 = MyObject('name1')obj1.memberFunc1('a')MyObject.classFunc2('b') 有用的交互式工具： 1 dir(variable1) #列出对象的所有可用方法 常见字符串操作 123456789101112131415161718192021 #通过分隔符连接列表/元组', '.join([ 'v1', 'v2', 'v3']) =&gt; 'v1, v2, v3'#格式化字符串string1 = 'My name is &#123;0&#125; &#123;name&#125;'newString1 = string1.format('Sean', name = 'Chen')#分裂字符串sep = '-';stringList1 = string1.split(sep)#获取子串start = 1;string1[start:8]#补 '0' 向右对齐字符串month = '5';month.zfill(2) =&gt; '05'month = '12';month.zfill(2) =&gt; '12'month.zfill(3) =&gt; '012' 异常处理 基本形式： 12345678910 try: ..except ValueError as e: print eexcept (TypeError, AnotherError): ..except: ..finally: .. # 清理，比如 close db; 手动引发异常： 1234 raise AssertionError # 断言失败raise SystemExit# 请求程序退出raise RuntimeError('错误信息 :..') 对列表、字典和元组的深入理解 语法糖（syntactic sugar）会使代码变得更加易读易写。 对列表的理解 将一些元素通过一个简短的语句传入一个过滤器进行过滤和转化，然后可以组成一个新的列表。 1234567 #基本形式[expr for val in collection if condition]#ShortCutresult = []for val in collection: if condition: result.append(expr) 可以省略过滤条件，只留下表达式。 对字典的理解 基本形式： 1 &#123;key-expr : value-expr for value in collection if condition&#125; 对集合的理解 基本形式：和列表一样，只是应该使用 () 而不是 [] 。 嵌套列表 基本形式： 1 [expr for val in collection for innerVal in val if condition] var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"关于 Linux 你可能不是非常了解的七件事","date":"2017-10-06T04:51:31.000Z","path":"2017/10/06/Seven-things-you-may-not-know-so-far-about-Linux/","text":"使用 Linux 最酷的事情之一就是随着时间的推移，你可以不断获得新的知识。每天，你都可能会遇到一个新的实用工具，或者只是一个不太熟悉的奇技淫巧，但是却非常有用。这些零碎的东西并不总是能够改变生活，但是却是专业知识的基础。 即使是专家，也不可能事事皆知。无论你有多少经验，可能总会有更多的东西需要你去学习。所以，在这儿我列出了七件关于 Linux 你可能不知道的事情。 一个查找命令历史的交互模式 你可能对 history 命令非常熟悉，它会读取 bash 历史，然后以编号列表的方式输出到标准输出（stdout）。然而，如果你在 curl 命令的海洋里寻找一个特定的链接（URL），那么这个列表并不总是那么容易阅读的。 你还可以有另一个选择，Linux 有一个交互式的反向搜索可以帮助你解决这个问题。你可以通过快捷键 ctrl+r启动交互模式，然后进入一个交互提示中，它将会根据你提供的字符串来向后搜索 bash 历史，你可以通过再次按下 ctrl+r 向后搜索更老的命令，或者按下 ctrl+s 向前搜索。 注意，ctrl+s 有时会与 XON/XOFF 流控制冲突，即 XON/XOFF 流控制也会使用该快捷键。你可以通过运行 stty -ixon 命令来禁用该快捷键。在你的个人电脑上，这通常是有用的，但是在禁用前，确保你不需要 XON/XOFF 。 Cron 不是安排任务的唯一方式 Cron 任务对于任何水平的系统管理员，无论是毫无经验的初学者，还是经验丰富的专家来说，都是非常有用的。但是，如果你需要安排一个一次性的任务，那么 at 命令为你提供了一个快捷的方式来创建任务，从而你不需要接触 crontab 。 at 命令的运行方式是在后面紧跟着你想要运行任务的运行时间。时间是灵活的，因为它支持许多时间格式。包括下面这些例子： 123 at 12:00 PM September 30 2017at now + 1 hourat 9:00 AM tomorrow 当你以带参数的方式输入 at 命令以后，将会提示你该命令将在你的 Linux 系统上运行。这可能是一个备份脚本，一套维护任务，或者甚至是一个普通的 bash 命令。如果要结束任务，可以按 ctrl+d 。 另外，你可以使用 atq 命令查看当前用户的所有任务，或者使用 sudo atq 查看所有用户的任务。它将会展示出所有排定好的任务，并且每个任务都伴有一个 ID 。如果你想取消一个排定好的任务，可以使用 atrm 命令，并且以任务 ID 作为参数。 你可以按照功能搜索命令，而不仅仅是通过名字 记住命令的名字非常困难，特别是对于初学者来说。幸运的是，Linux 附带了一个通过名字和描述来搜索 man 页面的工具。 下次，如果你没有记住你想要使用的工具的名称，你可以尝试使用 apropos 命令加上你想要干的事情的描述。比如，apropos build filesystem 将会返回一系列名字和描述包括了 “build” 和 “filesystem” 单词的工具。 apropos 命令接受一个或多个字符串作为参数，但同时它也有其他参数，比如你可以使用 -r 参数，从而通过正则表达式来搜索。 一个允许你来管理系统版本的替代系统 如果你曾进行过软件开发，你就会明白跨项目管理不同版本的语言的支持的重要性。许多 Linux 发行版都有工具可以来处理不同的内建版本。 可执行文件比如 java 往往符号链接到目录 /etc/alternatives 下。反过来，该目录会将符号链接存储为二进制文件并提供一个管理这些链接的接口。Java 可能是替代系统最常管理的语言，但是，经过一些配置，它也可以作为其他应用程序替代品，比如 NVM 和 RVM （NVM 和 RVM 分别是 NodeJS 和 Ruby 的版本管理器）。 在基于 Debian 的系统中，你可以使用 update-alternatives 命令创建和管理这些链接。在 CentOS 中，这个工具就叫做 alternatives 。通过更改你的 alternatives 文件中的链接，你便可以安装一个语言的多个版本，并且在不同的情况下使用不同的二进制。这个替代系统也提供了对任何你可能在命令行运行的程序的支持。 shred 命令是更加安全的删除文件方式 我们大多数时候总是使用 rm 命令来删除文件。但是文件去哪儿了呢？真相是 rm 命令所做的事情并不是像你所想像的那样，它仅仅删除了文件系统和硬盘上的数据的硬链接。硬盘上的数据依旧存在，直到被另一个应用重写覆盖。对于非常敏感的数据来说，这会带来一个很大的安全隐患。 shred 命令是 rm 命令的升级版。当你使用 shred 命令删除一个文件之后，文件中的数据会被多次随机覆写。甚至有一个选项可以在随机覆写之后对所有的数据进行清零。 如果你想安全的删除一个文件并且以零覆盖，那么可以使用下面的命令： shred -u -z [file name] 同时，你也可以使用 -n 选项和一个数字作为参数，从而指定在随机覆盖数据的时候迭代多少次。 通过自动更正来避免输入很长的无效文件路径 有多少次，你输入一个文件的绝对路径，然而却看到“没有该文件或目录”的消息。任何人都会明白输入一个很长的字符串的痛苦。幸运的是，有一个很简单的解决办法。 内建的 shopt 命令允许你设置不同的选项来改变 shell 的行为。设置 cdspell 选项是避免输入文件路径时一个字母出错的头痛的一个简单方式。你可以通过运行 shopt -s cdspell 命令来启用该选项。启用该选项后，当你想要切换目录时，会自动更正为最匹配的目录。 Shell 选项是节省时间的一个好方法（更不用说减少麻烦），此外还有许许多多的其他选项。如果想查看你的系统中所有选项的完整列表，可以运行不带参数的 shopt 命令。需要注意的是，这是 bash 的特性，如果你运行 zsh 或者其他可供选择的 shell，可能无法使用。 通过子 shell 返回到当前目录 如果你曾经配置过一个比较复杂的系统，那么你可能会发现你需要频繁的更换目录，从而很难跟踪你所在的位置。如果在运行完一个命令后自动返回到当前位置，不是很好吗？ Linux 系统实际上提供了一个解决该问题的方法，并且非常简单。如果你想通过 cd 命令进入另一个目录完成一些任务，然后再返回当前工作目录，那么你可以将命令置于括号中。你可以在你的 Linux 系统上尝试下面这个命令。记住你当前的工作目录，然后运行： 1 (cd /etc &amp;&amp; ls -a) 该命令会输出 /etc 目录的内容。现在，检查你的当前工作目录。它和执行该命令前的目录一样，而不是 /etc 目录。 它是如何工作的呢？运行一个括号中的命令会创建一个子 shell 或一个当前 shell 进程的复刻副本。该子 shell 可以访问所有的父变量，反之则不行。所以请记住，你是在运行一个非常复杂的单行命令。 在并行处理中经常使用子 shell ，但是在命令行中，它也能为你带来同样的力量，从而使你在浏览文件系统时更加容易。 via: http://opensourceforu.com/2017/09/top-7-things-linux-may-not-known-far/ 作者：PHIL ZONA译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Ubuntu 下代理服务器失败无法上网的解决办法","date":"2017-09-25T00:56:12.000Z","path":"2017/09/25/Setting-Proxy-For-google-chrome-in-Ubuntu/","text":"在 Ubuntu 上装了一个 Xfce 桌面，前段时间一直在使用 Xfce 桌面，今天切换回 GNOME 桌面以后，发现 google-chrome 无法上网了，说是代理服务器有问题，按照它的提示在设置中进行设置，结果打开代理服务器设置时，又出现下面的信息： 123 When running Google Chrome under a supported desktop environment, the system proxy settings will be used. However, either your system is not supported or there was a problem launching your system configuration.But you can still configure via the command line. Please see man google-chrome-stable for more information on flags and environment variables. 因此，无法在浏览器中进行设置。 后来找到了解决办法：直接对桌面图标进行设置。 首先，在 root 下用 vim 编辑器打开 /usr/share/applications/google-chrome.destop，或者直接sudo vim /usr/share/applications/google-chrome.destop 打开后显示下面的内容： 1234567891011121314151617181920 [Desktop Entry]Version=1.0Name=Google ChromeGenericName=Web BrowserComment=Access the InternetExec=/usr/bin/google-chrome-stable %UTerminal=falseIcon=google-chromeType=ApplicationCategories=Network;WebBrowser;MimeType=text/html;text/xml;application/xhtml_xml;image/webp;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;Actions=NewWindow;NewPrivateWindow;[Desktop Action NewWindow]Name=New WindowExec=/usr/bin/google-chrome-stable [Desktop Action NewPrivateWindow]Name=New Incognito WindowExec=/usr/bin/google-chrome-stable --incognito 在第六行的后面加上--proxy-auto-detect，变为如下： 1234567891011121314151617181920 [Desktop Entry]Version=1.0Name=Google ChromeGenericName=Web BrowserComment=Access the InternetExec=/usr/bin/google-chrome-stable %U --proxy-auto-detectTerminal=falseIcon=google-chromeType=ApplicationCategories=Network;WebBrowser;MimeType=text/html;text/xml;application/xhtml_xml;image/webp;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;Actions=NewWindow;NewPrivateWindow;[Desktop Action NewWindow]Name=New WindowExec=/usr/bin/google-chrome-stable [Desktop Action NewPrivateWindow]Name=New Incognito WindowExec=/usr/bin/google-chrome-stable --incognito 保存退出，再次打开 google-chrome，便可以正常上网了。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Linux 文件系统概览","date":"2017-09-23T04:48:42.000Z","path":"2017/09/23/Introduction-to-Linux-FileSystem/","text":"本文旨在高屋建瓴地来讨论 Linux 文件系统概念，而不是对某种特定的文件系统，比如 EXT4 是如何工作的进行具体的描述。另外，本文也不是一个文件系统命令的教程。 每台通用计算机都需要将各种数据存储在硬盘驱动器（HDD）或其他类似设备上，比如 USB 存储器。这样做有两个原因。首先，当计算机关闭以后，内存（RAM）会失去存于它里面的内容。尽管存在非易失类型的 RAM，在计算机断电以后还能把数据存储下来（比如采用 USB 闪存和固态硬盘的闪存），但是，闪存和标准的、易失性的 RAM，比如 DDR3 以及其他相似类型的 RAM 相比，要贵很多。 数据需要存储在硬盘驱动上的另一个原因是，即使是标准的 RAM 也要比普通硬盘贵得多。尽管 RAM 和硬盘的价格都在迅速下降，但是 RAM 的价格依旧在以字节为单位来计算。让我们进行一个以字节为单位的快速计算：基于 16 GB 大的 RAM 的价格和 2 TB 大的硬盘驱动的价格。计算显示 RAM 的价格大约比硬盘驱动贵 71 倍。今天，一个典型的 RAM 的价格大约是 0.000000004373750 美元/每字节。 直观的展示一下在很久以前 RAM 的价格，在计算机发展的非常早的时期，其中一种类型的 RAM 是基于在 CRT 屏幕上的点。这种 RAM 非常昂贵，大约 1 美元/每字节。 定义 你可能听过其他人以各种不同和令人迷惑的方式谈论过文件系统。文件系统这个单词本身有多重含义，你需要从一个讨论或文件的上下文中理解它的正确含义。 我将根据我所观察到的在不同情况下使用“文件系统”这个词来定义它的不同含义。注意，尽管我试图遵循标准的“官方”含义，但是我打算基于它的不同用法来定义这个术语（如下）。这就是说我将在本文的后续章节中进行更详细的探讨。 始于顶层 root（/）目录的整个 Linux 目录结构。 特定类型的数据存储格式，比如 EXT3、EXT4、BTRFS 以及 XFS 等等。Linux 支持近百种类型的文件系统，包括一些非常老的以及一些最新的。每一种文件系统类型都使用它自己独特的元数据结构来定义数据是如何存储和访问的。 用特定类型的文件系统格式化后的分区或逻辑卷，可以挂载到 Linux 文件系统的指定挂载点上。 文件系统的基本功能 磁盘存储是文件系统必须的功能，它与之伴生的有一些有趣而且不可或缺的细节。很明显，文件系统是用来为非易失数据的存储提供空间，这是它的基本功能。然而，它还有许多从需求出发的重要功能。 所有文件系统都需要提供一个名字空间，这是一种命名和组织方法。它定义了文件应该如何命名、文件名的最大长度，以及所有可用字符集中可用于文件名中字符集子集。它也定义了一个磁盘上数据的逻辑结构，比如使用目录来组织文件而不是把所有文件聚集成一个单一的、巨大的文件混合体。 定义名字空间以后，元数据结构是为该名字空间提供逻辑基础所必须的。这包括所需数据结构要能够支持分层目录结构，同时能够通过结构来确定硬盘空间中的块是已用的或可用的，支持修改文件或目录的名字，提供关于文件大小、创建时间、最后访问或修改时间等信息，以及位置或数据所属的文件在磁盘空间中的位置。其他的元数据用来存储关于磁盘细分的高级信息，比如逻辑卷和分区。这种更高层次的元数据以及它所代表的结构包含描述文件系统存储在驱动器或分区中的信息，但与文件系统元数据无关，与之独立。 文件系统也需要一个应用程序接口（API），从而提供了对文件系统对象，比如文件和目录进行操作的系统功能调用的访问。API 也提供了诸如创建、移动和删除文件的功能。它也提供了算法来确定某些信息，比如文件存于文件系统中的位置。这样的算法可以用来解释诸如磁盘速度和最小化磁盘碎片等术语。 现代文件系统还提供一个安全模型，这是一个定义文件和目录的访问权限的方案。Linux 文件系统安全模型确保用户只能访问自己的文件，而不能访问其他用户的文件或操作系统本身。 最后一块组成部分是实现这些所有功能所需要的软件。Linux 使用两层软件实现的方式来提高系统和程序员的效率。 图片 1：Linux 两层文件系统软件实现。 这两层中的第一层是 Linux 虚拟文件系统。虚拟文件系统提供了内核和开发者访问所有类型文件系统的的单一命令集。虚拟文件系统软件通过调用特殊设备驱动来和不同类型的文件系统进行交互。特定文件系统的设备驱动是第二层实现。设备驱动程序将文件系统命令的标准集解释为在分区或逻辑卷上的特定类型文件系统命令。 目录结构 作为一个通常来说非常有条理的处女座，我喜欢将东西存储在更小的、有组织的小容器中，而不是存于同一个大容器中。目录的使用使我能够存储文件并在我想要查看这些文件的时候也能够找到它们。目录也被称为文件夹，之所以被称为文件夹，是因为其中的文件被类比存放于物理桌面上。 在 Linux 和其他许多操作系统中，目录可以被组织成树状的分层结构。在 Linux 文件系统层次标准中定义了 Linux 的目录结构（LCTT 译注：可参阅这篇）。当通过目录引用来访问目录时，更深层目录名字是通过正斜杠（/）来连接，从而形成一个序列，比如 /var/log 和 /var/spool/mail 。这些被称为路径。 下表提供了标准的、众所周知的、预定义的顶层 Linux 目录及其用途的简要清单。 目录 描述 / (root 文件系统) root 文件系统是文件系统的顶级目录。它必须包含在挂载其它文件系统前需要用来启动 Linux 系统的全部文件。它必须包含需要用来启动剩余文件系统的全部可执行文件和库。文件系统启动以后，所有其他文件系统作为 root 文件系统的子目录挂载到标准的、预定义好的挂载点上。 /bin /bin 目录包含用户的可执行文件。 /boot 包含启动 Linux 系统所需要的静态引导程序和内核可执行文件以及配置文件。 /dev 该目录包含每一个连接到系统的硬件设备的设备文件。这些文件不是设备驱动，而是代表计算机上的每一个计算机能够访问的设备。 /etc 包含主机计算机的本地系统配置文件。 /home 主目录存储用户文件，每一个用户都有一个位于 /home 目录中的子目录（作为其主目录）。 /lib 包含启动系统所需要的共享库文件。 /media 一个挂载外部可移动设备的地方，比如主机可能连接了一个 USB 驱动器。 /mnt 一个普通文件系统的临时挂载点（如不可移动的介质），当管理员对一个文件系统进行修复或在其上工作时可以使用。 /opt 可选文件，比如供应商提供的应用程序应该安装在这儿。 /root 这不是 root（/）文件系统。它是 root 用户的主目录。 /sbin 系统二进制文件。这些是用于系统管理的可执行文件。 /tmp 临时目录。被操作系统和许多程序用来存储临时文件。用户也可能临时在这儿存储文件。注意，存储在这儿的文件可能在任何时候在没有通知的情况下被删除。 /usr 该目录里面包含可共享的、只读的文件，包括可执行二进制文件和库、man 文件以及其他类型的文档。 /var 可变数据文件存储在这儿。这些文件包括日志文件、MySQL 和其他数据库的文件、Web 服务器的数据文件、邮件以及更多。 表 1：Linux 文件系统层次结构的顶层 这些目录以及它们的子目录如表 1 所示，在所有子目录中，粗体的目录组成了 root 文件系统的必需部分。也就是说，它们不能创建为一个分离的文件系统并且在开机时进行挂载。这是因为它们（特别是它们包含的内容）必须在系统启动的时候出现，从而系统才能正确启动。 /media 目录和 /mnt 目录是 root 文件系统的一部分，但是它们从来不包含任何数据，因为它们只是一个临时挂载点。 表 1 中剩下的非粗体的目录不需要在系统启动过程中出现，但会在之后挂载到 root 文件系统上，在开机阶段，它们为主机进行准备，从而执行有用的工作。 请参考官方 Linux 文件系统层次标准（FHS）网页来了解这些每一个目录以及它们的子目录的更多细节。维基百科上也有关于 FHS 的一个很好的介绍。应该尽可能的遵循这些标准，从而确保操作和功能的一致性。无论在主机上使用什么类型的文件系统，该层次目录结构都是相同的。 Linux 统一目录结构 在一些非 Linux 操作系统的个人电脑上，如果有多个物理硬盘驱动器或多个分区，每一个硬盘或分区都会分配一个驱动器号。知道文件或程序位于哪一个硬盘驱动器上是很有必要的，比如 C: 或 D: 。然后，你可以在命令中使用驱动器号，以 D: 为例，为了进入 D: 驱动器，你可以使用 cd 命令来更改工作目录为正确的目录，从而定位需要的文件。每一个硬盘驱动器都有自己单独的、完整的目录树。 Linux 文件系统将所有物理硬盘驱动器和分区统一为一个目录结构。它们均从顶层 root 目录（/）开始。所有其它目录以及它们的子目录均位于单一的 Linux 根目录下。这意味着只有一棵目录树来搜索文件和程序。 因为只有一个文件系统，所以 /home、/tmp、/var、/opt 或 /usr 能够创建在和 root（/）文件系统不同的物理硬盘驱动器、分区或逻辑分区上，然后挂载到一个挂载点（目录）上，从而作为 root 文件系统树的一部分。甚至可移动驱动器，比如 USB 驱动器或一个外接的 USB 或 ESATA 硬盘驱动器均可以挂载到 root 文件系统上，成为目录树不可或缺的部分。 当从 Linux 发行版的一个版本升级到另一个版本或从一个发行版更改到另一个发行版的时候，就会很清楚地看到这样创建到不同分区的好处。通常情况下，除了任何像 Fedora 中的 dnf-upgrade 之类的升级工具，会明智地在升级过程中偶尔重新格式化包含操作系统的硬盘驱动来删除那些长期积累的垃圾。如果 /home 目录是 root 文件系统的一部分（位于同一个硬盘驱动器），那么它也会被格式化，然后需要通过之前的备份恢复。如果 /home 目录作为一个分离的文件系统，那么安装程序将会识别到，并跳过它的格式化。对于存储数据库、邮箱、网页和其它可变的用户以及系统数据的 /var 目录也是这样的。 将 Linux 系统目录树的某些部分作为一个分离的文件系统还有一些其他原因。比如，在很久以前，我还不知道将所有需要的 Linux 目录均作为 root（/）文件系统的一部分可能存在的问题，于是，一些非常大的文件填满了 /home 目录。因为 /home 目录和 /tmp 目录均不是分离的文件系统，而是 root 文件系统的简单子目录，整个 root 文件系统就被填满了。于是就不再有剩余空间可以让操作系统用来存储临时文件或扩展已存在数据文件。首先，应用程序开始抱怨没有空间来保存文件，然后，操作系统也开始异常行动。启动到单用户模式，并清除了 /home 目录中的多余文件之后，终于又能够重新工作了。然后，我使用非常标准的多重文件系统设置来重新安装 Linux 系统，从而避免了系统崩溃的再次发生。 我曾经遇到一个情况，Linux 主机还在运行，但是却不允许用户通过 GUI 桌面登录。我可以通过使用虚拟控制台之一，通过命令行界面（CLI）本地登录，然后远程使用 SSH 。问题的原因是因为 /tmp 文件系统满了，因此 GUI 桌面登录时所需要的一些临时文件不能被创建。因为命令行界面登录不需要在 /tmp 目录中创建文件，所以无可用空间并不会阻止我使用命令行界面来登录。在这种情况下，/tmp 目录是一个分离的文件系统，在 /tmp 所位于的逻辑卷上还有大量的可用空间。我简单地扩展了 /tmp 逻辑卷的容量到能够容纳主机所需要的临时文件，于是问题便解决了。注意，这个解决方法不需要重启，当 /tmp 文件系统扩大以后，用户就可以登录到桌面了。 当我在一家很大的科技公司当实验室管理员的时候，遇到过另外一个故障。开发者将一个应用程序安装到了一个错误的位置（/var）。结果该应用程序崩溃了，因为 /var 文件系统满了，由于缺乏空间，存储于 /var/log 中的日志文件无法附加新的日志消息。然而，系统仍然在运行，因为 root 文件系统和 /tmp 文件系统还没有被填满。删除了该应用程序并重新安装在 /opt 文件系统后，问题便解决了。 文件系统类型 Linux 系统支持大约 100 种分区类型的读取，但是只能对很少的一些进行创建和写操作。但是，可以挂载不同类型的文件系统在同一个 root 文件系统上，并且是很常见的。在这样的背景下，我们所说的文件系统一词是指在硬盘驱动器或逻辑卷上的一个分区中存储和管理用户数据所需要的结构和元数据。能够被 Linux 系统的 fdisk 命令识别的文件系统类型的完整列表在此，你可以感受一下 Linux 系统对许多类型的系统的高度兼容性。David Both 居住在美国北卡罗纳州的首府罗利，是一个 Linux 开源贡献者。他已经从事 IT 行业 40 余年，在 IBM 教授 OS/2 20 余年。1981 年，他在 IBM 开发了第一个关于最初的 IBM 个人电脑的培训课程。他也曾在 Red Hat 教授 RHCE 课程，也曾供职于 MCI worldcom，Cico 以及北卡罗纳州等。他已经为 Linux 开源社区工作近 20 年。 Linux 支持读取这么多类型的分区系统的主要目的是为了提高兼容性，从而至少能够与一些其他计算机系统的文件系统进行交互。下面列出了在 Fedora 中创建一个新的文件系统时的所有可选类型： btrfs cramfs ext2 ext3 ext4 fat gfs2 hfsplus minix msdos ntfs reiserfs vfat xfs 其他发行版支持创建的文件系统类型不同。比如，CentOS 6 只支持创建上表中标为黑体的文件系统类型。 挂载 在 Linux 系统上“挂载mount”文件系统的术语是指在计算机发展的早期，磁带或可移动的磁盘组需要需要物理地挂载到一个合适的驱动器设备上。当通过物理的方式放置到驱动器上以后，操作系统会逻辑地挂载位于磁盘上的文件系统，从而操作系统、应用程序和用户才能够访问文件系统中的内容。 一个挂载点简单的来说就是一个目录，就像任何其它目录一样，是作为 root 文件系统的一部分创建的。所以，比如，home 文件系统是挂载在目录 /home 下。文件系统可以被挂载到其他非 root 文件系统的挂载点上，但是这并不常见。 在 Linux 系统启动阶段的最初阶段，root 文件系统就会被挂载到 root 目录下（/）。其它文件系统在之后通过 SystemV 下的 rc 或更新一些的 Linux 发行版中的 systemd 等 Linux 启动程序挂载。在启动进程中文件系统的挂载是由 /etc/fstab 配置文件管理的。一个简单的记忆方法是，fstab 代表“文件系统表file system table”，它包含了需要挂载的文件系统的列表，这些文件系统均指定了挂载点，以及针对特定文件系统可能需要的选项。 使用 mount 命令可以把文件系统挂载到一个已有的目录/挂载点上。通常情况下，任何作为挂载点的目录都应该是空的且不包含任何其他文件。Linux 系统不会阻止用户挂载一个已被挂载了文件系统的目录或将文件系统挂载到一个包含文件的目录上。如果你将文件系统挂载到一个已有的目录或文件系统上，那么其原始内容将会被隐藏，只有新挂载的文件系统的内容是可见的。 结论 我希望通过这篇文章，阐明了围绕文件系统这个术语的一些可能的模糊之处。我花费了很长的时间，以及在一个良师的帮助下才真正理解和欣赏到 Linux 文件系统的复杂性、优雅性和功能以及它的全部含义。 如果你有任何问题，请写到下面的评论中，我会尽力来回答它们。 下个月 Linux 的另一个重要概念是：万物皆为文件。这个概念对用户和系统管理员来说有一些有趣和重要的实际应用。当我说完这个理由之后，你可能会想阅读我的文章：万物皆为文件，这篇文章会在我下个月计划写的关于 /dev 目录的文章之前写完。（LCTT 译注，也可参阅这篇） （题图 : 原始图片来自 Rikki Endsley. CC BY-SA 4.0） via: https://opensource.com/life/16/10/introduction-linux-filesystems 作者：David Both译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"C 语言中变量的段","date":"2017-09-12T02:16:42.000Z","path":"2017/09/12/the-Section-of-Variables/","text":"前言 在 C 语言中，不同的变量位于不同的段，下面进行简单分析。 看下面一个简单的 C 程序： 123456789101112131415161718 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *myname=\"Bao Yungang\";char gdata[128];char bdata[16] = &#123;1,2,3,4&#125;;main() &#123; char * ldata[16]; char * ddata; ddata = malloc(16); printf(\"myname:%llX\\n\", myname); printf(\"main: %llX\\n\", main); printf(\"gdata: %llX\\nbdata:%llX\\nldata:%llx\\n&amp;ddata:%llx\\nddata: %llx\\n\", gdata,bdata,ldata,&amp;ddata,ddata); free(ddata); return 1;&#125; 我们分析一下程序中出现的变量所位于的段。 分析 首先，根据所学知识进行分析： myname 变量是一个全局变量，并且进行了初始化，指向一个字符串常量。因此，myname 变量本身位于数据段：.data myname所指向的字符串是一个字符串常量，根据 C 语言知识，是只读的，所以应位于只读数据段：.rodata gdata是一个为进行初始化的全局变量，因此位于BSS段（Block Started by Symbol）。 bdata和myname一样是初始化了的全局变量，因此位于数据段。 ldata是一个main函数中的局部变量，因此位于栈中。 ddata变量自身也是main函数中的一个局部变量，因此也位于栈中。 ddata所指向的内存空间是通过malloc函数动态分配的，因此位于堆中。 验证 下面，通过objdump来进行验证： 首先，使用gcc来编译源程序(Ubuntu 16.04.4 + gcc 5.4.0)： 1 gcc -save-temps addr_space.c 通过添加 -save-temps选项来生成中间文件。 下面，使用 objdump 来查看段信息： 1 objdump -D ./a.out 通过-D选项显示出所有段的内容。 首先看bdata 和myname ，我们可以直接在 .data 段看到： 12345678910111213141516 Disassembly of section .data:0000000000601040 &lt;__data_start&gt;: ...0000000000601048 &lt;__dso_handle&gt;: ...0000000000601050 &lt;myname&gt;: 601050: 68 07 40 00 00 pushq $0x4007 ...0000000000601060 &lt;bdata&gt;: 601060: 01 02 add %eax,(%rdx) 601062: 03 04 00 add (%rax,%rax,1),%eax ... 对于 gdata ，也可以直接在 .bss 段看到： 1234567 Disassembly of section .bss:0000000000601080 &lt;completed.7585&gt;: ...00000000006010a0 &lt;gdata&gt;: ... 下面看myname 所指向的字符串常量。 首先，运行程序，输出如下： 123456 myname:400768main: 400626gdata: 6010A0bdata:601060ldata:7ffc84068960ddata:1490010 由运行结果知，myname的值为 400768，它即为 myname所指向的字符串常量的地址。然后我们在 objdump的输出内容中搜索该地址，得到它位于 .rodata中： 12345678910111213141516171819202122232425262728293031323334353637383940 Disassembly of section .rodata:0000000000400760 &lt;_IO_stdin_used&gt;: 400760: 01 00 add %eax,(%rax) 400762: 02 00 add (%rax),%al 400764: 00 00 add %al,(%rax) 400766: 00 00 add %al,(%rax) 400768: 42 61 rex.X (bad) 40076a: 6f outsl %ds:(%rsi),(%dx) 40076b: 20 59 75 and %bl,0x75(%rcx) 40076e: 6e outsb %ds:(%rsi),(%dx) 40076f: 67 61 addr32 (bad) 400771: 6e outsb %ds:(%rsi),(%dx) 400772: 67 00 6d 79 add %ch,0x79(%ebp) 400776: 6e outsb %ds:(%rsi),(%dx) 400777: 61 (bad) 400778: 6d insl (%dx),%es:(%rdi) 400779: 65 3a 25 6c 6c 58 0a cmp %gs:0xa586c6c(%rip),%ah # a9873ec &lt;_end+0xa3862cc&gt; 400780: 00 6d 61 add %ch,0x61(%rbp) 400783: 69 6e 3a 20 25 6c 6c imul $0x6c6c2520,0x3a(%rsi),%ebp 40078a: 58 pop %rax 40078b: 0a 00 or (%rax),%al 40078d: 00 00 add %al,(%rax) 40078f: 00 67 64 add %ah,0x64(%rdi) 400792: 61 (bad) 400793: 74 61 je 4007f6 &lt;__GNU_EH_FRAME_HDR+0x36&gt; 400795: 3a 20 cmp (%rax),%ah 400797: 25 6c 6c 58 0a and $0xa586c6c,%eax 40079c: 62 (bad) 40079d: 64 61 fs (bad) 40079f: 74 61 je 400802 &lt;__GNU_EH_FRAME_HDR+0x42&gt; 4007a1: 3a 25 6c 6c 58 0a cmp 0xa586c6c(%rip),%ah # a987413 &lt;_end+0xa3862f3&gt; 4007a7: 6c insb (%dx),%es:(%rdi) 4007a8: 64 61 fs (bad) 4007aa: 74 61 je 40080d &lt;__GNU_EH_FRAME_HDR+0x4d&gt; 4007ac: 3a 25 6c 6c 78 0a cmp 0xa786c6c(%rip),%ah # ab8741e &lt;_end+0xa5862fe&gt; 4007b2: 64 64 61 fs fs (bad) 4007b5: 74 61 je 400818 &lt;__GNU_EH_FRAME_HDR+0x58&gt; 4007b7: 3a 25 6c 6c 78 0a cmp 0xa786c6c(%rip),%ah # ab87429 &lt;_end+0xa586309&gt; ... 因此，说明 myname指向的字符串常量位于 .rodata 中。事实上，看中间一栏，从 400768 开始，到 400772 的第一个数结束，其中的内容 42 61 6f 20 59 75 6e 67 61 6e 67对应的 ASCII 码就是字符串 “Bao Yungang” 。 对于 ldata 和 ddata 以及 ddata 所指向的分配空间，很难直接从 objdump 的输出中看出来。我们再把 ddata变量本身的地址也打印出来： 1234567 myname:400768main: 400626gdata: 6010A0bdata:601060ldata:7ffe92607930&amp;ddata:7ffe92607928ddata: 221a010 我们看到，ldata和ddata的地址非常大，而 ddata所指向的分配空间的地址相对来说要小很多，这其实也一定程度上验证了我们的结论，根据我们已知的结论，在程序执行过程中，函数中的局部变量是在函数压栈以后，在栈中分配的，而 malloc 函数分配的空间则是在堆中进行分配的，而栈是从上往下长（高地址到低地址），堆则相反，是从下往上长（低地址到高地址），因此，栈中的变量地址较大，而堆中的则较小，所以，程序运行结果与之相符。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"编译器简介： 在 Siri 前时代如何与计算机对话","date":"2017-09-12T02:16:15.000Z","path":"2017/09/12/Introduction-to-Compiler/","text":"简单说来，一个编译器compiler不过是一个可以翻译其他程序的程序。传统的编译器可以把源代码翻译成你的计算机能够理解的可执行机器代码。（一些编译器将源代码翻译成别的程序语言，这样的编译器称为源到源翻译器或转化器transpilers。）LLVM 是一个广泛使用的编译器项目，包含许多模块化的编译工具。 传统的编译器设计包含三个部分： 前端Frontend将源代码翻译为中间表示intermediate representation (IR)* 。clang 是 LLVM 中用于 C 家族语言的前端工具。 优化器Optimizer分析 IR 然后将其转化为更高效的形式。opt 是 LLVM 的优化工具。 后端Backend通过将 IR 映射到目标硬件指令集从而生成机器代码。llc 是 LLVM 的后端工具。 注：LLVM 的 IR 是一种和汇编类似的低级语言。然而，它抽离了特定硬件信息。 Hello, Compiler 下面是一个打印 “Hello, Compiler!” 到标准输出的简单 C 程序。C 语法是人类可读的，但是计算机却不能理解，不知道该程序要干什么。我将通过三个编译阶段使该程序变成机器可执行的程序。 123456789 // compile_me.c// Wave to the compiler. The world can wait.#include &lt;stdio.h&gt;int main() &#123; printf(\"Hello, Compiler!\\n\"); return 0;&#125; 前端 正如我在上面所提到的，clang 是 LLVM 中用于 C 家族语言的前端工具。Clang 包含 C 预处理器C preprocessor、词法分析器lexer、语法解析器parser、语义分析器semantic analyzer和 IR 生成器IR generator。 C 预处理器在将源程序翻译成 IR 前修改源程序。预处理器处理外部包含文件，比如上面的 #include &lt;stdio.h&gt;。 它将会把这一行替换为 stdio.h C 标准库文件的完整内容，其中包含 printf 函数的声明。 通过运行下面的命令来查看预处理步骤的输出： 1 clang -E compile_me.c -o preprocessed.i 词法分析器（或扫描器scanner或分词器tokenizer）将一串字符转化为一串单词。每一个单词或记号token，被归并到五种语法类别之一：标点符号、关键字、标识符、文字或注释。 compile_me.c 的分词过程： 语法分析器确定源程序中的单词流是否组成了合法的句子。在分析记号流的语法后，它会输出一个抽象语法树abstract syntax tree（AST）。Clang 的 AST 中的节点表示声明、语句和类型。 compile_me.c 的语法树： 语义分析器会遍历抽象语法树，从而确定代码语句是否有正确意义。这个阶段会检查类型错误。如果 compile_me.c 的 main 函数返回 &quot;zero&quot;而不是 0， 那么语义分析器将会抛出一个错误，因为 &quot;zero&quot; 不是 int 类型。 IR 生成器将抽象语法树翻译为 IR。 对 compile_me.c 运行 clang 来生成 LLVM IR： 1 clang -S -emit-llvm -o llvm_ir.ll compile_me.c 在 llvm_ir.ll 中的 main 函数： 1234567891011 ; llvm_ir.ll@.str = private unnamed_addr constant [18 x i8] c\"Hello, Compiler!\\0A\\00\", align 1define i32 @main() &#123; %1 = alloca i32, align 4 ; &lt;- memory allocated on the stack store i32 0, i32* %1, align 4 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0)) ret i32 0&#125;declare i32 @printf(i8*, ...) 优化程序 优化程序的工作是基于其对程序的运行时行为的理解来提高代码效率。优化程序将 IR 作为输入，然后生成改进后的 IR 作为输出。LLVM 的优化工具 opt 将会通过标记 -O2（大写字母 o，数字 2）来优化处理器速度，通过标记 Os（大写字母 o，小写字母 s）来减少指令数目。 看一看上面的前端工具生成的 LLVM IR 代码和运行下面的命令生成的结果之间的区别： 1 opt -O2 -S llvm_ir.ll -o optimized.ll 在 optimized.ll 中的 main 函数： 12345678910 optimized.ll@str = private unnamed_addr constant [17 x i8] c\"Hello, Compiler!\\00\"define i32 @main() &#123; %puts = tail call i32 @puts(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str, i64 0, i64 0)) ret i32 0&#125;declare i32 @puts(i8* nocapture readonly) 优化后的版本中， main 函数没有在栈中分配内存，因为它不使用任何内存。优化后的代码中调用 puts 函数而不是 printf 函数，因为程序中并没有使用 printf 函数的格式化功能。 当然，优化程序不仅仅知道何时可以把 printf 函数用 puts 函数代替。优化程序也能展开循环并内联简单计算的结果。考虑下面的程序，它将两个整数相加并打印出结果。 1234567 // add.c#include &lt;stdio.h&gt;int main() &#123; int a = 5, b = 10, c = a + b; printf(\"%i + %i = %i\\n\", a, b, c);&#125; 下面是未优化的 LLVM IR： 1234567891011121314151617181920 @.str = private unnamed_addr constant [14 x i8] c\"%i + %i = %i\\0A\\00\", align 1define i32 @main() &#123; %1 = alloca i32, align 4 ; &lt;- allocate stack space for var a %2 = alloca i32, align 4 ; &lt;- allocate stack space for var b %3 = alloca i32, align 4 ; &lt;- allocate stack space for var c store i32 5, i32* %1, align 4 ; &lt;- store 5 at memory location %1 store i32 10, i32* %2, align 4 ; &lt;- store 10 at memory location %2 %4 = load i32, i32* %1, align 4 ; &lt;- load the value at memory address %1 into register %4 %5 = load i32, i32* %2, align 4 ; &lt;- load the value at memory address %2 into register %5 %6 = add nsw i32 %4, %5 ; &lt;- add the values in registers %4 and %5\\. put the result in register %6 store i32 %6, i32* %3, align 4 ; &lt;- put the value of register %6 into memory address %3 %7 = load i32, i32* %1, align 4 ; &lt;- load the value at memory address %1 into register %7 %8 = load i32, i32* %2, align 4 ; &lt;- load the value at memory address %2 into register %8 %9 = load i32, i32* %3, align 4 ; &lt;- load the value at memory address %3 into register %9 %10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i32 0, i32 0), i32 %7, i32 %8, i32 %9) ret i32 0&#125;declare i32 @printf(i8*, ...) 下面是优化后的 LLVM IR： 12345678 @.str = private unnamed_addr constant [14 x i8] c\"%i + %i = %i\\0A\\00\", align 1define i32 @main() &#123; %1 = tail call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i64 0, i64 0), i32 5, i32 10, i32 15) ret i32 0&#125;declare i32 @printf(i8* nocapture readonly, ...) 优化后的 main 函数本质上是未优化版本的第 17 行和 18 行，伴有变量值内联。opt 计算加法，因为所有的变量都是常数。很酷吧，对不对？ 后端 LLVM 的后端工具是 llc。它分三个阶段将 LLVM IR 作为输入生成机器代码。 指令选择是将 IR 指令映射到目标机器的指令集。这个步骤使用虚拟寄存器的无限名字空间。 寄存器分配是将虚拟寄存器映射到目标体系结构的实际寄存器。我的 CPU 是 x86 结构，它只有 16 个寄存器。然而，编译器将会尽可能少的使用寄存器。 指令安排是重排操作，从而反映出目标机器的性能约束。 运行下面这个命令将会产生一些机器代码： 1 llc -o compiled-assembly.s optimized.ll 12345678910 _main: pushq %rbp movq %rsp, %rbp leaq L_str(%rip), %rdi callq _puts xorl %eax, %eax popq %rbp retqL_str: .asciz \"Hello, Compiler!\" 这个程序是 x86 汇编语言，它是计算机所说的语言，并具有人类可读语法。某些人最后也许能理解我。 相关资源： 设计一个编译器 开始探索 LLVM 核心库 via: https://nicoleorchard.com/blog/compilers 作者：Nicole Orchard译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Npm 安装 Hexo 失败的解决办法","date":"2017-09-02T05:12:32.000Z","path":"2017/09/02/Fix-Error-With-Install-Hexo/","text":"用 npm 安装 Hexo 时候出现错误，使用 sudo 安装依旧不行。 错误如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /usr/local/bin/hexo -&gt; /usr/local/lib/node_modules/hexo-cli/bin/hexo&gt; dtrace-provider@0.8.5 install /usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider&gt; node scripts/install.js&gt; hexo-util@0.6.1 postinstall /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util&gt; npm run build:highlight&gt; hexo-util@0.6.1 build:highlight /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.jsonsh: 1: cannot create highlight_alias.json: Permission deniednpm ERR! code ELIFECYCLEnpm ERR! errno 2npm ERR! hexo-util@0.6.1 build:highlight: `node scripts/build_highlight_alias.js &gt; highlight_alias.json`npm ERR! Exit status 2npm ERR! npm ERR! Failed at the hexo-util@0.6.1 build:highlight script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.┌──────────────────────────────────────────────────────────┐│ npm update check failed ││ Try running with sudo or get access ││ to the local update config store via ││ sudo chown -R $USER:$(id -gn $USER) /home/fenglv/.config │└──────────────────────────────────────────────────────────┘npm ERR! A complete log of this run can be found in:npm ERR! /home/fenglv/.npm/_logs/2017-09-02T05_00_49_566Z-debug.lognpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.2 (node_modules/hexo-cli/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.2: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"linux\",\"arch\":\"x64\"&#125;)npm ERR! code ELIFECYCLEnpm ERR! errno 2npm ERR! hexo-util@0.6.1 postinstall: `npm run build:highlight`npm ERR! Exit status 2npm ERR! npm ERR! Failed at the hexo-util@0.6.1 postinstall script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! /home/fenglv/.npm/_logs/2017-09-02T05_00_53_335Z-debug.log 解决办法：参见npm 官网 1 sudo chown -R $USER $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125; 问题解决。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"听说过时间表，但是你是否知道“哈希表”","date":"2017-09-02T04:44:26.000Z","path":"2017/09/02/Hash-Tables/","text":"探索哈希表hash table的世界并理解其底层的机制是非常有趣的，并且将会受益匪浅。所以，让我们了解它，并从头开始探索吧。 哈希表是许多现代软件应用程序中一种常见的数据结构。它提供了类似字典的功能，使你能够在其中执行插入、删除和删除等操作。这么说吧，比如我想找出“苹果”的定义是什么，并且我知道该定义被存储在了我定义的哈希表中。我将查询我的哈希表来得到定义。它在哈希表内的记录看起来可能像：&quot;苹果&quot; =&gt; &quot;一种拥有水果之王之称的绿色水果&quot;。这里，“苹果”是我的关键字，而“一种拥有水果之王之称的水果”是与之关联的值。 还有一个例子可以让我们更清楚，哈希表的内容如下： 1234 \"面包\" =&gt; \"固体\"\"水\" =&gt; \"液体\"\"汤\" =&gt; \"液体\"\"玉米片\" =&gt; \"固体\" 我想知道面包是固体还是液体，所以我将查询哈希表来获取与之相关的值，该哈希表将返回“固体”给我。现在，我们大致了解了哈希表是如何工作的。使用哈希表需要注意的另一个重要概念是每一个关键字都是唯一的。如果到了明天，我拥有一个面包奶昔（它是液体），那么我们需要更新哈希表，把“固体”改为“液体”来反映哈希表的改变。所以，我们需要添加一条记录到字典中：关键字为“面包”，对应的值为“液体”。你能发现下面的表发生了什么变化吗？（LCTT 译注：不知道这个“面包奶昔”是一种什么食物，大约是一种面包做的奶昔，总之你就理解成作者把液体的“面包奶昔”当成一种面包吧。） 1234 \"面包\" =&gt; \"液体\"\"水\" =&gt; \"液体\"\"汤\" =&gt; \"液体\"\"玉米片\" =&gt; \"固体\" 没错，“面包”对应的值被更新为了“液体”。 关键字是唯一的，我的面包不能既是液体又是固体。但是，是什么使得该数据结构与其他数据结构相比如此特殊呢？为什么不使用一个数组来代替呢？它取决于问题的本质。对于某一个特定的问题，使用数组来描述可能会更好，因此，我们需要注意的关键点就是，我们应该选择最适合问题的数据结构。例如，如果你需要做的只是存储一个简单的杂货列表，那么使用数组会很适合。考虑下面的两个问题，两个问题的本质完全不同。 我需要一个水果的列表 我需要一个水果的列表以及各种水果的价格（每千克） 正如你在下面所看到的，用数组来存储水果的列表可能是更好的选择。但是，用哈希表来存储每一种水果的价格看起来是更好的选择。 12345678 //示例数组[\"苹果\", \"桔子\", \"梨子\", \"葡萄\"] //示例哈希表 &#123; \"苹果\" : 3.05, \"桔子\" : 5.5, \"梨子\" : 8.4, \"葡萄\" : 12.4 &#125; 实际上，有许多的机会需要使用哈希表。 时间以及它对你的意义 这是对时间复杂度和空间复杂度的一个复习。 平均情况下，在哈希表中进行搜索、插入和删除记录的时间复杂度均为 O(1) 。实际上，O(1) 读作“大 O 1”，表示常数时间。这意味着执行每一种操作的运行时间不依赖于数据集中数据的数量。我可以保证，查找、插入和删除项目均只花费常数时间，“当且仅当”哈希表的实现方式正确时。如果实现不正确，可能需要花费很慢的 O(n) 时间，尤其是当所有的数据都映射到了哈希表中的同一位置/点。 构建一个好的哈希表 到目前为止，我们已经知道如何使用哈希表了，但是如果我们想构建一个哈希表呢？本质上我们需要做的就是把一个字符串（比如 “狗”）映射到一个哈希代码（一个生成的数），即映射到一个数组的索引。你可能会问，为什么不直接使用索引呢？为什么要这么麻烦呢？因为通过这种方式我们可以直接查询 “狗” 并立即得到 “狗” 所在的位置，String name = Array[&quot;狗&quot;] // 名字叫拉斯。而使用索引查询名称时，可能出现的情况是我们不知道名称所在的索引。比如，String name = Array[10] // 该名字现在叫鲍勃 - 那不是我的狗的名字。这就是把一个字符串映射到一个哈希代码的益处（对应于一个数组的索引而言）。我们可以通过使用模运算符和哈希表的大小来计算出数组的索引：index = hash_code % table_size。 我们需要避免的另一种情况是两个关键字映射到同一个索引，这叫做哈希碰撞，如果哈希函数实现的不好，这很容易发生。实际上，每一个输入比输出多的哈希函数都有可能发生碰撞。通过下面的同一个函数的两个输出来展示一个简单的碰撞： 12 int cat_idx = hashCode(\"猫\") % table_size; //cat_idx 现在等于 1int dog_idx = hashCode(\"狗\") % table_size; //dog_idx 也等于 1 我们可以看到，现在两个数组的索引均是 1 。这样将会出现两个值相互覆盖，因为它们被写到了相同的索引中。如果我们查找 “猫” 的值，将会返回 “拉斯” ，但是这并不是我们想要的。有许多可以解决哈希碰撞的方法，但是更受欢迎的一种方法叫做链接。链接的想法就是对于数组的每一个索引位置都有一个链表，如果碰撞发生，值就被存到链表中。因此，在前面的例子中，我们将会得到我们需要的值，但是我们需要搜索数组中索引为 1 的位置上的链表。伴有链接的哈希实现需要 O(1 + α) 时间，其中 α 是装载因子，它可以表示为 n/k，其中 n 是哈希表中的记录数目，k 是哈希表中可用位置的数目。但是请记住，只有当你给出的关键字非常随机时，这一结论才正确（依赖于 SUHA）。 这是做了一个很大的假设，因为总是有可能任何不相等的关键字都散列到同一点。这一问题的一个解决方法是去除哈希表中关键字对随机性的依赖，转而把随机性集中于关键字是如何被散列的，从而减少矛盾发生的可能性。这被称为…… 通用散列 这个观念很简单，从通用散列universal hash家族集合随机选择一个哈希函数 h 来计算哈希代码。换句话来说，就是选择任何一个随机的哈希函数来散列关键字。通过这种方法，两个不同的关键字的散列结果相同的可能性将非常低（LCTT 译注：原文是“not be the same”，应是笔误）。我只是简单的提一下，如果不相信我那么请相信数学。实现这一方法时需要注意的另一件事是如果选择了一个不好的通用散列家族，它会把时间和空间复杂度拖到 O(U)，其中 U 是散列家族的大小。而其中的挑战就是找到一个不需要太多时间来计算，也不需要太多空间来存储的哈希家族。 上帝哈希函数 追求完美是人的天性。我们是否能够构建一个完美的哈希函数，从而能够把关键字映射到整数集中，并且几乎没有碰撞。好消息是我们能够在一定程度上做到，但是我们的数据必须是静态的（这意味着在一定时间内没有插入/删除/更新）。一个实现完美哈希函数的方法就是使用 2 级哈希2-Level Hashing，它基本上是我们前面讨论过的两种方法的组合。它使用通用散列来选择使用哪个哈希函数，然后通过链接组合起来，但是这次不是使用链表数据结构，而是使用另一个哈希表。让我们看一看下面它是怎么实现的： 但是这是如何工作的以及我们如何能够确保无需关心碰撞？ 它的工作方式与生日悖论相反。它指出，在随机选择的一堆人中，会有一些人生日相同。但是如果一年中的天数远远大于人数（平方以上），那么有极大的可能性所有人的生日都不相同。所以这二者是如何相关的？对于每一个链接哈希表，其大小均为第一级哈希表大小的平方。那就是说，如果有两个元素被散列到同一个点，那么链接哈希表的大小将为 4 。大多数时候，链接哈希表将会非常稀疏/空。 重复下面两步来确保无需担心碰撞： 从通用散列家族中选择一个哈希函数来计算 如果发生碰撞，那么继续从通用散列家族中选择另一个哈希函数来计算 字面上看就是这样（这是一个 O(n^2) 空间的解）。如果需要考虑空间问题，那么显然需要另一个不同的方法。但是值得庆幸的是，该过程平均只需要进行两次。 总结 只有具有一个好的哈希函数才能算得上是一个好的哈希表。在同时保证功能实现、时间和空间的提前下构建一个完美的哈希函数是一件很困难的事。我推荐你在解决问题的时候首先考虑哈希表，因为它能够为你提供巨大的性能优势，而且它能够对应用程序的可用性产生显著差异。哈希表和完美哈希函数常被用于实时编程应用中，并且在各种算法中都得到了广泛应用。你见或者不见，哈希表就在这儿。 via: http://www.zeroequalsfalse.press/2017/02/20/hashtables/ 作者：Marty Jacobs译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"通过开源书籍学习 Ruby 编程","date":"2017-09-02T04:44:13.000Z","path":"2017/09/02/Open-Source-Ruby-Books/","text":"开源的 Ruby 书籍 Ruby 是由 Yukihiro “Matz” Matsumoto 开发的一门通用目的、脚本化、结构化、灵活且完全面向对象的编程语言。它具有一个完全动态类型系统，这意味着它的大多数类型检查是在运行的时候进行，而非编译的时候。因此程序员不必过分担心是整数类型还是字符串类型。Ruby 会自动进行内存管理，它具有许多和 Python、Perl、Lisp、Ada、Eiffel 和 Smalltalk 相同的特性。 Ruby on Rails 框架对于 Ruby 的流行起到了重要作用，它是一个全栈 Web 框架，目前已被用来创建许多受欢迎的应用，包括 Basecamp、GitHub、Shopify、Airbnb、Twitch、SoundCloud、Hulu、Zendesk、Square 和 Highise 。 Ruby 具有很高的可移植性性，在 Linux、Windows、Mac OS X、Cygwin、FreeBSD、NetBSD、OpenBSD、BSD/OS、Solaris、Tru64 UNIX、HP-UX 以及其他许多系统上均可运行。目前，Ruby 在 TIOBE 编程社区排名 12 。 这篇文章有 9 本很优秀的推荐书籍，有针对包括初学者、中级程序员和高级程序员的书籍。当然，所有的书籍都是在开源许可下发布的。 这篇文章是 OSSBlog 的系列文章开源编程书籍的一部分。 《Ruby Best Practices》 作者： Gregory Brown (328 页) 《Ruby Best Practices》适合那些希望像有经验的 Ruby 专家一样使用 Ruby 的程序员。本书是由 Ruby 项目 Prawn 的开发者所撰写的，它阐述了如何使用 Ruby 设计美丽的 API 和特定领域语言，以及如何利用函数式编程想法和技术，从而简化代码，提高效率。 《Ruby Best Practices》 更多的内容是关于如何使用 Ruby 来解决问题，它阐述的是你应该使用的最佳解决方案。这本书不是针对 Ruby 初学者的，所以对于编程新手也不会有太多帮助。这本书的假想读者应该对 Ruby 的相应技术有一定理解，并且拥有一些使用 Ruby 来开发软件的经验。 这本书分为两部分，前八章组成本书的核心部分，后三章附录作为补充材料。 这本书提供了大量的信息： 通过测试驱动代码 - 涉及了大量的测试哲学和技术。使用 mocks 和 stubs 通过利用 Ruby 神秘的力量来设计漂亮的 API：灵活的参数处理和代码块 利用动态工具包向开发者展示如何构建灵活的界面，实现单对象行为，扩展和修改已有代码，以及程序化地构建类和模块 文本处理和文件管理集中于正则表达式，文件、临时文件标准库以及文本处理策略实战 函数式编程技术优化了模块代码组织、存储、无穷目录以及更高顺序程序。 理解代码如何出错以及为什么会出错，阐述如何处理日志记录 通过利用 Ruby 的多语言能力削弱文化屏障 熟练的项目维护 本书为开源书籍，在 CC NC-SA 许可证下发布。 在此下载《Ruby Best Practices》。 《I Love Ruby》 作者： Karthikeyan A K (246 页) 《I Love Ruby》以比传统的介绍更高的深度阐述了基本概念和技术。该方法为编写有用、正确、易维护和高效的 Ruby 代码提供了一个坚实的基础。 章节内容涵盖： 变量 字符串 比较和逻辑 循环 数组 哈希和符号 Ranges 函数 变量作用域 类 &amp; 对象 Rdoc 模块和 Mixins 日期和时间 文件 Proc、匿名 和 块 多线程 异常处理 正则表达式 Gems 元编程 在 GNU 自由文档许可证之下，你可以复制、发布和修改本书，1.3 或任何之后版本由自由软件基金会发布。 点此下载《I Love Ruby》。 Programming Ruby – The Pragmatic Programmer’s Guide 作者： David Thomas, Andrew Hunt (HTML) 《Programming Ruby – The Pragmatic Programmer’s Guide》是一本 Ruby 编程语言的教程和参考书。使用 Ruby，你将能够写出更好的代码，更加有效率，并且使编程变成更加享受的体验。 内容涵盖以下部分： 类、对象和变量 容器、块和迭代器 标准类型 更多方法 表达式 异常、捕获和抛出 模块 基本输入和输出 线程和进程 何时抓取问题 Ruby 和它的世界、Web、Tk 和 微软 Windows 扩展 Ruby 映像、对象空间和分布式 Ruby 标准库 面向对象设计库 网络和 Web 库 嵌入式文件 交互式 Ruby shell 这本书的第一版在开放发布许可证 1.0 版或更新版的许可下发布。本书更新后的第二版涉及 Ruby 1.8 ，并且包括所有可用新库的描述，但是它不是在免费发行许可证下发布的。 点此下载《Programming Ruby – The Pragmatic Programmer’s Guide》。 《Why’s (Poignant) Guide to Ruby》 作者：why the lucky stiff (176 页) 《Why’s (poignant) Guide to Ruby》是一本 Ruby 编程语言的介绍书籍。该书包含一些冷幽默，偶尔也会出现一些和主题无关的内容。本书包含的笑话在 Ruby 社区和卡通角色中都很出名。 本书的内容包括： 关于本书 Kon’nichi wa, Ruby 一个快速（希望是无痛苦的）的 Ruby 浏览（伴随卡通角色）：Ruby 核心概念的基本介绍 代码浮动小叶：评估和值，哈希和列表 组成规则的核心部分：case/when、while/until、变量作用域、块、方法、类定义、类属性、对象、模块、IRB 中的内省、dup、self 和 rbconfig 模块 中心：元编程、正则表达式 当你打算靠近胡须时：在已存在类中发送一个新方法 天堂演奏 本书在 CC-SA 许可证许可下可用。 点此下载《Why’s (poignant) Guide to Ruby》。 《Ruby Hacking Guide》 作者： Minero Aoki ，翻译自 Vincent Isambart 和 Clifford Escobar Caoille (HTML) 通过阅读本书可以达成下面的目标： 拥有关于 Ruby 结构的知识 掌握一般语言处理的知识 收获阅读源代码的技能 本书分为四个部分： 对象 动态分析 评估 外部评估 要想从本书中收获最多的东西，需要具备一定 C 语言的知识和基本的面向对象编程知识。本书在 CC-NC-SA 许可证许可下发布。 原书的官方支持网站为 i.loveruby.net/ja/rhg/ 点此下载《Ruby Hacking Guide》 《The Book Of Ruby》 作者： How Collingbourne (425 页) 《The Book Of Ruby》是一本免费的 Ruby 编程高级教程。 《The Book Of Ruby》以 PDF 文件格式提供，并且每一个章节的所有例子都伴有可运行的源代码。同时，也有一个介绍来阐述如何在 Steel 或其他任何你喜欢的编辑器/IDE 中运行这些 Ruby 代码。它主要集中于 Ruby 语言的 1.8.x 版本。 本书被分成很小的块。每一个章节介绍一个主题，并且分成几个不同的子话题。每一个编程主题由一个或多个小的自包含、可运行的 Ruby 程序构成。 字符串、数字、类和对象 - 获取输入和输出、字符串和外部评估、数字和条件测试：if … then、局部变量和全局变量、类和对象、实例变量、消息、方法、多态性、构造器和检属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量 类等级、属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量 字符串和 Ranges - 用户自定义字符串定界符、引号等更多 数组和哈希 - 展示如何创建一系列对象 循环和迭代器 - for 循环、代码块、while 循环、while 修改器以及 until 循环 条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修改器、以及 case 语句 方法 - 类方法、类变量、类方法是用来干什么的、Ruby 构造器、单例方法、单例类、重载方法以及更多 传递参数和返回值 - 实例方法、类方法、单例方法、返回值、返回多重值、默认参数和多重参数、赋值和常量传递以及更多 异常处理 - 涉及 rescue、ensure、else、错误数量、retry 和 raise 块、Procs 和 匿名 - 阐述为什么它们对 Ruby 来说很特殊 符号 - 符号和字符串、符号和变量以及为什么应该使用符号 模块和 Mixins 文件和 IO - 打开和关闭文件、文件和目录、复制文件、目录询问、一个关于递归的讨论以及按大小排序 YAML - 包括嵌套序列，保存 YAML 数据以及更多 Marshal - 提供一个保存和加载数据的可选择方式 正则表达式 - 进行匹配、匹配群组以及更多 线程 - 向你展示如何同时运行多个任务 调试和测试 - 涉及交互式 Ruby shell（IRB.exe）、debugging 和 单元测试 Ruby on Rails - 浏览一个创建博客的实践指南 动态编程 - 自修改程序、重运算魔法、特殊类型的运算、添加变量和方法以及更多 本书由 SapphireSteel Software 发布，SapphireSteel Software 是用于 Visual Studio 的 Ruby In Steel 集成开发环境的开发者。读者可以复制和发布本书的文本和代码（免费版） 点此下载《The Book Of Ruby》 《The Little Book Of Ruby》 作者： Huw Collingbourne (87 页) 《The Little Book of Ruby》是一本一步接一步的 Ruby 编程教程。它指导读者浏览 Ruby 的基础。另外，它分享了《The Book of Ruby》一书的内容，但是它旨在作为一个简化的教程来阐述 Ruby 的主要特性。 章节内容涵盖： 字符串和方法 - 包括外部评估。详细描述了 Ruby 方法的语法 类和对象 - 阐述如何创建一个新类型的对象 类等级 - 一个特殊类型的类，其为一些其他类的简化并且继承了其他一些类的特性 访问器、属性、类变量 - 访问器方法，属性读写器，属性创建变量，调用超类方法以及类变量探索 数组 - 学习如何创建一系列对象：数组包括多维数组 哈希 - 涉及创建哈希表，为哈希表建立索引以及哈希操作等 循环和迭代器 - for 循环、块、while 循环、while 修饰器以及 until 循环 条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修饰器以及 case 语句 模块和 Mixins - 包括模块方法、模块作为名字空间模块实例方法、模块或 ‘mixins’、来自文件的模块和预定义模块 保存文件以及更多内容 本书可免费复制和发布，只需保留原始文本且注明版权信息。 点此下载《The Little Book of Ruby》 《Kestrels, Quirky Birds, and Hopeless Egocentricity》 作者： Reg “raganwald” Braithwaite (123 页) 《Kestrels, Quirky Birds, and Hopeless Egocentricity》是通过收集 “Raganwald” Braithwaite 的关于组合逻辑、Method Combinators 以及 Ruby 元编程的系列文章而形成的一本方便的电子书。 本书提供了通过使用 Ruby 编程语言来应用组合逻辑的一个基本介绍。组合逻辑是一种数学表示方法，它足够强大，从而用于解决集合论问题以及计算中的问题。 在这本书中，读者会会探讨到一些标准的 Combinators，并且对于每一个 Combinators，书中都用 Ruby 编程语言写程序探讨了它的一些结果。在组合逻辑上，Combinators 之间组合并相互改变，书中的 Ruby 例子注重组合和修改 Ruby 代码。通过像 K Combinator 和 .tap 方法这样的简单例子，本书阐述了元编程的理念和递归 Combinators 。 本书在 MIT 许可证许可下发布。 点此下载《Kestrels, Quirky Birds, and Hopeless Egocentricity》 《Ruby Programming》 作者： Wikibooks.org (261 页) Ruby 是一种解释性、面向对象的编程语言。 本书被分为几个部分，从而方便按顺序阅读。 开始 - 向读者展示如何在其中一个操作系统环境中安装并开始使用 Ruby Ruby 基础 - 阐述 Ruby 语法的主要特性。它涵盖了字符串、编码、写方法、类和对象以及异常等内容 Ruby 语义参考 内建类 可用模块，涵盖一些标准库 中级 Ruby 涉及一些稍微高级的话题 本书在 CC-SA 3.0 本地化许可证许可下发布。 点此下载《Ruby Programming》 无特定顺序，我将在结束前推荐一些没有在开源许可证下发布但可以免费下载的 Ruby 编程书籍。 Mr. Neighborly 的 Humble Little Ruby Book – 一个易读易学的 Ruby 完全指南。 Introduction to Programming with Ruby – 学习编程的基础知识，一切从零开始。 Object Oriented Programming with Ruby – 学习编程的基础知识，一切从零开始。 Core Ruby Tools – 对 Ruby 的四个核心工具 Gems、Ruby Version Managers、Bundler 和 Rake 进行了简短的概述。 Learn Ruby the Hard Way, 3rd Edition – 一本适合初学者的入门书籍。 Learn to Program – 来自 Chris Pine。 Ruby Essentials – 一个准确且简单易学的 Ruby 学习指南。 via: https://www.ossblog.org/study-ruby-programming-with-open-source-books/ 作者：Steve Emms译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"外部排序","date":"2017-08-08T04:53:19.000Z","path":"2017/08/08/External-Sort/","text":"主存储器与外部存储器 外存储器与内存储器相比,优点是: 价格较低 永久的存储能力 缺点: 访问外存储器上的数据比访问内存要慢5 ~ 6 个数量级 因此，要求我们在开发系统时必须考虑如何使外存访问次数达到最少。 磁盘 磁盘存储器通常称为直接存取设备,或随机存取设备,它访问外存上文件的任一记录的时间几乎相同。 磁盘存储器可以顺序存取,也可以随机存取。 每个记录盘面上有很多磁道,数据就存放在这些磁道上。它们在记录盘面上形成一个个同心圆。 每个记录盘面都有一个读写磁头。所有记录盘面的读写磁头都安装在同一个动臂上,随动臂向内或向外做径向移动,从一个磁道移到另一个磁道。 任一时刻,所有记录盘面的读写磁头停留在各个记录盘面的半径相同的磁道上。 各个记录盘面上半径相同的磁道合在一起称为柱面。一个磁道可以划分为若干段,称为扇区,一个扇区就是一次读写的最小数据量。这样,对磁盘存储器来说,从大到小的存储单位是:柱面号、盘片号、磁道号和扇区。 在磁盘组上一次读写的时间主要花在寻找时间上。因此,在磁盘上存放信息时应将相关信息放在同一柱面或邻近柱面上,以求在读写信息时尽量减少磁头来回移动的次数,以避免不必要的寻找时间。 外排序 当待排序的记录数目特别多时,在内存中不能一次处理,必须把它们以文件的形式存放于外存,排序时再把它们一部分一部分调入内存进行处理。这样,在排序过程中必须不断地在内存与外存之间传送数据。这种基于外部存储设备(或文件)的排序技术就是外排序。 外排序的基本过程 基于磁盘进行的排序多使用归并排序方法。其排序过程主要分为两个阶段: 按可用内存大小,将外存上含 n 个记录的文件划分为若干长度为 l 的段 , 用某种内排序方法对各段进行排序。经过排序的段叫做归并段 (Run) 。当它们生成后就被写到外存中去。 把1生成的初始归并段加以归并 , 一趟趟扩大归并段和减少归并段数 , 直至得到整个有序文件为止。 K-路平衡归并 做K-路平衡归并时，如果有m个初始归并段，相应的归并树有logkm+1(logkm上取整)层，需要归并logkm(上取整)趟。 败者树 败者树是一棵正则的完全二叉树。其中 每个叶结点存放各归并段在归并过程中当前参加比较的记录; 每个非叶结点记忆它两个子女结点中记录排序码大的结点 ( 即败者 ) ; 因此,根结点中记忆树中当前记录排序码最小的结点 ( 最小记录 ) 。 败者树与胜者树的区别在于一个选择了败者 ( 排序码大者)，一个选择了胜者(排序码小者) K-路平衡归并排序算法 12345678910111213141516171819202122232425262728293031323334353637 const int MaxValue = ; //当作无穷大值使用void kwaymerge(Element *r, int k) &#123; int i, q; r = new Element[k]; //败者树中的k个记录 int *key = new int[k+1]; //记录的排序码 int *loser = new int[k]; //存放败者树 for (i = 0; i &lt; k; i++) &#123; //叶结点的值 InputRecord(r[i]); key[i] = r[i].key; &#125;; for (i = 0; i &lt; k; i++) loser[i] = k; key[k] = -Maxvalue; //初始化 for (i = k-1; i &gt; 0; i--) adjust (key, loser, k, i); //从key[k-1]到key[0]调整形成败者树 while (key[loser[0]] != MaxValue) &#123; //选冠军 q = loser[0]; //取当前最小记录 OutputRecord(r[q]); //写到输出归并段 InputRecord(r[q]); //读入下一个记录 key[q] = r[q].key; adjust (key, loser, k, q); //从key[q]起调整 &#125; Output end of run marker; //输出段结束标志 delete []r; delete []key; delete []loser;&#125;; //败者树的调整算法void adjust (int key[]; int loser[]; int k; int q) &#123;// 从败者树某叶结点 key[q] 起到根进行比较 , 将最小// key 记录所在归并段的段号记入 loser[0] 。 for (int t = (k+q)/2; t &gt; 0; t /= 2)//t 是 q 的双亲 if (key[loser[t]] &lt; key[q]) &#123;// 败者记入 loser[t] ,胜者记入 q int temp = q; q = loser[t]; loser[t] = temp; &#125;//q 与 loser[t] 交换 loser[0] = q;&#125;; 每选出一个当前排序码最小的记录 , 就需要在将它送入输出缓冲区之后 , 从相应归并段的输入缓冲区中取出下一个参加归并的记录 , 替换已经取走的最小记录 , 再从叶结点到根结点 , 沿某一特定路径进行调整 , 将下一个排序码最小记录的归并段号调整到 loser[0]中。 段结束标志 MaxNum升入 loser[0], 排序完成。 归并路数 k 不是越大越好。归并路数 k 增大 , 相应需增加输入缓冲区个数。如果可供使用的内存空间不变 , 势必要减少每个输入缓冲区的容量 , 使内外存交换数据的次数增大。 初始归并段的生成 为减少读写磁盘次数 , 除增加归并路数 k 外 ,还可减少初始归并段个数 m 。在总记录数 n一定时 , 要减少 m , 必须增大初始归并段长度。 如果规定每个初始归并段等长 , 则此长度应根据生成它的内存工作区空间大小而定 , 因而 m的减少也就受到了限制。 为了突破这个限制 , 可采用败者树来生成初始归并段。在使用同样大内存工作区的情况下 ,可以生成平均比原来等长情况下大一倍的初始归并段 , 从而减少初始归并段个数。 最佳归并树 归并树是描述归并过程的 m 叉树。因为每一次做 m路归并都需要有 m个归并段参加 , 因此 , 归并树是只有度为 0和度为 m 的结点的正则 m 叉树。 在归并树中： 各叶结点代表参加归并的各初始归并段 叶结点上的权值即为该初始归并段中的记录个数 根结点代表最终生成的归并段 叶结点到根结点的路径长度表示在归并过程中的读记录次数 各非叶结点代表归并出来的新归并段 归并树的带权路径长度 WPL 即为归并过程中的总读记录数。因而,在归并过程中总的读写记录次数为 2*WPL 。 不同的归并方案所对应的归并树的带权路径长度各不相同。为了使得总的读写次数达到最少 , 需要改变归并方案 , 重新组织归并树。可将 Huffman 树的思想扩充到 m 叉树的情形。在归并树中 , 让记录个数少的初始归并段最先归并 , 记录个数多的初始归并段最晚归并 , 就可建立总读写次数达到最少的最佳归并树。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"内部排序","date":"2017-08-08T04:51:50.000Z","path":"2017/08/08/Inner-Sort/","text":"排序 排序:将一组杂乱无章的数据按一定的规律顺次排列起来。 假设含 n 个记录的序列为 { R1, R2, … , Rn }其相应的关键字序列为 { K1, K2, … , Kn }这些关键字相互之间可以进行比较,即在它们之间存在着这样一个关系 : Kp1 &lt;= Kp2 &lt;= …&lt;= Kpn按此固有关系将上式记录序列重新排列,即使序列成为一个按关键字排序的 序列:{ Rp1, Rp2, … , Rpn }的操作称作排序。 排序算法的稳定性 : 当输入含重复关键字时,重复元素在输入、输出序列中的相对次序是否保持不变。 内排序与外排序 : 内排序是指在 整个排序过程 数据元素全部存放在内存、 不需要访问外存便能完成 的排序, 称此类排序为内部排序 ; 反之,若参加排序的记录数量很大 ,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序, 称为外部排序。 排序算法的分类 :内部排序算法很多。但就其全面性能而言,很难认为哪种方法是最好的。没一种方法都有各自的优缺点,适合在不同环境下使用。插入排序、交换排序、选择排序、归并排序、计数排序等等 &lt; 按排序过程中依据的不同原则 &gt; 待排记录数据类型定义 1234567891011 //待排记录的数据类型定义如下 :#define MAXSIZE 1000 // 待排顺序表最大长度typedef int KeyType; // 关键字类型为整数类型typedef struct &#123; KeyType key;// 关键字项 InfoType otherinfo; // 其它数据项&#125; RcdType;// 记录类型typedef struct &#123; RcdType r[MAXSIZE+1]; // r[0] 闲置 int length;// 顺序表长度&#125; SqList;// 顺序表类型 冒泡排序 基于交换的排序方法。 观察：有序/无序序列中，任意/总有一对相邻元素顺序/逆序 扫描交换：依次比较每一对相邻元素，如有必要，交换之 经一轮扫描交换后，最大元素必然就位；经一轮扫描交换后，问题的规模缩减至n-1。 若整趟扫描都没有进行交换，则排序完成。 1234567891011121314151617181920212223242526 void BubbleSort(Elem R[ ], int n) &#123; i = n;//首先从n位置排序 bool sorted = false; while (!sorted) &#123;//第[i..n]大元素已排序，寻找 第i-1大元素 sorted = true; for (j = 1; j &lt; i; j++) //从[1..i-1]寻找第i-1大元素 if (R[j+1].key &lt; R[j].key) &#123; //将大的记录向后移 Swap(R[j], R[j+1]); sorted = false; //记下进行交换的记录位置 &#125; //if i -= 1; &#125; // while&#125; // BubbleSortvoid BubbleSort(Elem R[ ], int n) &#123; int i = n;//首先从n位置排序 while (i &gt;1) &#123;//第[i..n]大元素已排序，寻找 第i-1大元素 int lastExchangeIndex = 1; for (j = 1; j &lt; i; j++) //从[1..i-1]寻找第i-1大元素 if (R[j+1].key &lt; R[j].key) &#123; //将大的记录向后移 Swap(R[j], R[j+1]); lastExchangeIndex = j; //记下进行交换的记录位置 &#125; //if i = lastExchangeIndex; //本趟进行过交换的最后一个记录的位置 &#125; // while&#125; // BubbleSort 时间复杂度 最好情况：O(n)；最坏情况：O(n^2) 稳定性 稳定 归并排序 基本方法:分而治之，序列一分为二 //O(1)；子序列递归排序 //2×T(n/2)；合并有序子序列 //O(n) 归并排序算法的复杂度为 O(nlogn) 关键在于 merge 的实现 123456789101112131415161718192021222324252627 void mergesort (int low, int hi ) &#123; if (hi-lo&lt;2) return; // 单个元素区间自然有序 else &#123; mi = (low+hi)/2; // 以中点为界 mergesort (low, mi); // 将前半段排序 mergesort (mi+1, hi); // 对后半段排序 Merge (low, mi, hi); // 归并 &#125;&#125; // Msort//二路归并算法void Merge (int low, int mi, int hi) &#123; RcdType *A = elements+low; int lb = mi-low; RcdType *B = new RcdType[1b]; for (i=0; i&lt;lb; B[i] = A[i++]); int lc = hi-mi; RcdType *C = elements+mi; for (i=0, j=0, k=0; j&lt;lb || k&lt;lc; ) &#123; if ( (j&lt;lb) &amp;&amp; (lc&lt;=k || B[j].key&lt;=C[k].key) ) A[i++] = B[j++]; if ( (k&lt;lc) &amp;&amp; (lb&lt;=j || C[k].key&lt;B[j].key) ) A[i++] =C[k++]; &#125; delete(B);&#125;//Merge 算法分析 优点： 最坏情况下最优 O(nlogn) 性能的第一个排序算法 不需要随机读写,完全顺序访问 - 尤其适用于列表之类的序列，磁带之类的设备 只要实现恰当,可保证稳定 可扩展性极佳,十分适宜于外部排序 - 海量网页搜索结果的归并易于并行化 稳定的排序算法。 缺点： 需要对等规模的辅助空间 即便输入完全(或者接近)有序,仍需 O(nlogn) 时 插入排序 基本方法: 始终将序列看作两部分sorted + unsorted，L[0, r]+L[r, n} 初始条件：r=0; 迭代: 处理 e=L[r]，在 sorted 中确定当前元素 e 的适当位置,插入 e ,得到有序的 L[0, r] 不变性:随着 r 的递增, L[0, r) 始终有序,直到 r =n, L 即为整体有序 12345678 void InsertionSort ( SqList &amp;L ) &#123;// 对顺序表 L 作插入排序 for ( i=2; i&lt;=L.length; ++i ) // 逐个将 i 插入已排好 [1..i-1] 中 if (L.r[i].key &lt; L.r[i-1].key) &#123; // 只有小于时需要改变位置 p = search(L.r[i], i, L); L.r[p] = L.r[i]; &#125;&#125; // InsertSort 算法分析 最坏情况：O(n)； 最好情况：O(n^2)； 稳定的排序算法。 选择排序 起泡排序之所以需要O(n2)时间，是因为为挑选每个当前最大的元素M，需做O(n)次比较和O(n)次交换 实际上经过O(n)次比较确定M后，一次交换足矣 123456789101112 void SelectSort (Elem R[], int n ) &#123; // 对记录序列R[1..n]作简单选择排序。 for (i=1; i&lt;n; ++i) &#123; // 选择第 i 小的记录，并交换到位 j = SelectMinKey(R, i); // 与第 i 个记录交换 if (i!=j) int t = R[i]; R[i] = R[j]; R[j] = t; &#125;&#125; // SelectSort 算法分析 共迭代n次，在第k次迭代中SelectMinKey的复杂度O(n-k) SelectMinKey的复杂度可以降至O(logn) 树形选择排序/锦标赛排序 一种按照锦标赛思想进行选择排序的方法。这个过程可以用一棵有 n 个叶子结点的完全二叉树表示：叶节点:待排序元素(选手)；内部节点:孩子中的胜者； 这种比赛树又称为胜者树。 锦标赛选择 更新:唯上一优胜者的祖先,才有必要重新参加比赛，只需从其所在叶节点出发,逐层上溯直到树根。 堆排序 堆是满足下列性质的数列：{r1, r2, ..., rn} 大顶堆 r_i &gt;= r_2i, r_i &gt;= r_2i+1 小顶堆 r_i &lt;= r_2i, r_i &lt;= r_2i+1 堆的结构性 : 逻辑上:等同于完全二叉树 物理上:直接借助顺序存储实现 堆的堆序性：堆是符合这样定义的一棵有局部顺序的线性化完全二叉树：K[i]\\le K[parent(i)]或$K[i]\\ge K[parent(i)]` 优先级队列(PQ priority queue) 队列的一种，不过它可以按照自定义的一种方式（数据的优先级）来对队列中的数据进行态的访问，以方便快速求取最大优先级的数据。 栈和队列，都是PQ的特例——优先级完全取决于元素的插入次序 应用：操作系统中的任务调度、中断处理、离散事件模拟等等 作为底层数据结构所支持的高效操作，是很多高效算法的基础 完全二叉堆：插入 为插入一个新的元素 e ,只需将 e 作为末元素放入原顺序结构。 唯一可能违反堆序性的只有该新节点和它的父亲。 只需从其所在叶节点出发,逐层上溯直到满足堆序性【上滤】。 效率： e 与父亲的交换,每次只需 o(1) 时间,且每经过一次交换, e 都会上升一层; 在插入新节点 e 的整个过程中,只有 e 的祖先们才有可能需要参与交换; 堆是一棵完全树,必平衡,故 e 的祖先至多 o(logn) 所以，通过上滤,可在 O(logn) 时间内插入一个新节点,并整体的重新调整为堆。 1234567891011121314 //插入和上滤Insert(Sqlist &amp;heap, RedType e)&#123; heap.r[heap.length] = e; heap.length += 1; percolateUp(heap, heap.length);&#125; percolateUp(Sqlist &amp;heap, int i)&#123; while ( ParentValid(i) )&#123; j = Parent（i）； if ( heap.r[i].key &gt; heap.r[j].key ) break; swap(heap.r[i], heap.r[j]); i = j; &#125;&#125; 完全二叉堆：删除 最大元素始终在堆顶,故删除只需摘除首元素,代之以末元素 e；// 结构性自然保持,那堆序性如何保持? 唯一可能违反堆序性的只有该节点e 和它的孩子们。 只需从根节点出发,与孩子中的大者换位,逐层下滤直到满足堆 效率:通过下滤,可在 O(logn) 时间内删除堆顶节点,并整体地重新调整为堆。 建堆 自上而下的上滤 建堆可以是一个从空堆开始,依次插入各元素。 1234 Heapify(Sqlist &amp;L)&#123; for (i =1; i&lt;L.length; i++) percolateUp(L, i) ; // 经上滤插入各节点&#125; 效率: 在最坏情况下,每个元素都需上滤到根节点,所以时间复杂度是O(nlogn) 。 自下而上的下滤 给定堆 H0 、 H1 和节点 P,为了得到堆 H0 UPU H1 ,只需将 ra(H0的堆顶) 和 rb(H1的堆顶) 当作 P 的孩子,对 p 下滤 从下向上,子堆逐层合并 1234 Heapify(Sqlist &amp;L)&#123; for (int i = L.length/2; i&gt;0; i--) percolateDown(L, i) ; // 下滤各内部节点&#125; 效率：时间复杂度为O(n) 堆排序即是利用堆的特性,不断输出当前最小( 大 ) 值,从而实现对序列进行排序的一种排序方法。 堆排序是不稳定的排序算法。 1234567891011 //堆排序算法void HeapSort (Sqlist &amp;L ) &#123;// 对顺序表 L 进行堆排序 Heapify ( L ); // 建大顶堆 for ( i=H.length; i&gt;1; --i ) &#123; int t = H.r[0]; H.r[0] = H.r[i]; H.r[i] = t; // 将堆顶记录和当前未经排序子序列H.r[1..i] 中最后一个记录相互交换堆 &#125; percolateDown(L, 0) ; // 对 H.r[0..i-1] 调整,成为新堆&#125; // HeapSort 算法分析： 堆排序的时间复杂度为 O(nlogn) 。 堆排序方法对 n 较大的文件是很有效的。 左式堆 左式堆是一棵单侧倾斜的树: 节点分布偏向左侧 合并操作只涉及右侧 12345678910111213141516171819202122232425262728293031 //左式堆的合并BiNode *Merge(BiNode *a, *b)&#123; if ( !a) return b; if (!b) return a; if ( a-&gt;data&lt;=b-&gt;data ) swap( b, a);//一般确保b不大，确保堆序性 a-&gt;rchild = merge(a-rchild, b); //将a的右子堆与b合并 a-&gt;rchild-&gt;parent = a;//更新父子关系 if ( !a-&gt;lchild || a-&gt;lchild-&gt;NPL &lt; a-&gt;rchild-&gt;NPL ) swap( a-&gt;lchild, a-&gt;rchild ); a-&gt;NLP = a-&gt;rc ? A-&gt;rchild-&gt;NPL+1: 1;//更新父节点的NPL return a;&#125;//左式堆的插入 insert( )BiNode *insert(BiNode *a, e)&#123; BiNode *v = new BiNode(e); root= merge(a, v); root-&gt;parent = NULL;&#125;//左式堆的最大元素的删除DelMaxBiNode *insert(BiNode *root)&#123; BiNode *lHeap = root-&gt;lChild ;BiNode *rHeap = root-&gt;rChild; e = root-&gt;data; delete root; root = merge( lHeap,rHeap); if ( root ) root-&gt;parent = NULL; return e;&#125; 快速排序 分治策略的再一次体现 将序列分为两个子序列: S = SL +SR；规模缩小: max{|SL|,|SR|}&lt;n；彼此独立: max(SL ) &lt;= min(SR ) 在子序列分别递归地排序后,原序列自然有序 平凡解:当只剩单个元素时,本身就是解 QuickSort 的难点在于“分” [ 归并排序 ] 123456789101112131415161718192021222324252627282930313233 void QSort (RedType &amp; R[], int s, int t ) &#123; // 对记录序列R[s..t]进行快速排序 if (s &lt; t-1) &#123; // 长度大于1 pivotloc = Partition(R, s, t); // 对 R[s..t] 进行一次划分 QSort(R, s, pivotloc-1); // 对低子序列递归排序 QSort(R, pivotloc+1, t); // 对高子序列递归排序 &#125;&#125; // QSortvoid QuickSort( SqList &amp; L) &#123; // 对顺序表进行快速排序 QSort(L.r, 1, L.length);&#125; // QuickSortint Partition (RedType&amp; R[], int low, int high) &#123; pivotkey = R[low].key; // 枢轴 while (low&lt;high) &#123; while (low&lt;high &amp;&amp; R[high].key&gt;=pivotkey) --high; R[low]=R[high]; while (low&lt;high &amp;&amp; R[low].key&lt;=pivotkey) ++low; R[high]=R[low]; &#125; return low;// 返回枢轴所在位置&#125; // Partitionint Partition2 (RedType&amp; R[], int low, int high) &#123; pivotkey = R[low].key; // 枢轴 mid = low; for (int k = low+1; k&lt;=high; k++) if (R[k].key&lt;pivotkey) swap(R[++mid], R[k]); swap(R[low], R[mid]);return mid;// 返回枢轴所在位置&#125; // Partition例: 希尔排序 又称“缩小增量排序”，将记录序列分成若干子序列，分别对每个子序列进行插入排序。 1234567891011121314 void ShellSort (SqList &amp;L, int dlta[], int t)&#123;// 增量序列为 dlta[] 的希尔排序,序列长为 t for (k=0; k&lt;t; ++t) ShellInsert(L, dlta[k]);&#125; // ShellSortvoid ShellInsert ( SqList &amp;L, int dk ) &#123; for ( i=dk+1; i&lt;=n; ++i )// 对每个元素在当前增量子序列中排序 if ( L.r[i].key&lt; L.r[i-dk].key) &#123;// 在子序列中用直接插入法排序当前元素 L.r[0] = L.r[i]; for (j=i-dk; j&gt;0&amp;&amp;(L.r[0].key&lt;L.r[j].key); j-=dk) L.r[j+dk] = L.r[j]; // 记录后移,查找插入位置 L.r[j+dk] = L.r[0]; // 插入 &#125; // if&#125; // ShellInsert 算法分析 希尔排序是一种不稳定的插入排序方法。 希尔排序的时间复杂性与各列内部排序的算法 ( 插入 ) 由关。内部排序不一定是高效的,但需要是 input-sensitive 但其实际运行的时间更多地取决于所取“增量”序列的有关,涉及数学上尚未解决的难题。 基数排序 基数排序是一种借助“多关键字排序”的思想来实现“单关键字排序”的内部排序算法。 实现多关键字排序通常有两种作法 : 关键字{K^0&gt;K^1&gt;...&gt;K^{d-1}} 最高位优先 MSD 法 (Most Significant Digit first ) 先对 K^0 进行排序,按 K^0$的不同值将记录序列分成若干子序列之后,分别对 $K^1进行排,…,最后对最次位关键字排序。 最低位优先 LSD 法 (Least Significant Digit first) 先对K^{d-1} 进行排序,然后对K^{d-2} 进行排序, …, 最后对最主位关键字 K^0排序。 对比 最高位优先法 必须将序列逐层分割为若干子序列,然后对各子序列分别进行排序 。 最低位优先法 使用这种排序方法对每一个关键字进行排序时,不必分成子序列,对每个关键字都是整个序列参加排序。 按 LSD 排序时,可以通过若干次“分配”和“收集”来实现排序。其好处是不需要进行关键字间的比较。 实现 在计算机上实现基数排序时,为减少所需辅助存储空间,应采用链表作存储结构,即链式基数排序,具体作法为: 待排序记录以指针相链,构成一个链表; “分配” 时,按当前“关键字位”所取值,将记录分配到不同的 “链队列” 中,每个队列中记录的 “关键字位” 相同; “收集”时,按当前关键字位取值从小到大将各队列首尾相链成一个链表 ； 对每个关键字位均重复 2) 和 3) 两步。 链表基数排序算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #define MAX_NUM_OF_KEY 8#define RADIX 10#define MAX_SPACE 10000typedef struct&#123; KeysType keys[MAX_NUM_OF_KEY]; InfoType otheritems; int next;&#125;SLCell;typedef struct&#123; SLCell r[MAX_SPACE]; int keynum; int recnum;&#125;SLList;typedef int ArrType[RADIX];void Distribute(SLCell &amp;r, int I, ArrType &amp;f, ArrType &amp;e)&#123; for (j=0; j&lt;RADIX; ++j) f[j] = 0; for (p=r[0].next; p; p= r[p].next)&#123; j = r[p].keys[i]; if (!f[j]) f[j] = p; else r[e[j]].next = p; e[j] = p; &#125;&#125;Void Collect(SLCell &amp;r, int I, ArrType f, ArrType e)&#123; for (j=0; !f[j]; j = succ(j)); r[0].next = f[j]; t = e[j]; while (j&lt;RADIX)&#123; for (j=succ(j); j&lt;RADIX-1&amp;&amp;!f[j]; j = succ(j)); if (f[j]) &#123; r[t].next = f[j]; t = e[j];&#125; &#125; r[t].next = 0;&#125;Void Radixsort(SLList &amp;L)&#123; //L是静态链表表示的顺序表 //对L作基数排序，使得L成为自小到大的有序静态链表 for (i=0；i&lt;L.recnum;；++i）L.r[i].next = i+1； L.r[L.recnum].next = 0; for (i=0; i&lt;L.recnum; ++i)&#123; Distribute(L.r, i, f, e); Collect(L.r, I, f, e); &#125;&#125; 算法分析 若每个排序码有 d 位 , 需要重复执行 d 趟“分配”与“收集”。每趟对 n 个元素进行“分配”,对 radix 个队列进行“收集”。总时间复杂度为O(d(n+radix)) 若基数 radix 相同 , 对于元素个数较多而排序码位数较少的情况 , 使用链式基数排序较好。 基数排序需要增加 n+2radix 个附加链接指针。 基数排序是稳定的排序方法。 2-路插入排序 2- 路插入排序是在折半插入排序的基础上进行的改进,目的是减少排序过程中记录移动的次数。 算法的思想为:另设一个和原始待排序列 L 相同的数组D ,该数组是一个循环向量。首先将 L[1] 复制给 D[1] ,并把 D[1]看成是已排好序的序列中处于中间位置的元素,之后将 L 中的从第二个元素开始依次插入到数组 D 中。 表插入排序 为了减少在排序过程中进行的“移动”记录的操作，静态链表结构可以避免元素移动。 123456789101112131415161718192021 #define SIZE 100 typedef struct &#123; RcdType rc; int next; &#125;SLNode; typedef struct &#123; SLNode numbers[SIZE]; int length; &#125;SLinkList; void LInsertionSort (Elem SL[ ] , int n)&#123;// 对记录序列 SL[1..n] 作表插入排序 SL[0].key = MAXINT ; SL[0].next = 1; SL[1].next = 0; for ( i=2; i&lt;=n; ++i )&#123; // 逐个将 i 插入已排好 [1..i-1] 中 for ( j=0, k = SL[0].next; SL[k].key&gt;=SL[i].key ;j=k, k=SL[k].next ); // 从表头开始寻找插入位置 SL[j].next = i; SL[i].next = k; &#125;&#125;// LinsertionSort 表插入排序的结果只是求得一个有序链表。为了方便查找，需要对结果进行重新排列求得一个有序数组。 比较 各种排序方法之间的比较： 排序方法 比较次数(最好) 比较次数(最差) 移动次数(最好) 移动次数(最差) 稳定性 附加存储 直接插入排序 n n^2 0 n^2 稳定 1 冒泡排序 n n^2 0 n^2 稳定 1 快速排序 nlog2n n^2 log2n n 不稳定 log2n 堆排序 nlog2n nlog2n 不稳定 1 归并排序 nlog2n nlog2n 稳定 n var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"查找和搜索-Part3","date":"2017-08-07T04:51:28.000Z","path":"2017/08/07/Find-and-Search-Part3/","text":"键树 / 数字查找树 Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征: ( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。 键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数 ( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关 ( 排序 ) 键树被约定为是一棵有序树,即同一层中兄弟结点之间依所含符号自左至右有序,并约定结束符‘ $’ 小于任何其它符号。 键树的存储结构:双链树 12345678910 typedef struct DLTNode &#123; char symbol; struct DLTNode *next; // 指向兄弟结点的指针 NodeKind kind; union &#123; Record *infoptr; // 叶子结点内的记录指针 struct DLTNode *first;// 分支结点内的孩子链指针 &#125;&#125; DLTNode, *DLTree; // 双链树的类型 在双链树中查找记录 假设: T 为指向双链树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $) 查找过程: 从树根出发,沿 first 指针到结点 p ,进行比较K.ch[i] =? p-&gt;symbol ,其中, 0 ≤ i ≤ K.num-1， 若相等,沿 first 指针比较下一个字符， 若不等,沿 next 指针顺序查找 12345678910111213141516171819202122 #define MAXKEYLEN 20typedef struct &#123; char ch[MAXKEYLEN]; // 关键字 int num;// 关键字长度&#125; KeysType;// 关键字类型RECORD *SearchDLTree(DLTree T, KeysType K) &#123; DLTree p; int i; p = T-&gt;first; i=0; // 初始化 while (p &amp;&amp; i&lt;K.num) &#123; while (p &amp;&amp; p-&gt;symbol != K.ch[i]) // 查找关键字的第 i 位 p = p-&gt;next; if (p &amp;&amp; i&lt;K.num-1) p = p-&gt;first; // 准备查找下一位 ++i; &#125; // 查找结束 if (!p) return NULL; // 查找不成功 else return p-&gt;infoptr; // 查找成功&#125; //Search DLTree 键树的存储结构: Trie 树 123456789101112131415 typedef struct TrieNode &#123; NodeKind kind; // 结点类型 union &#123; struct &#123; KeyType K; Record *infoptr &#125; lf;// 叶子结点 ( 关键字和指向记录的指针 ) struct &#123; TrieNode *ptr[27]; int num &#125; bh;// 分支结点 (27 个指向下一层结点的指针 ) &#125;&#125; TrieNode, *TrieTree; // 键树类型T 在Trie树中查找记录 假设 : – T 为指向 Trie 树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $) 查找过程: – 从树根出发,搜索和对应字母相应的指针 p:– 若 p 不空,且 p 所指为分支结点,则– p= p-&gt;bh.ptr[ord(K.ch[i])] ( 其中, ord 给出字符在字母表中的序号, 0 ≤ i ≤ K.num-1 )– 沿 p 指针比较下一个字符,直到叶子结点– 若未找到 p ,则查找不成功 1234567891011121314 //在键树 T 中查找关键字等于 K 的记录//ord 求字符在字母表中序号int ord(char c) &#123; return c-'@'; &#125;RECORD *SearchTrie(TrieTree T, KeysType K) &#123; TrieTree p; int i;// 对 K 的每个字符逐个查找, *p 为分支结点 for (p=T, i=0; p &amp;&amp; p-&gt;kind==BRANCH &amp;&amp; i&lt;K.num;p=p-&gt;bh.ptr[ord(K.ch[i])], i++) ; if (p &amp;&amp; p-&gt;kind==LEAF &amp;&amp;strcmp(p-&gt;lf.K.ch, K.ch)==0) return p-&gt;lf.infoptr; // 查找成功 else return NULL; // 查找不成功&#125; //SearchTrie 哈希表 基本思想 Motivation :已有的查找方法需要进行一系列的指定值与数据元素的关键字的比较 – 不同的查找其差别在于关键字和给定值进行比较的顺序不同– 原因:数据元素的关键字和数据元素的存储位置之间没有确定的关系– 结果:查找的效率取决于和给定值进行比较的关键字的个数 Solution : ( 通过哈希函数和冲突处理方法 ) 由记录的关键字确定记录在表中的地址,并将记录放入此地址,这样构成的表叫哈希表 – 哈希查找 ( 又叫散列查找 ) :通过哈希表中的对应关系进行一次存取,就能得到所查的元素– 特别适用于,只知道关键字的所属范围,但不知道确切的关键字 基本概念 哈希函数:在记录的关键字与记录的存储地址之间建立了一种确定的对应关系 – 哈希函数是一种映象,是从关键字空间到存储地址空间的一种映象。– 对于记录 ai , addr(ai) =H(ki) ,其中, addr(ai)是ai的地址, ki 是记录 ai 的关键字– 哈希函数通常是一种压缩映象,所以冲突不可避免– 冲突:对于关键字 ki、 kj ,若 ki!=kj ,但 H(ki)=H(kj)的现象叫冲突 (collision)– 同义词:具有相同哈希函数值的两个不同的关键字,称为该哈希函数的同义词 哈希表设计要素 确定哈希函数的定义域 ( 所有关键字 ) 和值域(0... m-1) 构造合适的哈希函数 – 使得同一关键字总被映射到同一地址– 使得对于所有可能的元素 ( 记录的关键字 ) ,其函数值能尽可能覆盖整个地址空间且均匀地映射到地址空间 所谓均匀 (uniform) 是指从一个关键字映射到地址集合中任何一个地址的概率是相等的,即使得发生冲突的可能性尽可能最少 – 哈希函数的构造简单,能在较短的时间内计算出来。 冲突元给出处理冲突的方法,即当冲突出现时如何为冲突元素找到另一个存储位置。 哈希函数的构造 直接定址法 直接定址法:取关键字或关键字的某个线性函数作哈希地址,即:H(key)=key 或 H(key)=a·key+b(a,b 为常数 ) 特点:直接定址法所得地址集合与关键字集合大小相等,不会发生冲突,但实际中很少使用 举例:根据年份查找该年份的人口数量 数字分析法 数字分析法:若关键字为以 r 为基的数,取关键字的若干位或组合作为哈希地址 特点:适用于关键字位数比哈希地址位数大,且事先知道可能出现的关键字的情况 ( 如频度 ) 平方取中法 平方取中法:将关键字平方后取中间几位作为哈希地址 哈希函数所取的位数由哈希表的长度决定 特点:一个数平方后中间几位和数的每一位都有关,则由随机分布的关键字得到的哈希地址也是随机的 – 适用于:不知道全部关键字情况– 适用于:关键字中的每一位都有某些数字重复出现 折叠法 折叠法 (folding) :将关键字分割成位数相同的几部分 ( 最后一部分可以不同 ) ,然后取这几部分的叠加和作为哈希地址 数位叠加有移位叠加和间界叠加 – 移位叠加:将分割后的几部分低位对齐相加– 间界叠加:从一端到另一端沿分割界来回折迭,然后对齐相加 特点:适于关键字位数很多,且每一位上数字分布大致均匀 除留余数法 除留余数法:取关键字被某个不大于哈希表表长 m 、但最接近于或等于 m 的质数 p 除后所得余数作哈希地址,即:H(key) = key MOD p (p &lt;= m)– 从 p 到 (m-1) 的地址可以在处理冲突的时候用 特点:简单、常用的哈希函数构造方法 一般,哈希函数可以设成: H(key) =(a*key+b) MOD p (a&gt;0, b&gt;0, a MOD p!=0, p 为素数 ) p的选取： 选取p=2^i(p&lt;= m) :便于用移位来实现运算,但等于将关键字的高位忽略而仅留下低位二进制数,因此,高位不同而低位相同的关键字都成为了同义词 选取p=qf (q 、 f 都是 p 的质因数, p&lt;=m) :则所有含有 q 或 f因子的关键字的哈希地址均是 q或 f 的倍数 随机数法 随机数法:取关键字的随机函数值作哈希地址,即H(key)=random(key) 当哈希表中关键字长度不等时,该方法比较合适 选取哈希函数时应考虑的因素 计算哈希函数所需时间 关键字的长度 哈希表长度 ( 即哈希地址范围 ) 关键字分布情况 记录的查找频率 冲突处理方法 开放定址法 当冲突发生时,形成某个探测序列;按此序列逐个探测哈希表中的其他地址,直到为给定的关键字找到一个空地址 ( 开放的地址 ) 为止,将发生冲突的记录放到该地址中 哈希地址的计算公式是: H0 =H(key)Hi (key)=(H(key)+di ) MOD m , i=1, 2, ..., m-1– 其中: H(key) 为哈希函数; m 是哈希表长度; Hi (key) 为经第 i 次探测后得到的哈希地址; di 是第 i 次探测时的增量序列 根据 di 的形成方法,有: – 线性探测法 (Linear Probing)– 二次探测法 (Quadratic Probing)– 伪随机探测法: 用伪随机函数获得伪随机数列 线性探测法 将哈希表 T[0 ...m-1] 看成循环向量。当发生冲突时,从初次发生冲突的位置依次向后探测其他的地址,即: 增量序列为: di=1, 2, 3, ..., m-1 设初次发生冲突的地址是 h ,则依次探测 T[h+1] , T[h+2]... ,直到 T[m-1] 时又循环到表头,再次探测 T[0] , T[1]... ,直到 T[h-1] 探测过程终止的情况: – 探测到的地址为空:表中没有记录。若是查找操作则失败;若是插入操作，则将记录写入到该地址– 探测到的地址有给定的关键字:若是查操作找则成功;若是插入操作则失败– 直到 T[h] :仍未探测到空地址或给定的关键字,则表示哈希表满 线性探测法的特点: – 优点:只要哈希表未满,总能找到一个不冲突的哈希地址– 缺点:二次聚集 ( 两个第一次哈希地址不同的记录争夺同一个后继哈希地址 ) 二次探测法 增量序列为: d_i=1^2,-1^2,2^2,-2^2,3^2,......+k^2,- k^2 (k &lt;= ⌊ m/2 ⌋ ) – 当 M是质数,且装填因子小于等于0.5 ,可以找出空闲地址– 表长 m 形如 4j+3 的质数 ( 如 7, 11, 19, 23, 31, 43, ... 等 ) 时,可以保证查找链的前 m 项均互异:基于 费马双平方定理 除了 2 这个特殊的素数,所有的素数都可以分两类:被 4 除余 1 的素数,如 5 , 13 , 17 , 29 , 37 , 41 ,这类素数都能表示为两个整数的平方和;第二类则是被 4 除余 3 的素数如 3, 7 , 11 , 19 , 23 , 31 。这类不能表示为两个整数的平方和。 优点:探测序列跳跃式地哈希到整个表中,不易产生冲突的聚集现象 缺点:不能保证探测到哈希表的所有地址 再哈希法 构造若干个哈希函数,当发生冲突时,利用不同的哈希函数再计算下一个新哈希地址,直到不发生冲突为止, – 即: Hi =RHi (key) i=1, 2, ..., k– 其中, RHi 为一组不同的哈希函数。第一次发生冲突时,用 RH1 计算,第二次发生冲突时,用 RH2 计算,依此类推直到到某个 Hi不发生冲突为止 优点:不易产生冲突的聚集现象 缺点:计算时间增加 链地址法 将所有关键字为同义词 ( 哈希地址相同 ) 的记录存储在一个单链表中,并用一维数组存放链表的头指针 设哈希表长为 m ,定义一个一维指针数组: RecNode *linkhash[m] ,其中 RecNode 是结点类型,每个分量的初值为空。凡哈希地址为 k 的记录都插入到以linkhash[k]为头指针的链表中,插入位置可以在表头或表尾或按关键字排序插入 优点:不易产生冲突的聚集;删除记录也很简单 建立公共溢出区 在基本哈希表之外,另外设立一个溢出表保存与基本表中记录冲突的所有记录 设哈希表长为 m ,设立基本哈希表 Hashtable[m],每个分量保存一个记录;溢出表 Overtable[m],一旦某个记录的哈希地址发生冲突,都填入溢出表中 哈希查找过程 哈希表的主要目的是用于快速查找,且插入和删除操作都要用到查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //开放定址哈希表的结构int hashsize[] = &#123; 997, ... &#125;;typedef struct &#123; ElemType *elem; //ElemType 中含 key int count; // 当前数据元素个数 int sizeindex;// hashsize[sizeindex] 为当前容量&#125; HashTable;#define SUCCESS 1#define UNSUCCESS 0#define DUPLICATE -1//在哈希表 H 中查找关键码为 K 的元素Status SearchHash(HashTable H, HKeyType K, int &amp;p, int &amp;c) &#123;// 若查找成功,以 p 指示待查数据元素在表中位置,并返回//SUCCESS ,否则,以 p 指示插入位置,并返回 UNSUCCESS,//c 用以记录冲突次数,其初值置零,供建表插入时参考 p = Hash(K); // 求得哈希地址 while ((H.elem[p].key != NULLKEY) &amp;&amp; !equal(K, (H.elem[p].key))) // 该位置中填有记录，并且关键字不相等 collision(p, ++c); // 求得下一探查地址 p if (equal(K, (H.elem[p].key))) return SUCCESS;// 查找成功, p 返回待查数据元素位置 else return UNSUCCESS;// 查找不成功, p 返回的是插入位置&#125; // SearchHash//哈希表插入算法Status InsertHash(HashTable &amp;H, HElemType e) &#123;// 查找不成功时插入数据元素 e 到开放定址哈希表 H 中,// 并返回 OK ;若冲突次数过大,则重建哈希表 int c = 0; int p = 0; if (SearchHash(H, e.key, p, c) == SUCCESS ) return DUPLICATE;// 表中已有与 e 有相同关键字的元素 else if (c &lt; H.cursize) &#123;// 冲突次数 c 未达到上限 ( 阈值 c 可调 ) H.elem[p] = e; ++H.count; return SUCCESS; // 插入 e &#125; else &#123; RecreateHashTable(H); // 重建哈希表 return UNSUCCESS; &#125;&#125; // InsertHash 哈希查找的性能分析 从哈希查找过程可见,尽管哈希表在关键字与记录的存储地址之间建立了直接映象,但由于存在冲突,查找过程仍是一个给定值与关键字进行比较的过程,仍要用 ASL 评价哈希查找效率 哈希查找时,关键字与给定值比较的次数取决于: – 哈希函数– 处理冲突的方法– 哈希表的填满因子：alpha = 填入表中的记录/表的大小 一般情况下,可以认为选用的哈希函数是均匀的,则在讨论 ASL 时,可以不考虑它的因素 哈希表的ASL是填满因子$\\alpha$的函数，而不是$n$的函数。 用哈希表构造查找表时，可以选择一个合适的填满因子，使得ASL限定在某个范围内。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"查找和搜索-Part2","date":"2017-08-07T04:51:24.000Z","path":"2017/08/07/Find-and-Search-Part2/","text":"AVL 树 Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率 Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和 Landis于 1962 年提出的,故称 AVL 树 变种:红黑树,树堆,伸展树 基本概念 平衡二叉树 (Balanced Binary Tree 或 Height-Balanced Tree) 或者是空树,或者是满足下列性质的二叉树 左子树和右子树深度之差的绝对值不大于 1 左子树和右子树也都是平衡二叉树 结点的平衡因子 (Balance Factor) :该结点的右子树的深度减去其左子树深度 平衡二叉树上每个结点的平衡因子只可能是 1 、 0和 -1 平衡二叉排序树 (Balanced Binary Sort Tree) :一棵二叉树既是二叉排序树又是平衡二叉树 结构定义 12345 typedef struct BSTNode &#123; ElemType data; int bf; // 平衡因子 struct BSTNode *lchild , *rchild;&#125; BSTNode, *BSTree; 平衡化旋转 如果在一棵平衡的二叉排序树中插入一个新结点,造成了不平衡。此时必须调整树的结构,使之平衡化 每插入一个新结点时, AVL 树中相关结点的平衡状态会发生改变。因此,在插入一个新结点后,需要从插入位置沿通向根的路径回溯,检查各结点的平衡因子 如果在某一结点发现不平衡,停止回溯。从发生不平衡的结点起,沿刚才回溯的路径取直接下两层的结点 如果这三个结点处于一条直线上,则采用单旋转进行平衡化。单旋转可按其方向分为左单旋转和右单旋转 , 其中一个是另一个的镜像,其方向与不平衡的形状相关 如果这三个结点处于一条折线上,则采用双旋转进行平衡化。 右单旋转(RotateRight) : LL 型 在结点 A 的左子女的左子树 D 上插入新结点使其高度增 1 导致结点 A 的平衡因子增到 -2 ,造成不平衡 为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 B 和 D ,以结点 B 为旋转轴,将结点 A 顺时针旋转 1234567891011 void R_Rotate(BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树作右旋处理// 处理之后 p 指向新的树根结点,// 即旋转处理之前的左子树的根结点 BSTree lc; lc = p-&gt;lchild; //lc 指向 *p 的左子树根结点 p-&gt;lchild = lc-&gt;rchild;// lc 的右子树挂接为 *p 的左子树 lc-&gt;rchild = p; p = lc; //p 指向新的根结点&#125; // R_Rotate 左单旋转 (RotateLeft) : RR 型 在结点 A 的右子女的右子树 E 中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变成 2 ,出现不平衡 为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 C 和 E ,以结点 C 为旋转轴,让结点 A 反时针旋转 p 123456789101112 void L_Rotate(BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树作左旋处理// 处理之后 p 指向新的树根结点// 即旋转处理之前的右子树的根结点 BSTree rc; rc = p-&gt;rchild; //rc 指向 *p 的右子树根结点//rc 的左子树挂接为 *p 的右子树 p-&gt;rchild = rc-&gt;lchild; rc-&gt;lchild = p;//p 指向新的根结点 p = rc;&#125; //L_Rotate 先左后右双旋转 (RotationLeftRight)-LR 型 在结点 A 的左子女的右子树中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变为 -2 ,造成不平衡 以结点 E 为旋转轴,将结点 B 反时针旋转,以 E 代替原来 B 的位置 1234567891011 void LR_Rotate (BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树做先左后右旋转 BSTree lc,rc;// 初始化 rc =p; lc =rc-&gt;lchild; p=lc-&gt;rchild; // 重新确定根 lc-&gt;rchild=p-&gt;lchild; // 为 BF 拉链 p-&gt;lchild=lc; // 设置新根的左孩子,为 EB 拉链 rc-&gt;lchild=p-&gt;rchild; // 为 AG 拉链 p-&gt;rchild=rc; // 为 EA 拉链&#125; // LR_Rotate 先右后左双旋转 (RotationRightLeft)-RL 型 在结点 A 的右子女的左子树中插入新结点,该子树高度增 1 。结点 A 的平衡因子变为 2 ,发生了不平衡 首先以结点 D 为旋转轴,将结点 C 顺时针旋转,以 D 代替原来 C 的位置 1234567891011 void RL_Rotate (BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树做先右后左旋转 BSTree lc,rc;// 初始化 lc =p; rc =lc-&gt;rchild; p=rc-&gt;lchild; rc-&gt;lchild=p-&gt;rchild; p-&gt;rchild=rc; lc-&gt;rchild=p-&gt;lchild; p-&gt;lchild=lc;&#125; // RL_Rotate AVL 树的插入 AVL 树的插入算法是从一棵空树开始,通过输入一系列关键字,逐步建立 AVL 树 在向一棵本来是平衡的 AVL 树中插入一个新结点时,需从插入结点沿通向根的路径向上回溯,如果某个结点的平衡因子的绝对值 |bf| &gt; 1 ,那么需从这个结点出发,使用平衡旋转方法进行平衡化处理 算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 #define LH -1 // 左高#define EH 0 // 等高#define RH 1 // 右高Status InsertAVL(BSTree &amp;T, ElemType e, Boolean &amp;taller) &#123;// 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点,// 则插入一个数据元素为 e 的新结点,并返回 1 ,否则返回0 。// 若因插入而使二叉排序树失去平衡,则作平衡旋转处理,// 布尔变量 taller 反映 T 长高与否 if (!T) &#123; // 插入新结点,树 \" 长高 \" ,置 taller 为 TRUE T = (BSTree) malloc (sizeof(BSTNode)); T-&gt;data = e; T-&gt;lchild = T-&gt;rchild = NULL; T-&gt;bf = EH; taller = TRUE; &#125; else &#123; if (EQ(e.key, T-&gt;data.key))&#123; taller = false; return 0;//已经存在记录，不再插入 &#125; if (LT(e.key, T-&gt;data.key)) &#123;// 应继续在 *T 的左子树中进行搜索 if (InsertAVL(T-&gt;lchild, e, taller)==0) return 0; // 未插入 if (taller) // 插入到 *T 的左子树中且左子树 \" 长高“ switch (T-&gt;bf) &#123; // 检查 *T 的平衡度 case LH: // 原本左子树比右子树高,需作左平衡处理 LeftBalance(T); taller = FALSE; break; case EH: // 原本左、右子树等高// 现因左子树增高而使树增高 T-&gt;bf = LH; taller = TRUE; break; case RH: // 原本右子树比左子树高 S// 现左、右子树等高 T-&gt;bf = EH; taller = FALSE; break; &#125; // switch (T-&gt;bf) &#125; // if else &#123; // 应继续在 T↑ 的右子树中进行搜索 if (InsertAVL(T-&gt;rchild, e, taller)==0) return 0; if (taller) // 已插入到 *T 的右子树且右子树长高 switch (T-&gt;bf) &#123; // 检查 *T 的平衡度 case LH: // 原本左子树比右子树高// 现左、右子树等高 T-&gt;bf = EH; taller = FALSE; break; case EH: // 原本左、右子树等高// 现因右子树增高而使树增高 T-&gt;bf = RH; taller = TRUE; break; case RH: // 原本右子树比左子树高// 需要作右平衡处理 RightBalance(T); taller = FALSE; break; &#125; //switch (T-&gt;bf) &#125; //else &#125; // else return 1; &#125; //InsertAVL//对以指针 T 所指结点为根的二叉树作左平衡旋转处理void LeftBalance(BSTree &amp;T) &#123;// 本算法结束时,指针 T 指向新的根结点 BSTree lc,rd; lc = T-&gt;lchild; // lc 指向 *T 的左子树根结点 switch (lc-&gt;bf) &#123; // 检查 *T 的左子树的平衡度// 并作相应平衡处理 case LH:// 新结点插入在 *T 的左孩子的左子树上,// 要作单右旋处理 T-&gt;bf = lc-&gt;bf = EH; R_Rotate(T); break; case RH: // 新结点插入在 *T 的左孩子的右子树上// 要作双旋处理 rd = lc-&gt;rchild; // rd 指向 *T 的左孩子的右子树根 switch (rd-&gt;bf) &#123; // 修改 *T 及其左孩子的平衡因子 case LH: T-&gt;bf = RH; lc-&gt;bf = EH; break; case EH: T-&gt;bf = lc-&gt;bf = EH; break; case RH: T-&gt;bf = EH; lc-&gt;bf = LH; break; &#125; //switch (rd-&gt;bf) rd-&gt;bf = EH;// 对 *T 的左子树作左旋平衡处理 L_Rotate(T-&gt;lchild); R_Rotate(T); // 对 *T 作右旋平衡处理 &#125; // switch (lc-&gt;bf)&#125; // LeftBalancevoid RightBalance(BSTree *T)&#123; BSTree lc,ld; lc=(*T)-&gt;rchild; switch(lc-&gt;bf)&#123; case RH: (*T)-&gt;bf=lc-&gt;bf=EH; L_Rotate(T); break; case LH: ld=lc-&gt;lchild; switch(ld-&gt;bf)&#123; case LH: (*T)-&gt;bf=EH; lc-&gt;bf=RH; break; case EH: (*T)-&gt;bf=lc-&gt;bf=EH; break; case RH: lc-&gt;bf=EH; (*T)-&gt;bf=LH; &#125; ld-&gt;bf=EH; R_Rotate(&amp;((*T)-&gt;rchild)); L_Rotate(T); break; case EH: (*T)-&gt;bf=RH; lc-&gt;bf=LH; L_Rotate(T); break; &#125;&#125;//RightBalance AVL树的删除 如果被删结点 x 最多只有一个子女,可做简单删除 – 将结点 x 从树中删去– 因为结点 x 最多有一个子女,可以简单地把 x 的双亲中原来指向 x 的指针改指到这个子女结点– 如果结点 x 没有子女, x 双亲原来指向 x的指针置为 NULL– 将原来以结点 x 为根的子树的高度减 1 如果被删结点 x 有两个子女 – 搜索 x 在中序次序下的直接前驱 y ( 同样可以找直接后继 )– 把结点 y 的内容传送给结点 x ,现在问题转移到删除结点 y 。把结点 y 当作被删结点 x– 因为结点 y 最多有一个子女,可以简单地用 前一页给出的方法进行删除 必须沿结点 x 通向根的路径反向追踪高度的变化对路径上各个结点的影响 用一个布尔变量 shorter 来指明子树高度是否被缩短 – 布尔变量 shorter 的值初始化为 True 对于从 x 的双亲到根的路径上的各个结点p,在 shorter 保持为 True 时执行下面操作;如果 shorter 变成 False ,算法终止 – 在每个结点上要做的操作取决于 shorter 的值和结点的 bf ,有时还要依赖子女的 bf 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 int deleteAVL(BSTree *t, ElemType key, bool&amp; shorter)&#123; if((*t)== NULL)&#123; shorter=false; return false; &#125; else if(EQ(key, (*t)-&gt;data))&#123; BSTNode* q = NULL; if((*t)-&gt;lchild == NULL)&#123; q = *t; (*t) = (*t)-&gt;rchild; delete q; shorter = true; &#125; else if((*t)-&gt;rchild == NULL)&#123; q = (*t); (*t) = (*t)-&gt;lchild; delete q; shorter = true; &#125; else&#123; q = (*t)-&gt;lchild; while(q-&gt;rchild) q = q-&gt;rchild; (*t)-&gt;data = q-&gt;data; deleteAVL(&amp;((*t)-&gt;lchild), q-&gt;data, shorter); &#125; &#125; else if(LT(key, (*t)-&gt;data))&#123; if(!deleteAVL(&amp;((*t)-&gt;lchild), key, shorter)) return false; if(shorter)&#123; switch((*t)-&gt;bf)&#123; case LH: (*t)-&gt;bf = EH; shorter = true; break; case EH: (*t)-&gt;bf = RH; shorter = false; break; case RH: RightBalance(t); if((*t)-&gt;rchild-&gt;bf == EH) shorter = false; else shorter = true; break; &#125; &#125; &#125; else&#123; if(!deleteAVL(&amp;((*t)-&gt;rchild), key, shorter)) return false; if(shorter)&#123; switch((*t)-&gt;bf)&#123; case LH: LeftBalance(t); if((*t)-&gt;lchild-&gt;bf == EH) shorter = false; else shorter = true; break; case EH: (*t)-&gt;bf = LH; shorter = false; break; case RH: (*t)-&gt;bf = EH; shorter = true; break; &#125; &#125; &#125; return true;&#125; AVL 上的查找 AVL上进行查找的时间复杂度为O(logn) . B树 一棵m阶B树，或者是空树，或者是满足下面性质的一棵树： 每个节点至多有m棵子树 节点要么是根节点，或者是叶子节点，或者至少有两棵子树 除根节点外，所有非终节点至少有m/2(上取整)棵子树 所有非终端节点应包含如下信息： (n, A_0, K_1, A_1, K_2, A_2, ..., K_n, A_n) 其中，K_i$是关键字，且$K_i &lt; K_{i+1}, A_i$为指向孩子节点的指针，且$A_{i-1}$所指向的子树中的所有节点的关键字均小于$K_i,A_i$所指向子树中的所有节点的关键字均大于$K_i，n$是节点中关键字的个数，$n+1为子树的棵树。 所有叶子节点都在树的同一层上，且不带信息。 叶子节点为外部节点，查找失败时候的节点，实际上不存在。 m阶B树定义 123456789 #define m 3typedef struct BTNode &#123; int keynum; // 结点中关键字个数,即结点大小 struct BTNode *parent; // 指向父结点的指针 KeyType key[m+1]; // 关键字, 0 号单元不用 Record *recptr[m+1]; // 记录指针向量,0 号单元不用 struct BTNode *ptr[m+1]; // 子树指针向量&#125; BTNode, *BTree; //B 树结点和 B 树的类型 B 树的查找:类似二叉排序树 (1) 从树的根结点 T 开始,在 T所指向的结点的关键字向量 key[1...keynum] 中查找给定值 K( 用 s 顺序查找或折半查找 ) : 若 key[i]=K(1≤i≤keynum) ,则查找成功,返回结点及关键字位置;否则,转 (2) ; (2) 将 K 与向量 key[1...keynum]中的各个分量的值进行比较,以选定查找的子树: ​ – 若 K &lt; key[1] : T=T-&gt;ptr[0]​ – 若 key[i] &lt; K&lt; key [i+1] (i=1, 2, ...keynum-1) : T=T-&gt;ptr[i]​ – 若 K&gt;key[keynum] : T=T-&gt;ptr[keynum] 转 (1) ,直到 T 是叶子结点且未找到相等的关键字,则查找失败。在 B+树上插入、删除的过程基本上和 B 树类似 1234567891011121314151617181920212223242526272829 typedef struct &#123; BTNode *pt; // 指向找到的结点 int i; // 在结点中的关键字序号 int tag;//1 :查找成功, 0 :查找失败&#125; Result;int Search(BTree p, KeyType K)&#123; for(int i=0; i &lt; p-&gt;keynum &amp;&amp; p-&gt;key[i+1] &lt;= K; i++); return i; // p-&gt;key[i] &lt;= K &lt; p-&gt;key[i+1]&#125;//在 m 阶 B 树 T 上查找关键字 K ,返回结果 (pt,i,tag)Result SearchBTree(BTree T, KeyType K) &#123; BTree p, q; int found, i, j=0; Result R;// 初始化, p 指向待查结点, q 指向 p 的双亲 p = T; q = NULL; found = FALSE; i = 0; while (p &amp;&amp; !found) &#123; i = Search(p, K); // 在 p-&gt;key[1..keynum] 中查找 i ,// 使得 p-&gt;key[i]&lt;=K&lt;p-&gt;key[i+1] if (i&gt;0 &amp;&amp; p-&gt;key[i]==K) found = TRUE; // 找到待查关键字 else &#123; q = p; p = p-&gt;ptr[i]; &#125; &#125; if (found) &#123; // 查找成功: pt 所指结点中第 i 个关键字等于 K R.pt = p; R.i = i; R.tag = 1; &#125; else &#123; // 关键字 k 应插入在 pt 所指结点中的第 i 和第 i+1 个关键字之间 R.pt = q; R.i = i; R.tag = 0; &#125; return R; // 返回结果信息 : K 的位置 ( 或插入位置 )&#125; // SearchBTree 在 B 树上的查找有两种基本操作: ​ – 在 B 树上查找结点:在磁盘上进行​ – 在结点中查找关键字:将结点信息读入内存后再查找 因此,磁盘上的查找次数 ( 即:待查找的记录关键字在 B 树上的层次数 ) 是决定 B 树查找效率的首要因素. B树的插入 B 树的生成是从空树起,逐个插入关键字 插入时不是每插入一个关键字就添加一个叶子结点,而是首先在最低层的某个叶子结点中添加一个关键字,然后 若关键字的数目达到 m ,则分裂成两个结点,并将中间关键字插入到 p 的父结点,这时,父结点也可能不满足 m 阶 B 树的要求( 分枝数大于 m) ,则必须对父结点进行分裂,一直进行下去,直到没有父结点或分裂后的父结点满足 m 阶 B 树的要求 当根结点分裂时,因没有父结点,则建立一个新的根, B 树增高一层 1234567891011121314 BTNode *split(BTNode *p)// 结点 p 中包含 m 个关键字,从中分裂出一个新的结点&#123; BTNode *q ; int k, mid, j ; q=(BTNode *)malloc(sizeof( BTNode)); mid=(m+1)/2; q-&gt;ptr[0]=p-&gt;ptr[mid]; for (j=1,k=mid+1; k&lt;=m; k++) &#123; q-&gt;key[j]=p-&gt;key[k] ; q-&gt;ptr[j++]=p-&gt;ptr[k] ; &#125; // 将 p 的后半部分移到新结点 q 中 q-&gt;keynum=m-mid ; p-&gt;keynum=mid-1 ; return(q) ;&#125; B树的删除 在 B 树上删除一个关键字 K ,首先找到关键字所在的结点 N ,然后在 N 中进行关键字 K 的删除操作。 B+树 m 阶 B+ 树, B 树的一种变体 一棵 m 阶 B+ 树与 m 阶 B 树的主要差异是: 若一个结点有 n 棵子树,则必含有 n 个关键字 所有叶子结点中包含了全部记录的关键字信息以及这些关键字记录的指针,而且叶子结点按关键字的大小从小到大顺序链接,构成一个有序链表 在 B+ 树中,所有的非叶子结点可以看成是索引,结点中只含有其子树的根结点中的最大 ( 或最小 ) 关键字 B+树定义 12345678910111213 #define M 3typedef enum&#123;branch, left&#125; NodeType;typedef struct BPNode &#123; NodeTag tag; // 结点标志 int keynum; // 结点中关键字的个数 struct BTNode *parent; // 指向父结点的指针 KeyType key[M+1]; // 关键字向量 ,key[0] 未用 union pointer &#123; struct BTNode *ptr[M+1]; // 子树指针向量 RecType *recptr[M+1]; //recptr[0] 未用 &#125;ptrType ; // 用联合体定义子树指针和记录指针&#125;BPNode; B+树的查找 与 B 树相比,对 B+ 树不仅可以从根结点开始按关键字随机查找,而且可以从最小关键字起,按叶子结点的链接顺序进行顺序查找。 在 B+ 树上进行随机查找的过程基本上和 B树类似。 在 B+ 树上进行随机查找时,若非叶子结点的关键字等于给定的 K 值,并不终止,而是继续向下直到叶子结点 ( 只有叶子结点才存储记录 ) , 即无论查找成功与否,都走了一条从根结点到叶子结点的路径。 B+ 树的插入、删除 在 B+ 树上插入、删除的过程基本上和 B 树类似。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"查找和搜索-Part1","date":"2017-08-05T04:51:20.000Z","path":"2017/08/05/Find-and-Search-Part1/","text":"基本概念 查找表 (Search Table) :相同类型的数据元素 ( 或记录 ) 组成的集合,每个数据元素通常由若干数据项构成 关键字 (Key ,码 ) :数据元素中某个 ( 或几个 ) 数据项的值,它可以标识一个数据元素 – 主关键字 (Primary Key) :能唯一标识一个数据元素的关键字– 次关键字 (Secondary Key) :能标识若干个数据元素的关键字 关键字类型 数据元素的关键字:其类型通常是可以进行比较运算的类型 典型的关键字类型 123456789 typedef float KeyType ;// 实型typedef int KeyType ; // 整型typedef char KeyType ; // 字符串型• 数据元素类型typedef struct RecType &#123;KeyType key ; // 关键字域... ... // 其他域&#125; ElemType; 对两个关键字的比较 123456789 //C 的宏定义// 对数值型关键字#define EQ(a, b) ((a)==(b))#define LT(a, b) ((a)&lt;(b))#define LQ(a, b) ((a)&lt;=(b))// 对字符串型关键字#define EQ(a, b) (!strcmp((a), (b)) )#define LT(a, b) (strcmp((a), (b))&lt;0 )#define LQ(a, b) (strcmp((a), (b))&lt;=0 ) 查找 根据给定的 Key 值,在查找表中确定一个关键字等于给定值的数据元素或记录 查找表中存在满足条件的数据元素 / 记录,则查找成功,返回所查到的数据元素或其在查找表中的位置 查找表中不存在满足条件的记录,则查找失败 “ 关键字等于给定值 ” 只是一种最为常用的查找条件,实际应用中可能会有其他的查找件,例如查找 “ 关键字在某个范围内的数据元素 ” 等等 采用何种查找方法,首先取决于查找表的组织,即按何种关系组织 / 存储数据元素 查找表是记录的集合,而集合中的元素之间是一种完全松散的关系,因此,查找表是一种非常灵活的数据结构,可以用多种方式来存储 查找及其方法分类 静态查找 / 静态查找表 (Static Search Table):只对该表的数据元素进行查询 动态查找 / 动态查找表 (Dynamic Search Table) :在对该表实施查找的同时,可插入查找表中不存在的记录,或从查找表中删除已存在的某个记录;表的结构本身是在查找过程中动态生成的 分类1：按存储结构的不同 线性表查找: 数据元素保存在顺序表或链表中 哈希查找:数据元素保存在哈希表中,根据给定的 Key 值直接访问 查找表, 从而找到要查找的记录 树表查找:数据元素保存在树中 分类2： 内查找:整个查找过程全部在内存进行 外查找:在查找过程中还需要访问外存，例如:查找表太大,无法全部放入内存中 查找方法的评价指标 查找过程中的主要操作是关键字的比较,查找过程中关键字的平均比较次数是衡量一个查找算法效率高低的标准 ASL (Average Search Length , 平均查找长度 ) 定义为需要和给定值进行比较的关键字的个数的期望值 静态查找表 静态查找表:可以用线性表 ( 顺序表或线性链表 ) 实现 静态查找表 StaticSearchTable 的基本操作: 123456 void CreateSSTable(SSTable *t);// 构造一个查找表void Destroy(SSTable *t);void ListSSTable(SSTable *t); // 输出查找表int SearchSSTable(SSTable *t,KeyType key); // 查找成功,返回元素值在表中位置void Traverser(SSTable *t, void Visit(ElemType *e)); // 按某种次序对 t 的每个元素调用函数 Visit()一次且一次 静态查找表的查找方法 基于顺序表的查找: 顺序查找 (SequentialSearch) ,逐一比较 基于有序表的查找 – 折半查找 / 二分查找 (Binary Search) :每次对查找表进行折半缩小– Fibonacci 查找 :根据 Fibonacci 数列的特点对查找表进行分割– 静态树表查找 基于索引顺序表的查找:索引顺序查找 /分块查找 (Blocking Search) ,基于顺序表和其索引的查找 顺序查找 顺序表的定义如下： 123456 typedef struct SSTable&#123;// 数据元素存储空间的基地址// 建表时按实际长度分配, 0 号单元留空ElemType *elem;int length ; // 实际元素个数&#125; SSTable; 顺序查找算法： 从表的一端 ( 例如:最后一个记录 ) 开始,逐个将记录的关键字和给定 Key 值进行比较– 若某个记录的关键字和给定 Key 值相等,查找成功– 否则,若扫描完整个表,仍然没有找到相应的记录,则查找失败 简单实现： 1234567 int SearchSSTable(SSTable *t, KeyType key) &#123; for(int i=1; i&lt;=t-&gt;length &amp;&amp; (t-&gt;elem[i].key != key); i++ ); if( i&lt;=t-&gt;length ) return i; else return 0;&#125; //Search_Seq 标准算法： 12345678 int SearchSSTable(SSTable *t,KeyType key) &#123;// 设置哨兵,查找失败时返回 0 t-&gt;elem[0].key=key;// 从后往前找 for (int i=t-&gt;length; !EQ(t-&gt;elem[i].key, key); i--) ; return i ; // 找不到时, i 为 0&#125;//设立哨兵后可以使循环中省掉了一次比较 算法分析： 查找成功时候的比较次数：ASL = (n+1)/2 查找失败时候的比较次数：ASL=n+1 若查找成功与不成功的概率相等，则 ASL = 3(n+1)/4 缺点： 查找效率低,当 n 较大时,不宜采用顺序查找。 改进： 根据数据元素被查找的概率组织顺序表，在不等概率的情况下，按被查找概率的升序排序。 在数据元素中增加一数据项,用于记录对该数据元素的访问次数– 在每次查找后,维护查找表使得其按照数据元素的访问次数升序排序 在每次查找后,将刚查找到的元素移动至表尾:已发生的事会重复发生 为顺序表加索引 折半查找 基于有序顺序表的查找算法。 – 查找表中的所有记录是按关键字有序 ( 升序或降序 ) 排列的 查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次将待查记录所在区间缩小一半 ) ,直到找到或找不到记录为止 算法思想： 初始:用 Low、 High 和 Mid 表示待查找区间的下界、上界和中间位置指针,初值设置为 Low=1 , High=n (1) 取中间位置 Mid : Mid=(Low+High)/2 (2) 比较中间位置记录的关键字与给定的 Ke值: – 相等:查找成功;– 大于:待查记录在区间的前半段,修改上界指针: High=Mid-1 ,转 (1) ;– 小于:待查记录在区间的后半段,修改下界指针: Low=Mid+1 ,转 (1) ; 直到越界 (Low&gt;High) ,查找失败 算法实现： 1234567891011121314151617 // 在有序表 t 中折半查找其关键字等于 key 的数据元素int SearchSSTable(SSTable *t, KeyType key) &#123; int low, high, mid; low = 1; high = t-&gt;length; // 置区间初值 while (low &lt;= high) &#123; mid = (low + high) / 2; if (EQ(key , t-&gt;elem[mid].key))// 找到,返回该待查元素在表中的位置 return mid; else if (LT(key, t-&gt;elem[mid].key))// 继续在前半区间进行查找 high = mid - 1; else // 继续在后半区间进行查找 low = mid + 1; &#125; return 0; // 顺序表中不存在待查元素&#125; 算法分析： 查找时,每经过一次比较,查找范围就缩小一半,该过程可用一棵二叉树表示: – 把当前查找区间的中点作为根结点– 左子区间和右子区间分别作为根的左子树和右子树– 排在中间位置前面的作为左子树的结点– 排在中间位置后面的作为右子树的结点 上述描述查找过程的二叉树被称为折半查找的判定树(Decision Tree) – 内结点代表顺序表中已有的元素,外结点代表失败结点,它表示在两个相邻已有元素值之间的值 找到有序表中任一记录的过程是走了一条从根结点到与该记录相应的结点的路径,与给定值进行比较的关键字个数为该结点在判定树上的层次数 查找成功时候的ASL = (n+1)/nlog2(n+1) - 1 当n很大时(n&gt;50)，ASL = log2(n+1) - 1 算法优缺点分析： Strength :折半查找速度很快 – 1000 个元素的有序表,至多需要比较 10 次– 1000,000个元素的有序表,需要不超过 20 次的比较 Limitation :查找对象是有序表,即在查找之前需要对顺序表进行排序操作 Weaknesses : – 折半查找无法应用于链表– 在不等概率查找的情况下,折半查找不一定是有序表最好的查找方法– 当查找表的长度不大时,也许折半查找的效率不如顺序查找 Conclusion :适合于大量的静态数据 – 有序表的插入和删除都比较麻烦,平均要移动表中一半的元素 Fibonacci 查找 基于有序顺序表的查找 – 查找表中的所有记录是按关键字有序 ( 升序或降序 )排列的 查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次根据 Fibonacci 数列的特点对查找表进行分割 ) ,直到找到或找不到记录为止 算法思想 设查找表中的记录数 n比某个 Fibonacci 数小 1,即设 n=F(j)-1 用 Low 、 High 和 Mid 表示待查找区间的下界、上界和分割位置,初值为 Low=1 , High=n (1) 取分割位置 Mid : Mid=F(j-1) (2) 比较 key 值与分割位置记录的关键字: – 相等: 查找成功– 小于:待查记录在区间的前半段,修改上界指针:High=Mid-1 ,这时,区间长度为 F(j-1)-1 ,转(1) ;– 大于:待查记录在区间的后半段,修改下界指针:Low=Mid+1 , 这时,区间长度为 F(j-2)-1 ,转(1) ; 直到越界 (Low&gt;High) ,查找失败 算法实现 1234567891011121314151617181920212223242526272829 //Fibonacci 数的计算int fib(int n) &#123; int i, f, f0=0, f1=1; if (n==0) return 0 ; if (n==1) return 1 ; for (i=2 ; i&lt;=n ; i++ ) &#123; f=f0+f1 ; f0=f1 ; f1=f ; &#125;chazhao return f ;&#125;// 在有序表 t 中用 Fibonacci 方法查找关键字为 key 的记录int SearchSSTableFibonacci(SSTable *t, KeyType key , int n)&#123; int Low=1, High, Mid, f1, f2 ; High=fib(n); f1=fib(n-1); f2=fib(n-2);chazhao while (Low&lt;=High) &#123; Mid=Low+f1-1; if ( EQ(key, t-&gt;elem[Mid].key) ) return Mid ; else if ( LT(key, t-&gt;elem[Mid].key) )&#123; High=Mid-1; f2=f1-f2; f1=f1-f2; &#125; else&#123; Low=Mid+1; f1=f1-f2; f2=f2-f1; &#125; &#125; return 0;&#125; 算法分析 Fibonacci 查找的平均性能比折半查找好，但最坏情况下比折半查找差。 插值查找：根据key值来决定与哪个记录比较并分区。 插值查找适用于关键字均匀分布。 索引顺序查找 / 分块查找 查找表的组织:将查找表分成几块 – 块间有序,即第 i+1 块的所有记录关键字均大于 ( 或小于 ) 第 i 块记录关键字– 块内无序– 在查找表的基础上附加一个索引表,索引表是按关键字有序的,索引表中记录的构成是:– 可以建立多级索引– 可以建立多种索引 先 ( 用顺序查找或折半查找 ) 确定待查记录所在块,再在块内查找 ( 顺序查找 ) 算法实现 123456789101112131415161718192021222324 //数据结构typedef struct IndexType &#123; KeyType maxkey; // 块中最大的关键字 int startpos;// 块的起始位置指针//int length;// 块的长度&#125; Index;//算法实现int SearchSSTableBlock (SSTable *t, Index ind[], KeyType key , int n , int b) &#123; // 表长为 n ,块数为 b int i=0, j , k ;// 在块间顺序查找 while ((i&lt;b)&amp;&amp; LT(ind[i].maxkey, key) ) i++ ; if (i&gt;b) return(0); // 没有找到 j=ind[i].startpos; while ((j&lt;n) &amp;&amp; LQ(t-&gt;elem[j].key, ind[i].maxkey) ) &#123;// 在块内顺序查找 if ( EQ(t-&gt;elem[j].key, key) ) break ; j++ ; &#125; if (j&gt;n||!EQ(t-&gt;elem[j].key, key) ) j=0; return(j)；&#125; 算法分析 索引顺序查找的平均查找长度ASL等于 = 查找索引表确定所在块的平均查找长度Lb + 在块内查找元素的平均查找长度Lw. 查找方法比较 顺序查找 分块查找 折半查找 Fibonacci查找 表结构 有序表/无序表 分块有序表 有序表 有序表 存储结构 顺序存储结构/线性链表 顺序存储结构/线性链表 顺序存储结构 顺序存储结构 ASL 最大 介于两者之间 最小 平均比折半查找好 静态树表/次优查找树的查找 若有序表中的各个元素的查找概率不等,那么,用折半查找,性能未必最优 如何改进,以提高性能 ? – 需要找到查找性能最佳的判定树,即,静态最优查找树 (Static Optimal Tree)– 该判定树的带权内路径长度之和最小 算法思路 构造静态最优查找树的时间开销太大 为有序表构造次优查找树 (Nearly Optimal Search Tree) 基于次优查找树的查找 – 给定 Key ,– 从根结点开始,将 Key 值与根结点比较,若 key大于根结点值,在右子树中查找,若 key 小于根结点值,在左子树中查找– 平均查找长度与 logn 成正比 递归构造次优查找树t 123456789101112131415161718192021222324252627 // 根据有序表 R[low..high] 及其累计权值表 sw( 其中 sw[0]==0)构造次优查找树 tBiTree SecondOptimal(ElemType R[], float sw[], int low, int high) &#123; int i,j; float min,dw; BiTree *t; i = low; min = (float) fabs(sw[high]-sw[low]); dw = sw[high]+sw[low-1]; for (j=low+1; j&lt;=high; ++j) // 选择最小的 ΔPi 值 if (fabs(dw-sw[j]-sw[j-1]) &lt; min) &#123; i = j; min = (float)fabs(dw-sw[j]-sw[j-1]); &#125; if (!(t = (BiTree *)malloc(sizeof(BiTreeTNode)))) return ERROR; t-&gt;data = R[i];// 生成结点 if (i==low) t-&gt;lchild = NULL;// 左子树空 else t-&gt;lchild=SecondOptimal(R, sw, low, i-1); // 构造左子树 if (i==high) t-&gt;rchild = NULL; // 右子树空 else t-&gt;rchild=SecondOptimal(R, sw, i+1, high); // 构造右子树 return t; &#125; // SecondOptimal 动态查找表 表的组织方式 若以线性表的形式组织查找表,那么如需要对查找表进行插入、删除或排序操作,就必须移动大量的记录 – 当记录数很多时,这种移动的代价很大 以树的形式组织查找表,可以对查找表进行动态、高效的查找 – 二叉排序树– 平衡二叉树– B 树– B+ 树– 键树 二叉排序树 二叉排序树或者是空树,或者是满足下列性质的二叉树: 若左子树不为空,则左子树上所有结点的值( 关键字 ) 都小于根结点的值; 若右子树不为空,则右子树上所有结点的值( 关键字 ) 都大于根结点的值; 左、右子树都分别是二叉排序树 每个结点的 Key互不相同 数据结构 12345678910 //BST 可以用二叉链表来存储typedef int KeyType;typedef struct RecType&#123; KeyType key;//Others&#125; ElemType;typedef struct BiTreeNode &#123; ElemType data; struct BiTreeNode *lchild,*rchild;&#125; *BiTree; BST的查找算法1 123456789101112 // 在根指针 T 所指二叉排序树中,// 递归地查找其关键字等于 key 的数据元素,// 若查找成功,则返回指向该数据元素结点的指针// 若查找不成功,则返回空指针BiTree SearchBST (BiTree T, KeyType key) &#123; if (!T || EQ(key, T-&gt;data.key)) return T; // 查找结束 else if (LT(key, T-&gt;data.key)) return SearchBST(T-&gt;lchild, key); // 在左子树中查找 else return SearchBST(T-&gt;rchild, key); // 在右子树中查找&#125; // SearchBST 注：若按中序遍历一棵二叉排序树,所得到的结点序列是一个递增序列 BST的构造 BST 是在查找过程中,当树中不存在关键字等于给定值的结点时进行插入 – 新插入的结点一定是 BST 的一个新的叶子结点,并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子 因此: – 需要一个 BST 的查找算法,它在没有找到指定值时,返回:查找路径上访问的最后一个结点– 基于上述查找算法,形成 BST 的构造算法： 123456789101112131415 // 若查找成功,则指针 p 指向该数据元素结点,并返回 TRUE// 否则指针 p 指向查找路径上访问的最后一个结点,并返回// FALSE 。指针 f 指向 T 的双亲,其初始调用值为 NULLStatus SearchBST(BiTree T, KeyType key, BiTree f, BiTree &amp;p)&#123; if (!T) &#123; p = f; return FALSE; &#125; // 查找不成功 else if (EQ(key, T-&gt;data.key)) &#123; p = T; return TRUE; &#125; // 查找成功 else if (LT(key, T-&gt;data.key)) return SearchBST(T-&gt;lchild, key, T, p); // 在左子树中查找 else return SearchBST(T-&gt;rchild, key, T, p); // 在右子树中查找&#125; // SearchBST BST的插入算法 123456789101112131415161718 // 当二叉排序树 T 中没有关键字等于 e.key 的数据元素时,// 插入 e 并返回 TRUE ,否则返回 FALSEStatus InsertBST(BiTree &amp;T, ElemType e)&#123; BiTree p,s; if (!SearchBST(T, e.key, NULL, p)) &#123; // 查找不成功 s = (BiTree)malloc(sizeof( BiTreeNode )); s-&gt;data = e; s-&gt;lchild = s-&gt;rchild = NULL; if (!p) T = s; // 插入 s 为新的根结点 else if (LT(e.key, p-&gt;data.key)) p-&gt;lchild=s; // 插入 s 为左孩子 时,不必移动其它 else p-&gt;rchild=s;// 插入 s 为右孩子 return TRUE; &#125; else return FALSE; // 树中已有关键字相同的结点,不再插入&#125; // Insert BST BST上节点的删除 从 BST 上删除一个结点,需要保证删除结点后的树仍满足 BST 的性质 设被删除结点为 p ,其父结点为 f ,分如下情况: 若 p 是叶子结点: 直接删除 p 若 p 只有一棵子树 ( 左子树或右子树 ) :直接用 p 的左子树 ( 或右子树 ) 取代 p 的位置而成为 f的一棵子树 若 p 既有左子树又有右子树 方法一：用 p 的直接前驱 ( 或直接后继 ) 结点 s 代替 p ,即从 p 的左子树中选择值最大的结点 s 放在 p 的位置 ( 用结点 s 的内容替换结点 p 内容 ) ,然后删除结点 s ,并将 s的左子树作为 s 的父结点的右子树 方法二：找到 s , s 是 p 的左子树中的最右边的结点且没有右子树,将 p 的右子树作为 s 的右子树,然后用 p的左子树顶替被删结点 ( 也就是将 p 的左子树为 f 的左子树 ) 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 Status DeleteBST(BiTree *T, KeyType key)// 若二叉排序树 T 中存在关键字等于 key 的数据元素时,// 则删除该数据元素结点 p ,返回 TRUE ;否则返回 FALSE&#123; if (!T) return FALSE;// 不存在关键字等于 key 的数据元素 else &#123; if (EQ(key, T-&gt;data.key))// 找到关键字等于 key 的数据元素 return Delete(T); else if (LT(key, T-&gt;data.key)) return DeleteBST(T-&gt;lchild, key); else return DeleteBST(T-&gt;rchild, key); &#125;&#125;//DeleteBST// 从二叉排序树中删除结点 p ,并重接它的左或右子树，伪代码Status Delete(BiTree &amp;p) &#123; BiTree q, s; if (!p-&gt;rchild) &#123;// 右子树空则只需重接它的左子树 q = p; p = p-&gt;lchild; //将 p 原来的父结点 ( 设为 f) 与 p 相连 f-&gt;lchild/rchild=p free(q); &#125; else if (!p-&gt;lchild) &#123;// 只需重接它的右子树 q = p; p = p-&gt;rchild; //将 p 原来的父结点 ( 设为 f) 与 p 相连 f-&gt;lchild/rchild=p free(q); &#125; else &#123; // 左右子树均不空,按方法一// 左右子树均不空 q = p; s = p-&gt;lchild; while (s-&gt;rchild)// 转左,然后向右到尽头 q &#123; q = s; s = s-&gt;rchild; &#125;//s 指向被删结点的前驱 p-&gt;data = s-&gt;data; if (q != p) q-&gt;rchild = s-&gt;lchild;// 重接 *q 的右子树 else q-&gt;lchild = s-&gt;lchild;// 重接 *q 的左子树 free(s); &#125; return TRUE;&#125; BST的查找性能分析 二叉排序树上成功的查找次数不会超过二叉树的深度,而具有 n 个结点的二叉排序树的深度,最好为 log2n ,最坏为 n 。因此二叉排序树查找的最好时间复杂度为 O(log2n) ,最坏的时间复杂度为 O(n)。 在随机情况下, n 个结点的二叉排序树的平均查找长度 (ASL) 和log2n( 树的深度 ) 是等数量级的。 随机:各个元素的查找概率相同,元素组成的序列是随机的 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"动态存储管理","date":"2017-07-30T11:57:40.000Z","path":"2017/07/30/Dynamic-Memory-Management/","text":"存储空间的分配和管理 问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序 问题的解决策略:采用动态存储管理思想 存储空间的分配和管理策略的选择与用户的需求有关: 用户存储请求的分配量的大小分布 用户存储分配请求和释放请求的频率 分配效率 对系统的重要性 动态存储管理 - 堆的管理 堆(heap)：操作系统在内存中划出一块地址连续的大区域 占用块:已分配给用户使用的一块地址连续的内存区域; 空闲块:未曾分配的地址连续的内存区域 堆的管理要解决的问题:如何根据用户的存储 / 内存分配请求分配内存空间?如何回收被释放的或不再使用的 ) 内存空间? 堆的使用:利用程序设计语言提供的内存动态分配函数– C : malloc() , calloc() , realloc , free() 函数– C++ : new , delete 函数等 内存分配方式 方式1： 从高地址空闲块中进行分配,直到分配无法进行时,才回收所有用户不再使用的空闲块,重新组织一个大的空闲块来再分配。 方式2：用户程序一旦运行结束,便将它所占的内存区释放成为空闲块,同时,每当新用户请求分配内存时,需查找整个内存区中所有空闲块,并从中找出一个合适的空闲块分配之。 可利用空间表 可利用空间表 / 存储池:包含所有可分配的空闲块 – 当用户请求分配时,系统从可利用空间表中删除一个结点分配之 – 当用户释放其所占内存时,系统即回收并将它插入到可利用空间表中 可利用空间表的组织方式 – 目录表 – 链表方式 链式可利用空间表的分配方式 当可利用空间表以链表方式组织时,每个空闲块就是链表中的一个结点– 分配时:从链表中找到一个合适的结点加以分配,然后将该结点删除之;– 回收时:将空闲块插入到链表中。 具体的分配和释放的策略取决于结点 ( 空闲块 ) 的结构– 空闲块的大小相同– 空闲块的大小只有几种规格– 空闲块的大小不固定 分配方式1：空闲块的大小相同 – 将进行动态存储分配的整个内存区域( 堆 ) 按所需大小分割成若干大小相同的块,然后用指针链接成一个可利用空间表。– 分配时:从表的首结点分配,然后删除该结点– 回收时:将释放的空闲块插入表头– 存在的问题:空间利用率不高当请求分配的块空间大小比最大规格的结点还大时,分配不能进行。而实际上内存空间却可能存在比所需大小还要大的的连续空间。 分配方式2：空闲块大小只有几种规格 – 根据统计分析得到的概率分布,事先对动态分配的堆建立若干个可利用空间链表,同一链表中的结点 ( 块 ) 大小都相同。– 分配时:根据请求的大小,将最接近该大小的某个链表的首结点分配给用户。若剩余部分正好是另一种规格大小,则将剩余部分插入到另一种规格的链表中,然后删除该结点– 回收时:只要将所释放的空闲块插入到相应大小的表头– 存在的问题:同前 分配方式3：请求分配的块大小不确定 – 整个堆空间开始是一个空闲块,链表中只有一个大小为整个堆的结点,随着分配和回收的进行,链表中的结点大小和个数动态变化– 链表结点中,增加一个表示结点大小的域 (size),以保存空闲块的大小– 分配策略:若用户请求分配大小为 n(kB) 的内存,而链表中有若干大小不小于 n 的空闲块时,如何分配 ? 首次拟合法 (First fit) 最佳拟合法 (Best fit) 最差拟合法 (Worst fit) 首次拟合法 (First fit) 分配时:从表头指针开始查找可利用空间表,将找到的第一个不小于 n 的空闲块的部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点 回收时:将释放的空闲块插在链表的表头 特点:分配时随机的;回收时仅需插入到表头 最佳拟合法 (Best fit) 分配时:扫描整个可利用空间链表,找到一个大小满足要求且最接近 n 的空闲块,将其中的一部分 ( 即所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点 回收时:只要将释放的空闲块插入到可利用空间链表的合适位置 为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 包括块回收时 ) 成按从小到大排序 ( 升序 ) 优点:适用于请求分配的内存块大小范围较广的系统 缺点:系统容易产生无法分配的内存碎片;无论分配与回收,都需要查找空闲链表,最费时 最差拟合法 (Worst fit) 分配时:扫描整个可利用空间链表,找到一个大小最大的空闲块,将其中的一部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点 回收时:只要将释放的空闲块插入到链表的合适位置 为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 块回收时 ) 成按从大到小排序 (降序 ) 特点:适用于请求分配的内存块的大小范围较窄的系统;分配无需查找,回收需要查找适当的位置 边界标识法 (Boundary Tag Method) 操作系统中常用的动态存储管理方法 将所有的空闲块链接成一个双重循环链表 每个内存区域的头部和底部两个边界上分别设置标识,以标识该区域为占用块或空闲块 在回收块时易于判别在物理位置上与其相邻的内存区域是否为空闲块,以便于将所有地址连续的空闲存储区合并成一个尽可能大的空闲块 可利用空间表的节点结构： 123456789101112131415161718192021 typedef struct word &#123;union &#123;// 头部域,指向前驱结点 struct word *llink;// 尾部域,指向本结点的头部 struct word *uplink;&#125;; int tag; //0 :空闲; 1 :占用 int size;// 头部域,指向后继结点 struct word *rlink;//OtherType other;&#125;WORD, head, foot, *Space;// 指向 p 所指结点的底部#define FootLoc(p) (p+p-&gt;size-1)Space FootLoc(Space p) &#123; char *q; Space f; q=(char *)p; f=(Space)(q+sizeof(char)*p-&gt;size-sizeof(foot)); return f;&#125; 分配算法：两个约定 分配约定 选定适当常量 e ,设待分配空闲块、请求分配空间的大小分别为 m 、 n 当 m-n&lt;=e 时:将整个空闲块分配给用户; 当 m-n&gt;e 时:则只分配请求的大小 n 给用户; 尽量减少空闲块链表中出现小碎片 ( 容量 ≤ e) ,提高分配效率;减少对空闲块链表的维护工作量 为了避免修改指针,约定将高地址部分分配给用户 查找约定 每次需要查找空闲块时,从上次刚分配结点的后继结点开始查找空闲块 作用:提高查找空闲块的速度,防止小容量结点聚集 分配算法：首次拟合法 123456789101112131415161718192021222324252627282930 const int e = 16; // 不保留小于等于 e 的剩余量// 若有不小于 n 的空闲块,则分配相应的存储块,并返回其首地址, 否则返回 NULLSpace AllocBoundTag(Space pav, int n) &#123; Space p;// 查找不小于 n 的空闲块 for (p=pav; p &amp;&amp; p-&gt;size&lt;n &amp;&amp; p-&gt;rlink!=pav; p=p-&gt;rlink); if (!p || p-&gt;size&lt;n) return NULL; // 找不到,返回空指针 else &#123; // p 指向找到的空闲块 Space f = FootLoc(p); // f 指向底部 pav = p-&gt;rlink;// pav 指向 *p 结点的后继结点 if (p-&gt;size-n &lt;= e) &#123; // 整块分配,不保留小于等于 e 的剩余量 if (pav==p) pav = NULL; // 可利用空间表变为空表 else &#123; // 在表中删除分配的结点 pav-&gt;llink = p-&gt;llink; p-&gt;llink-&gt;rlink = pav; &#125; p-&gt;tag = f-&gt;tag = 1; // 修改分配结点的头部和底部标志 &#125; else &#123; // 分配该块的后 n 个字 f-&gt;tag = 1; // 修改分配块的底部标志 p-&gt;size -= n; // 置剩余块大小 f = FootLoc(p); // 指向剩余块底部 f-&gt;tag = 0; f-&gt;uplink = p; // 设置剩余块底部 p = f+1; // 指向分配块头部 p-&gt;tag = 1; p-&gt;size = n; // 设置分配块头部 &#125; return p; // 返回分配块首地址 &#125;&#125; // AllocBoundTag 回收算法 情况1 释放块的左、右邻块均为占用块:将被释放块简单地插入到空闲块链表中即可 12345678910 p-&gt;tag=0 ; FootLoc(p)-&gt;uplink=p;FootLoc(p)-&gt;tag=0;if ( !pav )pav=p-&gt;llink=p-&gt;rlink=p; // 第一个空闲块else &#123;// 刚释放的空闲结点是插在 pav 之前,并成为 pavq=pav-&gt;llink; p-&gt;rlink=pav ;p-&gt;llink=q ; q-&gt;rlink=pav-&gt;llink=p ;pav=p ; //pav 指向刚释放的空闲结点// 成为下次分配最先查询的结点&#125; 情况2、3 释放块的左邻块空闲而右邻块为占用:和左邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部 123 n=p-&gt;size;s=(p-1)-&gt;uplink; s-&gt;size+=n; // 设置新空闲块大小f=FootLoc(p); f-&gt;uplink=s; f-&gt;tag=0; // 设置新空闲块底部 释放块的左邻占用而右邻空闲:和右邻块合并成一个大的空闲块结点,改变右邻块的 size 域及重新设置( 合并后 ) 结点的头部 12345 t= FootLoc(p)+1; p-&gt;tag=0; q=t-&gt;llink;p-&gt;llink=q; q-&gt;rlink=p ; // 设置空闲块的前驱q1=t-&gt;rlink ; p-&gt;rlink=q1 ; q1-&gt;llink=p ;p-&gt;size+=t-&gt;size; // 设置新空闲块大小FootLoc(t)-&gt;uplink=p ; // 底部指针指向新结点的头部 情况4 释放块的左、右邻块均为空闲块:和左、右邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部 12345678 n=p-&gt;size;s=(p-1)-&gt;uplink;//s 指向左邻块t= FootLoc(p)+1; //t 指向右邻块 , p+p-&gt;sizes-&gt;size +=n+t-&gt;size; // 设置新空闲结点的大小// 在空闲链表中,删除右邻空闲块q=t-&gt;llink; q1=t-&gt;rlink; // 修改右邻原来的关系q-&gt;rlink=q1; q1-&gt;llink=q ;FootLoc(t)-&gt;uplink=s; // 新结点底部指针指向其头部 伙伴系统 (Buddy System) 操作系统中常用的动态存储管理方法 与边界标识法类似,所不同是:无论占用块或空闲块,其大小均为 2 的 k 次幂 ,不是以顺序片段来分配内存 伙伴系统的可利用空间表: 将所有大小相同的空闲块建于一张子表中,每个子表是一个双重链表,这样的链表可能有 m+1 个 再将这 m+1 个表头指针用向量结构组织成一个表 可利用空间表的结构: 123456789101112 #define M 16typedef struct WORD_b &#123; WORD_b * llink;// 前驱结点 int tag;// 块占用标识 int kval;// 块的大小,是 2 的幂次 WORD_b *rlink;// 后继结点 OtherType other;&#125; WORD_b, head;typedef struct HeadNode &#123; int nodesize; WORD_b * first;&#125; FreeList[M+1];// 子表个数为 M+1 伙伴系统的分配算法 1234567891011121314151617181920212223242526 WORD_b* AllocBuddy (FreeList avail[], int n) &#123;// avail[0..m] 为可利用空间表, n 为申请分配量,若有不小于n 的空闲块,则分配相应的存储块,并返回其首地址;否则返回 NULL WORD_b *pa, *pre, *suc, *pi;// 查找满足分配要求的子表 for (int k=0; k&lt;=m &amp;&amp; (!avail[k].first ||avail[k].nodesize&lt;n+1);k++) ; if (k&gt;m) return NULL; // 分配失败 else &#123; // 进行分配 pa = avail[k].first; // 指向可分配子表的第一个结点// 分别指向前驱和后继 pre = pa-&gt;llink; suc = pa-&gt;rlink; if (pa==suc) avail[k].first = NULL; // 分配后该子表变成空表 else &#123; // 从子表删去 *pa 结点 pre-&gt;rlink = suc; suc-&gt;llink = pre; avail[k].first = suc; &#125;// 将剩余块插入相应子表 for (int i=1; avail[k-i].nodesize&gt;=n+1; ++i) &#123; pi = pa+(int)pow(2, (k-i)); pi-&gt;rlink = pi; pi-&gt;llink = pi; pi-&gt;tag = 0; pi-&gt;kval = k-i; avail[k-i].first = pi; &#125; pa-&gt;tag = 1; pa-&gt;kval = k-(--i); &#125; return pa;&#125; // AllocBuddy 回收算法 释放占用块时,需要将该新的空闲块插入到可利用空闲表中 考虑合并成大块的问题:只有 “ 互为伙伴 ” 的两个子块均空闲时才合并;即使有两个相邻且大小相同的空闲块,如果不是 “ 互为伙伴 ” ( 从同一个大块中分裂出来的 ) 也不合并。 设要回收的空闲块的首地址是 p ,其大小为 2^k : (1) 判断其 “ 互为伙伴 ” 的块是否空闲: 若不空闲,仅将要回收的空闲块直接插入到相应的子表中;否则转 (2) ; (2) 按以下步骤进行空闲块的合并: 在相应子表中找到其伙伴并删除之; 合并两个空闲块; (3) 重复 (2) ,直到合并后的空闲块的伙伴不是空闲块为止 特点:算法简单;速度快;但容易产生碎片 无用单元收集 无用单元:用户不再使用而系统没有回收的变量和结构 产生原因:程序 Bug – p=malloc(size); … … p=NULL; // 未回收的空间– p=malloc(size); … … q=p;free(p);// 悬挂访问 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"局部变量的栈溢出","date":"2017-07-28T13:47:54.000Z","path":"2017/07/28/Stack-Over-Flow-in-Function/","text":"先上代码： 123456789101112131415161718192021222324252627 #include&lt;iostream&gt;const int MAX_N = 10000000;using namespace std;bool Tree[MAX_N] = &#123;false&#125;;//全局变量int main()&#123; int depth, balls; cin &gt;&gt; depth &gt;&gt; balls; int ind = 0; int last = 0; while( ind ++ &lt; balls )&#123; int curr = 1; for ( int i = 0; i &lt; depth; ++i )&#123; if( false == Tree[curr] )&#123; curr = curr*2; &#125; else&#123; curr = curr*2 + 1; &#125; Tree[curr] = !Tree[curr]; last = curr; &#125; &#125; cout &lt;&lt; last &lt;&lt; endl; return 0;&#125; 代码1 12345678910111213141516171819202122232425262728 #include&lt;iostream&gt;const int MAX_N = 10000000;using namespace std;bool Tree[MAX_N] = &#123;false&#125;;int main()&#123; int depth, balls; cin &gt;&gt; depth &gt;&gt; balls; bool Tree[MAX_N] = &#123;false&#125;;//局部变量 int ind = 0; int last = 0; while( ind ++ &lt; balls )&#123; int curr = 1; for ( int i = 0; i &lt; depth; ++i )&#123; if( false == Tree[curr] )&#123; curr = curr*2; &#125; else&#123; curr = curr*2 + 1; &#125; Tree[curr] = !Tree[curr]; last = curr; &#125; &#125; cout &lt;&lt; last &lt;&lt; endl; return 0;&#125; 代码2 观察代码1和代码2，二者只有一个区别，前者Tree为全局变量，而后者为局部变量。一般来说，我们可能觉得两个函数运行的时候不会有什么不同，然而却出现不同的结果： 代码1能正确运行，代码2： 惊喜不惊喜，意外不意外！ 我们知道，在内存中，全局变量存于全局变量区，而局部变量位于栈中，函数以栈帧的形式存储。相对来说，全局变量区空间较大，而栈空间较小，因此便导致了代码2的栈溢出，而代码1则正常。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"《Linux 命令行大全》学习笔记-Part3","date":"2017-06-20T04:54:21.000Z","path":"2017/06/20/Linux-Command-Line-learning-notes-Part3/","text":"Chapter 14 软件包管理 低级软件包： Debian : dpkg/rpm dpkg –install file.deb/rpm -i package_file/rpm -U package_file：安装/升级软件 dpkg –list ：列出所有已安装软件 dpkg –status package_name：判断是否已安装 dpkg –search filename/rpm -qf file_name：查询文件所属命令 高级软件包：apt-get apt-get update ; apt-cache search file_name：搜索软件包 apt-get update ; apt-get install package_name：安装软件包 apt-get remove package_name/yum erase package_name：删除软件包，彻底删除干净，可加上 –purge 参数 apt-get update ; apt-get upgrade ：更新/升级软件包 apt-cache show packagename ：显示软件包相关信息 apt-cache search package_name/yum search package_name：搜索软件包 Chapter 15 存储介质 /etc/fstab 文件：显示系统启动时挂载的设备。 mount ：查看已挂载文件系统（不带参数） mount -t ext4 /dev/sda1 /mnt ：挂载文件系统（root 权限），-t 选项指定文件系统类型 umount /dev/hdc：卸载设备 ls /dev：查看/dev目录下的设备信息 sudo tail -f /var/log/messages ：实时系统监测 sudo fdisk /dev/sdb：磁盘分区 sudo fdformat /dev/sdb1：格式化 sudo mkfs -t ext4 /dev/sdb1：创建新的文件系统(-t vfat:fat32) sudo fsck /dev/sdb1：检查闪存（事先需卸载） dd if=input_file of=output_file：文件复制（数据块） example: dd if=/dev/sdb of=/dev/sdc ​ dd if=ubuntu.iso of=/dev/sdc（创建系统启动盘） 挂载镜像文件：mkdir /mnt/iso_file; mount -t iso9660 -o loop image.iso /mnt/iso_file wodim dev=/dev/cdrw blank=fast ：擦除设备 wodim dev=/dev/cdrw image.iso ：写入镜像文件 md5sum image.iso：计算校验和 Chapter 16 网络 ping ：向网络主机发送特殊数据包，检测网络是否连通，例如：ping linux.com traceroute ：跟踪网络数据包的传输路径，例如：traceroute ucasfl.me netstat ：检查网络设置及相关统计数据 -ie 选项：检查系统中的网络接口信息 -r 选项：显示内核的网络路由表 文件传输 ftp: 123456 ftp fileserver:连接主机cd dir:进入目录ls:列出内容lcd dir ：切换目录get something:下载东西help:显示命令列表 lftp：与 ftp 类似，支持更多的协议和功能 wget ：用于文件下载的命令行程序，既可从网站上下载，也可从 ftp 站点下载 example: wget http://ucasfl.me/scripts/vim_config.sh ssh:安全登录远程计算机：ssh user@hostname/ip ssh user@remote_host command : 远程执行命令 scp user@remote_host:document.txt /user/home/ ：将远程文件复制到当前的 home 目录下 sftp : 命令与 ftp 类似，不过远程主机不需要 ftp 服务器，只需要 ssh 服务器 Chapter 17 文件搜索 locate filename：搜索文件，支持扩展，例如：locate zip :搜索以 zip 开头的文件 find : 较复杂的方式查找文件 find ~ | wc -l : 计算当前系统总目录的文件数。 1234567 find ~ -type x : 指定类型查找，x 为参数x: b:块设备文件 c:字符设备文件 d:目录文件 f:普通文件 l:符号链接 find 命令的 test 项参数： 123456789101112131415161718 -cmin n ：匹配n分钟前改变状态的文件或目录，不到n分钟，用 -n，超过n分钟，用+n-cnewer file :匹配内容或属性的修改时间比file晚的文件或目录-ctime 24:匹配系统中n*24小时前文件状态被改变的文件或目录-empty: 匹配空文件或空目录-group name:匹配属于name组的文件或目录-iname pattern:与-name test项功能类似，只是不区分大小写-inum n:匹配索引节点是n的文件-mmin n:匹配n分钟前内容被修改的文件或目录-mtime n:匹配n*24小时前只有内容被修改的文件或目录-name pattern :匹配有特定通配符的文件或目录-newer file :匹配内容的修改时间比file文件更近的文件或目录-nouser:匹配不属于有效用户的文件或目录-nogroup:匹配不属于有效组的文件或目录-perm mode :寻找访问权限与既定模式匹配的文件或目录-samefile name:与-inum test 选项类似-size n:匹配n大小的文件-type c:匹配c类型的文件-user name:匹配属于name用户的文件或目录 find 命令的逻辑操作符： -and :与 -or : 或 -not : 非 () : 括号 注：在shell中，括号需要加反斜杠进行转义。 action 选项： 12345 预定义操作：-delete: 删除匹配文件-ls: 对匹配的文件执行ls操作-print: 将匹配的文件的全路径以标准形式打印出，默认形式-quit: 匹配成功便退出 自定义操作： -exec/-ok command {}; :command 为预执行命令(-ok会在每一次执行命令前询问用户) touch filename: 设定或更新文件的修改时间，文件不存在时，会创建一个新文件(空文件) stat filename: 显示文件的所有信息及属性 option选项： 12345 -depth: 引导find程序处理目录前先处理目录内的文件-maxdepth levels: 当执行测试条件行为时，设置find程序陷入的目录数的最大级别数-mindepth levels: 设置find程序陷入目录数的最小级别数-noleaf: 指导find程序不要基于“正在搜索类UNIX文件系统”的假设来优化搜索，当扫描DOS/Windows文件系统和CD时，会用到该选项-mount: 引导find程序不要遍历挂载在其他文件系统上的目录 Chapter 18 归档和备份 gzip: 12 gzip filename: 压缩文件gunzip filename.gz: 解压缩文件 gzip 命令的一些选项： 123456789 -c: 将输出内容写到标准输出端口并且保持原有文件-d: 解压缩，gzip -d == gunzip-f: 强制压缩-h: 显示有用信息，可用 --help 代替-l: 列出所有压缩文件的压缩统计，也可以用 --list 代替-r: 存在目录时，递归压缩 ==--recursive-t: 检验压缩文件的完整性 ==--test-v: 在压缩时显示详细信息，==--verbose-number: 设置压缩级别，number是1~9的一个数，默认压缩级别是6 bzip2/bunzip2: 与gzip命令类似，不过使用不同的压缩算法，该算法具有高质量的数据压缩能力，但降低了压缩速度。 tar: 归档文件 用法：tar mode pathname… tar命令的操作模式： 123456 c: 创建文件或目录的归档文件x: 从归档文件中提取文件t: 在归档文件末尾追加指定路径名r: 列出归档文件的内容f: 指定归档文件名v: 获取详细信息 example: tar cf/cvf file.tar file: 归档文件 tar xf/xvf file.tar file: 提取文件 zip: 打包压缩文件 example: zip -r file.zip file 解压缩：unzip file.zip rsync: 远程文件、目录的同步 Chapter 19 正则表达式 grep: 文本搜索，搜索文本文件中与指定正则表达式匹配的行，并送至标准输出 命令用法： grep mode searchfile，例如 grep -h ‘^int$’ test.c grep 选项： 1234567 -i: 忽略大小写-v: 输出不匹配行-c: 输出匹配项数目-l: 输出匹配项文件名而不是直接输出匹配行-L: 与-l类似，但输出不包含匹配项的文件名-n: 在每个匹配行前面加上该行在文件中的行号-h: 进行多文件搜索时，抑制文件名输出 正则表达式： 详细内容可查看计算理论相关书籍。 元字符：^ $ . [ ] - ? * + ( ) | \\ a/A~z/Z 为文字字符 注：在命令行中输入包含元字符的正则表达式时，应把元字符用引号括起来以避免不必要的shell 扩展。 任意字符： . : 匹配任意字符 example: ls /usr/bin/ | grep -h ‘.zip’ 注意，上面输出中并不会包含zip，因为zip只包含三个字符，而这里至少要有四个字符。 开头字符和末尾字符： ^ : 匹配开头字符 $ : 匹配末尾字符 example : ls /usr/bin | grep -h ‘^zip’ : 匹配以zip开头的输出 ls /usr/bin | grep -h ‘zip$’ : 匹配以zip结尾的输出 ls /usr/bin | grep -h ‘^zip$’ : 输出只有zip 中括号表达式和字符类 中括号除了可用于匹配正则表达式中的给定字符外，还可用于匹配字符集中的单个字符。借助中括号，也可指定要匹配的字符集，例如：ls /usr/bin | grep -h ‘[bg]zip’ 会输出以bzip和gzip开头的输出。 注：^在中括号中表示否定；-在中括号中表示字符范围。 否定 在中括号中使用 ^ ,表示剩余字符不应该出现，例如： ls /usr/bin/ | grep -h &#39;[^bg]zip&#39; 会得到包含zip但zip前面既不是b，又不是g的程序。 注：^ 只有在中括号中的第一个字符才会当作否定符，否则当作普通符号处理。 字符范围 使用 - 例： 123 grep -h '^[A-Z]' filename :所有以大写字母开头的行grep -h '^[A-Za-z0-9]' filename :所有以字母和数字开头的行grep -h '[-AZ]' filename :仅表示包含连字符，大写字母A或Z的行 POSIX 字符集 12345678910111213 [:alnum:] 字母字符和数字字母，在ASCII中，与[A-Za-z0-9]等效[:word:] 与上者相比，多了下划线字符_[:alpha:] 字母字符，在ASCII中，等效于[A-Za-z][:blank:] 空字符，包括空格和制表符[:cntrl:] ASCII控制符，包括ASCII字符0~31以及127[:digit:] 数字0~9[:graph:] 可见字符，在ASCII中，包括字符33~126[:lower:] 小写字母[:punct:] 标点符号字符[:print:] 可打印字符，包括[:graph:]中的所有字符加上空格字符[:space:] 空白字符包括空格符，制表符，回车符，换行符垂直制表符以及换页符，在ASCII中，等价于[\\t\\r\\n\\v\\f][:upper:] 大写字母[:xdigit:] 用于表示十六进制的字符 ==[0-9a-fA-F] 例如： ls /usr/sbin/[[:upper:]]* : 列出所有以大写字母开头的文件 或选项：| 例如： 12 echo \"AAA\" | grep -E 'AAA|BBB|CCC'ls /usr/bin | grep -Eh '^(bz|gz|zip)' 匹配以bz或gz或zip开头的程序 匹配某元素0次或1次：? ? 置于字符的后面表示前面的字符（单个）匹配一次或零次 匹配0次或多次： * 用法和上者类似。 匹配一次或多次： + 用法和上者类似。 以指定次数匹配： 1234 &#123;n&#125; 前面的元素恰好出现n次&#123;n,m&#125; 前面的元素出现的次数在n~m之间时匹配&#123;n,&#125; 前面的元素超过n次时匹配&#123;,m&#125; 前面的元素不超过m次时匹配 locate 查找文件： 选项： –regexp 支持基本正则表达式 –regex 支持扩展正则表达式 less 和 Vim 二者皆支持正则表达式搜索，并且搜索方法相同：按下“/”键后，输入正则表达式，便可搜索。 Chapter 20 文本处理 cat : 进行文件间的拼接并输出到标准输出 选项： -A : 输出非打印字符 -n : 对行编号 -s : 禁止输出多个空白行 sort : 对文本进行排序 sort 是一个排序程序，操作对象为标准输入或是命令行中指定的一个或多个文件，然后将结果送至标准输出。 example: 12 sort &gt; foo.txt 可在键盘输入然后sort排序后输入到 foo.txt 中（重定向）sort file1 file2 file3 &gt; file_sorted 将三个文件进行排序后输出到一个文件中 sort 选项： 1234567 -b 忽略行开头的空格，默认情况下，会对整个行进行排序-f 排序时不区分大小写-n 基于字符串的长度进行排序而不是基于字母表顺序进行排序-r 逆序进行排序-m 将输入的多个参数当作已经排序好的。将多个文件合并为一个排序好的文件，而不执行额外的排序操作-o 将排序结果输出到文件而不是标准输出-t 定义字段分隔符，默认情况下是空格或制表符 uniq 给定一个排序好的文件或标准输入，unip会删除重复的行并将结果输出到标准输出中。 注意：uniq仅对排序好的文件有用，因为uniq只能移除相邻的重复行。 123456 -c 输出重复行列表，并且在重复行的前面加上出现的次数-d 只输出重复行，不包括单独行-f n 忽略每行的前n个字段-i 行与行之间比较时忽略大小写-s n 忽略每行的前n个字符-u 仅输出不重复的行，该选项是默认的 cut 从文本行中提取一段文字并输出至标准输出。 1234 -c char_list 从文本行中提取char_list定义的内容，例，cut -c 7-10 提取每行中的7-10个字符-f field_list 从文本行中提取field_list定义的一个或多个字段-d delim_char 使用-f选项后，可使用delim_char作为字段分隔符，默认时以Tab制表符隔开--complemet 从文本中提取整行，除了那些-c和/或-f指定的部分 paste - 合并文本行 example: paste file1.txt file2.txt：将两个文件中的内容按行拼接起来 join - 连接两个文件中具有相同字段的行 example: join file1.txt file2.txt comm - 逐行比较两个已排序好的文件 详见另一篇博客 - Linux Command of comm diff - 逐行比较文件 patch - 对原文件进行 diff 操作 tr - 替换或删除字符 sed - 用于文本过滤和转换的流编辑器 aspell - 交互式拼写检查工具 Chapter 21 格式化输出 nl - 对行进行标号 example : nl file.txt : 默认对非空行进行标号。 fold - 设定文本行长度 example : 12 fold -w 15 file.txt 每行设置为15个字符fold -w 15 -s file.txt 使其断行时考虑单词边界 fmt - 简单的文本格式化工具 pr - 格式化打印文本 printf - 格式化并打印数据，与C语言中的printf类似。 Chapter 22 打印 pr : 转换打印文本，从而进行打印操作 lpr: 打印文件 lp: 打印文件 a2ps: 格式化文件，以在PostScript打印机上打印 lpstat: 显示打印状态信息 lpq: 显示打印机队列状态 lprm: 取消打印任务 cancel: 取消打印任务 Chapter 23 编译程序 123 ./configuremakesudo make install var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"C 语言中的静态变量","date":"2017-06-19T09:17:44.000Z","path":"2017/06/19/The-Static-Variables-in-C/","text":"静态变量 静态变量的关键字为 static ，采用静态存储方式，一般的声明如： 1 static int a;//a 为一个静态变量 静态变量的一些特点： 静态局部变量在函数内定义，但不像自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。 静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 允许对构造类静态局部量赋初值。若未赋以初值，则由系统自动赋值。数值型变量自动赋初值0，字符型变量赋空字符。 对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。 根据静态局部变量的特点， 可以看出它是一种生存期为整个源文件的量。虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用， 而且保存了前次被调用后留下的值。 因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。 尽管如此，全局静态变量和局部静态变量还有一些区别。 全局静态变量 尽管全局静态变量的生命周期为整个源程序，但是，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。 局部静态变量 在一些函数比如递归函数中，局部静态变量用处较大，比如在递归函数中。但是需要注意，每次在主函数中调用该函数时，局部静态变量都保存之前的值。此时，需要注意一个问题。 如果在一个递归函数中，当递归调用时，需要静态变量保存之前的值，而每次在主函数中调用该递归函数，都需要将该静态变量赋一个固定的初值，那么可以多加一个参数来实现。 下面是一个例子。通过中序遍历一个平衡二叉排序树来获取一个递增序列，将该序列存于一个数组中，并得到数组的最后一个元素下标。 第一种实现： 123456789101112131415 int inorder(BiTree T, int key[], int *last)&#123; static int i = 0; if(!T) return 1; else&#123; if (inorder(T-&gt;lchild, key, last, ++ restore))&#123; key[i++] = T-&gt;data;//get array list if (inorder(T-&gt;rchild, key, last, ++ restore))&#123; *last = i - 1;// get the length-1 of list return 1; &#125; &#125; return 0; &#125;&#125;//inorder 如果在主函数中，该函数仅调用一次，那么像这样写没有任何问题。但是，如果主函数中多次调用了该递归函数，那么之后的调用 i 的初值遍不是 0 ，而这儿我们需要在是 0 ，当每次在主函数中调用时。 我们可以通过添加一个参数来保证每次在主函数中调用该递归函数时，i 的初值均为 0： 1234567891011121314151617 int inorder(BiTree T, int key[], int *last, int restore)&#123; static int i = 0; if (!restore) i = 0;//when everytime call the function in main function, restore i to zero if(!T) return 1; else&#123; if (inorder(T-&gt;lchild, key, last, ++ restore))&#123; key[i++] = T-&gt;data;//get array list if (inorder(T-&gt;rchild, key, last, ++ restore))&#123; *last = i - 1;// get the length-1 of list return 1; &#125; &#125; return 0; &#125;&#125;//inorder 如上面的代码所示，我们增加了一个新的参数 restore，每次在主函数中调用该函数时，restore 传入的值为 0 ，这样便可消除上面的问题。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"递归实现平衡二叉树的插入、删除、合并和分裂","date":"2017-06-19T08:39:12.000Z","path":"2017/06/19/Using-Recursive-Method-to-Finish-the-Join-Split-of-AVL-Tree/","text":"平衡二叉树 平衡二叉树是这样一棵树，要么是一棵空树，要么是满足下面条件的树： 左子树和右子树的深度的绝对值只差不超过 1; 左子树和右子树也是平衡二叉树。 既是二茬排序树又是平衡二叉树的树为平衡二茬排序树。下面说到的平衡二叉树表示平衡二茬排序树。 在平衡二叉树的结构定义中，比二叉树多了一个平衡因子。实现平衡二叉树的插入和删除是一件比较头疼的事情。因为每次插入或删除之后都要检查平衡是否被破坏，如果被破坏，则要进行各种左旋、右旋的平衡化。 除了插入和删除，有的时候还会涉及到将两个平衡二叉树或多个合并成一个平衡二叉树。或者将一个平衡二叉树分裂为两个平衡二叉树，其中一个中的值均小于等于 $x$，另一个的值均大于 $x$ 。对于合并，最常规的方法自然是，将其中一个二叉树中的点一个个插入到另一个平衡二叉树中。然而，这样做的时间复杂度很大，而且其中一棵二叉树被破坏。但是，如果通过递归来做，则可以在不破坏两棵树的前提下创建一棵新的平衡二叉树，并且时间复杂度比前者要优越很多。 算法 下面说一下该算法： 分别中序遍历两棵二叉树，得到两个有序序列。 将两个有序序列合并为一个有序序列。 利用该有序序列来创建一棵新的平衡二叉树。 递归部分： 终止条件： 序列中只剩下一个或两个记录，一个时，直接建节点，插入记录；两个时，可建节点，将前者插入，然后再后一个作为前者的右孩子插入。 递归： 当序列数大于二时，首先建立节点，将序列最中间的记录插入，然后递归，将中间节点之前的记录作为左孩子插入，中间节点后面的记录作为右孩子插入。 通过该算法构造出的二叉树一定为平衡二茬排序树： 每次递归保证了左边的点小于根节点，右边的点大于根节点，因此为排序树。 递归过程中保证了左右孩子的数目相等或相差一个，这样保证了左右孩子的深度绝对值只差不会超过 1 。 利用这一个思路，也可进行分裂、插入和删除： 分裂：中序遍历平衡二叉树得到序列，定位出 $x$ 的位置，利用递归算法和 $x$ 以及之前的序列可构造出一棵二叉树，之后的序列同样构造出一棵二叉树。 插入：先中序遍历得到序列，将需插入的值插入序列，然后再建树，只是这样相当于重新创建一棵二叉树。 删除：和插入一样。 C 语言实现： 下面是合并和分裂的 C 语言实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAX 100#define MMAX 200typedef struct BiTreeNode&#123; int number; int data; struct BiTreeNode *lchild; struct BiTreeNode *rchild;&#125;BiTreeNode, *BiTree;void join(BiTree *T, int key[], int first, int last); //use a sorted array key[] to create a balanced treevoid split(BiTree T, BiTree *T1, BiTree *T2, int x); //split a balanced tree into two balanced treeint inorder(BiTree T, int key[], int *last, int restore); //inorder traverse a balanced tree to get the record listint preorder(BiTree T); //preorder traverse a treeint get_index_x(int key[], int last, int x, int *index_x); //get the index of x in array keyvoid merge_array(int key[], int key1[], int key2[], int len1, int len2, int *last); //merge two sorted array into one sorted arrayvoid merge_tree(BiTree *T, BiTree T1, BiTree T2); //merge two balanced tree into one balanced treevoid merge_tree(BiTree *T, BiTree T1, BiTree T2)&#123; int key[MMAX], key1[MAX], key2[MAX]; int len1, len2, last; //get lists inorder(T1, key1, &amp;len1, 0); inorder(T2, key2, &amp;len2, 0); //merge lists merge_array(key, key1, key2, len1, len2, &amp;last); join(T, key, 0, last); //create tree&#125;//merge_treevoid merge_array(int key[], int key1[], int key2[], int len1, int len2, int *last)&#123; int i, j, k ; key[0] = (key1[0] &lt; key2[0])?key1[0]:key2[0];//get the first value for(i = 0, j = 0, k = 1; i &lt;= len1 &amp;&amp; j &lt;= len2; )&#123; //merge lists if (key1[i] &lt; key2[j] )&#123; if (key1[i] != key[k-1]) key[k++] = key1[i++]; else i ++; &#125; else &#123; if (key2[j] != key[k-1]) key[k++] = key2[j++]; else j ++; &#125; &#125; if (i &lt;= len1)&#123; //merge remain record of key1[] while ( i &lt;= len1 ) &#123; key[k++] = key1[i++]; &#125; &#125; else if(j &lt;= len2 )&#123; //merge remain record of key2[] while ( j &lt;= len2 ) &#123; key[k++] = key2[j++]; &#125; &#125; else ; *last = k - 1; //get lenth-1&#125;//merge_arrayvoid join(BiTree *T, int key[], int first, int last)&#123; //create balanced tree using sorted array if(first == last)&#123;//left one record *T = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;data = key[first]; (*T)-&gt;lchild = (*T)-&gt;rchild = NULL; &#125; else if(first == last - 1)&#123;//left two record *T = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;data = key[first]; (*T)-&gt;rchild = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;rchild-&gt;data = key[last]; (*T)-&gt;lchild = (*T)-&gt;rchild-&gt;lchild = (*T)-&gt;rchild-&gt;rchild = NULL; &#125; else&#123; //insert middle record int middle = (first + last) / 2; *T = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;data = key[middle]; //recursive call the join function join(&amp;((*T)-&gt;lchild), key, first, middle - 1); join(&amp;((*T)-&gt;rchild), key, middle + 1, last); &#125;&#125; //joinvoid split(BiTree T, BiTree *T1, BiTree *T2, int x)&#123; //split one balanced tree T into two balanced tree T1 and T2 int key[MAX]; int last, index_x; inorder(T, key, &amp;last, 0);//get sorted list array int get_x = get_index_x(key, last, x, &amp;index_x);//get the index of x in array key if (get_x)&#123; //call join funcion to create balanced tree join(T1, key, 0, index_x); join(T2, key, index_x + 1, last); &#125; else&#123; //all record &gt; x or &lt;= x, don't need split; *T1 = T; *T2 = NULL; &#125;&#125; //splitint get_index_x(int key[], int last, int x, int *index_x)&#123; int i, j; for ( i = 0; i &lt;= last; i++ ) &#123; j = i + 1; if( key[i] &lt;= x &amp;&amp; key[j] &gt; x &amp;&amp; j &lt;= last )&#123; *index_x = i; return 1; &#125; &#125; return 0;&#125;//get_indexint inorder(BiTree T, int key[], int *last, int restore)&#123; static int i = 0; if (!restore) i = 0;//when everytime call the function in main function, restore i to zero if(!T) return 1; else&#123; if (inorder(T-&gt;lchild, key, last, ++ restore))&#123; key[i++] = T-&gt;data;//get array list if (inorder(T-&gt;rchild, key, last, ++ restore))&#123; *last = i - 1;// get the length-1 of list return 1; &#125; &#125; return 0; &#125;&#125;//inorderint preorder(BiTree T)&#123; if(!T)&#123; return 1; &#125; else&#123; printf( \"%d \", T-&gt;data ); if(preorder(T-&gt;lchild)) if(preorder(T-&gt;rchild)) return 1; return 0; &#125; return 0;&#125;//preorderint main( int argc, char **argv ) &#123; int key[16]; for ( int i = 1; i &lt;= 16; i++ ) &#123; key[i-1] = 4*i - 3; &#125; BiTree T; join(&amp;T, key, 0, 15); preorder(T); printf( \"\\n\\n\" ); int num[40]; for ( int i = 0; i &lt; 40; i++ ) &#123; num[i] = 2*i + 1; &#125; BiTree T0, T1, T2; join(&amp;T0, num, 0, 39); preorder(T0); printf( \"\\n\\n\" ); int x; printf( \"Input x: \" ); scanf(\"%d\", &amp;x); split(T0, &amp;T1, &amp;T2, x); preorder(T1); printf( \"\\n\" ); preorder(T2); printf( \"\\n\\n\" ); int key1[10], key2[20]; for(int i = 0; i &lt; 10; i ++) key1[i] = 3*i; for ( int i = 0; i &lt; 20; i++ ) &#123; key2[i] = 2*i; &#125; BiTree t, t1, t2; join(&amp;t1, key1, 0, 9); preorder(t1); printf( \"\\n\" ); join(&amp;t2, key2, 0, 19); preorder(t2); printf( \"\\n\\n\" ); merge_tree(&amp;t, t1, t2); preorder(t); printf( \"\\n\" ); return 0;&#125; var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Python 中的命名冲突","date":"2017-06-18T13:40:57.000Z","path":"2017/06/18/Name-Conflict-in-Python/","text":"前言 今天中午正在吃饭，一位外校的学妹突然发微信问关于 Python 的编程题，其实很简单，但中间却出了一些意料不到的差错。 正文 学妹问的其中一个题是利用 random 函数连续取 100 个随机数，统计其中小于 0.2 的随机数个数。这题很简单，毕竟该学妹并不是计算机系的，所以不会也算正常吧。 我们知道，random 函数是 Python 内建的 random 模块中的一个函数，可直接调用该模块来用。它能够产生区间 0~1 之间的随机数。 下面是我写的代码： 1234567891011 #!/home/fenglv/FILE/anaconda2/bin/pythonimport random as rddef less(): num = 0 for i in range(100): value = rd.random() if value &lt; 0.2: num += 1 return numif __name__ == '__main__': print less() 无论怎么看，这个代码都是没问题的。因为它的确是对的，但是，当我运行的时候，却出错了： 123456 Traceback (most recent call last): File \"random.py\", line 11, in &lt;module&gt; print less() File \"random.py\", line 6, in less value = rd.random()AttributeError: 'module' object has no attribute 'random' WTF？于是我在 Python 提示符下一行一行的运行代码，发现却是对的？ 后来上网查，在 stackoverflow 上看到了答案。其实过去也注意过，只是这次却不小心忽略了。 在 Python，每一个脚本就是一个模块，模块名就是脚本名。 而我把这个文件命名为了 random.py ，于是便和内建的 random 模块冲突了，所以才导致错误的出现。 所以，无论如何，一定切记不要把脚本名命名了和内建模块名相同，特别是你还在该脚本中调用这一模块时。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"总结：Python+MySQL","date":"2017-06-13T14:45:04.000Z","path":"2017/06/13/Summary:Python+MySQL/","text":"前言 最近越来越懒了，写博客甚至只想贴几行代码上去。 直接进入正题。 最近在做师兄给安排的一个任务，说简单点就是用 Python 来操作 MySQL 进行一些简单的数据统计。 正题 第一步：通过 Python 连接到数据库。需要先安装一个模块 MySQLdb： 首先，访问https://pypi.python.org/pypi/MySQL-python下载适合系统的安装包。 然后： 12345 $ gunzip MySQL-python-1.2.2.tar.gz$ tar -xvf MySQL-python-1.2.2.tar$ cd MySQL-python-1.2.2$ python setup.py build$ python setup.py install 第二步：连接到 MySQL 数据库： 12 import MySQLdbdb = MySQLdb.connect(\"hostname\", \"username\", \"password\", \"database_name\") 第三步：执行 SQL 语句（接上）: 12345 # examplecursor = db.cursor()sql = \"SELECT * FROM database_name\"# executecursor.execute(sql) 第四步：Fetch 结果： 1234 # fetch one lineresult = cursor.fetchone()# fetch all linesresult = cursor.fetchall() 第五步：关闭连接： 1 cursor.close() 有了这些，并且懂一些基本的 SQL 知识的话，就知道怎么用 Python 来操作数据库了。 下面，说一下利用 Python 从 MySQL fetch 出来的数据的类型： 1 SELECT raw_name COUNT(row_name) FROM database_name GROUP BY raw_name; 通过上一语句 fetch 得到的数据为字典类型：键值对为：raw_name - COUNT(raw_name) . 1 SELECT * FROM databasse_name; 通过上一语句 fetch 得到的数据为元组类型，元组中的每一个元素依旧为元组。 知道了数据类型，就可以方便利用 Python 对数据进行处理了。 Python 文件读写 后一个参数为打开方式。 r：只读 w：写（会覆盖） w+：追加 a：追加（append) 读文件： 1 file_object.read() 写文件： 12 file_object.write('string')file_object.writelines('string') 关闭文件： 1 file_object.close() var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"使用 Python 开始你的机器学习之旅","date":"2017-06-07T14:42:18.000Z","path":"2017/06/07/Start-Machine-Learning-with-Python/","text":"机器学习是你的简历中必需的一门技能。我们简要概括一下使用 Python 来进行机器学习的一些步骤。 你想知道如何开始机器学习吗？在这篇文章中，我将简要概括一下使用 Python 来开始机器学习的一些步骤。Python 是一门流行的开源程序设计语言，也是在人工智能及其它相关科学领域中最常用的语言之一。机器学习简称 ML，是人工智能的一个分支，它是利用算法从数据中进行学习，然后作出预测。机器学习有助于帮助我们预测我们周围的世界。 从无人驾驶汽车到股市预测，再到在线学习，机器学习通过预测来进行自我提高的方法几乎被用在了每一个领域。由于机器学习的实际运用，目前它已经成为就业市场上最有需求的技能之一。另外，使用 Python 来开始机器学习很简单，因为有大量的在线资源，以及许多可用的 Python 机器学习库。 你需要如何开始使用 Python 进行机器学习呢？让我们来总结一下这个过程。 提高你的 Python 技能 由于 Python 在工业界和科学界都非常受欢迎，因此你不难找到 Python 的学习资源。如果你是一个从未接触过 Python 的新手，你可以利用在线资源，比如课程、书籍和视频来学习 Python。比如下面列举的一些资源： Python 学习之路 Google 开发者 Python 课程（视频） Google 的 Python 课堂 安装 Anaconda 下一步是安装 Anacona。有了 Anaconda ，你将可以开始使用 Python 来探索机器学习的世界了。Anaconda 的默认安装库包含了进行机器学习所需要的工具。 基本的机器学习技能 有了一些基本的 Python 编程技能，你就可以开始学习一些基本的机器学习技能了。一个实用的学习方法是学到一定技能便开始进行练习。然而，如果你想深入学习这个领域，那么你需要准备投入更多的学习时间。 一个获取技能的有效方法是在线课程。吴恩达的 Coursera 机器学习课程 是一个不错的选择。其它有用的在线训练包括： Python 机器学习： Scikit-Learn 教程 Python 实用机器学习教程 你也可以在 LiveEdu.tv 上观看机器学习视频，从而进一步了解这个领域。 学习更多的 Python 库 当你对 Python 和机器学习有一个好的感觉之后，可以开始学习一些开源的 Python 库。科学的 Python 库将会使完成一些简单的机器学习任务变得很简单。然而，选择什么库是完全主观的，并且在业界内许多人有很大的争论。 一些实用的 Python 库包括： Scikit-learn ：一个优雅的机器学习算法库，可用于数据挖掘和数据分析任务。 Tensorflow ：一个易于使用的神经网络库。 Theano ： 一个强大的机器学习库，可以帮助你轻松的评估数学表达式。 Pattern ： 可以帮助你进行自然语言处理、数据挖掘以及更多的工作。 Nilearn ：基于 Scikit-learn，它可以帮助你进行简单快速的统计学习。 探索机器学习 对基本的 Python、机器学习技能和 Python 库有了一定理解之后，就可以开始探索机器学习了。接下来，尝试探索一下 Scikit-learn 库。一个不错的教程是 Jake VanderPlas 写的 Scikit-learn 简介。 然后，进入中级主题，比如 K-均值聚类算法简介、线性回归、决策树和逻辑回归。 最后，深入高级机器学习主题，比如向量机和复杂数据转换。 就像学习任何新技能一样，练习得越多，就会学得越好。你可以通过练习不同的算法，使用不同的数据集来更好的理解机器学习，并提高解决问题的整体能力。 使用 Python 进行机器学习是对你的技能的一个很好的补充，并且有大量免费和低成本的在线资源可以帮助你。你已经掌握机器学习技能了吗？可以在下面留下你的评论，或者提交一篇文章来分享你的故事。 作者简介： Michael J. Garbade 博士是旧金山 LiveEdu Inc（Livecoding.tv）的创始人兼首席执行官。Livecoding.tv 是世界上观看工程师直播编代码最先进的直播平台。你可以通过观看工程师们写网站、移动应用和游戏，来将你的技能提升到一个新的水平。MichaelJ. Garbade 博士拥有金融学博士学位，并且是一名自学成才的工程师，他喜欢 Python、Django、Sencha Touch 和视频流。 via: https://opensource.com/article/17/5/python-machine-learning-introduction 作者：Michael J. Garbade译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Python 中的 __Main__","date":"2017-06-07T06:38:12.000Z","path":"2017/06/07/main-in-Python/","text":"在 C 语言中，我们有一个 main 函数，每一个程序的执行都以 main 函数为入口。在 Python 中，也有同样的 main 函数。 Python 中，我们写的一个模块都有一个名字，当它单独执行，不被其他模块调用时，它的名字就是 __main__，但是，当它被其他模块调用时，它的名字就是文件名。下面看例子。 123456 # hello.pydef hello(): string = 'Hello, world!\\n' print stringif __name__ == \"__main__\": printf \"This is module \"hello.py\"\" 正如上面的例子。当它作为模块被其他模块调用时，if 后面的语句便不会执行；反之，当它作为一个单独的模块运行时，便会执行 if 后面的语句。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"使用 Comm 比较两个排序好的文件","date":"2017-06-05T14:39:58.000Z","path":"2017/06/05/Linux-Command-of-comm/","text":"Linux 中的 comm 命令可以让用户按行比较两个已经排序好的文件。在本教程中，我们将使用一些浅显易懂的例子来讨论这个命令行工具。在开始之前，请注意，本教程中提到的所有例子都已经在 Ubuntu 16.04LTS 版本中测试过。 下面的例子将会告诉你 comm 命令是如何工作的。 1、 如何使用 comm 比较两个排序好的文件 要使用 comm 命令比较两个排序好的文件，只需要把它们的名字作为 comm 命令的参数。下面是通常的语法： 1 comm [name-of-first-file] [name-of-second-file] 比如，假设 file1 和 file2 是这种情况下的两个文件。前者包含下面几行内容： 1234 001056127258 而后者包含下面几行内容： 1234 002056167369 此时，comm 命令的输出如下图所示： 1 comm file1 file2 你可以看到，输出包含 3 列。第一列是仅包含在 file1 中的内容，第二列是仅包含在 file2 中的内容，最后，第三列是两个文件中均包含的内容。 2、 如何不输出 comm 命令输出中的某些列 如果你想，你可以不输出 comm 命令输出中的某些列。对于该特性，你有三个命令行选项可用：-1、-2 和 -3 。正如你所猜想的，这些数字表示你不想输出的列。 比如，下面这个命令将会不输出上面例子中的第三列： 1 comm -3 file1 file2 因此，你可以看到，第三列并没有输出。 注意，你可以通过一个单一命令同时不输出多列内容。比如： 1 comm -12 file1 file2 上面这个命令将会不输出第一、二列。 3、 如何使用 comm 命令比较两个未排序好的文件 正如我们所知道的，comm 只可用于排序好的文件。如果发现其中一个文件未排序好，那么便会在输出中产生一条信息来告诉用户。比如，我们交换 file1 的第一行和第二行，然后与 file2 进行比较。下面是该命令的输出： 你可以看到，这个命令产生一个输出告诉我们：file1 还没有排序好。此时，如果你不想让这个工具检查输入是否已经排序好，那么你可以使用 --nocheck-order 选项： 1 comm --nocheck-order file1 file2 你可以看到，前面出现的提示信息已经消失了。 注意，如果你想明确告诉 comm 命令来检查输入文件是否排序好，那么你可以使用 --check-order 选项。 4、 如何用自定义字符串分隔 comm 命令的输出列 默认情况下，comm 命令的输出列之间是以空格分隔的。然而，如何你想使用一个自定义字符串作为分隔符，那么你可以使用 --output-delimiter 选项。使用该选项时需要指定你想用来作为分隔符的字符串。 1 comm --output-delimiter=+ file1 file2 比如，我们使用加号来作为分隔符： 5、 如何使 comm 的输出行以 NUL 字符终止 默认情况下，comm 命令的输出行以新行终止。然而，如果你想，那么你可以改为以 NUL 字符终止，只需要使用 -z 选项即可： 1 comm -z file1 file2 结论 comm 命令并没有特别多的特性性，我们在这儿已经讨论了它的绝大多数命令行选项。只需要理解和练习在这篇教程中讨论的内容，那么你便可以在日常工作中知道如何使用这个工具了。如果你有任何问题或者疑问，请前往该命令的 man 手册，或者在下面评论。 via: https://www.howtoforge.com/linux-comm-command/ 作者：Himanshu Arora译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"MyCLI ：一个支持自动补全和语法高亮的 MySQL/MariaDB 客户端","date":"2017-06-05T09:37:12.000Z","path":"2017/06/05/MyCli-Tutorial/","text":"MyCLI 是一个易于使用的命令行客户端，可用于受欢迎的数据库管理系统 MySQL、MariaDB 和 Percona，支持自动补全和语法高亮。它是使用 prompt_toolkit 库写的，需要 Python 2.7、3.3、3.4、3.5 和 3.6 的支持。MyCLI 还支持通过 SSL 安全连接到 MySQL 服务器。 MyCLI 的特性 当你第一次使用它的时候，将会自动创建一个文件 ~/.myclirc。 当输入 SQL 的关键词和数据库中的表、视图和列时，支持自动补全。 默认情况下也支持智能补全，能根据上下文的相关性提供补全建议。 比如： 12 SELECT * FROM &lt;Tab&gt; - 这将显示出数据库中的表名。SELECT * FROM users WHERE &lt;Tab&gt; - 这将简单的显示出列名称。 通过使用 Pygents 支持语法高亮 支持 SSL 连接 提供多行查询支持 它可以将每一个查询和输出记录到一个文件中（默认情况下禁用）。 允许保存收藏一个查询（使用 \\fs 别名 保存一个查询，并可使用 \\f 别名 运行它）。 支持 SQL 语句执行和表查询计时 以更吸引人的方式打印表格数据 如何在 Linux 上为 MySQL 和 MariaDB 安装 MyCLI 在 Debian/Ubuntu 发行版上，你可以很容易的像下面这样使用 apt 命令 来安装 MyCLI 包： 12 $ sudo apt-get update$ sudo apt-get install mycli 同样，在 Fedora 22+ 上也有 MyCLI 的可用包，你可以像下面这样使用 dnf 命令 来安装它： 1 $ sudo dnf install mycli 对于其他 Linux 发行版，比如 RHEL/CentOS，你需要使用 Python 的 pip 工具来安装 MyCLI。首先，使用下面的命令来安装 pip： 1 $ sudo yum install pip 安装好 pip 以后，你可以像下面这样安装 MyCLI： 1 $ sudo pip install mycli 在 Linux 中如何使用 MyCLI 连接 MySQL 和 MariaDB 安装好 MyCLI 以后，你可以像下面这样使用它： 1 $ mycli -u root -h localhost 自动补全 对于关键词和 SQL 函数可以进行简单的自动补全： MySQL 自动补全 智能补全 当输入 FROM 关键词以后会进行表名称的补全： MySQL 智能补全 别名支持 当表的名称设置别名以后，也支持列名称的补全： MySQL 别名支持 语法高亮 支持 MySQL 语法高亮： MySQL 语法高亮 格式化 SQL 的输出 MySQL 的输出会通过 less 命令 进行格式化输出： MySQL 格式化输出 要登录 MySQL 并同时选择数据库，你可以使用和下面类似的命令： 123 $ mycli local_database$ mycli -h localhost -u root app_db$ mycli mysql://amjith@localhost:3306/django_poll 更多使用选项，请输入： 1 $ mycli --help via: https://www.tecmint.com/mycli-mysql-client-with-auto-completion-syntax-highlighting/ 作者：Aaron Kili译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"4 个用于构建优秀的命令行用户界面的 Python 库","date":"2017-06-04T09:34:33.000Z","path":"2017/06/04/4-Best-Library-of-Python-for-Build-Good-cli-ui/","text":"在这个分为两篇的关于具有绝佳命令行界面的终端程序的系列文章的第二篇教程中，我们将讨论 Prompt、Toolkit、Click、Pygments 和 Fuzzy Finder 。 这是我的一个分为两篇的关于具有绝佳命令行界面的终端程序的系列文章的第二篇教程。在第一篇文章中，我们讨论了一些能够使命令行应用用起来令人感到愉悦的特性。在第二篇文章中，我们来看看如何用 Python 的一些库来实现这些特性。 我打算用少于 20 行 Python 代码来实现。让我们开始吧。 Python Prompt Toolkit 我习惯于把这个库称为命令行应用的瑞士军刀，它可以作为 readline 、curses 等的替代品。让我们首先安装这个库，然后开始该教程： 1 pip install prompt_toolkit 我们以一个简单的 REPL （LCTT 译注：REPL —— Read-Eval-Print Loop，交互式开发环境）开始。一个典型的 REPL 会接收用户的输入，进行一个操作，然后输出结果。比如在我们的例子中，我们将要实现一个具有 “回显” 功能的 REPL 。它仅仅是原样打印出用户的输入： REPL 12345 from prompt_toolkit import promptwhile 1: user_input = prompt('&gt;') print(user_input) 这就是实现 REPL 的全部代码。它可以读取用户的输入，然后打印出用户的输入内容。在这段代码中使用的 prompt 函数来自 prompt_toolkit 库，它是 readline 库的一个替代品。 命令历史 为了增强我们的 REPL 的功能，我们可以添加命令历史： 12345678 from prompt_toolkit import promptfrom prompt_toolkit.history import FileHistorywhile 1: user_input = prompt('&gt;', history=FileHistory('history.txt'), ) print(user_input) 我们刚刚给 REPL 添加了持久的命令历史。现在，我们可以使用上/下箭头来浏览命令历史，并使用 Ctrl-R 来搜索命令历史。它满足了命令行的基本准则。 自动推荐 在第一篇教程中，我讲到的一个可发现性技巧是自动推荐历史命令。（我是首先在 fish shell 中看到的这一特性）让我们把这一特性加入到我们的 REPL 中： 12345678910 from prompt_toolkit import promptfrom prompt_toolkit.history import FileHistoryfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistorywhile 1: user_input = prompt('&gt;', history=FileHistory('history.txt'), auto_suggest=AutoSuggestFromHistory(), ) print(user_input) 我们只需要给 prompt() API 调用添加一个新的参数。现在，我们有了一个具有 fish shell 风格的 REPL，它可以自动推荐历史命令。 自动补全 现在，让我们通过自动补全来加强 Tab 补全。它能够在用户开始输入的时候弹出可能的命令推荐。 REPL 如何来进行推荐呢？我们使用一个字典来进行可能项的推荐。 比如说我们实现一个针对 SQL 的 REPL 。我们可以把 SQL 关键字存到自动补全字典里面。让我们看一看这是如何实现的： 123456789101112131415 from prompt_toolkit import promptfrom prompt_toolkit.history import FileHistoryfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistoryfrom prompt_toolkit.contrib.completers import WordCompleterSQLCompleter = WordCompleter(['select', 'from', 'insert', 'update', 'delete', 'drop'], ignore_case=True)while 1: user_input = prompt('SQL&gt;', history=FileHistory('history.txt'), auto_suggest=AutoSuggestFromHistory(), completer=SQLCompleter, ) print(user_input) 再次说明，我们只是简单的使用了 prompt-toolkit 内建的一个叫做 WordCompleter 的补全特性，它能够把用户输入和可能推荐的字典进行匹配，然后提供一个列表。 现在，我们有了一个能够自动补全、fish shell 风格的历史命令推荐以及上/下浏览历史的 REPL 。实现这些特性只用了不到 10 行的实际代码。 Click Click 是一个命令行创建工具包，使用它能够更容易的为程序解析命令行选项的参数和常量。在这儿我们不讨论如何使用 Click 来作为参数解析器。相反，我们将会看看 Click 带有的一些功能。 安装 Click： 1 pip install click 分页器 分页器是 Unix 系统上的实用工具，它们能够一次一页地显示很长的输出。分页器的一些例子包括 less、more、most 等。通过分页器来显示一个命令的输出不仅仅是一个友好的设计，同时也是必要的。 让我们进一步改进前面的例子。我们不再使用默认的 print() 语句，取而代之的是 click.echo_via_pager() 。它将会把输出通过分页器发送到标准输出。这是平台无关的，因此在 Unix 系统或 Windows 系统上均能工作。如果必要的话，click_via_pager 会尝试使用一个合适的默认分页器来输出，从而能够显示代码高亮。 12345678910111213141516 from prompt_toolkit import promptfrom prompt_toolkit.history import FileHistoryfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistoryfrom prompt_toolkit.contrib.completers import WordCompleterimport clickSQLCompleter = WordCompleter(['select', 'from', 'insert', 'update', 'delete', 'drop'], ignore_case=True)while 1: user_input = prompt(u'SQL&gt;', history=FileHistory('history.txt'), auto_suggest=AutoSuggestFromHistory(), completer=SQLCompleter, ) click.echo_via_pager(user_input) 编辑器 在我前面的文章中一个值得一提的细节是，当命令过于复杂的时候进入编辑器来编辑。Click 有一个简单的 API 能够打开编辑器，然后把在编辑器中输入的文本返回给应用。 12 import clickmessage = click.edit() Fuzzy Finder Fuzzy Finder 是一种通过少量输入来为用户减少推荐的方法。幸运的是，有一个库可以实现 Fuzzy Finder 。让我们首先安装这个库： 1 pip install fuzzyfinder Fuzzy Finder 的 API 很简单。用户向它传递部分字符串和一系列可能的选择，然后，Fuzzy Finder 将会返回一个与部分字符串匹配的列表，这一列表是通过模糊算法根据相关性排序得出的。比如： 123456 &gt;&gt;&gt; from fuzzyfinder import fuzzyfinder&gt;&gt;&gt; suggestions = fuzzyfinder('abc', ['abcd', 'defabca', 'aagbec', 'xyz', 'qux'])&gt;&gt;&gt; list(suggestions)['abcd', 'defabca', 'aagbec'] 现在我们有了 fuzzyfinder，让我们把它加入到我们的 SQL REPL 中。方法是我们自定义一个 completer 而不是使用来自 prompt-toolkit 库的 WordCompleter 。比如： 1234567891011121314151617181920212223 from prompt_toolkit import promptfrom prompt_toolkit.history import FileHistoryfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistoryfrom prompt_toolkit.completion import Completer, Completionimport clickfrom fuzzyfinder import fuzzyfinderSQLKeywords = ['select', 'from', 'insert', 'update', 'delete', 'drop']class SQLCompleter(Completer): def get_completions(self, document, complete_event): word_before_cursor = document.get_word_before_cursor(WORD=True) matches = fuzzyfinder(word_before_cursor, SQLKeywords) for m in matches: yield Completion(m, start_position=-len(word_before_cursor))while 1: user_input = prompt(u'SQL&gt;', history=FileHistory('history.txt'), auto_suggest=AutoSuggestFromHistory(), completer=SQLCompleter(), ) click.echo_via_pager(user_input) Pygments 现在，让我们给用户输入添加语法高亮。我们正在搭建一个 SQL REPL，如果具有彩色高亮的 SQL 语句，这会很棒。 Pygments 是一个提供语法高亮的库，内建支持超过 300 种语言。添加语法高亮能够使应用变得彩色化，从而能够帮助用户在执行程序前发现 SQL 中存在的错误，比如拼写错误、引号不匹配或括号不匹配。 首先，安装 Pygments ： 1 pip install pygments 让我们使用 Pygments 来为 SQL REPL 添加颜色： 12345678910111213141516171819202122232425 from prompt_toolkit import promptfrom prompt_toolkit.history import FileHistoryfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistoryfrom prompt_toolkit.completion import Completer, Completionimport clickfrom fuzzyfinder import fuzzyfinderfrom pygments.lexers.sql import SqlLexerSQLKeywords = ['select', 'from', 'insert', 'update', 'delete', 'drop']class SQLCompleter(Completer): def get_completions(self, document, complete_event): word_before_cursor = document.get_word_before_cursor(WORD=True) matches = fuzzyfinder(word_before_cursor, SQLKeywords) for m in matches: yield Completion(m, start_position=-len(word_before_cursor))while 1: user_input = prompt(u'SQL&gt;', history=FileHistory('history.txt'), auto_suggest=AutoSuggestFromHistory(), completer=SQLCompleter(), lexer=SqlLexer, ) click.echo_via_pager(user_input) Prompt Toolkit 能够和 Pygments 一同很好的工作。我们把 Pygments 提供的 SqlLexer 加入到来自 prompt-toolkit 的 prompt 中。现在，所有的用户输入都会被当作 SQL 语句，并进行适当着色。 结论 我们的“旅途”通过创建一个强大的 REPL 结束，这个 REPL 具有常见的 shell 的全部特性，比如历史命令，键位绑定，用户友好性比如自动补全、模糊查找、分页器支持、编辑器支持和语法高亮。我们仅用少于 20 行 Python 代码就实现了这个 REPL 。 via: https://opensource.com/article/17/5/4-practical-python-libraries 作者：Amjith Ramanujam译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"在 Linux 中使用 Pushd 和 Popd 命令来进行高效的目录导航","date":"2017-06-04T09:32:01.000Z","path":"2017/06/04/Linux-Command-of-popd-and-pushd/","text":"有时候，通过命令来在 Linux 文件系统导航是一件非常痛苦的事情，特别是对于一些新手。通常情况下，我们主要使用 cd（改变目录）命令在 Linux 文件系统之间移动。 在之前的文章中，我们回顾了一个非常简单但很有用的 Linux 上的 CLI 工具，文章叫做 bd：快速返回某级父目录而不用冗余地输入 “cd ../../..” 在这个教程中，我们将讨论两个相关的命令：pushd 和 popd ，使用它们可以高效的浏览 Linux 目录结构。这两个命令在大多数 shell ，比如 bash、tcsh 中都存在。 推荐阅读：Autojump：快速浏览 Linux 文件系统的一个高级 cd 命令 pushd 和 popd 命令在 Linux 系统中如何工作 pushd 和 popd 命令根据 ‘LIFO’（后进先出）原则工作。在这个原则之下，只有两个操作是允许的：把一个目录压入栈，以及把一个目录弹出栈。 pushd 命令会增加一个目录到栈顶，而 popd 命令会从栈顶移除一个目录。 为了显示目录栈中（或历史）的目录，我们可以使用下面展示的 dirs 命令： 123 $ dirs或$ dirs -v dirs - 显示位于目录栈中的目录 pushd 命令：将一个目录路径添加到／放入目录栈（历史）中，之后，你可以浏览位于目录栈（历史）中的任意目录。当把一个新的目录入栈时，会打印出当前位于栈中的所有目录。 下面这些命令会展示这个命令是如何工作的： 1234 $ pushd /var/www/html/$ pushd ~/Documents/$ pushd ~/Desktop/$ pushd /var/log/ pushd - 添加新目录入栈 根据上面输出的目录栈可知（目录索引按倒序排列）： /var/log 是目录栈中的第五个目录，索引为 0 ~/Desktop/ 是第四个，索引为 1 ~/Document/ 是第三个，索引为 2 /var/www/html 是第二个，索引为 3 ~ 是第一个，索引为 4 另外，我们也可以使用目录索引的形式 pushd +# 或 pushd -# 来添加目录入栈。为了进入目录 ~/Documents ，我们可以输入： 1 $ pushd +2 pushd －通过数字浏览目录 注意，经过上一步操作以后，栈的内容便发生了改变。所以，要从上面的例子中进入目录 /var/www/html ，我们应该使用下面的命令： 1 $ pushd +1 pushd －通过数字浏览目录 popd 命令－从栈顶或历史中移除一个目录。为了列出目录栈中的所有目录，只需输入： 1 $ popd 为了从目录栈中移除一个目录，我们可以使用 popd +# 或 popd -# 命令，在这时，我们需要输入下面的命令来移除目录 ~/Documents ： 1 $ popd +1 popd－从栈中以移除目录 via: https://www.tecmint.com/pushd-and-popd-linux-filesystem-navigation/ 作者：Aaron Kili译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Ctex 到 TexLive","date":"2017-05-28T06:44:47.000Z","path":"2017/05/28/From-Ctex-to-TeXlive/","text":"前言 一年前开始学习使用 Latex。 最开始在 Windows 系统下安装 Ctex 套装，编辑器用 MikTex 自带的 TexWorks。几个月后，编辑器改用 TexStudio，用起来确实比 TexWorks 要快，也更舒服。 作为一个 Linux 系统的忠实热爱者，想把所有的事情都在 Linux 系统上完成。于是，不久前在 Linux 系统上安装了 TexLive ，和 Ctex 相比之下，这才是正统的 Tex 。 正文 换到 Linux 系统下使用 TexLive 以后，发现它对中文的支持似乎不是很好，虽然以后可能会尝试尽量只用英文，但目前来说，没有好的中文支持很让我头疼，主要是强迫症。 折腾了一晚上，起始并不是不支持，只是自己不知道怎么用。下面说一下具体有用的东西（前面部分都是废话）。 安装 TexLive 有两种安装方法，第一种是下载镜像，然后进行安装，网上也已经有很多教程。 第二种方法当然就是使用软件包进行安装： 12 $ sudo apt-get update$ sudo apt-get install texlive-full 之后是一个比较漫长的安装过程。 安装完成以后，可以通过下面的命令查看是否安装成功： 1 $ tex --version 如果安装成功，就会出来一系列版本、版权的相关信息。 中文支持 一开始，我发现不能支持中文，后来其实也并没有做什么特殊的更改，最后发现只是因为自己不会用 TexLive 而已。 目前，我大概只用 LaTex 来写一些课的作业和做 Presentation 。难免还是会用到中文，所以这问题还是得解决。 首先，要有中文支持，需要用到下面一个宏包：xeCJK，即需要在文档中加入： 12 \\documentclass[UTF8]&#123;ctexart&#125;\\usepackage&#123;xeCJK&#125; 现在，就可以支持中文了，同时还可以设置字号和字体，比如我要设置为 4 号楷体，那么只需加入： 12 \\CJKfamily&#123;zhkai&#125;\\zihao&#123;4&#125; 如果是 presentation，那么我们使用的是： 123 \\documentclass&#123;beamer&#125;\\usepackage&#123;ctex&#125;\\usepackage&#123;xeCJK&#125; 这样就可以支持中文了，字体和字号设置同上。 编译 注意：一般情况下，我们用两种编译方式： xelatex file.tex ：当使用了 xeCJK 宏包时，必须使用此种编译方式。 pdflatex file.tex：这是另一种编译方式，它对其他宏包的支持似乎比 xelatex 好。 自己使用的两个简单的模板放到了 GitHub 上面：https://github.com/ucasFL/LaTextemplet 后记 值得一提的是，TexLive 的编译速度比 Ctex 不知道快到哪儿去了，不过我觉得和系统也有很大的关系。 另外，其实 Tex 的精髓终究还是命令行。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Python-Mode：在 Vim 编辑器中开发 Python 应用的 Vim 插件","date":"2017-05-26T09:27:47.000Z","path":"2017/05/26/The-Vim-Plug-of-Python-Mode/","text":"Python-mode 是一个 Vim 插件，它使你能够在 Vim 编辑器中更快的利用包括 pylint、rope、pydoc、pyflakes、pep8、autopep8、pep257 和 mccable 在内的各种库来写 Python 代码，这些库提供了一些编码功能，比如静态分析、特征重构、折叠、补全和文档等。 这个插件包含了所有你在 Vim 编辑器中可以用来开发 Python 应用的特性。 Python-mode 的特性 它包含下面这些值得一提的特性： 支持 Python 2.6+ 至 Python 3.2 版本 语法高亮 提供 virtualenv 支持 支持 Python 式折叠 提供增强的 Python 缩进 能够在 Vim 中运行 Python 代码 能够添加/删除断点 支持 Python 的 motion 和运算符 能够在运行的同时检查代码（pylint、pyflakes、pylama ……） 支持自动修复 PEP8 错误 允许在 Python 文档中进行搜索 支持代码重构 支持强代码补全 支持定义跳转 在这篇教程中，我将阐述如何在 Linux 中为 Vim 安装设置 Python-mode，从而在 Vim 编辑器中开发 Python 应用。 如何在 Linux 系统中为 Vim 安装 Python-mode 首先安装 Pathogen （它使得安装插件超级简单，并且运行文件位于私有目录中），从而更加容易的安装 Python-mode 运行下面的命令来获取 pathogen.vim 文件和它需要的目录： 12 # mkdir -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; \\# curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 然后把下面这些内容加入 ~/.vimrc 文件中： 123 execute pathogen#infect()syntax onfiletype plugin indent on 安装好 pathogen 以后，你可以像下面这样把 Python-mode 插件放入 ~/.vim/bunble 目录中： 12 # cd ~/.vim/bundle # git clone https://github.com/klen/python-mode.git 然后像下面这样在 Vim 中重建 helptags ： 1 :helptags 你需要启用 filetype-plugin （:help filetype-plugin-on）和 filetype-indent （:help filetype-indent-on）来使用 Python-mode 。 在 Debian 和 Ubuntu 中安装 Python-mode 另一种在 Debian 和 Ubuntu 中安装 Python-mode 的方法是使用 PPA，就像下面这样 123 $ sudo add-apt-repository https://klen.github.io/python-mode/deb main$ sudo apt-get update$ sudo apt-get install vim-python-mode 如果你遇到消息：“The following signatures couldn’t be verified because the public key is not available”，请运行下面的命令： 1 $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys B5DF65307000E266 现在，使用 vim-addon-manager 启用 Python-mode： 12 $ sudo apt install vim-addon-manager$ vim-addons install python-mode 在 Linux 中定制 Python-mode 如果想覆盖默认键位绑定，可以在 .vimrc 文件中重定义它们，比如： 123456 \" Override go-to.definition key shortcut to Ctrl-]let g:pymode_rope_goto_definition_bind = \"&lt;C-]&gt;\"\" Override run current python file key shortcut to Ctrl-Shift-elet g:pymode_run_bind = \"&lt;C-S-e&gt;\"\" Override view python doc key shortcut to Ctrl-Shift-dlet g:pymode_doc_bind = \"&lt;C-S-d&gt;\" 注意，默认情况下， Python-mode 使用 Python 2 进行语法检查。你可以在 .vimrc 文件中加入下面这行内容从而启动 Python 3 语法检查。 1 let g:pymode_python = 'python3' 你可以在 Python-mode 的 GitHub 仓库找到更多的配置选项： https://github.com/python-mode/python-mode 这就是全部内容了。在本教程中，我向你们展示了如何在 Linux 中使用 Python-mode 来配置 Vim 。请记得通过下面的反馈表来和我们分享你的想法。 作者简介： Aaron Kili 是一个 Linux 和 F.O.S.S 爱好者、Linux 系统管理员、网络开发人员，现在也是 TecMint 的内容创作者，他喜欢和电脑一起工作，坚信共享知识。 via: https://www.tecmint.com/python-mode-a-vim-editor-plugin/ 作者：Aaron Kili译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"8 个优秀的开源 Markdown 编辑器","date":"2017-05-23T09:23:40.000Z","path":"2017/05/23/8-Excellent-Open-Source-Markdown-Editor/","text":"Markdown 首先，对 Markdown 进行一个简单的介绍。Markdown 是由 John Gruber 和 Aaron Swartz 共同创建的一种轻量级纯文本格式语法。Markdown 可以让用户“以易读、易写的纯文本格式来进行写作，然后可以将其转换为有效格式的 XHTML（或 HTML）“。Markdown 语法只包含一些非常容易记住的符号。其学习曲线平缓；你可以在炒蘑菇的同时一点点学习 Markdown 语法（大约 10 分钟）。通过使用尽可能简单的语法，错误率达到了最小化。除了拥有友好的语法，它还具有直接输出干净、有效的（X）HTML 文件的强大功能。如果你看过我的 HTML 文件，你就会知道这个功能是多么的重要。 Markdown 格式语法的主要目标是实现最大的可读性。用户能够以纯文本的形式发布一份 Markdown 格式的文件。用 Markdown 进行文本写作的一个优点是易于在计算机、智能手机和个人之间共享。几乎所有的内容管理系统都支持 Markdown 。它作为一种网络写作格式流行起来，其产生一些被许多服务采用的变种，比如 GitHub 和 Stack Exchange 。 你可以使用任何文本编辑器来写 Markdown 文件。但我建议使用一个专门为这种语法设计的编辑器。这篇文章中所讨论的软件允许你使用 Markdown 语法来写各种格式的专业文档，包括博客文章、演示文稿、报告、电子邮件以及幻灯片等。另外，所有的应用都是在开源许可证下发布的，在 Linux、OS X 和 Windows 操作系统下均可用。 Remarkable 让我们从 Remarkable 开始。Remarkable 是一个 apt 软件包的名字，它是一个相当有特色的 Markdown 编辑器 — 它并不支持 Markdown 的全部功能特性，但该有的功能特性都有。它使用和 GitHub Markdown 类似的语法。 你可以使用 Remarkable 来写 Markdown 文档，并在实时预览窗口查看更改。你可以把你的文件导出为 PDF 格式（带有目录）和 HTML 格式文件。它有强大的配置选项，从而具有许多样式，因此，你可以把它配置成你最满意的 Markdown 编辑器。 其他一些特性： 语法高亮 支持 GitHub 风味的 Markdown 支持 MathJax - 通过高级格式呈现丰富文档 键盘快捷键 在 Debian、Ubuntu、Fedora、SUSE 和 Arch 系统上均有 Remarkable 的可用的简易安装程序。 主页： https://remarkableapp.github.io/许可证： MIT 许可 Atom 毫无疑问， Atom 是一个神话般的文本编辑器。超过 50 个开源包集合在一个微小的内核上，从而构成 Atom 。伴有 Node.js 的支持，以及全套功能特性，Atom 是我最喜欢用来写代码的编辑器。Atom 的特性在杀手级开源应用的文章中有更详细介绍，它是如此的强大。但是作为一个 Markdown 编辑器，Atom 还有许多不足之处，它的默认包不支持 Markdown 的特性。例如，正如上图所展示的，它不支持等价渲染。 但是，开源拥有强大的力量，这是我强烈提倡开源的一个重要原因。Atom 上有许多包以及一些复刻，从而添加了缺失的功能特性。比如，Markdown Preview Plus 提供了 Markdown 文件的实时预览，并伴有数学公式渲染和实时重加载。另外，你也可以尝试一下 Markdown Preview Enhanced。如果你需要自动滚动特性，那么 markdown-scroll-sync 可以满足你的需求。我是 Markdown-Writer和 Markdown-pdf的忠实拥趸，后者支持将 Markdown 快速转换为 PDF、PNG 以及 JPEG 文件。 这个方式体现了开源的理念：允许用户通过添加扩展来提供所需的特性。这让我想起了 Woolworths 的 n 种杂拌糖果的故事。虽然需要多付出一些努力，但能收获最好的回报。 主页： https://atom.io/许可证： MIT 许可 Haroopad Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。 Haroo 在韩语中的意思是“一天”。 它的功能列表非常可观。请看下面： 主题、皮肤和 UI 组件 超过 30 种不同的编辑主题 - tomorrow-night-bright 和 zenburn 是近期刚添加的 编辑器中的代码块的语法高亮 Ruby、Python、PHP、Javascript、C、HTML 和 CSS 的语法高亮支持 基于 CodeMirror，这是一个在浏览器中使用 JavaScript 实现的通用文本编辑器 实时预览主题 基于 markdown-css 的 7 个主题 语法高亮 基于 hightlight.js 的 112 种语言以及 49 种样式 定制主题 基于 CSS （层叠样式表）的样式 演示模式 - 对于现场演示非常有用 绘图 - 流程图和序列图 任务列表 扩展 Markdown 语法，支持 TOC（目录）、 GitHub 风味 Markdown 以及数学表达式、脚注和任务列表等 字体大小 使用首选窗口和快捷键来设置编辑器和预览字体大小 嵌入富媒体内容 视频、音频、3D、文本、开放图形以及 oEmbed 支持大约 100 种主要的网络服务（YouTude、SoundCloud、Flickr 等） 支持拖放 显示模式 默认：编辑器｜预览器，倒置：预览器｜编辑器，仅编辑器，仅预览器（View -&gt; Mode） 插入当前日期和时间 多种格式支持（Insert -&gt; Data &amp; Time） HtML 到 Markdown 拖放你在 Web 浏览器中选择好的文本 Markdown 解析选项 大纲预览 纯粹主义者的 Vim 键位绑定 Markdown 自动补全 导出为 PDF 和 HTML 带有样式的 HTML 复制到剪切板可用于所见即所得编辑器 自动保存和恢复 文件状态信息 换行符或空格缩进 （一、二、三）列布局视图 Markdown 语法帮助对话框 导入和导出设置 通过 MathJax 支持 LaTex 数学表达式 导出文件为 HTML 和 PDF 创建扩展来构建自己的功能 高效地将文件转换进博客系统：WordPress、Evernote 和 Tumblr 等 全屏模式－尽管该模式不能隐藏顶部菜单栏和顶部工具栏 国际化支持：英文、韩文、西班牙文、简体中文、德文、越南文、俄文、希腊文、葡萄牙文、日文、意大利文、印度尼西亚文土耳其文和法文 主页 http://pad.haroopress.com/许可证： GNU GPL v3 许可 StackEdit StackEdit 是一个功能齐全的 Markdown 编辑器，基于 PageDown（该 Markdown 库被 Stack Overflow 和其他一些 Stack 交流网站使用）。不同于在这个列表中的其他编辑器，StackEdit 是一个基于 Web 的编辑器。在 Chrome 浏览器上即可使用 StackEdit 。 特性包括： 实时预览 HTML，并通过绑定滚动连接特性来将编辑器和预览的滚动条相绑定 支持 Markdown Extra 和 GitHub 风味 Markdown，Prettify/Highlight.js 语法高亮 通过 MathJax 支持 LaTex 数学表达式 所见即所得的控制按键 布局配置 不同风格的主题支持 la carte 扩展 离线编辑 可以与 Google 云端硬盘（多帐户）和 Dropbox 在线同步 一键发布到 Blogger、Dropbox、Gist、GitHub、Google Drive、SSH 服务器、Tumblr 和 WordPress 主页： https://stackedit.io/许可证： Apache 许可 MacDown MacDown 是在这个列表中唯一一个只运行在 macOS 上的全特性编辑器。具体来说，它需要在 OX S 10.8 或更高的版本上才能使用。它在内部使用 Hoedown 将 Markdown 渲染成 HTML，这使得它的特性更加强大。Heodown 是 Sundown 的一个复活复刻。它完全符合标准，无依赖，具有良好的扩展支持和 UTF-8 感知。 MacDown 基于 Mou，这是专为 Web 开发人员设计的专用解决方案。 它提供了良好的 Markdown 渲染，通过 Prism 提供的语言识别渲染实现代码块级的语法高亮，MathML 和 LaTex 渲染，GTM 任务列表，Jekyll 前端以及可选的高级自动补全。更重要的是，它占用资源很少。想在 OS X 上写 Markdown？MacDown 是我针对 Web 开发者的开源推荐。 主页： https://macdown.uranusjr.com/许可证： MIT 许可 ghostwriter ghostwriter 是一个跨平台的、具有美感的、无干扰的 Markdown 编辑器。它内建了 Sundown 处理器支持，还可以自动检测 pandoc、MultiMarkdown、Discount 和 cmark 处理器。它试图成为一个朴实的编辑器。 ghostwriter 有许多很好的功能设置，包括语法高亮、全屏模式、聚焦模式、主题、通过 Hunspell 进行拼写检查、实时字数统计、实时 HTML 预览、HTML 预览自定义 CSS 样式表、图片拖放支持以及国际化支持。Hemingway 模式按钮可以禁用退格键和删除键。一个新的 “Markdown cheat sheet” HUD 窗口是一个有用的新增功能。主题支持很基本，但在 GitHub 仓库上也有一些可用的试验性主题。 ghostwriter 的功能有限。我越来越欣赏这个应用的通用性，部分原因是其简洁的界面能够让写作者完全集中在策划内容上。这一应用非常值得推荐。 ghostwirter 在 Linux 和 Windows 系统上均可用。在 Windows 系统上还有一个便携式的版本可用。 主页： https://github.com/wereturtle/ghostwriter许可证： GNU GPL v3 许可 Abricotine Abricotine 是一个为桌面构建的、旨在跨平台且开源的 Markdown 编辑器。它在 Linux、OS X 和 Windows 上均可用。 该应用支持 Markdown 语法以及一些 GitHub 风味的 Markdown 增强（比如表格）。它允许用户直接在文本编辑器中预览文档，而不是在侧窗栏。 该应用有一系列有用的特性，包括拼写检查、以 HTML 格式保存文件或把富文本复制粘贴到邮件客户端。你也可以在侧窗中显示文档目录，展示语法高亮代码、以及助手、锚点和隐藏字符等。它目前正处于早期的开发阶段，因此还有一些很基本的 bug 需要修复，但它值得关注。它有两个主题可用，如果有能力，你也可以添加你自己的主题。 主页： http://abricotine.brrd.fr/许可证： GNU 通用公共许可证 v3 或更高许可 ReText ReText 是一个简单而强大的 Markdown 和 reStructureText 文本编辑器。用户可以控制所有输出的格式。它编辑的文件是纯文本文件，但可以导出为 PDF、HTML 和其他格式的文件。ReText 官方仅支持 Linux 系统。 特性包括： 全屏模式 实时预览 同步滚动（针对 Markdown） 支持数学公式 拼写检查 分页符 导出为 HTML、ODT 和 PDF 格式 使用其他标记语言 主页： https://github.com/retext-project/retext许可证： GNU GPL v2 或更高许可 via: https://www.ossblog.org/markdown-editors/ 作者：Steve Emms译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Vim 中使用模式行进行文本特定设置","date":"2017-05-20T09:15:15.000Z","path":"2017/05/20/Text-Specific-Setting-in-Vim/","text":"虽然插件毫无疑问是 Vim 最大的优势，然而，还有其它一些功能，使得它成为当今 Linux 用户中最强大、功能最丰富的文本编辑器/IDE 之一。其中一个功能就是可以根据文件做特定的设置。我们可以使用该编辑器的模式行（Modeline）特性来实现该功能。 在这篇文章中，我将讨论如何使用 Vim 的模式行（Modeline）特性来简单的理解一些例子。 在开始之前，值得提醒一下，这篇教程中提及的所有例子、命令和指令都已经在 Ubuntu 16.04 中使用 Vim 7.4 版本测试过。 VIM 模式行 用法 正如上面已经提到的， Vim 的模式行特性让你能够进行特定于文件的更改。比如，假设你想把项目中的一个特定文件中的所有制表符用空格替换，并且确保这个更改不会影响到其它所有文件。这是模式行帮助你完成你想做的事情的一个理想情况。 因此，你可以考虑将下面这一行加入文件的开头或结尾来完成这件事。 1 # vim: set expandtab: （LCTT 译注：模式行就是一行以注释符，如 #、//、/* 开头，间隔一个空格，以 vim: 关键字触发的设置命令。可参看：http://vim.wikia.com/wiki/Modeline_magic ） 如果你是在 Linux 系统上尝试上面的练习来测试用例，很有可能它将不会像你所期望的那样工作。如果是这样，也不必担心，因为某些情况下，模式行特性需要先激活才能起作用（出于安全原因，在一些系统比如 Debian、Ubuntu、GGentoo 和 OSX 上默认情况下禁用）。 为了启用该特性，打开 .vimrc 文件（位于 home 目录），然后加入下面一行内容： 1 set modeline 现在，无论何时你在该文件输入一个制表符然后保存时（文件中已输入 expandtab 模式行命令的前提下），都会被自动转换为空格。 让我们考虑另一个用例。假设在 Vim 中， 制表符默认设置为 4 个空格，但对于某个特殊的文件，你想把它增加到 8 个。对于这种情况，你需要在文件的开头或末尾加上下面这行内容： 1 // vim: noai:ts=8: 现在，输入一个制表符，你会看到，空格的数量为 8 个。 你可能已经注意到我刚才说的，这些模式行命令需要加在靠近文件的顶部或底部。如果你好奇为什么是这样，那么理由是该特性以这种方式设计的。下面这一行（来自 Vim 官方文件）将会解释清楚： “模式行不能随意放在文件中的任何位置：它需要放在文件中的前几行或最后几行。modelines 变量控制 Vim 检查模式行在文件中的确切位置。请查看 :help modelines 。默认情况下，设置为 5 行。” 下面是 :help modelines 命令（上面提到的）输出的内容： 如果 modeline 已启用并且 modelines 给出了行数，那么便在相应位置查找 set 命令。如果 modeline 禁用或 modelines 设置的行数为 0 则不查找。 尝试把模式行命令置于超出 5 行的范围（距离文件底部和顶部的距离均超过 5 行），你会发现， 制表符将会恢复为 Vim 默认数目的空格 — 在我的情况里是 4 个空格。 然而，你可以按照自己的意愿改变默认行数，只需在你的 .vimrc 文件中加入下面一行命令 1 set modelines=[新值] 比如，我把值从 5 增加到了 10 。 1 set modelines=10 这意味着，现在我可以把模式行命令置于文件前 10 行或最后 10 行的任意位置。 继续，无论何时，当你在编辑一个文件的时候，你可以输入下面的命令（在 Vim 编辑器的命令模式下输入）来查看当前与命令行相关的设置以及它们最新的设置。 1 :verbose set modeline? modelines? 比如，在我的例子中，上面的命令产生了如下所示的输出： 1234 modeline Last set from ~/.vimrcmodelines=10 Last set from ~/.vimrc 关于 Vim 的模式行特性，你还需要知道一些重要的点： 默认情况下，当 Vim 以非兼容（nocompatible）模式运行时该特性是启用的，但需要注意的是，在一些发行版中，出于安全考虑，系统的 vimrc 文件禁用了该选项。 默认情况下，当以 root 权限编辑文件时，该特性被禁用（如果你是使用 sudo 方式打开该文件，那么该特性依旧能够正常工作）。 通过 set 来设置模式行，其结束于第一个冒号，而非反斜杠。不使用 set，则后面的文本都是选项。比如，/* vim: noai:ts=4:sw=4 */ 是一个无效的模式行。 （LCTT译注：关于模式行中的 set，上述描述指的是：如果用 set 来设置，那么当发现第一个 : 时，表明选项结束，后面的 */ 之类的为了闭合注释而出现的文本均无关；而如果不用 set 来设置，那么以 vim: 起头的该行所有内容均视作选项。 ） 安全考虑 令人沮丧的是， Vim 的模式行特性可能会造成安全性问题。事实上，在过去，已经报道过多个和模式行相关的问题，包括 shell 命令注入，任意命令执行和无授权访问等。我知道，这些问题发生在很早的一些时候，现在应该已经修复好了，但是，这提醒了我们，模式行特性有可能会被黑客滥用。 结论 模式行可能是 Vim 编辑器的一个高级命令，但是它并不难理解。毫无疑问，它的学习曲线会有一些复杂，但是不需多问也知道，该特性是多么的有用。当然，出于安全考虑，在启用并使用该选项前，你需要对自己的选择进行权衡。 你有使用过模式行特性吗？你的体验是什么样的？记得在下面的评论中分享给我们。 via: https://www.howtoforge.com/tutorial/vim-modeline-settings/ 作者：Ansh译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"向 Linus Torvalds 学习让编出的代码具有 “Good Taste”","date":"2017-05-14T09:18:20.000Z","path":"2017/05/14/Linus's-Coding-Preference-of-Good-Tastes/","text":"在最近关于 Linus Torvalds 的一个采访中，这位 Linux 的创始人，在采访过程中大约 14:20 的时候，提及了关于代码的 “good taste”。good taste？采访者请他展示更多的细节，于是，Linus Torvalds 展示了一张提前准备好的插图。 他展示的是一个代码片段。但这段代码并没有 “good taste”。这是一个具有 “poor taste” 的代码片段，把它作为例子，以提供一些初步的比较。 这是一个用 C 写的函数，作用是删除链表中的一个对象，它包含有 10 行代码。 他把注意力集中在底部的 if 语句。正是这个 if 语句受到他的批判。 我暂停了这段视频，开始研究幻灯片。我发现我最近有写过和这很像的代码。Linus 不就是在说我的代码品味很差吗？我放下自傲，继续观看视频。 随后， Linus 向观众解释，正如我们所知道的，当从链表中删除一个对象时，需要考虑两种可能的情况。当所需删除的对象位于链表的表头时，删除过程和位于链表中间的情况不同。这就是这个 if 语句具有 “poor taste” 的原因。 但既然他承认考虑这两种不同的情况是必要的，那为什么像上面那样写如此糟糕呢？ 接下来，他又向观众展示了第二张幻灯片。这个幻灯片展示的是实现同样功能的一个函数，但这段代码具有 “goog taste” 。 原先的 10 行代码现在减少为 4 行。 但代码的行数并不重要，关键是 if 语句，它不见了，因为不再需要了。代码已经被重构，所以，不用管对象在列表中的位置，都可以运用同样的操作把它删除。 Linus 解释了一下新的代码，它消除了边缘情况，就是这样。然后采访转入了下一个话题。 我琢磨了一会这段代码。 Linus 是对的，的确，第二个函数更好。如果这是一个确定代码具有 “good taste” 还是 “bad taste” 的测试，那么很遗憾，我失败了。我从未想到过有可能能够去除条件语句。我写过不止一次这样的 if 语句，因为我经常使用链表。 这个例子的意义，不仅仅是教给了我们一个从链表中删除对象的更好方法，而是启发了我们去思考自己写的代码。你通过程序实现的一个简单算法，可能还有改进的空间，只是你从来没有考虑过。 以这种方式，我回去审查最近正在做的项目的代码。也许是一个巧合，刚好也是用 C 写的。 我尽最大的能力去审查代码，“good taste” 的一个基本要求是关于边缘情况的消除方法，通常我们会使用条件语句来消除边缘情况。你的测试使用的条件语句越少，你的代码就会有更好的 “taste” 。 下面，我将分享一个通过审查代码进行了改进的一个特殊例子。 这是一个关于初始化网格边缘的算法。 下面所写的是一个用来初始化网格边缘的算法，网格 grid 以一个二维数组表示：grid[行][列] 。 再次说明，这段代码的目的只是用来初始化位于 grid 边缘的点的值，所以，只需要给最上方一行、最下方一行、最左边一列以及最右边一列赋值即可。 为了完成这件事，我通过循环遍历 grid 中的每一个点，然后使用条件语句来测试该点是否位于边缘。代码看起来就是下面这样： 12345678910111213141516 for (r = 0; r &lt; GRID_SIZE; ++r) &#123; for (c = 0; c &lt; GRID_SIZE; ++c) &#123; // Top Edge if (r == 0) grid[r][c] = 0; // Left Edge if (c == 0) grid[r][c] = 0; // Right Edge if (c == GRID_SIZE - 1) grid[r][c] = 0; // Bottom Edge if (r == GRID_SIZE - 1) grid[r][c] = 0; &#125;&#125; 虽然这样做是对的，但回过头来看，这个结构存在一些问题。 复杂性 — 在双层循环里面使用 4 个条件语句似乎过于复杂。 高效性 — 假设 GRID_SIZE 的值为 64，那么这个循环需要执行 4096 次，但需要进行赋值的只有位于边缘的 256 个点。 用 Linus 的眼光来看，将会认为这段代码没有 “good taste” 。 所以，我对上面的问题进行了一下思考。经过一番思考，我把复杂度减少为包含四个条件语句的单层 for 循环。虽然只是稍微改进了一下复杂性，但在性能上也有了极大的提高，因为它只是沿着边缘的点进行了 256 次循环。 1234567891011121314 for (i = 0; i &lt; GRID_SIZE * 4; ++i) &#123; // Top Edge if (i &lt; GRID_SIZE) grid[0][i] = 0; // Right Edge else if (i &lt; GRID_SIZE * 2) grid[i - GRID_SIZE][GRID_SIZE - 1] = 0; // Left Edge else if (i &lt; GRID_SIZE * 3) grid[i - (GRID_SIZE * 2)][0] = 0; // Bottom Edge else grid[GRID_SIZE - 1][i - (GRID_SIZE * 3)] = 0;&#125; 的确是一个很大的提高。但是它看起来很丑，并不是易于阅读理解的代码。基于这一点，我并不满意。 我继续思考，是否可以进一步改进呢？事实上，答案是 YES！最后，我想出了一个非常简单且优雅的算法，老实说，我不敢相信我会花了那么长时间才发现这个算法。 下面是这段代码的最后版本。它只有一层 for 循环并且没有条件语句。另外。循环只执行了 64 次迭代，极大的改善了复杂性和高效性。 1234567891011 for (i = 0; i &lt; GRID_SIZE; ++i) &#123; // Top Edge grid[0][i] = 0; // Bottom Edge grid[GRID_SIZE - 1][i] = 0; // Left Edge grid[i][0] = 0; // Right Edge grid[i][GRID_SIZE - 1] = 0;&#125; 这段代码通过每次循环迭代来初始化四条边缘上的点。它并不复杂，而且非常高效，易于阅读。和原始的版本，甚至是第二个版本相比，都有天壤之别。 至此，我已经非常满意了。 那么，我是一个有 “good taste” 的开发者么？ 我觉得我是，但是这并不是因为我上面提供的这个例子，也不是因为我在这篇文章中没有提到的其它代码……而是因为具有 “good taste” 的编码工作远非一段代码所能代表。Linus 自己也说他所提供的这段代码不足以表达他的观点。 我明白 Linus 的意思，也明白那些具有 “good taste” 的程序员虽各有不同，但是他们都是会将他们之前开发的代码花费时间重构的人。他们明确界定了所开发的组件的边界，以及是如何与其它组件之间的交互。他们试着确保每一样工作都完美、优雅。 其结果就是类似于 Linus 的 “good taste” 的例子，或者像我的例子一样，不过是千千万万个 “good taste”。 你会让你的下个项目也具有这种 “good taste” 吗？ via: https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a 作者：Brian Barto译者：ucasFL校对：wxy 本文由 LCTT 组织编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"图-Part3","date":"2017-05-11T08:50:36.000Z","path":"2017/05/11/Graph-Part3/","text":"最小生成树:克鲁斯卡尔 (Kruskal) 算法 先构造一个只含 n 个顶点的子图 SG ,然后从权值最小的边开始,若添加该边不会使得 SG 中产生回路,则在 SG上加上这条边。如此重复,直至加上 n-1条边为止。 贪心原则:根据权值,从小到大依次尝试各边。 具体描述： 设 G=(V, E) 是具有 n 个顶点的连通网,现要构造 G 的最小生成树 T=(U, TE) – 初始时: U=V , TE={}– 对 G 中的边按权值大小从小到大排序– 选取权值最小的边 (vi , vj )– 若边 (vi , vj ) 加入到 TE 后形成回路,则舍弃该边;否则,将该边并入到 TE 中,即 TE=TE ∪ {(vi , vj )}– 重复前一步骤,直到 TE 中包含有 n-1 条边为止 贪心策略 – 局部最优,但不一定能达到全局最优– 但在拟阵上实施贪心策略,就能实现最优解 算法实现的关键：回路的检测。解决办法：定义一个一维数组Vset[n]。 – 初值: vSet[i]=i ,表示每个顶点各自组成一个连通分量,连通分量的编号简单地使用顶点在图中的位置 ( 编号 )– 往 TE 中增加一条边 (vi , vj) 之前,先检查 vSet[i] 和 vSet[j] 值 若 vSet[i]=vSet[j] ,则表明 vi 和 vj 处在同一个连通分量中,加入此边会形成回路 若 vSet[i]≠vSet[j] ,则加入此边不会形成回路,故将此边加入到生成树的边集中 加入一条新边后,将两个不同的连通分量合并:将一个 连通分量的编号换成另一个连通分量的编号 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940 typedef int ElemType;typedef struct Enode&#123; int ivex , jvex; // 边所依附的两个顶点 int weight; // 边的权值&#125; ENode; // 边表元素类型定义typedef struct &#123; int vexnum , edgenum; // 顶点数和边数 ElemType vexlist[MAX_VEX]; // 顶点表 ENode edgelist[MAX_EDGE]; // 边表&#125; EGraph; // 用边表存放图typedef struct MSTEdge&#123; int vex1,vex2,weight; // 边所依附的两个顶点及权重&#125; MSTEdge; // 存放最小生成树MSTEdge *Kruskal (EGraph *g)&#123; int i,j,k,s1,s2; MSTEdge *TE; int *vSet; TE=(MSTEdge *)malloc(g-&gt;vexnum*sizeof(MSTEdge)); vSet=(int *)malloc(g-&gt;vexnum*sizeof(int)); for(i=0;i&lt;g-&gt;vexnum;i++) vSet[i]=i;// 初始化数组 vSet // 对边按权值从小到大排序 BubbleSort(g-&gt;edgelist,g-&gt;edgenum); i=0;j=0; while(i&lt;g-&gt;vexnum &amp;&amp; j&lt;g-&gt;edgenum) &#123; s1=vSet[g-&gt;edgelist[j].ivex]; s2=vSet[g-&gt;edgelist[j].jvex]; // 若边的两个顶点的连通分量编号不同 , // 则将该边加入到 TE 中 if(s1!=s2) &#123; TE[i].vex1=g-&gt;edgelist[j].ivex; TE[i].vex2=g-&gt;edgelist[j].jvex;+ TE[i].weight=g-&gt;edgelist[j].weight; i++; for(k=0;k&lt;g-&gt;vexnum;k++) if(vSet[k]==s2) vSet[k]=s1; &#125; j++; &#125; free(vSet); return TE;&#125; 算法改进： 回路检测 – 边的加入,会形成多颗树– 为每棵树各选出一个 leader– 每个顶点设指针 parent– 沿 parent 可以找到对应的 leader– leader.parent = 该子树的结点个数– 在引入新边 e =(u,v) 时:– 由 u, v 的 parent 找到并比较 leader(u) 和 leader(v)– e 的引入形成回路 iff leader(u) = leader(v) 未形成回路时的子树合并 1234 if(leader(u).parent &gt; leader(v).parent) leader(u).parent=leader(v);else leader(v).parent =leader(u) Kruskal 算法的时间复杂度 设带权连通图有 n 个顶点和 e 条边 则算法的主要执行是: – vSet 数组初始化:时间复杂度是 O(n)– 边表按权值排序:若采用堆排序或快速排序,时间复杂度是O(eloge)– 回路检测和连通分量合并 while 循环:最大执行频度是 O(n) ,其中包含修改 vSet 数组,共执行 n-1 次,时间复杂度是 O(n^2 ) 优化后,时间复杂度是 O(e) 若将生成树 T 的连通分量看成等价类,则构造 T 加入新边的过程类似求等价类 整个算法的时间复杂度是 O(eloge+n^2 ) ,优化后, Kruskal 算法的时间复杂度为 O(eloge) 独立系统和拟阵 有限集 E 的一个子集簇 F ,若具有如下的性质:对于 F 中的任一个元素 E ,当 S 是 Ei 的子集时 S 也是 F 中的元素,即 S ⊆ Ei ∈ F ==&gt; S ∈ F,则 F 称为独立系统,其元素为独立集。 — 在独立系统上定义的组合优化问题,称为最优独立集问题,例如求最小生成树,最优边无关集。 拟阵是指一个独立系统 F 满足下列可扩充条件:对任意两个独立集 I 、 I’ ,若 I’ 中的元素个数大于 I 的元素个数,则 I’ 中必存在一个不属于 I 的元素 e 使得将 e 加入 I 时,它仍是一个独立集。 贪心算法能求得最优独立集的充分必要条件是该独立系统是一个拟阵。 定理:如果 G=(V,E) 是一个无向图,则是个拟阵,其中集合为 E ,即 G 的边集,为无回路的 E 的子集。 用贪心算法求解拟阵的组合优化问题,能获得最优解。 Prim 算法和 Kruskal 算法的简单描述： Prime 算法：选定一个顶点，然后添加与它相连的最小权值边，加上新的顶点，再继续选与这两个顶点相连权值最小的边，一直进行下去，直到有 n-1 条边。 Kruskal 算法：选边，从权值最小的往上选，确保不形成回路（贪心算法）。 图的路径 关键路径 / 最长路径:有向无环带权图 /AOE 网 最短路径: 带权有向图 ( 权非负 ) ,求单源最短路径: Dijkstra 算法 带权图,求所有顶点之间的最短路径: Floyd算法 路径 对无向图 G=(V, E) ,若从顶点 vi 经过若干条边能到达 vj ,称顶点 vi 和 vj 是连通的,又称顶点 vi到 vj 有路径 对有向图 G=(V, E) ,从顶点 vi 到 vj 有有向路径,指的是从顶点 vi 经过若干条有向边 (弧) 能到达 vj 路径上边或有向边 ( 弧 ) 的数目称为该路径的长度 从顶点 vi 到 vj 的路径不唯一 两种路径表示法:边 / 弧的序列,结点序列– Path=ei0, ei1, …eim , eij属于E, j=1,2, …,m– Path=vi0, vi1, …vim , vij属于V 且 (vij-1 , vij 属于 E, j=1,2, …,m 在一条路径中,若没有重复相同的顶点,该路径称为简单路径 (simple path) 第一个顶点和最后一个顶点相同的路径称为回路 (circuit, 环 cycle) 在一个回路中,若除第一个与最后一个顶点之外,其余顶点不重复出现的回路称为简单回路。 欧拉路径 (Euler path) :若图 G 中存在这样一条简单路径,使得它恰好通过 G 中的每条边一次。 欧拉回路 (Euler circuit) :若欧拉路径的第一个顶点和最后一个顶点相同。 哈密顿路径 (Hamilton path) :通过图 G 的每个结点一次,且仅一次的简单路径。 哈密顿回路：第一个顶点和最后一个顶点相同的哈密顿路径 有向无环带权图 /AOE 网的关键路径 AOE(Activity On Edge) 网是一个顶点表示事件 (Event) 、弧表示活动(Activity) 的有向无环图, 弧上的权值表示相应活动所需的时间 (Duration) 或费用。 只有一个入度为 0 的点 ( 称为起点 ) 和一个出度为 0 的点( 称为汇点 ) 每个事件表示在其前的所有活动已经完成,其后的活动可以开始 在 AOE 网上从起点到汇点的长度最长的路径,是关键路径 (Critical Path) — 关键路径的长度表示完成整个工程所需的最短时间— 关键活动:关键路径上的活动— 关键活动若不按期完成,就会影响整个工程的完成— 非关键活动加速并不能使整个工程提前。想使整个工程提前,要考虑关键路径上的关键活动 顶点 ( 事件 ) 的最早发生时间 ve 是从起点到该顶点的最长路径长度 汇点的最早发生时间是最短工期 顶点 ( 事件 ) 的 ( 不影响工程进度的 ) 最迟发生时间 vl 是从汇点最早发生时间减去该顶点到汇点的最长路径长度。 起点的最早发生时间等于其最迟发生时间 汇点的最早发生时间等于其最迟发生时间 对弧 ( 活动 ) ,其弧头的最迟发生时间减去弧尾的最早发生时间是该活动最长可持续时间,再减去弧权,为这个弧 ( 活动 ) 允许的延时 D 。 识别关键活动： 利用拓扑排序计算图 g 的一个拓扑序列 从拓扑排序序列的第一个顶点 ( 起点 ) 开始,按拓扑顺序依次计算每个顶点 ( 事件 ) 的最早发生时间ve(i) 有向网 g 采用邻接表存储结构,若 g 无回路,则用栈 T 返回 g 的一个拓扑序列, ve 中保存各顶点事件的最早发生时间 按拓扑顺序的逆序,从最后一个顶点 ( 汇点 ) 开始,依次计算每个事件的最迟发生时间 vl(i) 找出 vl(i) - ve(i) == 0 的点 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 typedef int Status;#define OK 1#define ERROR 0Status TopologicalOrder(AGraph *g, char orderResult[],int ve[]) &#123; for(i=0;i&lt;MAX_VERTEX_NUM;i++) indegree[i]=0; FindIndegree(g,indegree); for(i=g-&gt;vexnum-1;i&gt;=0;i--) if(indegree[i]==0) &#123; // 入度为 0 者进栈 stack[top]=i; top++; &#125; for(i=0;i&lt;g-&gt;vexnum;i++) ve[i]=0; count=0; // 对输出顶点计数 while(top!=0)&#123; top--;i=stack[top]; orderResult[count]=g-&gt;v[i].vertex; count++; for(p=g-&gt;v[i].first;p;p=p-&gt;next)&#123; // 弧 ij j=p-&gt;vindex;// 对 i 号顶点的每个邻接点的入度减 1 if(--indegree[j]==0)&#123;// 若入度减为 0 ,则入栈 stack[top]=j; top++; &#125; if(ve[j]&lt;ve[i] + p-&gt;info) ve[j]=ve[i]+ p-&gt;info; &#125; &#125; if(count&lt;g-&gt;vexnum) return ERROR;// 该图有回路 else return OK; &#125;Status CriticalPath(AGraph *g) &#123; if (!TopologicalOrder(g, orderedV, ve)) return ERROR;// 初始化顶点事件的最迟发生时间 for(i=0;i&lt;g-&gt;vexnum;i++) vl[i] = ve[g-&gt;vexnum-1]; // 按拓扑逆序求各顶点的 vl 值 top=g-&gt;vexnum; while (top) for(top--,j=orderedV[top]-'A',p=g-&gt;v[j].first;p; p=p-&gt;next) &#123; k=p-&gt;vindex; dut=p-&gt;info; //dut&lt;j,k&gt; if (vl[j]&gt;vl[k]-dut) vl[j]=vl[k]-dut; &#125; for (j=0; j&lt;g-&gt;vexnum; ++j) // 求 ee, el 和关键路径 for (p=g-&gt;v[j].first; p; p=p-&gt;next)&#123; k=p-&gt;vindex; dut=p-&gt;info; ee = ve[j]; el = vl[k]-dut; tag = (ee==el) ? '*' : ' '; if(tag=='*') printf(\"%c %c \\n\",'A'+j, 'A'+k); &#125; return OK;&#125; 算法分析： 设 AOE 网有 n 个事件, e 个活动,则算法的主要执行是:– 进行拓扑排序:时间复杂度是 O(n+e)– 求每个事件的 ve 值和 vl 值:时间复杂度是 O(n+e)– 根据 ve 值和 vl 值找关键活动:时间复杂度是 O(n+e) 整个算法的时间复杂度是 O(n+e) 最短路径 边上权值非负情形的单源最短路径问题 – Dijkstra 算法 边上权值为任意值的所有顶点之间的最短路径 – Floyd 算法 Dijkstra 算法 对于给定的有向图 G=(V , E) 及单个源点 Vs求 Vs 到 G 的其余各顶点的最短路径。Dijkstra 算法按路径长度递增次序产生最短路径。 最短路径：直接从源点到该点 ( 只含一条弧 ) ; 或者是,从源点经过已求得最短路径的顶点,再到达该顶点。 就同一个起点而言,任何最短路径的前缀,也是一条最短路径。 算法思想 -Dijkstra 算法： S 是已求得最短路径的终点的集合 定义一个数组 dist[n] ,其每个 dist[i] 分量保存从源点 V0 出发中间只经过集合 S 中的顶点而到达 Vi 的所有路径中长度最小的路径长度值,换句话说, dist[] 保存了当前已求得的从源点到其余各顶点的最短路径值 – 初始状态:• 若从 V0 到顶点 Vi 有边 , 则 dist[i] 为该边的权值• 若从 V0 到顶点 Vi 无边 , 则 dist[i] 为INFINITY 下一条最短路径的终点 Vj 必定是不在 S 中且是 dist 数组值最小的顶点 算法实现： 有向图用带权的邻接矩阵表示 数组 final[n] 用于标识一个顶点是否已加入S 中。 final[v] 为 1 当且仅当 v ∈ S ,即:已经求得从 v0 到 v 的最短路径 用二维数组 P 保存从 v0 顶点到其余顶点 v 的最短路径 123456789101112131415161718192021222324252627282930313233343536 // 求有向网 G 的 v0 顶点到其余顶点 v 的最短路径 P[v][] 及其带权长度 dist[v]void ShortestPath_DIJ(MGraph *g,int v0,PathMatrix &amp;P, int dist[]) &#123; int i=0,j, v,w,min; int final[MAX_VERTEX_NUM]; for (v=0; v&lt;g-&gt;vexnum; v++) &#123;// 初始化 final[v] = 0; dist[v] = g-&gt;arcs[v0][v]; for (w=0; w&lt;g-&gt;vexnum; w++) P[v][w] = 0; // 设空路径 if (dist[v] &lt; INFINITY) &#123; P[v][v0] = 1; P[v][v] = 1; &#125; &#125; dist[v0] = 0; final[v0] = 1; // 初始化, v0 顶点属于 S 集1// 主循环:每次求得 v0 到某个 v 顶点的最短路径并加 v 到 S 集 for (i=1; i&lt;g-&gt;vexnum; i++) &#123; // 其余 g-&gt;vexnum-1 个顶点 min = INFINITY; // 当前所知离 v0 顶点的最近距离 for (w=0; w&lt; g-&gt;vexnum; w++) if (!final[w]) //w 顶点在 V-S 中 if (dist[w]&lt;min) // w 顶点离 v0 顶点更近 &#123; v = w; min = D[w]; &#125; final[v] = 1; // 离 v0 顶点最近的 v 加入 S 集 // 更新当前最短路径及距离 for (w=0; w&lt;g-&gt;vexnum; w++) if (!final[w]&amp;&amp;(min+g-&gt;arcs[v][w] &lt;dist[w])) &#123; // 修改 dist[w] 和 P[w], w ∈ V-S dist[w] = min + g-&gt;arcs[v][w];+ for(j=0;j&lt;g-&gt;vexnum;j++) P[w][j] = P[v][j]; // 第 v 行赋值于第 w 行 P[w][w] = TRUE; // P[w] = P[v]+[w] &#125;//if &#125;//for&#125; //ShortestPath_DIJ Dijkstra 算法 - 算法分析： Dijkstra 算法的主要执行是: – 数组变量的初始化:时间复杂度是 O(n)– 求最短路径的二重循环:时间复杂度是 O(n^2) 因此,整个算法的时间复杂度是 O(n^2) Floyd 算法 求得有向图 G=(V ,E) 中每一对顶点间的最短路径： 时间复杂度仍是 O(n^3 ) 允许图中有带负权值的边,但不许有包含带负权值的边组成的回路 Floyd 算法 - 算法思想: Vi 和 Vj 之间的最短路径可能是: – 不存在通路– 直接相连– 最短路径 (Vi,Vk) + (Vk,Vj) D^K (Vi,Vj) 为中途只经过前 k 个顶点的最短路径长度 D^K (Vi,Vj)= Wij, k=0=min(D k-1 (Vi,Vj),D k-1 (Vi,Vk)+D k-1 (Vk,Vj)), k&gt;=1 设顶点集 S( 初值为空 ) ,用数组 D 的每个元素D[i][j] 保存从 Vi 只经过 S 中的顶点到达 Vj 的最短路径长度,其思想是:– 初始时令 S={ } , D[i][j] 的赋初值方式是:if i ==j:D[i][j]=0 ,else if exists PATH:D[i][j]=Wij, else:D[i][j]=INFINITY – 将图中一个顶点 V k 加入到 S 中,修改 D[i][j] 的值D[i][j]=Min ({D[i][j] , (D[i][k]+D[k][j]) })– 原因:从 Vi 经过 S 中的顶点 (Vk ) 到达 V-j 的路径长度可能比原来不经过 Vk 的路径更短– 重复上一步,直到 G 的所有顶点都加入到 S 中为止 算法实现： 12345678910111213141516171819202122 // 用 Floyd 算法求有向网 G 中各对顶点 v 和 w 之间的最短路径P[v][w] 及其带权长度 D[v][w] 。若 P[v][w][u] 为 TRUE ,则 u 是从 v 到 w 当前求得最短路径上的顶点void ShortestPath_FLOYD(MGraph G, PathMatrix P[], DistancMatrix &amp;D) &#123; int v,w,u,i; // 各对结点之间初始化已知路径及距离 for (v=0; v&lt;G.vexnum; ++v) for (w=0; w&lt;G.vexnum; ++w) &#123; D[v][w] = G.arcs[v][w]; for (u=0; u&lt;G.vexnum; ++u) P[v][w][u] = FALSE; if (D[v][w] &lt; INFINITY) &#123; // 从 v 到 w 有直接路径 P[v][w][v] = P[v][w][w] = TRUE; &#125;//if &#125;//for for (u=0; u&lt;G.vexnum; ++u) for (v=0; v&lt;G.vexnum; ++v) for (w=0; w&lt;G.vexnum; ++w) if (D[v][u]+D[u][w] &lt; D[v][w]) &#123; // 从 v 经 u 到 w 的一条路径更短 D[v][w] = D[v][u]+D[u][w]; for (i=0; i&lt;G.vexnum; ++i) P[v][w][i] =(P[v][u][i] || P[u][w][i]); &#125;//if&#125; // ShortestPath_FLOYD Floyd 算法 - 算法改进: 定义二维数组 Path[n][n](n 为图的顶点数 ) ,元素Path[i][j]保存从 Vi 到 Vj 的最短路径所经过的顶点 若 Path[i][j]=k :从 Vi 到 Vj 经过 Vk ,最短路径序列是 (Vi , …, Vk , …, Vj ) ,则路径子序列: (Vi ,…, Vk ) 和 (Vk , …, Vj ) 一定是从 Vi 到 Vk 和从 Vk 到 Vj的最短路径,从而可以根据 Path[i][k] 和 Path[k][j] 的值再找到该路径上所经过的其它顶点,… 依此类推: – 初始化为 Path[i][j]=-1 ,表示从 Vi 到 Vj 不经过任何 (S 中的中间 ) 顶点。当某个顶点 Vk 加入到 S 中后使 D[i][j] 变小时,令 Path[i][j]=k var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"图-Part2","date":"2017-05-11T08:32:48.000Z","path":"2017/05/11/Graph-Part2/","text":"图的结点排序:拓扑排序 拓扑排序 (Topological Sort) :由某个集合上的一个偏序得到该集合上的一个全序的操作。 集合上的关系:集合 A 上的关系是从 A 到 A 的关系(A x A)。 自反性 对称性与非对称性 传递性 偏序是指集合中仅有部分元素之间可以比较,而全序是指集合中任意两个元素之间都可以比较。 可以用有向无环图 (Directed Acycling Graph)表示集合元素以及元素之间的关系。DAG :图中没有回路 ( 环 ) 的有向图 AOV 网 (Activity On Vertex Network) :在有向图中,用顶点表示活动,用有向边表示活动之间的优先关系。 DAG/AOV 网的拓扑排序：DAG/AOV 网的拓扑排序:构造 AOV 网中顶点的一个拓扑线性序列 (v’1 ,v’2 , ⋯ ,v’n ) ,使得该线性序列不仅保持原来有向图中顶点之间的优先关系,而且对原图中没有优先关系的顶点之间也建立一种 ( 人为的 ) 优先关系。 拓扑排序算法 在 AOV 网中选择一个没有前驱的顶点并输出 注：选择不同的顶点,会产生不同的拓扑排序结果 在 AOV 网中删除该顶点以及从该顶点出发的 ( 以该顶点为尾的弧 ) 所有有向弧 ( 边 ) 重复执行前两步,直到图中全部顶点都已输出 ( 图中无环 ) 或图中不存在无前驱的顶点 ( 图中必有环 ). 算法实现： 采用正邻接链表作为 AOV 网的存储结构 设立堆栈,用来暂存入度为 0 的顶点 ( 即无前驱顶点 ) 删除以该顶点为尾的弧:弧头顶点的入度减 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 typedef int Status;#define OK 1#define ERROR 0//结点入度值的计算和保存//方案 1 :typedef struct node &#123; int vindex; // 邻接点在头结点数组中的位置 ( 下标 ) int count; // 记录该结点的入度 struct node *next;// 指向下一个表结点&#125;NodeLink; // 表结点类型定义//方案 2 :int indegree[MAX_VERTEX_NUM]; // 存放顶点的入度void FindIndegree(AGraph *g,int indegree[MAX_VERTEX_NUM])&#123; NodeLink *p; for(int i=0;i&lt;g-&gt;vexnum;i++)&#123; p=g-&gt;v[i].first; while(p) &#123; indegree[p-&gt;vindex]++; p=p-&gt;next; &#125; &#125;&#125;//栈,用于存放零入度顶点char stack[MAX_VERTEX_NUM];int top=0;Status TopologicalSort(AGraph *g) &#123; NodeLink *p; for(i=0;i&lt;MAX_VERTEX_NUM;i++) indegree[i]=0; FindIndegree(g,indegree); for(i=g-&gt;vexnum-1;i&gt;=0;i--) //for(i=0;i&lt;g-&gt;vexnum;i++) if(indegree[i]==0) &#123; // 入度为 0 者进栈 top++; stack[top]=i; &#125; count=0; // 对输出顶点计数 while(top!=0)&#123; i=stack[top]; top--; printf(\"%c\",g-&gt;v[i].vertex); count++;+ for(p=g-&gt;v[i].first;p;p=p-&gt;next)&#123; j=p-&gt;vindex; // 对 i 号顶点的每个邻接点的入度减 1 if(--indegree[j]==0)&#123; // 若入度减为 0 ,则入栈 top++; stack[top]=j; &#125; &#125; &#125; if(count&lt;g-&gt;vexnum) return ERROR; // 该图有回路 else return OK;&#125; 拓扑排序:算法时间复杂度分析 设 AOV 网有 n 个顶点, e 条边,则算法的主要执行是:– 统计各顶点的入度:时间复杂度是 O(n+e) ;– 入度为 0 的顶点入栈:时间复杂度是 O(n) ;– 排序过程:顶点入栈和出栈操作执行 n 次,入度减 1 的操作共执行 e 次,时间复杂度是 O(n+e) ;因此,整个算法的时间复杂度是 O(n+e) 。 拓扑排序应用： 应用 1 :图的回路 ( 环 ) 的检查方法:对有向图的顶点进行拓扑排序,若所有顶点都在其拓扑有序序列中,则无环。 应用 2 :工程执行顺序 / 课程先修顺序:对 AOV 网的顶点进行拓扑排序。 图的连通性 对无向图 G=(V , E) ,若任意vi , vj 属于V , vi和 vj 都是连通的 ( 指从 vi 到 vj 有路径存在 ),则称图 G 是连通图 (connected graph) ,否则称为非连通图。 对有向图 G=(V , E) ,若任意 vi , vj 属于V ,都有以 vi 为起点, vj 为终点以及以 vj 为起点, vi 为终点的有向路径,称图 G 是强连通图(strongly connected graph) ,否则称为非强连通图。 若 G 是非连通图,则极大的连通子图称为G 的连通分量 (connected component)。若 G 是非强连通图,则极大的强连通子图称为 G 的强连通分量 (strongly connected component)“ 极大”的含义:对子图再增加图 G 中的其它顶点,子图就不再连通。极大不等于最大。 生成树：连通图的生成树是一个极小连通子图,它含有图中全部 n 个顶点和只有能构成一棵树的 n-1 条边。 生成森林：有向图的生成森林是这样一个子图,由若干棵有向树组成,含有图中全部顶点,但只有足以构成若干棵不相交有向树的弧。 有向网：带权的有向连通图。 无向网：带权的无向连通图。 重连通图：若从一个连通图中删去任何一个顶点及其相关联的边,它仍为一个连通图的话,则该连通图被称为重 ( 双 ) 连通图 (biconnected graph)。 若连通图中的某个顶点和其相关联的边被删去之后,该连通图被分割成两个或两个以上的连通分量,则称此顶点为关节点 (articulation point)/ 割点(cut point)。 没有关节点的连通图为重连通图。 无向图的连通分量 对于无向图,对其进行遍历时: 若是连通图,仅需从图中任一顶点出发,就能访问图中的所有顶点。 若是非连通图,需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是这个连通分量的顶点集。 无向非连通图的生成森林 若 G=(V,E) 是无向非连通图,那么,对图进行遍历,可得到若干个连通分量的顶点集: V1(G), V2(G),…, Vn(G) 和相应所经过的边集: T1(G), T2(G), …, Tn(G)上述顶点集和对应的边集组成的二元组 Gi=(Vi(G),Ti(G))(1 &lt;= i &lt;= n) 是对应的图的连通分量的生成树,所有这些生成树构成了原来非连通图的生成森林。 求无向非连通图的生成森林 构造无向非连通图的深度优先生成森林算法 – 修改图的深度优先遍历算法– 采用孩子兄弟链表作为生成森林的存储结构 从某个顶点出发构造图的深度优先生成树算法 – 首先从某个顶点 V 出发,建立生成树树根结点,然后再分别以 V 的邻接点为始点,建立相应的子生成树,并将其作为 V 结点的子树链接到 V 结点上。– 算法是一个递归算法。 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 #define MAX_VERTEX_NUM 30typedef char ElemType;typedef struct node &#123; int vindex; // 邻接点在头结点数组中的位置 ( 下标 ) struct node *next;// 指向下一个表结点&#125;node, NodeLink; // 表结点类型定义typedef struct &#123; int vexnum,edgenum,kind; // 图的顶点数、边数、种类标志 struct &#123; ElemType vertex; NodeLink *first;// 指向第一个表结点 &#125;v[MAX_VERTEX_NUM];&#125;AGraph;typedef struct cstree &#123; ElemType data; struct CSNode *firstchild,*nextsibling;&#125;CSNode, *CSTree;CSTree DFSForest(AGraph *g) &#123; int i; CSTree p,q,t; t=NULL; for(i=0;i&lt;g-&gt;vexnum;i++) visited[i]=0; for(i=0;i&lt;g-&gt;vexnum;i++) if(!visited[i]) &#123; // 第 i 个顶点为新的生成树的根结点 p=(CSTree)malloc(sizeof(cstree)); // 分配根结点 p-&gt;data=GetVex(g,i);// 给该结点赋值 p-&gt;firstchild=NULL; p-&gt;nextsibling=NULL; if(!t) t=p; //p 是第一棵生成树的根 (t 的根 ) else // 其它生成树的根 , 成为前一棵的根的兄弟 q-&gt;nextsibling=p; q=p;//q 指示当前生成树的根 DFSTree(g,i,p);// 建立以 p 为根的生成树 &#125;//if return t;&#125; // DFSForest// 从第 x 个顶点出发递归地深度优先遍历图 G// 建立以 t 为根的生成树void DFSTree(AGraph *g,int x,CSTree t) &#123; int first=1; CSTree p,q; NodeLink *u; visited[x]=1; u=g-&gt;v[x].first; while(u)&#123; if(!visited[u-&gt;vindex])&#123; // 为 u 生成 生成树 t 的结点 p p= (CSTree)malloc(sizeof(cstree)); p-&gt;data=GetVex(g,u-&gt;vindex); p-&gt;firstchild=NULL;p-&gt;nextsibling=NULL; if(first) &#123; //u 是 x 的第一个未被访问的邻接顶点 t-&gt;firstchild = p; first=0; &#125; else &#123; //u 是 x 的其它未被访问的邻接顶点 // 那么, p 是上一邻接顶点的右兄弟结点 q-&gt;nextsibling= p; &#125; q=p; DFSTree(g,u-&gt;vindex,q); &#125; u=u-&gt;next; &#125;&#125; 有向图的强连通分量 对于有向图,在其每一个强连通分量中,任何两个顶点都是可达的。 任意V属于G ,与 V 可相互到达的所有顶点就是包含 V 的强连通分量的所有顶点。 设从 V 可到达 ( 以 V 为起点的所有有向路径的终点 ) 的顶点集合为 T1(G) ,而到达 V( 以 V 为终点的所有有向路径的起点 ) 的顶点集合为 T2(G) ,则包含 V 的强连通分量的顶点集合是: T1(G)∩T2(G) 。 求有向图 G 的强连通分量的基本步骤: 对 G 进行深度优先遍历,生成 G 的深度优先生成森林 T 对森林 T 的顶点按退出 DFS 函数的顺序进行编号 改变 G 中每一条弧的方向,构成一个新的有向图 G’ 按 (2) 中标出的顶点编号,从编号最大的顶点开始对 G’ 进行深度优先搜索,得到一棵深度优先生成树。若一次完整的搜索过程没有遍历 G’ 的所有顶点,则访问的顶点中选择一个编号最大的顶点,由它开始再进行深度优先搜索,并得到另一棵深度优先生成树。在该步骤中,每一次深度优先搜索所得到的生成树中的顶点就是 G 的一个强连通分量的所有顶点。 重复步骤 (4) ,直到 G’ 中的所有顶点都被访问。 算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //采用十字链表作为存储结构//用数组finished[n]存放顶点序列#define MAX_VERTEX_NUM 30typedef char ElemType;typedef struct ArcBox &#123; int tailvex, headvex;// 尾结点和头结点在图中的位置 //InfoType info;// 与弧相关的信息 如权值 struct ArcBox *hlink, *tlink;// 分别链接弧头相同和弧尾相同的弧&#125;ArcNode; // 弧结点typedef struct VexNode &#123; ElemType data; // 顶点信息 ArcBox *firstin, *firstout;// 分别指向该顶点第一条入弧和出弧&#125;VexNode;// 顶点结点typedef struct &#123; int vexnum, arcnum; VexNode xlist[MAX_VERTEX_NUM];&#125;OLGraph;int visited[MAX_VERTEX_NUM];int finished[MAX_VERTEX_NUM],count;void ConnectedComponent(OLGraph *g) &#123; int i,j,v,k=1; count=0; for(i=0; i&lt;g-&gt;vexnum; i++) visited[i]=0; for(i=0; i&lt;g-&gt;vexnum; i++) if (!visited[i]) DFS(g,i); // 对图 G 正向遍历 for(i=0; i&lt;g-&gt;vexnum; i++) visited[i]=0; for(j=g-&gt;vexnum-1;j&gt;=0;j--) &#123; v=finished[j]; if (!visited[v]) &#123; printf(\"\\n 第 %d 个连通分量顶点 :\", k++); ReverseDFS(g,v); // 对图 G 逆向遍历 printf(\"\\n\"); &#125; &#125;&#125;void DFS(OLGraph *g,int x) &#123;// 按弧的正向搜索 ArcBox *p; visited[x]=1; for(p=g-&gt;xlist[x].firstout; p!=NULL ; p=p-&gt;tlink) if (!visited[p-&gt;headvex]) DFS(g,p-&gt;headvex); finished[count++]=x;&#125;void ReverseDFS(OLGraph *g,int x) &#123;// 对图 G 按弧的逆向进行搜索 ArcBox *p; visited[x]=1; printf(\"%d\",x);// 输出顶点 for(p=g-&gt;xlist[x].firstin; p!=NULL;p=p-&gt;hlink) if(!visited[p-&gt;tailvex]) ReverseDFS(g,p-&gt;tailvex);&#125; 重连通图和关节点 关节点： 需借助图的深度优先生成树来分析：假设从某个顶点 V0 出发对连通图进行深度优先搜索遍历,则可得到一棵深度优先生成树,树上包含图的所有顶点。 若生成树的根结点有两个或两个以上的分支,则此顶点 ( 生成树的根 ) 必为关节点 对生成树上的任意一个内部结点 v( 非叶子结点 ) ,若其某棵子树的根或子树中的其它结点没有和 v 祖先相通的回边,则该结点 v 必为关节点。 对上述判定准则的算法表达：顶点 v 为关节点: 存在顶点 w 是生成树上顶点 v 的孩子,且 W 及其子孙均无指向 v 的祖先的回边 定义: low(v) = Min{visited[v], low[w], visited[k] } 其中 – 顶点 w 是生成树上顶点 v 的孩子– 顶点 k 是生成树上和顶点 v 由回边相联接的祖先– visited 记录深度优先遍历时的访问次序 若对顶点 v ,在生成树上存在一个子树根 w , 且 low[w] ≥ visited[v] ,则顶点 v 为关节点。 修改深度优先遍历算法: visited[v] 的值改为遍历过程中顶点的访问次序,该次序记录在 count 值中 遍历过程中,求得 low[v]=Min{visited[v],low[w],visited[k]} 从子树遍历返回时,判别 low[w] &gt;= visited[v] 123456789101112131415161718192021222324252627282930313233343536373839404142434445 //查找并输出连通图 G 上的全部关节点void FindArticul(AGraph *g) &#123; // 连通图 g 以邻接表作存储结构 // 全局变量 count 对访问计数 int v; struct ArcNode *p; // 设定邻接表上 0 号顶点为生成树的根 count=1; visited[0] = 1; // 其余顶点尚未访问 for (int i=1; i&lt;g-&gt;vexnum; ++i) visited[i] = 0; p = g-&gt;vertices[0].firstarc; if(p) &#123; v = p-&gt;adjvex;// 从第 v 顶点出发深度优先查找关节点 DFSArticul(g, v); if (count &lt; g-&gt;vexnum) &#123; // 生成树的根有至少两棵子树 // 根是关节点,输出 printf (0, g-&gt;vertices[0].data); while (p-&gt;nextarc) &#123; // 寻找还没有访问到的节点 p = p-&gt;nextarc; v = p-&gt;adjvex; if (visited[v]==0) DFSArticul(g, v); &#125;//while &#125;//if &#125;//if(p)&#125; // FindArticulvoid DFSArticul(AGraph *g, int v0 ) &#123; int min, w; struct ArcNode *p;//v0 是第 count 个访问的顶点 visited[v0] = min = ++count; for (p=g-&gt;vertices[v0].firstarc; p!=NULL;p=p-&gt;nextarc) &#123; // 检查 v0 的每个邻接顶点 w = p-&gt;adjvex; // w 为 v0 的邻接顶点 if (visited[w] == 0) &#123; // w 未曾被访问,是 v0 的孩子 DFSArticul(g, w); // 返回前求得 low[w] if (low[w] &lt; min) min = low[w]; // 从子树返回时判断 v0 是否是关节点 if (low[w] &gt;= visited[v0]) // 输出关节点 printf(v0, g-&gt;vertices[v0].data); &#125; else //w 是回边上的顶点 if (visited[w] &lt; min) //w 已被访问, w 是 v0 在生成树上的祖先 min = visited[w]; &#125;//for low[v0] = min;&#125; // DFSArticul 最小生成树 带权连通图 G 上的最小代价生成树。 覆盖 G 中的所有顶点 连通各个顶点但无环 加边的话,出现单环 删边的话,各个顶点不连通 Spanning tree 不唯一 生成树的代价:如果连通图是一个带权图,则其生成树中的边也带权,生成树中所有边的权值 ( 每条边上的权均为大于零的实数 ) 之和称为生成树的代价。– 生成树各边权重之和最小– Minimum Cost Spanning Tree 不唯一 ayley 公式: 连接 n 个互异顶点的树有 n^(n-2)棵;或等价地说, n 阶完全图 kn 有 n^(n-2) 棵生成树 构造最小生成树的基本原则: 尽可能选取权值最小的边 但不能构成回路 选择 n-1 条边 普里姆 (Prim) 算法 逐步添加结点 w , w 要满足:– 新添加的 w 和已经在生成树上的顶点 v 之间存在一条边,该边的权值在所有连通顶点 w 和 v 之间的边中取值最小; 从连通网 N=(U, E) 中找最小生成树 T=(U, TE)– 若从顶点 v0 出发构造, U={v0 } , TE={} ;– 先找权值最小的边 (u, v) ,其中 u ∈ U 且 v ∈ V-U,并且子图 (U, TE) 不构成环,则 U= U ∪ {v} , TE=TE ∪ {(u, v)} ;– 重复前一步,直到 U=V 为止,这时, TE 中必有 n-1 条边, T=(U, TE) 就是最小生成树;+ 算法实现： 设用数组 ( 邻接矩阵 ) 表示图– 若两个顶点之间不存在边,则对应的权值设为指定的最大值 所构造的最小生成树用一维数组存储其 n-1 条边 12345678910111213141516171819202122232425262728293031323334 typedef struct MSTEdge &#123; // 边所依附的图中两个顶点 int vex1, vex2; WeightType weight; // 边的权值&#125;MSTEdge;struct &#123; int adjvex; // 边所依附于 U 中的顶点 int lowcost ; // 该边的权值&#125; closedge[MAX_VERTEX_NUM];//用 Prim 算法从第 u 个顶点出发构造网 G的最小生成树 T ,输出 T 的各条边void MiniSpanTree_PRIM(MGraph G, VertexType u)&#123; int i,j,k; k= LocateVex(G, u); for (j=0; j&lt;G.vexnum; ++j ) &#123; // 辅助数组初始化 if (j!=k) &#123; closedge[j].adjvex=u; closedge[j].lowcost=G.arcs[k][j].adj; &#125; &#125; closedge[k].lowcost = 0; // 初始, U = &#123;u&#125; for (i=1; i&lt;G.vexnum; ++i) &#123; // 选择其余 G.vexnum-1 个顶点添加到生成树上 // 求出加入 T 的下一个结点:第 k 顶点 k = minimum(closedge); // 输出生成树的边,或者保存到 MSTEdge 数组中 printf(closedge[k].adjvex, G.vexs[k]); closedge[k].lowcost = 0; // 第 k 顶点并入 U 集+ for (j=0; j&lt;G.vexnum; ++j) if (G.arcs[k][j].adj &lt; closedge[j].lowcost) &#123; // 修改其它顶点的最小边 closedge[j].adjvex=G.vexs[k]; closedge[j].lowcost=G.arcs[k][j].adj; &#125; &#125;&#125; // MiniSpanTree Prim 算法的时间复杂度分析: 设带权连通图有 n 个顶点,则算法的主要执行是二重循环:– 求 closedge 中权值最小的边,频度为 n-1– 修改 closedge 数组,频度为 n 因此,整个算法的时间复杂度是 O(n^2 ) ,与边的数目无关。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"图-Part1","date":"2017-05-11T08:07:46.000Z","path":"2017/05/11/Graph-Part1/","text":"图 线性结构: 除第一个和最后一个元素外,任何一个元素都有唯一的一个直接前驱和直接后继。 非线性结构： 树结构:每个元素对下 ( 层 ) 可以有 0 个或多个元素相联系,对上 (层) 只有唯一的一个元素相关,数据元素之间有明显的层次关系 图结构:任意两个元素之间可能存在关系,图中任意元素之间都可能相关;结点之间的关系可以是任意的 图的术语 顶点、弧、 子图 (subgraph) 和生成子图 (spanning subgraph) 设有图 G=(V, E) 和 G’=(V’, E’) ,若 V’&lt;=V 且 E’&lt;=E ,则称图 G’ 是 G 的子图;若 V’=V 且 E’&lt;=E ,则称图 G’ 是 G 的一个生成子图。 简单图 (simple graph) :每条边连接两个不同的顶点且没有两条不同的边连接一对相同顶点的图 完全图 (complete graph) :在每对不同顶点之间恰好有一条边的简单图 多重图 (multigraph) :有多重边连接到同一对顶点的图 有向图：顶点之间的弧有序 无向图：顶点之间的弧无序 稀疏图 (sparse graph) :有很少边或弧的图 (e&lt;n log n) 的图,反之称为稠密图 (dense graph) 对于无向图,若图中顶点数为 n ,用 e 表示边的数目,则 e 的范围[0 , n(n-1)/2] 完全图:具有 n(n-1)/2 条边的无向图 对于有向图,若图中顶点数为 n ,用 e 表示弧的数目,则 e的范围[0 , n(n-1)] 完全图:具有 n(n-1) 条边的有向图 权重：与图的边 / 弧相关的数 带权图或网 (network) :图上每个边 ( 或弧 ) 都附加一个权值图的度 对于无向图 G=(V, E) : 若边 (v,w)属于E ,则称顶点 v 和 w 互为邻接点,即 v 和 w 相邻 (adjacent) ,而边 (v,w) 依附于 (incident) 顶点 v 和 w for any vi&lt;V ,依附于 vi 的边的数目称为顶点 vi 的度(degree) ,记为 TD(vi) 握手定理:/Handshaking theorem :所有顶点的度的和是图中边的 2 倍 定理:在任何图中,所有度数之和必为偶数 ,度数为奇数的结点必定是偶数个 推论:若图G有 n 个顶点, n+1 条边,则G中至少有一个结点的度数大于 3 。 对于有向图 G=(V, E) : 若有向弧 属于 E ,则称:顶点 v 邻接到顶点 w ,顶点 w 邻接自顶点 v ,弧 与顶点 v 、 w 相关联 以 vi 作为起点的有向边 ( 弧 ) 的数目称为顶点 vi 的出度 (outdegree) ,记为 OD(vi) 以 vi 作为终点的有向边 ( 弧 ) 的数目称为顶点 vi 的入度 (indegree) ,记为 ID(vi) 顶点 vi 的出度与入度之和称为 vi 的度,记为 TD(vi) , 即, TD(vi)=OD(vi)+ID(vi) 定理:所有顶点的度的和是图中边的 2 倍 定理:在任何有向图中,所有结点的入度之和等于所有结点的出度之和 图的存储结构 数组（邻接矩阵）表示法 对于有 n 个顶点的图: 用一维数组 vexs[n] 存储顶点信息 用二维数组 A[n][n] 存储顶点之间关系的信息 无向图:无权图的数组表示 如果vi, vj 有边，则 A[i][j] = 1; 否则 A[i][j] = 0 无向图:带权图的数组表示: 若 vi, vj 相邻，权值为Wij, 则 A[i][j] = Wij 否则，A[i][j] = infinity 无向图的邻接矩阵是 n 阶对称方阵; 对于顶点 vi ,其度数是第 i 行的非 0 元素的个数 无向图的边数是上 ( 或下 ) 三角形矩阵中非 0 元素个数 有向图:无权图的邻接矩阵表示: 若从 vi 到 vj 有弧，则 A[i][j] = 1;否则, A[i][j] = 0; 有向图:带权图的邻接矩阵表示: 若 vi, vj 之间有弧，权值为 Wij, 则 A[i][j] == Wij否则，A[i][j] = infinity 图的数组表示： 123456789101112131415161718 // 图的种类: UDG 无向图, DG 有向图, UDN 无向网, DN 有向网typedef enum &#123;UDG, DG, UDN, DN&#125; GraphKind;typedef struct ArcCell &#123; VRType adj; // 顶点关系类型: w/1/0 InfoType *info;&#125;ArcCell, AdjMatrix[MaxVertexNum][MaxVertexNum]typedef struct&#123; VertexType vexs[MaxVertexNum]; // 顶点向量 AdjMatrix arcs; // 邻接矩阵 int vernum,arcnum; // 图的顶点数和弧数 GraphKind kind;&#125;MGraph;typedef struct&#123; int vexnum,arcnum; // 顶点数,边数, GraphKind kind; // 图的种类 char vexs[Max]; // 存放顶点信息 int A[Max][Max];// 存放边的信息&#125;MGraph; 采用数组构造无向图： 12345678910111213141516171819 void CreateGraph(MGraph *g) &#123; int i,j,k; printf(\"Input: Vex Num &amp; Arc Num &amp; Arc Kind\\n\"); scanf(\"%d %d %d\",&amp;g-&gt;vexnum,&amp;g-&gt;arcnum,&amp;k); switch (k) &#123; case 0: g-&gt;kind=UDG;break; case 1: g-&gt;kind=DG;break; &#125; for(k=0;k&lt;g-&gt;vexnum;k++) g-&gt;vexs[k]='A'+k; for(i=0;i&lt;g-&gt;vexnum;i++) for(j=0;j&lt;g-&gt;vexnum;j++) g-&gt;A[i][j] = 0; // 初始化邻接矩阵 printf(\"Input: %d edges: \\n\",g-&gt;arcnum); for(k=0;k&lt;g-&gt;arcnum;k++)&#123; scanf(\"%d %d\",&amp;i,&amp;j); g-&gt;A[i][j]=1; if(g-&gt;kind==UDG) g-&gt;A[j][i]=1; // 无向图时,邻接矩阵是对称的 &#125; &#125; 输出无向图： 123456789 void ListGraph(MGraph *g)&#123; int i,j; for(i=0;i&lt;g-&gt;vexnum;i++) &#123; printf(\"%6c---\",g-&gt;vexs[i]); for(j=0;j&lt;g-&gt;vexnum;j++) printf(\"%4d\",g-&gt;A[i][j]); printf(\"\\n\"); &#125;&#125; 邻接表 (Adjacency List) 法 对图的每个顶点建立一个单链表:第 i 个单链表表示依附于顶点 Vi 的边 ( 对有向图是以顶点 Vi 为尾的弧 ). 链表中的结点称为表结点。 邻接点域 (adjvex) 指示与顶点 Vi 邻接的顶点在图中的位置 ( 顶点编号 ) 数据域 (info) 存储和边或弧相关的信息如权值等 链域 (nextarc) 指向下一个与顶点 Vi 邻接的表结点 每一个单链表设一个表头结点 数据域 (data) 存储顶点名或其他信息,链域 (firstarc) 指向链表中的一个结点; 所有表头结点用一个向量以顺序结构形式存储,以便随机访问任意顶点的链表:表头向量的下标指示顶点的序号; 有向图：正临接表（出度直观）；逆临接表（入度直观） 临接表的特点： 表头向量中每个分量就是一个单链表的表头结点,分量个数就是图中的顶点数目 在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点 在无向图,顶点 Vi 的度是第 i 个链表的结点数 对有向图,可以建立 ( 正 ) 邻接表或逆邻接表 在有向图中,第 i 个链表中的结点数是顶点 Vi的出 ( 或入 ) 度;求入 ( 或出 ) 度,须遍历整个邻接表 在边或弧稀疏的条件下,用邻接表表示比用邻接矩阵表示节省存储空间 临接表的实现： 1234567891011121314 #define MAX_VERTEX_NUM 30typedef char ElemType;typedef struct NodeLink &#123; int vindex; // 邻接点在头结点数组中的位置 ( 下标 ) struct NodeLink *next;//一个表结点&#125; NodeLink; // 表结点类型定义typedef struct &#123; // 图的顶点数、边数、种类标志 int vexnum,edgenum,kind; struct &#123; ElemType vertex; NodeLink *first;// 指向第一个表结点 &#125;v[MAX_VERTEX_NUM];&#125;AGraph; 采用临接表构造无向图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 void CreateGraph(AGraph *g,int n,int m)&#123; int i, e = 0; NodeLink *p, *q, *s; char x, y; g-&gt;vexnum = n; g-&gt;kind = m; for(i=0;i&lt;n;i++) &#123;// 初始化邻接表 g-&gt;v[i].vertex = 'A'+i; g-&gt;v[i].first=NULL; &#125; printf(\"Input edges x--&gt;y:\"); scanf(\"%c%c\",&amp;x,&amp;y); while(x!='X' &amp;&amp; y!='X')&#123; //生成节点并插入临接表 e++; s=(NodeLink *)malloc(sizeof(NodeLink)); s-&gt;vindex= y-'A'; if(g-&gt;v[x-'A'].first == NULL) &#123; g-&gt;v[x-'A'].first =s; s-&gt;next = NULL; &#125; else&#123; p=g-&gt;v[x-'A'].first; q=p-&gt;next; while (q!=NULL)&#123; p=q;q=q-&gt;next; &#125; p-&gt;next=s;s-&gt;next=q; &#125; if(!g-&gt;kind)&#123; // 无向图 s=(NodeLink *)malloc(sizeof(NodeLink)); s-&gt;vindex = x-'A'; if(g-&gt;v[y-'A'].first == NULL) &#123; g-&gt;v[y-'A'].first =s; s-&gt;next = NULL; &#125; else&#123; p=g-&gt;v[y-'A'].first; q=p-&gt;next;+ while(q!=NULL) &#123; p=q;q=q-&gt;next; &#125; p-&gt;next =s;s-&gt;next=q; &#125; &#125; scanf(\" %c%c\",&amp;x,&amp;y); &#125; g-&gt;edgenum =e;&#125; 输出无向图： 12345678910111213 void ListGraph(AGraph *g) &#123; int i; NodeLink *p; for(i=0;i&lt;g-&gt;vexnum;i++)&#123; printf(\"%d:%c---&gt;\",i,g-&gt;v[i].vertex); p=g-&gt;v[i].first; while(p) &#123; printf(\"%3d\",p-&gt;vindex); p=p-&gt;next; &#125; printf(\"\\n\"); &#125;&#125; 图的顶点定位： 1234567 // 确定一个顶点在 v 数组中的位置int LocateVex(AGraph *g,ElemType u)&#123; int k; for(k=0;k&lt;g-&gt;vexnum;k++) if (g-&gt;v[k].vertex == u) return k; return -1; // 图中无此顶点&#125; 十字链表 每个顶点对应一个结点:每条弧的弧头结点和弧尾结点都存放在链表中。 每条弧对应一个结点。 从一个顶点结点的 firstout 出发,沿表结点的 tlink 指针构成了正邻接表的链表结构。+ 从一个顶点结点的 firstin 出发,沿表结点的hlink 指针构成了逆邻接表的链表结构。 十字链表的实现： 1234567891011121314 #define MAX_VERTEX_NUM 30 // 最大顶点数typedef char ElemType;typedef struct ArcBox &#123; int tailvex, headvex;// 尾结点和头结点在图中的位置 //InfoType info; // 与弧相关的信息 如权值 struct ArcBox *hlink, *tlink; // 分别链接弧头相同和弧尾相同的弧&#125;ArcNode; // 弧结点typedef struct VexNode &#123; ElemType data; // 顶点信息+ ArcBox *firstin, *firstout; // 分别指向该顶点第一条入弧和出弧&#125;VexNode;// 顶点结点typedef struct &#123;int vexnum, arcnum; VexNode xlist[MAX_VERTEX_NUM];&#125;OLGraph; 采用十字链表构造有向图： 1234567891011121314151617181920 void CreateGraph(OLGraph *g) &#123; // G.kind = DG int i,j,k; char v1,v2; struct ArcBox *p; scanf(\"%d %d\",&amp;g-&gt;vexnum, &amp;g-&gt;arcnum); for(i=0; i&lt;g-&gt;vexnum; ++i) &#123; // 构造表头向量 g-&gt;xlist[i].data='A'+i; // 设置顶点值 g-&gt;xlist[i].firstin = g-&gt;xlist[i].firstout = NULL; &#125; for(k=0; k&lt;g-&gt;arcnum; ++k) &#123; // 输入各弧并构造十字链表 scanf(\" %c%c\",&amp;v1, &amp;v2); // 输入一条弧的始点和终点 i=LocateVex(g,v1); j=LocateVex(g,v2); // 确定 v1 和 v2 在 g 中位置 p=(ArcBox *) malloc (sizeof (ArcBox)); // 假定有足够空间 p-&gt;tailvex=i; p-&gt;headvex=j; p-&gt;hlink=g-&gt;xlist[j].firstin; p-&gt;tlink=g-&gt;xlist[j].firstout; g-&gt;xlist[j].firstin = g-&gt;xlist[i].firstout = p; // 在入弧和出弧链头插入 &#125; return;&#125; 临接多重表 邻接多重表:用于表示无向图 每个顶点用一个顶点结点表示: data 域:存储和顶点相关的信息;firstedge 域:指向依附于该顶点的第一条边所对应的表结点; 每条边用一个边结点表示; mark 域:用以标识该条边是否被访问过;ivex 和 jvex 域:分别保存该边所依附的两个顶点在图中的位置;info 域:保存该边的相关信息;ilink 域:指向下一条依附于顶点 ivex 的边;jlink 域:指向下一条依附于顶点 jvex 的边; 邻接多重表与邻接表的区别： 邻接表的同一条边用两个结点表示,而邻接多重表只用一个结点表示。 邻接多重表能较方便地完成对边的操作:– 标记已被搜索的边– 删除一条边 除标志域外,邻接多重表与邻接表表达的信息是相同的,因此,操作的实现也基本相似。 临接多重表的定义： 1234567891011121314151617 #define MAX_VERTEX_NUM 30 // 最大顶点数typedef emnu &#123;unvisited , visited&#125; VisitIf;typedef struct Ebox &#123; VisitIf mark; // 访问标记 int ivex, jvex; // 该边依附的两个结点在图中的位置 // 分别指向依附于这两个顶点的下一条边 struct EBox *ilink, *jlink; InfoType info ;// 与边相关的信息 , 如权值&#125;EBox ; // 弧边结点typedef struct VexBox &#123; VertexType data; // 顶点信息 EBox *firsedge ; // 指向依附于该顶点的第一条边&#125;VerBox; // 顶点结点typedef struct &#123; int vexnum,edgenum; // 无向图的顶点数和边数 VerBox adjmulist[MAX_VERTEX_NUM];&#125;AMGraph ; 图的遍历 从图的某一顶点出发,访遍图中的其余顶点,且每个顶点仅被访问一次。 复杂性:图的任意顶点可能和其余的顶点相邻接,可能在访问了某个顶点后,沿某条路径搜索后又回到原顶点。解决办法:在遍历过程中记下已被访问过的顶点,即:设置一个辅助向量 Visited1…n ,其初值为 0 ,一旦访问了顶点 vi 后,设置 Visited[i] 为 1 或为访问的次序号。 算法:– 深度优先搜索算法和广度优先搜索算法– 采用的数据结构是 ( 正 ) 邻接链表 深度优先搜索 (Depth First Search, DFS) 设初始状态时图中的所有顶点均未被访问 从图中某个顶点 V0 出发,访问此顶点,然后依次从 V0 的未被访问的邻接点出发深度优先遍历图,直至图中所有和 V0 有路径相通的顶点都被访问到; 若图中尚有顶点未被访问,则选一个未曾被访问的顶点作为起点,重复上述过程,直到图中所有顶点都被访问到为止。 DFS 递归实现： 1234567891011121314151617181920212223242526 //递归实现１int visited[MAX_VERTEX_NUM]; // 访问标志数组Status (* VisitFunc)(int v); // 函数变量// 从第 x 个顶点出发递归地深度优先遍历图 gvoid DFS(AGraph *g,int x) &#123; NodeLink *p; visited[x]=1; printf(\"%3c\",g-&gt;v[x].vertex);//VisitFunc(v); // 访问第 v 个顶点 p=g-&gt;v[x].first; while(p)&#123; if(!visited[p-&gt;vindex]) // 对 x 的尚未访问的邻接顶点 DFS(g,p-&gt;vindex); p=p-&gt;next; &#125;&#125;//递归实现２// 对图 G 作深度优先遍历，时间复杂度 O(n+e)int visited[MAX_VERTEX_NUM]; // 访问标志数组void DFSGraph(AGraph *g)&#123; int i; for(i=0;i&lt;g-&gt;vexnum;i++) visited[i]=0; // 访问标志数组初始化 for(i=0;i&lt;g-&gt;vexnum;i++) if(!visited[i]) DFS(g,i);&#125; 广度优先搜索 (Breadth First Search, BFS) 设初始状态时图中的所有顶点均未被访问 从图中的某个顶点 V0 出发,并在访问此顶点之后依次访问 V0 的所有未被访问过的邻接点,之后按这些顶点被访问的先后次序依次访问它们的邻接点,直至图中所有和V0 有路径相通的顶点都被访问到 若图中尚有顶点未被访问,则选一个未曾被访问的顶点作为起点,重复上述过程,直到图中所有顶点都被访问到为止 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 //BFS 非递归实现，伪代码void BFSTraverse(Graph G, Status (*Visit)(int v )) &#123; // 使用辅助队列 Q ,保存已访问过的顶点 // 使用访问标志数组 visited ,用于标记图中顶点是否被访问过 QElemType v,w; queue Q; QElemType u; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; InitQueue(Q); // 置空的辅助队列 Q for (v=0; v&lt;G.vexnum; ++v)&#123; if (!visited[v]) &#123;// v 尚未访问 visited[v] = TRUE; Visit(v); // 访问 v EnQueue(Q, v); // v 入队列 while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); // 队头元素出队并置为 u for (w=FirstAdjVex(G, u); w&gt;=0; w=NextAdjVex(G, u, w)) if (!visited[w]) &#123;// u 的尚未访问的邻接顶点 w 入队列 Q visited[w] = TRUE; Visit(w); EnQueue(Q, w); &#125;//if &#125;//while &#125;//if &#125;//&#125; //时间复杂度 O(n+e)//另一种非递归实现void BFS(AGraph *g,int x) &#123; // 用一个数组 q 作辅助队列 , q[0..front) 存放的是访问过的顶点 // q[front..rear) 存放的是已访问顶点的相邻点,是马上要访问的顶点 int q[MAX_VERTEX_NUM],front,rear,i; NodeLink *p; front=rear=0; q[rear++]=x; while(front != rear) &#123;// 顶点出队列,并访问它 x=q[front++]; printf(\"%c-&gt;\",g-&gt;v[x].vertex); visited[x]=1; p=g-&gt;v[x].first; while(p!=NULL)&#123; for(i=0;i&lt;rear;i++) // 判邻接点是否在数组 q 中 if(p-&gt;vindex == q[i]) break; if(i &gt;=rear)// 邻接点未被访问且不在队列中,则入队列 q[rear++]=p-&gt;vindex; p=p-&gt;next; // 找 x 的下一个邻接点 &#125; &#125;&#125;//递归实现void BFSGraph(AGraph *g)&#123; int i; for(i=0;i&lt;g-&gt;vexnum;i++) visited[i]=0; for(i=0;i&lt;g-&gt;vexnum;i++) if(!visited[i]) BFS(g,i);&#125; 图遍历的应用 连通图的生成树: DFS/BFS 非连通图的生成森林: DFS/BFS 重连通图 / 连通图关节点的判定: DFS 图的连通性检测: DFS/BFS 无向图的环路检测: DFS/BFS 有向图的环路检测: DFS 顶点之间的可达性检测: DFS/BFS 顶点之间的路径求解: DFS/BFS 顶点之间的最短距离: BFS 欧拉回路: DFS 拓扑排序: DFS var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"树-Part2","date":"2017-05-06T07:52:46.000Z","path":"2017/05/06/Tree-Part2/","text":"树与森林 树的三种存储表示方法： 双亲表示法：顺序存储，设置一个指示器指示双亲位置。 123456789 #define MAX_TREE_SIZE 100typedef struct PTNode&#123;//节点结构 TElemType data; int parent;//双亲位置域&#125;PTNode;typedef struct&#123; PTNode nodes[MAX_TREE_SIZE]; int r, n; //根的位置和节点数&#125;PTree; 孩子表示法：把每个节点的孩子节点排列起来，看成一个线性表，且以单链表做存储结构。则 n 个节点有 n 个孩子链表，n 个头指针又组成一个线性表。 123456789101112 typedef struct CTNode&#123; int child; struct CTNode *next;&#125;*ChildPtr, CTNode;typedef struct&#123; TElemType data;+ ChildPtr firstchild; //孩子链表头指针&#125;CTBox;typedef struct&#123; CTBox nodes[MAX_TREE_SIZE]; int n, r;&#125;CTree; 孩子兄弟表示法： firstChild 指向该结点的第一个子女结点。无序树时,可任意指定一个结点为第一个女。 nextSibling 指向该结点的下一个兄弟。任一结点在存储时总是有顺序的。若想找某结点的所有子女,可先找 firstChild, 再反复用 nextSibling 沿链扫描。 1234 typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild, *nextsibling;&#125; CSNode, *CSTree; 由于二叉树和树都可以用二叉链表作为存储结构,则以二叉链表作为媒介可导出树与二叉树之间的一个对应。给定一棵树,可以找到唯一的一棵二叉树与之对应。从物理上看,他们的二叉链表是相同的,只是解释不同。 从树的二叉链表表示的定义可知,任何一棵和树 对应的二叉树,其右子树必空 。 若把森林中第二棵树的根结点看作是第一棵树的根结点的兄弟,则同样可以导出二叉树的对应关系。由此即得森林转化为二叉树的算法。 和树对应的二叉树,其左、右子树的概念已改变为:左是孩子,右是兄弟 。 树和森林的遍历： 深度优先遍历 先根次序遍历：对应二叉树的先序遍历 后根次序遍历：对应二叉树的中序遍历 广度优先遍历 树与等价关系： 等价关系： 自反性 传递性 对称性 划分等价类： 令 S 中每个元素各自形成一个只含单个元素的子集,记为 S1 ,…, Sn。 依次扫描 m 个偶对,对每个扫描的偶对( x , y ),判定 x 和 y 所属的子集。假设 x∈Si , y∈Sj ,若 Si≠Sj ,则将 Si并入 Sj 并置 Si 为空(或将 Sj 并入 Si 并置 Sj 为空)。当 m 个偶对都被处理后,S1 , S2 ,… ,Sn 中所有非空子集即为 S 的 R 等价类。 1234567891011121314151617 //采用树的双亲表示法作为存储结构typedef PTree MFSet; //PTree 的定义见上面定义//查找函数int find_mfset(MFSet S, int i)&#123; if( i &lt; 1 || i &gt; S.n) return -1; for(j = i; S.nodes[j].parent &gt; 0; j = S.node.parent); return j;&#125;//find_mfset//归并函数Status merge_mfset(MFSet *S, int i, int j)&#123; //求并集 Si 并 Sj //S-&gt;node[i]和S-&gt;node[j]为两个不相交的子集 Si, Sj 的根节点 if( i &lt; 1 || i &gt; S-&gt;n || j &lt; 1 || j &gt; S-&gt;n) return ERROR; S-&gt;node[i]-&gt;parent = j;&#125; merge 算法改进：令成员少的指向成员多的，同时，需修改存储结构，令根节点的 parent 域存储子集中所含成员数目的负值。 1234567891011121314 void mix_mfset(MFset *S, int i, int j)&#123; if(i &lt; 1|| i &gt; S-&gt;n || j &lt; 1 || j &gt; S-&gt;n) return ERROR; if(S-&gt;node[i]-&gt;parent &gt; S-&gt;node[j]-&gt;parent)&#123; //Si 的成员比 Sj 少 S-&gt;node[j]-&gt;parent += S-&gt;node[i]-&gt;parent;+ S-&gt;node[i]-&gt;parent = j; &#125; else&#123; S-&gt;node[i]-&gt;parent += S-&gt;node[j]-&gt;parent; S-&gt;node[j]-&gt;parent = i; &#125; return OK;&#125;//mix_mfset 随着子集的依次合并,树的深度不断增大。为改善此种情况,当所需确定的元素 i 不在树的第二层时,可通过 “ 压缩路径 “ 功能缩短元素到达根结点的路径。 123456789 int fix_mfset(MFSet *S, int i)&#123; //确定 i 所在子集,将从 i 至根路径上所有结点变为根的孩子结点 if(i&lt;1 || i&gt;S.n)return-1; //i 不是 S 中的任何子集的元素 for(j=i ; S-&gt;nodes[j]-&gt;parent&gt;0 ; j=S-&gt;nodes[j]-&gt;parent); for(k=i;k !=j;k=t)&#123; t=S-&gt;nodes [ k ]-&gt;parent; S-&gt;nodes [ k ]-&gt;parent=j; &#125; return j;&#125; 哈夫曼树与哈夫曼编码 最优树的定义： 结点的路径长度定义为: 从根结点到该结点的路径上分支的数目。 树的路径长度定义为: 树中每个结点的路径长度之和。 完全 二叉树是 路径长度最短的 二叉树。 结点的带权路径长度定义为:从根结点到该结点的路径长度与该结点的权的乘积。 树的带权路径长度定义为:树中所有叶子结点的带权路径长度之和（WPL） 最优二叉树 (哈夫曼树)定义为: 假设有 n 个权子 {w1 , w2 , ….wn } ,构造一棵有 n 个叶子 结点的 二叉树,每个叶子结点带权 wi , 则其中带权路径长度 WPL 值最小的 二叉树为最优二叉树。在 Huffman 树中,权值大的结点离根最近。 Huffman 树的构造算法(贪心算法) 根据给定的 n 个权值（w1, w2, …, wn）构成 n 棵二叉树的集合 F = {T1, T2, …, Tn}，其中每棵二叉树 Ti 中只有一个带权为 wi 的根节点，其左右子树均为空。 在 F 中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树的根节点的权值之和。 在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。 重复上两个步骤，直到 F 中只含一棵树，该树便为 Huffman 树。 贪心算法： 贪心算法(又称贪婪算法)是指,在对问题求解时,总是做出在当前看来是最好的选择。也就是说,不从整体最优上加以考虑,他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解,但对相当广范围的 许多问题是能产生整体最优解的,或者是整体最优解的近似解。 正则二叉树：哈夫曼树中没有度为 1 的结点,树中任意非叶子结点都有 2 个儿子,这类树又称为正则二叉树。 一棵有 n 个叶子结点的哈夫曼树共有 2n-1 个结点 。 显然：除最下面那棵树以外每一个叶子对应一个根节点，所有 N = n + n - 1 = 2n - 1;Huffman 编码 前缀编码；任意一个字符的编码都不是其他字符编码的前缀。 主要用途是实现数据压缩,实现数据的无损压缩。 利用二叉树可以构造一种不等长的二进制编码,而且得到的必为二进制前缀编码。如下图： A(0), B(10), C(110), D(111) 构造以出现频率为权值的哈夫曼树,就能得到相应的哈夫曼编码,这是一种最优前缀编码,即使所传电文的总长度最短。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 typedef struct &#123; unsigned int weight; unsigned int parent, lchild, rchild;&#125; HTNode, *HuffmanTree;typedef char **HuffmanCode;//求Huffman编码算法void HuffmanCoding(HuffmanTree *HT, HuffmanCode *HC, int *w, int n) &#123; //W 存放 n 个字符的权值，构造 Huffman 树 HT, 并求出 n 个字符的 Huffman 编码 HC m = 2*n-1; HT = (HuffmanTree )malloc((m+1)*sizeof(HTNode)); for (p=HT, i=1; i&lt;=n; ++i, ++p, ++w) *p=&#123;*w, 0, 0, 0); for (; i&lt;=m; ++i, ++p)//建树 *p = &#123;0, 0, 0, 0); for (i=n+1; i&lt;=m; ++i)&#123; Select(HT, i-1, s1, s2); HT[s1]-&gt;parent = I; HT[s2]-&gt;parent = I; HT[i]-&gt;lchild = s1; HT[i]-&gt;rchild = S2; HT[i]-&gt;weight = HT[s1]-&gt;weight+HT[s2]-&gt;weight; &#125; //从叶子到 根逆向求 每个 字符的哈夫曼编码 HC= ( HuffmanCode ) malloc( (n+1)*sizeof(char *));//分配n个字符编码的头指针向量 char *cd = (char *)mallco (n *sizeof(char));//分配求编码工作空间 cd[n-1] = “\\0”; for (i=1; i&lt;=n; ++i)&#123; int start = n-1; for (int c= i, int f=HT[i]-&gt;parent; f!=0; c=f, f=HT[f]-&gt;parent) if (HT[f]-&gt;lchild == c) cd[--start] = “0”; else cd[--start] = “1”; HC[i] = (char *)malloc((n-start)*sizeof(char)); strcpy(HC[i], &amp;cd[stat]); &#125; free(cd);&#125;//HuffmanCoding//-------- 无栈 非递归 遍历哈夫曼树,求哈夫曼编码 -------- HC= ( HuffmanCode ) malloc( (n+1)*sizeof(char *)); int p = m; int cdlen = 0; for ( int i=1 ; i&lt;=m ; ++i ) HT[i]-&gt;weight = 0; while (p) &#123; if (HT[p]-&gt;weight ==0)&#123; HP[p]-&gt;weight = 1; if (HP[p]-&gt;lchild != 0)&#123;p = HT[p]-&gt;lchild; cd[cdlen++] = “0”;&#125; else if (HT[p]-&gt;rchild == 0)&#123; HC[p] = (char *)malloc((cdlen+1)*sizeof(char)); cd[cdlen] = “\\0”; strcpy(HC[p], cd); &#125; &#125; else if (HT[p]-&gt;weight == 1)&#123; HT[p]-&gt;weight = 2; if (HT[p]-&gt;rchild != 0)&#123; p = HT[p]-&gt;rchild; cd[cdlen++] = “1”; &#125; &#125; else &#123; HT[p]-&gt;weight = 0; p = HT[p]-&gt;parent; --cdlen; &#125;//else &#125;//while 回溯法与树的遍历 回溯法是一种“穷举”方法 , 也叫试探法。它是一种系统地搜索问题的解的方法。 用回溯算法解决问题的一般步骤: 针对所所给问题,定义问题的解空间,它至少包含问题的一个(最优)解。 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。 以深度优先的方式搜索解空间,并且在搜索过程中用约束函数剪枝解空间,避免无效搜索。 树的计数 二叉树计数：讨论有 n 个节点，互不相似的二叉树的数目。 卡特兰数： S(n) = 1/(n+1)C(2n,n)(见组合数学)即 n 个节点对应 1/(n+1)C(2n,n) 棵不同的二叉树。C(2n,n)为 2n 个不同数中选 n 个的组合数。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"树-Part1","date":"2017-05-06T07:01:22.000Z","path":"2017/05/06/Tree-Part1/","text":"树的定义 树 (tree) 是一个 n(n&gt;=0) 个结点的有限集。 在一棵非空树中：(1) 有且仅有 一个的称为根 (root) 的结点；(2) 当 n&gt;1 时,其余结点可分为 m (m&gt;0)个互不相交的有限集 T_1 , T_2 , …, T_m. 树的基本术语： 结点:数据元素 + 若干指向子树的分支 结点的度:结点拥有的子树个数 树的度:树中所有结点的度的最大值 叶子结点:度为零的结点 分支结点:度大于零的结点 孩子:若结点的子树非空,结点子树的根即为该结点的子女。 双亲:若结点有子女,该结点是子女双亲。 兄弟:同一结点的子女互称为兄弟。 祖先:结点的祖先是从根到该结点所经分支上的所有结点。 子孙: 以某结点为根的子树种任一结点都是该结点的子孙。 结点的层次:规定根结点为第一层,其子女 结点的层次等于它的层次加一。 深度:树中结点的最大 层次称为树的深度。 有序树:树中结点的各棵子树 T0, T1, …是有次序的,即为有序树。 无序树: 森林:森林是 m ( m≥0 )棵树的集合。 二叉树 二叉树的定义：是一种树型结构,它的特点是每个节点至多只有两棵子树,并且,二叉树的子树有左右之分,其次序不能任意颠倒 。 满二叉树 (Full Binary Tree)：一棵 深度为 k 且有 2k−12k−1 个结点的二叉树。特点:每层上的结点数都是最大的结点数。 完全二叉树 (Complete Binary Tree)：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。 特点: 叶子结点只可能出现在层次最大的两层上 对任一结点,若其右分支下的子孙的最大层次为 l ,则其左分支下的子孙的最大层次必定为 l 或者 l+1 。 二叉树的基本性质 性质 1： 若二叉树结点的层次从 1 开始 ,则在二叉树的第 i 层最多有 $2^{i-1}$ 个结点( i≥1)。 性质 2： 深度为 k 的二叉树最少有 k 个结点,最多有 2^k−1个结点(k ≥1` )。（等比数列求和） 性质 3： 对任何一棵二叉树,如果其叶结点有 $n_0$ 个 , 度为 2 的非叶结点有 $n_2$个 ,则有： n_0=n_2+1性质 4： 具有 n (n≥0) 个结点的完全二叉树的深度为 log_2n+1 性质 5: 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号,则对完全二叉树中任意一个编号为 i 的结点: 若 i=1 ,则该结点是二叉树的根,无双亲;否则,编号为 i/2 的结点为其双亲结点 ; 若 2i&gt;n ,则该结点无左孩子,否则,编号为 2i 的结点为其左孩子结点; 若 2i+1&gt;n ,则该结点无右孩子结点,否则,编号为 2i+1 的结点为其右孩子结点。 二叉树的存储结构： 顺序存储：仅适用于完全二叉树，将完全二叉树中编号为 i 的节点存储在一维数组中编号为 i-1 的分量中。 1234567 #define OK 1#define ERROR 0typedef int Status;typedef char TElemType;#define MAX_TREE_SIZE 100 //二叉树最大节点数typedef TElemType SqBiTree[MAX_TREE_SIZE]; //０号单元存储根节点SqBiTree bt; 链式存储结构： 1234 typedef struct BiTNode&#123; TElemType data;+ struct BiTNode *lchild, *rchild;//左右孩子指针&#125;BiTNode, *BiTree; 创建二叉树： 1234567891011121314 Status CreateBiTree(BiTree *T)&#123; //按先序次序输入二叉树的值，空格字符表示空树 char ch; if ((ch = getchar ()) == ' ')&#123; T = NULL; &#125; else&#123; if(!(T = (BiTNode *) malloc (sizeof(BiTNode)))) exit(-1) T-&gt;data = ch;+ CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125; return 1;&#125;//CreateBiTree 遍历二叉树 顺着某一条搜索路径巡访二叉树中的结点,使得每个结点均被访问一次,而且仅被访问一次。 先序遍历：先访问根节点，然后访问左孩子，然后再访问右孩子；（对应前缀表达式） 中序遍历：先访问左孩子，然后访问根节点，最后访问右孩子；（对应中缀表达式） 后序遍历：先访问左孩子，然后访问右孩子，最后访问根节点；（对应后缀表达式） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 //先序遍历二叉树，递归Status PreOrderTraverse(BiTree T, Status(* Visit)(TElemType))&#123; if(T)&#123; if(Visit(T-&gt;data)) if(PreOrderTraverse(T-&gt;lchild, Visit)) if(PreOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125; else return OK;&#125;Status Visit(T-&gt;data)&#123; if (T-&gt;data != ' ')&#123; printf(\"%c\\n\",T-&gt;data); return OK; &#125; return ERROR;&#125;//中序遍历二叉树，递归Status InOrderTraverse(BiTree T, Status(* Visit)(TElemType e))&#123; if(T)&#123; if(InOrderTraverse(T-&gt;lchild, Visit)) if(Visit(T-&gt;data)) if(InOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125; return OK;&#125;//后序遍历二叉树，递归Status PostOrderTraverse(BiTree T, Status(* Visit)(TElemType e))&#123; if(T)&#123; if(PostOrderTraverse(T-&gt;lchild, Visit)) if(PostOrderTraverse(T-&gt;rchild, Visit)) if(Visit(T-&gt;data)) return OK; return ERROR; &#125;&#125;//下面部分为伪代码//先序遍历迭代算法１void PreOrder_iter1( BiTree T, Status ( *Visit)(TElemType e)&#123; IniStack ( S ) if (T) Push (S, T); While (! StackEmpty(S) ) &#123; // 在栈变空前反复循环 Pop (S, p); visit(p); // 弹出并访问当前结点 if (p-&gt;rchild) Push (S, p-&gt;rchild); // 右孩子先入后出 if (p-&gt;lchild) Push (S, p-&gt;lchild); // 左孩子后入先出 &#125;&#125;//先序遍历的迭代算法 2void PreOrder_iter2( BiTree T, Status ( *Visit)(TElemType e)&#123; IniStack(S); if (T) Push(S, T); do&#123; // 在栈变空前反复循环 Pop(S, x); while (x)&#123; // 访问子树 x 的左侧链,右子树入栈缓冲 visit(x); Push(S, x-&gt;rchild); // 右子树入栈 x = x-&gt;lchild; // 沿左侧链下行 &#125; &#125;while (! StackEmpty(S))&#125;中序遍历迭代算法 1void InOrder_iter1( BiTree T , Status ( *Visit)(TElemType e)&#123;// 采用二叉链表存储结构,中序遍历二叉树的非递归算法 IniStack ( S ); BiTree p = T ; while (p || ! StackEmpty(S))&#123; if (p) &#123; Push (S, p); p= p-&gt;lchild; &#125;// 从当前节点出发 , 逐批进栈 else&#123; Pop (S, p); if ( !Visit (p-&gt;data) ) return ERROR; // 退栈 , 访问 p = p-&gt;rightChild; // 遍历指针进到右子女 &#125; &#125; //while return OK;&#125;;中序遍历迭代算法 2void InOrder_iter2( BiTree T , Status ( *Visit)(TElemType e)&#123; // 采用二叉链表存储结构,中序遍历二叉树的非递归算法 IniStack ( S ); push(S, T) ; while ( ! StackEmpty(S) )&#123; while (GetTop(S, p) &amp;&amp; p) Push (S, p-&gt;lchild); Pop(S, p); if (! StackEmpty(S) )&#123; Pop (S, p); if ( !Visit (p-&gt;data)) return ERROR); // 退栈 , 访问 p = p-&gt;rightChild; // 遍历指针进到右子女 &#125; &#125; //while return OK;&#125;; 层次遍历二叉树： 层次序遍历二叉树就是从根结点开始,按层次逐层从左至右逐一遍历。 层次遍历方法按照深度,逐层对二叉树结构进行遍历,所以可以利用和栈对立的数据结构-队列来进行。 123456789101112 void InOrder_iter2( BiTree T , Status ( *Visit)(TElemType e)&#123; InitQueue(Q); EnQueue(Q, T); while ( ! QueueEmpty(Q) ) &#123; DeQueue(Q, x); Visit(x); if ( x-&gt;leftChild ) EnQueue( Q, x-&gt;leftChild ); if ( x-&gt;rightChild ) EnQueue( Q, x-&gt;rightChild); &#125;&#125; 线索化二叉树 二叉树的遍历实际将二叉树的非线性结构线性化,任一数据都有它的前驱和后继。但这种信息只能在遍历过程中才能得到。 预处理,将某种遍历顺序下的前驱、后继关系(线索)记在树的存储结构中,实现二叉树的线索化。而加上线索的二叉树称为线索二叉树。 n 个结点的二叉链表必定存在n+1 个空链域。 以这 n+1 个 leftChild 和 rightChild 的空闲指针用作 pred 指针和succ 指针,并增设两个标志ltag 和 rtag ,指明指针是指示子女还是前驱、后继线索。 当 ltag ( 或 rtag) = 0 ,表示相应指针指示左子女( 或右子女结点 ) ;当 ltag ( 或 rtag) = 1 ,表示相应指针为前驱 ( 或后继 ) 线索。 1234567 //二叉线索存储表示typedef enum &#123; Link, Thread &#125; PointerThr;// Link==0: 指针, Thread==1: 线索typedef struct BiThrNod &#123; TElemType data; struct BiThrNode *lchild, *rchild; // 左右指针 PointerThr LTag, RTag; // 左右标志&#125; BiThrNode, *BiThrTree; 为仿照线性表的存储界偶，在二叉树的线索表上添加新的头节点，并令其 lchild 指向二叉树的根节点， rchild 指向中序遍历时访问的最后一个节点；反之，令中序遍历的第一个节点的 lchild 和最后一个遍历的节点的 rchild 均指向头节点。 1234567891011121314 void InOrderTraverse_Thr(BiThrTree T,void (*Visit)(TElemType e)) &#123; //T 指向头结点。中序遍历二叉树 T 的非递归算法 BiThrTree p = T-&gt;lchild;// p 指向根结点 while ( p != T ) &#123; // 空树或遍历结束时, p==T while (p-&gt;LTag==Link) p = p-&gt;lchild; // 第一个结点 if ( ! Visit(p-&gt;data) ) return ERROR; while (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123; // 无右子树 p = p-&gt;rchild; Visit(p-&gt;data);// 访问后继结点 &#125; p = p-&gt;rchild; // p 进至其右子树根 &#125;&#125; // InOrderTraverse_Thr 线索化二叉树 在中序遍历过程中修改结点的左、右指针域,以保存当前访问结点的“前驱”和“后继”信息。遍历过程中,附设指针 pre, 并始终保持指针 pre 指向当前访问的、指针 p 所指结点的前驱。 1234567891011121314151617181920212223242526272829303132 Status InOrderThreading( BiThrTree *Thrt,BiThrTree T ) &#123; if(!(Thrt = (BiThrTree) malloc (sizeof(BiThrNode)))) exit(-1); Thrt-&gt;LTag= LINK ; Thrt-&gt;Rtag= Thread ; Thrt-&gt;rchild = Thrt; if (!T) Thre-&gt;lchild = Thrt; else &#123; Thrt-&gt;lchild = T; BiThrTree pre = Thrt; InThreading(T, pre); pre-&gt;rchild = Thrt; pre-Rtag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125; // InThreadingvoid InThreading(BiThrTree p, BiThrTree pre)&#123; if(p)&#123; InThreading(p-&gt;lchild, p); if(!p-&gt;lchild)&#123; p-&gt;LTag = Thread; p-&gt;lchild = pre; &#125; if(!pre-&gt;rchild)&#123; pre-&gt;RTag = Thread; pre-&gt;rchild = p; &#125; pre = p; InThreading(p-&gt;rchild ,pre); &#125;&#125;//InThreading var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"递归定理","date":"2017-04-29T11:55:23.000Z","path":"2017/04/29/Recursive-Theorem/","text":"递归定理是一个数学结论，在可计算性理论中起着重要作用。 该定理乍一看叙述性很强，实际上就是在说，为了制造一个能够看到自己描述的图灵机，并用它计算图灵机，只需要制造一个在上述定理中称为 T 的图灵机，使之以自己的描述作为输入的一部分，然后递归定理就产生一个新机器 R，它和 T 一样运行，只是 R 的描述被自动装在 T 中。 用一句话来概括递归定理，就是：图灵机可以输出自己的描述，然后还可以用它继续进行计算。 对于前者，一个有趣的事情就是，用一种程序语言，写一个程序，然后这个程序的输出就是自己。在网上看了一下，自己也琢磨了一下，总结出了几个不同的实现： 下面两个是用 Python写的： 12345 a = [\"print 'a = ', a, '\\\\n', ''.join(a)\"]print 'a = ', a, '\\n', ''.join(a)a = \"print 'a = ', repr(a), '\\n', repr(a)[1:-1]\"print 'a = ',repr(a), '\\n', repr(a)[1:-1] 这两个程序都是可以打印出自己。 还有 C​语言写的： 12 #include &lt;stdio.h&gt; int main() &#123; char *s = \"#include &lt;stdio.h&gt;%cint main() &#123; char *s = %c%s%c; printf( s, 10, 34, s, 34 ); return 0; &#125;\"; printf( s, 10, 34, s, 34 ); return 0; &#125; 这个版本的 C 语言也只有两行。 下面，还有一种方法，在程序中用 getc() 函数将源程序打印出来： 1234567891011 #include&lt;stdio.h&gt;int main( int argc, char **argv ) &#123; char c; FILE *fp; fp = fopen(\"SELF.c\",\"r\"); while((c = getc(fp)) != EOF)&#123; putchar(c); &#125; fclose(fp); return 0;&#125; 注：上面的源程序文件名即为 SELF.c。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"埃拉托色尼筛选法","date":"2017-04-26T12:33:25.000Z","path":"2017/04/26/the Sieve of Eratosthenes/","text":"埃拉托色尼筛选法(the Sieve of Eratosthenes)简称埃氏筛法，是古希腊数学家埃拉托色尼(Eratosthenes 274B.C.～194B.C.)提出的一种筛选法。 是针对自然数列中的自然数而实施的，用于求一定范围内的质数。 步骤： （1）先把1删除（现今数学界1既不是质数也不是合数）； （2）读取队列中当前最小的数2，然后把2的倍数删去； （3）读取队列中当前最小的数3，然后把3的倍数删去； （4）读取队列中当前最小的数5，然后把5的倍数删去； （5）如上所述直到需求的范围内所有的数均删除或读取； 今天，无意中看到这一算法，觉得很好，便用 C 语言来实现了该算法。采用链表作为数据结构，并通过递归筛选。下面是实现的 C 语言代码，已经过调试验证，结果正确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 //埃拉托色尼筛选法#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct LinkNode&#123; int data; struct LinkNode *next;&#125;LinkNode, *LinkList;//创建一个链表存储的从1到n的数组LinkList Create( int n)&#123; LinkList L,p; int i; L = (LinkList) malloc (sizeof(LinkNode)); if(!L) exit(0); L-&gt;next = NULL; for( i = n; i &gt; 0; i-- )&#123; p = (LinkList) malloc (sizeof(LinkNode)); if ( !p ) &#123; exit(0); &#125; p-&gt;data = i; p-&gt;next = L-&gt;next; L-&gt;next = p; &#125; return L;&#125;//求出所有素数(递归加筛选)void Prime(LinkList L, int n)&#123; static int i = 0; int state; LinkList p, q, r, s; state = i; p = L; q = p-&gt;next; while(state--)&#123; p = p-&gt;next; q = q-&gt;next; &#125; if (q == NULL || 2*q-&gt;data &gt; n) //终止 return; else if(q-&gt;data == 1)&#123; //删除1 r = p; p-&gt;next = q-&gt;next; free(r); i++; Prime(L, n); return; &#125; else&#123; //删除第一个的所有倍数 int value = p-&gt;data; LinkList temp; while(q)&#123; if (q-&gt;data % value == 0)&#123; p-&gt;next = q-&gt;next; temp = q; q = q-&gt;next; free(temp); &#125; if( !q ) break; p = p-&gt;next; q = q-&gt;next; &#125; i++; Prime(L, n); return; &#125;&#125;LinkList Create(int n);void Prime(LinkList L, int n);void PrintList(LinkList L);//打印值void PrintList(LinkList L)&#123; int i = 1; while( L-&gt;next )&#123; printf( \"%d\\t\", L-&gt;next-&gt;data ); if(i%7 == 0) printf( \"\\n\" ); i++; L = L-&gt;next; &#125; printf( \"\\n\" );&#125;int main( int argc, char **argv ) &#123; LinkList p; int n; printf( \"Enter number:\" ); scanf(\"%d\", &amp;n); p = Create(n); PrintList(p); Prime(p, n); printf( \"Prime:\\n\" ); PrintList(p); return 0;&#125; var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"再谈 C 语言中的指针","date":"2017-04-22T06:59:08.000Z","path":"2017/04/22/the-Error-Summary-of-C-Pointer-Part2/","text":"据说，指针是 C 语言中最灵活的地方，但可能也是 C 语言中最容易出错的地方。 指向指针的指针是指针的指针： 前两天，写一个关于十字链表存储稀疏矩阵的数据结构题，结果在初始化的时候就出现语法错误，而且折腾好久都没发现，先上代码： 12345678910111213141516 typedef int Status;typedef int ElemType;#define OK 1#define OVERFLOW 0typedef struct OLNode&#123; int i, j; //该非零元的行和列下标 ElemType e; struct OLNode *down, *right;&#125; OLNode, *OLink;typedef struct&#123; OLink *rhead, *chead;//行和列链表头指针向量 int mu, nu, tu;&#125;CrossList; 上面的代码是十字链表存储的结构定义。 在初始化时： 1234567 CrossList L;CrossList *M = &amp;L;M-&gt;mu = m;M-&gt;nu = n;M-&gt;tu = t;//m,n.t is constantsM-&gt;rhead = (OLink) malloc ((m + 1) * sizeof(OLink));M-&gt;chead = (OLink) malloc ((n + 1) * sizeof(OLink)); 其实仔细点就应该发现，rhead 和 chead 都是指向 OLink 的指针，所以它们是指向指针的指针，而我把它们转换成了指向 OLNode 的指针，自然就出错了，正确的应该是： 1234567 CrossList L;CrossList *M = &amp;L;M-&gt;mu = m;M-&gt;nu = n;M-&gt;tu = t;//m,n.t is constantsM-&gt;rhead = (OLink *) malloc ((m + 1) * sizeof(OLink));M-&gt;chead = (OLink *) malloc ((n + 1) * sizeof(OLink)); 这一点在函数传参过程中也很关键，下面再说。 C 语言中的传参是值传参 关于Ｃ语言中的值传参，最简单的一个典型例子就是交换两个变量的值： 12345 void wrongchange(int a, int b)&#123; int t = a; a = b; b = a;&#125; 我们都知道，上面的这个函数是无法交换 a,b 的值的，因为传入函数的只是a,b的值，所以函数里面发生什么并不会改变a,b的值，正确的做法是传入a,b的地址： 12345 coid correctchange(int *a, int *b)&#123; int t = *a; *a = *b; *b = t&#125; 也就是说，当把一个变量传入一个函数以后，不管你在这个函数里面对该变量做什么，在函数外面，这个变量都不会有任何变化，因为传参时仅仅是把该变量的值传入函数中去了。所以当我们要对变量进行改变时，需要传入变量的地址。 对于一般的变量，我们容易注意到这一点，可对于指针变量，当要改变指针变量的值的时候，就容易忽略了这一点，因为想着已经是地址了。 这次错误是在一个关于广义表的题：题目要求删除广义表中所有值等于 x 的原子节点。 第一个错误发生在创建一个广义表的时候，我把一个指向广义表的指针传入函数，这是没问题的。但是，后面就出现问题了： 12345678910111213141516171819202122232425262728293031323334353637383940 typedef int AtomType;typedef enum&#123;ATOM,LIST&#125;ElemTag;typedef struct GLNode &#123; ElemTag tag;// = ATOM or = LIST union &#123;// 原子结点和表结点的联合部分 AtomType atom; struct &#123;struct GLNode *hp, *tp;&#125; ptr;//ptr.hp,ptr.tp分别指向表头和表尾 &#125;;&#125;GLNode, *GList;void CreatGList(GList L)&#123;//part1 int i; GList p = L; p-&gt;tag = LIST; p-&gt;ptr.hp = (GList) malloc (sizeof (GLNode)); if(!p-&gt;ptr.hp)&#123; printf( \"Error!\" ); exit(0); &#125; p-&gt;ptr.hp-&gt;tag = ATOM; p-&gt;ptr.hp-&gt;atom = rand()%10; p-&gt;ptr.tp = (GList)malloc(sizeof(GLNode));//part2 p = p-&gt;ptr.tp; for( int i = 0; i &lt; 40 ; i ++ )&#123; p-&gt;tag = LIST; p-&gt;ptr.hp = (GList) malloc(sizeof(GLNode)); p-&gt;ptr.hp-&gt;tag = ATOM; p-&gt;ptr.hp-&gt;atom = rand()%10; p-&gt;ptr.tp = (GList) malloc (sizeof(GLNode)); p = q-&gt;ptr.tp; &#125; p-&gt;tag = ATOM; p-&gt;atom = rand()%10;&#125; 如果懂得一些 C 语言知识的话，很容易看出我的算法是什么样的，但是这样的做法是错的。首先，part1 是没有问题的，但part2有问题了： L是一个指向GLNode 的指针，因次，把它传入函数以后，可以改变L-&gt;ptr.hp,L-&gt;ptr.tp的值，这是有效的，但是，再继续给L-&gt;ptr.tp指向的节点进行操作，就有问题了。在这个函数里面是没有问题的，但是，离开这个函数以后后，那些节点都是没有意义的。 要解决这个问题，其实很简单：不要调用新的函数，直接在 main 函数中进行就可以了。 下一个又是传参的问题。 删除节点时，实际上要改变的是地址的值，因此，我们需要传入的参数不能是地址了，而应该是地址的地址，传入的变量也就是指针的指针变量。这话说起来好别扭…… 123456789101112131415161718 int DeleX(GList *L, AtomType x)&#123; if(!*L) return 1;//空表直接返回 else if((*L)-&gt;tag == ATOM)&#123; if((*L)-&gt;atom != x) return 1;//原子值不等于x else&#123; //删除值等于x的原子项 free(*L); *L = NULL; return 1; &#125; &#125; else&#123; DeleX(&amp;((*L)-&gt;ptr.hp), x); DeleX(&amp;((*L)-&gt;ptr.tp), x); return 1; &#125;&#125; 上面的代码是正确的，错误的就是传入的参数为 GList L，因此，传入的就是L的值，所以，无法改变L，也就不能成功删除节点了。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Ubuntu 和 Linux Mint 上启用桌面共享","date":"2017-04-15T15:34:33.000Z","path":"2017/04/15/How-to-Enable-Desktop-Share-in-Ubuntu-and-Linux-Mint/","text":"桌面共享是指通过图形终端仿真器在计算机桌面上实现远程访问和远程协作的技术。桌面共享允许两个或多个连接到网络的计算机用户在不同位置对同一个文件进行操作。 在这篇文章中，我将向你展示如何在 Ubuntu 和 Linux Mint 中启用桌面共享，并展示一些重要的安全特性。 在 Ubuntu 和 Linux Mint 上启用桌面共享 １、在 Ubuntu Dash 或 Linux Mint 菜单中，像下面的截图这样搜索 desktop sharing，搜索到以后，打开它。 在 Ubuntu 中搜索 Desktop sharing ２、打开 Desktop sharing 以后，有三个关于桌面共享设置的选项：共享、安全以及通知设置。 在共享选项下面，选中选项“允许其他用户查看桌面”来启用桌面共享。另外，你还可以选中选项“允许其他用户控制你的桌面”，从而允许其他用户远程控制你的桌面。 桌面共享偏好 ３、接下来，在“安全”部分，你可以通过勾选选项“你必须确认任何对该计算机的访问”来手动确认每个远程连接。 另外，另一个有用的安全特性是通过选项“需要用户输入密码”创建一个确定的共享密码。这样当用户每次想要访问你的桌面时需要知道并输入密码。 ４、对于通知，你可以勾选“仅当有人连接上时”来监视远程连接，这样每次当有人远程连接到你的桌面时，可以在通知区域查看。 配置桌面共享设置 当所有的桌面共享选项都设置好以后，点击“关闭”。现在，你已经在你的 Ubuntu 或 Linux Mint 上成功启用了桌面共享。 测试 Ubuntu 的远程桌面共享 你可以通过使用一个远程连接应用来进行测试，从而确保桌面共享可用。在这个例子中，我将展示上面设置的一些选项是如何工作的。 ５、我将使用 VNC（虚拟网络计算）协议通过 remmina 远程连接应用连接到我的 Ubuntu PC。 Remmina 桌面共享工具 ６、在点击 Ubuntu PC 以后，将会出现下面这个配置连接设置的界面， Remmina 桌面共享偏好 ７、当执行好所有设置以后，点击连接。然后，给用户名提供 SSH 密码并点击 OK 。 输入 SSH 用户密码 点击确定以后，出现下面这个黑屏，这是因为在远程机器上，连接还没有确认。 连接确认前的黑屏 ８、现在，在远程机器上，我需要如下一个屏幕截图显示的那样点击 Allow 来接受远程访问请求。 允许远程桌面共享 ９、在接受请求以后，我就成功地连接到了远程 Ubuntu 机器的桌面。 远程 Ubuntu 桌面 这就是全部内容了，在这篇文章中，我们讲解了如何在 Ubuntu 和 Linux Mint 中启用桌面共享。你使用评论部分给我们写反馈。 via: http://www.tecmint.com/enable-desktop-sharing-in-ubuntu-linux-mint/ 作者：Aaron Kili译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"数组和广义表","date":"2017-04-15T07:13:55.000Z","path":"2017/04/15/Array-and-Table/","text":"数组的类型定义 数组是几乎所有程序设计语言都设定为固有类型的一种数据类型。从线性结构看,数组类型可以看作是数据元素本身还是线性结构的一个数据结构。 n 维数组的特点是每一个数据元素受 n 个线性关系的约束,可以有多个直接前驱和多个直接后继 ; 数组元素的下标一般具有固定的下界和上界,因此它比其他复杂的非线性结构简单。 一维数组常被称为向量( Vector )； 二维数组 A[m][n] 可看成是由 m 个行向量组成的向量,也可看成是由 n 个列向量组成的向量； 一个二维数组类型可以定义为其分量类型为一维数组类型的一维数组类型； 数组的顺序表示和实现： 一旦建立了数组 ,结构中的数据元素个数 和元素之间的关系固定 。因此,采用顺序存储结构表示数组是自然;用顺序存储表示多维数组,就必须按某种次序将数组元素排列到一个序列中。 有两种顺序映象的方式: 以行序为主序； 以列序为主序； 数组元素的存储位置是其下标(j1 , j2 , ....,jn) 的线性函数。一旦确定了数组的各维的阶数, ci 就是常数。所以存取数组中任一元素的时间相等。我们称具有这一特点的存储结构为随机存储结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 #include&lt;stdarg.h&gt;#define MAX_ARRAY_DIM 8typedef int Status;typedef int OK;typedef int ERROR;typedef int OVERFLOW;typedef struct &#123; ElemType *base; //数组元素基址 int dim; //数组维数 int *bounds; //数组维界基址 int *constants; //数组映像函数常量基址&#125;Array;//初始化数组Status InitArray(Array *A, int dim, ...)&#123; //若数组维数和各维长度合法，则构造相应数组A并返回OK if( dim &lt; 1 || dim &gt; MAX_ARRAY_DIM ) return ERROR; A-&gt;dim = dim; A-&gt;bounds = (int *) malloc (dim * sizeof(int)); if(!A-&gt;bounds) exit(OVERFLOW); //若各维长度合法，则存入A-&gt;bounds,并求出元素总数 int elemtotal = 1; va_list ap; va_start(ap, dim);//va 初始化 for(int i = 0; i &lt; dim; i++)&#123; A-&gt;bounds[i] = va_arg(ap, int); //依次访问每一个参数 if(A-&gt;bounds[i] &lt; 0)&#123; return ERROR; &#125; elemtotal *= A-&gt;bounds[i]; &#125; va_end(ap); A-&gt;base = (ElemType *) malloc (elemtotal * sizeof(ElemType)); if(!A-&gt;base)&#123; return OVERFLOW; &#125; //求映像常数Ci A-&gt;constants = (int *) malloc (dim * sizeof(int)); if(!A-&gt;constants)&#123; return OVERFLOW; &#125; A-&gt;constants[dim - 1] = 1; for(int i = dim -2; i &gt;= 0; i--)&#123; A-&gt;constants[i] = A-&gt;boun[i+1] * A-&gt;constants[i+1]; &#125; return OK;&#125;//销毁数组Status DestroyArray(Array *A)&#123; if(!A-&gt;base)&#123; return ERROR; &#125; free(A-&gt;base); A-&gt;base = NULL; if(!A-&gt;bounds)&#123; return ERROE; &#125; free(A-&gt;bounds); A-&gt;bounds = NULL; if(!A-&gt;constants)&#123; return ERROR; &#125; free(A-&gt;constants); A-&gt;constants = NULL; return OK;&#125;//定位，相对位置Status Locate(Array *A, va_list ap, int *off)&#123; *off = 0; int ind for(int i = 0; i &lt; A-&gt;dim, i++)&#123; ind = va_arg(ap, int) if(ind &lt; 0|| ind &gt;= A-&gt;bounds[i]) return OVERFLOW; off += A-&gt;constants[i] * ind; &#125; return OK;&#125;Status value(Array *A, ElemType e, ...)&#123; va_list ap; int off, result; va_start(ap,e); if((result = Locate(A, ap, &amp;off)) &lt;= 0) return result; e = *(A-&gt;base + off); return OK;&#125;Status Assign(Array *A, ElemType e, ...)&#123; va_list ap; va_start(ap, e); int result, off; if((result = Locate(A, ap, &amp;off)) &lt;= 0 ) return result; *(A-&gt;base + off) = e; return OK;&#125; 矩阵的压缩存储(特殊矩阵) 特殊矩阵是指非零元素或零元素的分布有一定规律的矩阵。 假若值相同的元素或者零元素在矩阵中的分布有一定规律,则我们称此类矩阵为特殊矩阵;反之,称为稀疏矩阵。 特殊矩阵的压缩存储主要是针对阶数很高的特殊矩阵。为节省存储空间,对可以不存储的元素,如零元素或对称元素,不再存储。 对称矩阵 对称矩阵中的元素关于主对角线对称, aij = aji , 0 &lt;= i,j &lt;= n-1。 为节约存储,只存对角线及对角线以上的元素,或者只存对角线或对角线以下的元素。前者称为上三角矩阵,后者称为下三角矩阵。 对角矩阵 三对角矩阵中除主对角线及在主对角线上 下最临近的两条对角线上的元素外,所有其它元素均为0 。总共有 3n - 2个非零元素。 稀疏矩阵 以常规方法,即以二维数组表示高阶的稀疏矩阵时产生的问题 : 零值元素占了很大空间; 计算中进行了很多和零值的运算。如遇除法,则需判别除数是否为零; 解决问题的原则 : 尽可能少存或不存零值元素 ; 尽可能减少没有实际意义的运算 ; 操作方便;即:能尽可能快地找到与下标值 (i, j) 对应的元素 ;能尽可能快地找到同一行或同一列的非零值元。 在存储稀疏矩阵时,为节省存储空间,应只存储非零元素。但由于非零元素的分布一般没有规律,故在存储非零元素时,必须记下它所在的行和列的位置 ( i, j ) 。 基于三元组表示的稀疏矩阵的压缩存储方法: 三元组顺序表； 行逻辑联接的顺序表； 十字链表； 三元组顺序表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 #define MAXSIZE 12500 //假设非零元素个数的最大值为12500typedef struct &#123; int i, j ;// 该非零元的行下标和列下标 ElemType e ;// 该非零元的值&#125; Triple ; // 三元组类型typedef struct &#123; Triple data[MAXSIZE + 1]; int mu, nu, tu; // 矩阵的行数、列数和非零元素个数&#125; TSMatrix; // 稀疏矩阵类型//转置Status TransposeSMatrix(TSMatrix M, TSMatrix *T)&#123; *T-&gt;mu = M.nu; *T-&gt;nu = M.mu; *T-&gt;tu = M.tu; if(*T-&gt;tu)&#123; int q = 1; for(int col = 1; col &lt;= M.nu; col++)&#123; for(int p = 1; p &lt;= M.tu; p++ )&#123; if(M.data[p].j = col)&#123; *T-&gt;data[q]-&gt;i = M.data[p].j; *T-&gt;data[q]-&gt;j = M.data[p].i; *T-&gt;data[q]-&gt;e = M.data[p].e; q++; &#125; &#125; &#125; &#125; return OK;&#125;//TransposeSMatrix//快速转置算法Status FastTransposeSMatrix(TSMatrix M, TSMatrix *T)&#123; *T-&gt;mu = M.nu; *T-&gt;nu = M.mu; *T-&gt;tu = M.tu; int num[M.nu], cpot[M.nu]; if(*T-&gt;tu)&#123; for(int col = 1; col &lt;＝ M.nu; ++col)&#123; num[col] = 0; &#125; for(int t = 1; t &lt;= M.tu; t++)&#123; ++num[M.data[t].j];//求M中每一列含非零元素的个数 &#125; cpot[1] = 1; for(int col = 2; col &lt;= M.nu; col++)&#123; cpot[col] = cpot[col - 1] + num[col - 1];//求第col列第一个非零元素在b.data中的序号 &#125; for(int p = 1, int col; p &lt; M.tu; p++)&#123; col = M.data[p].j; q = cpot[col]; *T-&gt;data[q]-&gt;i = M.data[p].j; *T-&gt;data[q]-&gt;j = M.data[p].i; *T-&gt;data[q]-&gt;e = M.data[p].e; ++ cpot[col]; &#125;//for &#125;//if&#125;//FastTransposeSMatrix 行逻辑联接的顺序表 三元组顺序表又称有序的双下标法,它的特点是,非零元在表中按行序有序存储,因此便于进行依行顺序处理的矩阵运算。然而,若需随机存取某一行中的非零元,则需从头开始进行查找。 修改前述的稀疏矩阵的结构定义,增加一个数据成员rpos ,指示各行第一个非零元素的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 #define MAXMN 500typedef struct &#123; Triple data[MAXSIZE + 1]; //非零元三元组表 int rpos[MAXMN + 1]; // 各行第一个非零元的位置表 int mu, nu, tu;&#125; RLSMatrix; // 行逻辑链接顺序表类型//两个稀疏矩阵相乘Status MultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix *Q)&#123; if(M.nu != N.mu) return ERROR; //不能相乘，出错 *Q-&gt;mu = M.mu; *Q-&gt;nu = N.nu; *Q-&gt;tu = 0; //Q初始化 if(M.tu * N.tu != 0)&#123; int arow ; int i, j; int tp, p, q; int brow, t; int ctemp[N.nu]; for(arow = 1; arow &lt;= M.nu; arow++)&#123; for(i = 0; i &lt; N.nu; i++) ctemp[i] = 0; *Q-&gt;rpos[arow] = Q.tu + 1; if(arow &lt; M.tu) tp = M.rpos[arow + 1]; else tp = M.tu + 1; for(p = M.rpos[arow]; p &lt; tp; p++)&#123; brow = M.data[p].j;//对当前行非零元，找到在N中的行号 if(brow &lt; N.mu) t = N.rpos[brow + 1]; else t = N.tu + 1; for(q = N.rpos[brow]; q &lt; t; q++)&#123; ccol = N.data[q].j; ctemp[ccol] += M.data[p].e * M.data[q].e; &#125; //for q &#125; //求Q中第arow行的非零元 for(ccol = 1; ccol &lt;= *Q-&gt;nu; ccol++)//压缩存储该行非零元素 if(ctemp[ccol])&#123; if(++*Q-&gt;tu &gt; MAXSIZE) return ERROE; *Q-&gt;data[*Q-&gt;tu]-&gt;i = arow; *Q-&gt;data[*Q-&gt;tu]-&gt;j = ccol; *Q-&gt;data[*A-&gt;tu]-&gt;e = ctemp[ccol]; &#125;//if &#125;//for arow &#125;//if return OK;&#125;//MultSMatrix 十字链表 当矩阵的非零元个数和位置在操作中变化较大时 [ 例如矩阵的加法 ] ,就不宜采用顺序存储结构来表示三元组的线性表,而是采用链式存储结构表示三元组的线性表。 每个非零元由一个含 5个域的节点表示( i , j, e, right, down )： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 typedef struct OLNode&#123; int i, j; //该非零元的行和列下标 ElemType e; struct OLNODE *right, *down; //该非零元所在行表和列表的后继链域&#125; OLNode; *Olink;typedef struct&#123; OLink *rhead, *chead; //行和列链表头指针向量 int mu, nu, tu;&#125;CrossList;//创建采用十字链存储的稀疏矩阵Status CreateSMatrix_OL(CrossList *M)&#123; //if(M) //free(M); int m, n, t; int i, j, e; scanf(\"%d%d%d\",&amp;m, &amp;n, &amp;t); *M-&gt;mu = m; *M-&gt;nu = n; *M-&gt;tu = t; M-&gt;rhead = (OLink *) malloc ((m + 1) * sizeof(OLink)); M-&gt;chead = (OLink *) malloc ((n + 1) * sizeof(OLink)); if(!M-&gt;rhead || !M-&gt;chead) exit(OVERFLOW);//存储分配失败 for(i = 0; i &lt;= m; i++) M-&gt;rhead[i] = NULL; for(i = 0; i &lt;= n; i++) M-&gt;chead[i] = NULL;//初始化行列表头指针向量 for(scanf(\"%d%d%d\",&amp;i,&amp;j,&amp;e);i!=0;scanf(\"%d%d%d\",&amp;i,&amp;j,&amp;e))&#123; OLNode *p, *q; p = (OLNode *) malloc (sizeof(OLnode)); if(!p) exit(OVERFLOW); p-&gt;i = i; p-&gt;j = j; p-&gt;e = e;//生成节点 if(M-&gt;rhead[i] == NULL || M-&gt;rhead[i]-&gt;j &gt; j)&#123;//寻找在行表中的插入位置 p-&gt;right = M-&gt;rhead[i]; M-&gt;rhead[i] = p; &#125; else&#123; for(q = M-&gt;rhead[i]; q-&gt;right &amp;&amp; q-&gt;right-&gt;j &lt; j; q = q-&gt;right) ; p-&gt;right = q-&gt;right ; q-&gt;right = p; &#125;//完成行插入 if(M-&gt;chead[j] == NULL || M-&gt;chead[j]-&gt;i &gt; i)&#123; p-&gt;down = M.chead[j]; M-&gt;chead[j] = p; &#125;//寻找在列表中的插入位置 else&#123; for(q = M-&gt;head[j]; q-&gt;down &amp;&amp; q-&gt;down-&gt;i &lt; i; q = q-&gt;down); p-&gt;down = q-&gt;down; q-&gt;down = p; &#125;//完成列插入 &#125;//for return OK;&#125;//CreateSMatrix_OL 广义表 广义表是递归定义的线性结构。 当 LS 非空时, 表的第一个表元素称为广义表的表头( head ), 而其它表元素组成的表称为广义表的表尾( tail )。 广义表的存储结构 广义表的数据元素具有不同的结构,且是一个带深度的层次结构。因此难以用顺序存储结构来存放,而是采用链式存储结构。 构造存储结构的两种分析方法 : 表头、表尾分析法 子表分析法 表头表尾分析法：若广义表不空,则可分解为表头和表尾;反之,一对确定的表头和表尾可唯一确定广义表 123456789 typedef enum&#123;ATOM, LIST&#125; ElemTag;typedef struct GLNode &#123; ElemTag tag;// = ATOM or = LIST union &#123;// 原子结点和表结点的联合部分 AtomType atom; struct &#123;struct GLNode *hp, *tp;&#125; ptr;//ptr.hp,ptr.tp分别指向表头和表尾&#125;&#125; *GList; 子表分析法： 12345678910 typedef enum&#123;ATOM, LIST&#125; ElemTag;typedef struct GLNode &#123; ElemTag tag;// = ATOM or = LIST union &#123;// 原子结点和表结点的联合部分 AtomType atom; struct GLNode *hp; &#125;; struct GLNode *tp;// 相当于线性链表的 next&#125; *GList; m 元多项式的表示： 123456789 typedef struct MPNode &#123; ElemTag tag; int exp; // 指数域 union &#123;// 原子结点和表结点的联合部分 float coef; // 系数域 struct GLNodex *hp; &#125;; struct MPNode *tp ; // 相当于线性链表的 next&#125; *Mplist; //m 元多项式广义表类型定义 广义表操作得递归函数 利用递归算法分而治之的思想,递归算法设计中的关键问题是,如何将 一个子问题的解组合成原问题的解。 求广义表的深度 将广义表 LS (a1 , a2 , a3 , ..., an ) 分解成 n 个子表,分别 ( 递归 ) 求得每个子表的深度 。 广义表的深度 =Max { 子表的深度 } +1 DEPTH(LS)的递归定义： 基本项 当 LS 为空表时，DEPTH(LS) = 1; 当 LS 为原子时，DEPTH(LS) = 0; 归纳项 DEPTH(LS) = 1 + Max{DEPTH(ai)} i = 1,2,...,n 12345678910111213141516 int GListDepth(GList L)&#123;//采用头尾链表存储结构 int max; int dep; if(!L)&#123; return 1;//空表深度为1 &#125; if(L-&gt;tag == ATOM)&#123; return 0;//原子深度为0 &#125; for(max = 0, GList pp = L; pp; pp = pp-&gt;ptr.tp)&#123; dep = GListDepth(pp-&gt;ptr.hp); if(dep &gt; max) max = dep; &#125; return max + 1;&#125;//GListDepth 复制广义表 将广义表分解成表头和表尾两部分,分别 ( 递归 ) 复制求得新的表头和表尾。 新的广义表由新的表头和表尾构成。 基本项 : InitGList(NEWLS) 当LS 为空表 递归项: COPY(表头) { 复制表头 } COPY(表尾) { 复制表尾 } 1234567891011121314151617 Status CopyGList(GList *T, GList L)&#123;//由L复制得T if(!L)&#123; T = NULL;//复制空表 &#125; else&#123; if(!(T = (GList)malloc(sizeof(GLNode)))) exit(OVERFLOW); *T-&gt;tag = L-&gt;tag; if(L-&gt;tag == ATOM) *T-&gt;atom = L-&gt;atom; else&#123; CopyGList(*T-&gt;ptr.hp, L-&gt;ptr.hp); CopyGList(*T-&gt;ptr.tp, L-&gt;ptr.tp); &#125;//else &#125;//else return OK;&#125;//CopyGList 建立广义表的存储结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //伪代码Status CreateGList(GList &amp;L, SString S)&#123; if(StrCompare(S, emp)) L = NULL; //emp = \"()\" else&#123; if(!(L = (GList)malloc(sizeof(GLNode)))) exit(OVERFLOW);//建立表节点 if(StrLength(S) == 1)&#123; L-&gt;tag = ATOM; L-&gt;atom = S; &#125; else&#123; L-&gt;tag = LIST; p = L; SubString(sub, 2, StrLength(S) - 2); do&#123;//重复建立n个子表 sever(sub, hsub);//从sub中分离出表头串hsub CreateGList(p-&gt;ptr.hp, hsub); q = p; if(!StrEmpty(sub))&#123;//表尾不空 if(!(p = (GLNode *)malloc(sizeof(GLNode)))) exit(OVERFLOW); p-&gt;tag = LIST; q-&gt;ptr.tp = p; &#125;//if &#125; while(!StrEmpty(sub)); q-&gt;ptr.tp = NULL &#125;//else &#125;//else return OK;&#125;//CreateGListStatus sever(SString &amp;str, SString &amp;hstr)&#123; n = StrLength(str); i = 0; k = 0; do&#123; ++i; SubString(ch, str, i, 1); if(ch == '()') ++k; else if(ch == ')') --k; &#125;while(i &lt; n &amp;&amp; (ch != ','|| k != 0)); if(i &lt; n)&#123; SubString(hstr, str, 1, i - 1); SubString(str, str, i + 1, n - i); &#125; else&#123; StrCopy(hstr, str); ClearString(str); &#125;&#125;//sever var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"NMAP 常用扫描简介（二）","date":"2017-04-12T15:43:15.000Z","path":"2017/04/12/NMAP-Comman-Scan-Introduction-2/","text":"在我们之前的 NMAP 安装一文中，列出了 10 种不同的 ZeNMAP 扫描模式，大多数的模式使用了不同的参数。各种不同参数代表执行不同的扫描模式。这篇文章将介绍最后剩下的两种常用扫描类型。 四种通用扫描类型 下面列出了最常用的四种扫描类型： PING 扫描（-sP） TCP SYN 扫描（-sS） TCP Connect() 扫描（-sT） UDP 扫描（-sU） 当我们利用 NMAP 来执行扫描的时候，这四种扫描类型是我们需要熟练掌握的。更重要的是需要知道这些命令做了什么，并且需要知道这些命令是怎么做的。在这篇文章中将介绍两种 TCP 扫描 — TCP SYN 扫描和 TCP Connect() 扫描。 (阅读 NMAP 常用扫描简介（一）) TCP SYN 扫描 （-sS） TCP SYN 扫描是默认的 NMAP 扫描方式。为了运行 TCP SYN 扫描，你需要有 Root 权限。 TCP SYN 扫描的目的是找到被扫描系统上的已开启端口。使用 NMAP 扫描可以扫描在防火墙另一侧的系统。当扫描通过防火墙时，扫描时间会延长，因为数据包会变慢。 TCP SYN 扫描的工作方式是启动一个“三次握手”。正如在另一篇文章中所述，“三次握手”发生在两个系统之间。首先，源系统发送一个包到目标系统，这是一个同步（SYN）请求。然后，目标系统将通过同步/应答（SYN/ACK）响应。接下来，源系统将通过应答（ACK）来响应，从而建立起一个通信连接，然后，可以在两个系统之间传输数据。 TCP SYN 扫描通过执行下面的步骤来进行工作： 源系统向目标系统发送一个同步请求，该请求中包含一个端口号。 如果添加在上一步中的所请求的端口号是开启的，那么目标系统将通过同步/应答（SYN/ACK）来响应源系统。 源系统通过重置（RST）来响应目标系统，从而断开连接。 目标系统可以通过重置/应答（RST/ACK）来响应源系统。 这种连接已经开始建立，所以这被认为是半开放连接。因为连接状态是由 NMAP 来管理的，所以你需要有 Root 权限。 如果被扫描的端口是关闭的，那么将执行下面的步骤： 源系统发送一个同步（SYN）请求到目标系统，该请求中包含一个端口号。 目标系统通过重置（RST）响应源系统，因为该端口是关闭的。 如果目标系统处于防火墙之后，那么 ICMP 传输或响应会被防火墙禁止，此时，会执行下面的步骤： 源系统发送一个同步（SYN）请求到目标系统，该请求中包含一个端口号。 没有任何响应，因为请求被防火墙过滤了。 在这种情况下，端口可能是被过滤、或者可能打开、或者可能没打开。防火墙可以设置禁止指定端口所有包的传出。防火墙可以禁止所有传入某个指定端口的包，因此目标系统不会接收到请求。 注：无响应可能发生在一个启用了防火墙的系统上。即使在本地网络，你也可能会发现被过滤的端口。 我将向 图片１那样执行对单一系统（10.0.0.2）的 TCP SYN 扫描。使用命令 sudo nmap -sS &lt;IP 地址&gt; 来执行扫描。&lt;IP 地址&gt;可以改为一个单一 IP 地址，像图片１那样，也可以使用一组 IP 地址。 图片１ 你可以看到它表明 997 个被过滤端口没有显示在下面。NMAP 找到两个开启的端口：139 和 445 。 注：请记住，NMAP 只会扫描绝大多数熟知的 1000 多个端口。以后，我们会介绍可以扫描所有端口或者指定端口的其它扫描。 该扫描会被 WireShark 俘获，正如图片２所展示的那样。在这儿，你可以看到对目标系统的初始地址解析协议（ARP）请求。在 ARP 请求下面的是一长列到达目标系统端口的 TCP 请求。第 4 行是到达 http-alt 端口（8080）。源系统的端口号为 47128 。正如图片３ 展示的，许多 SYN 请求只有在做出响应以后才会发送。 图片２ 图片３ 在图片３的第 50 行和第 51 行，你可以看到，重置（RST）包被发送给了目标系统。第 53 行和第 55 行显示目标系统的 RST/ACK（重置/应答）。第 50 行是针对 ‘microsoft-ds’ 端口（445），第 51 行是针对 ‘netbios-ssn’ 端口（135），我们可以看到，这两个端口都是打开的。（LCTT 译注：在 50 行和 51 行之前，目标系统发回了 SYN/ACK 响应，表示端口打开。）除了这些端口，没有其他 ACK（应答）是来自目标系统的。每一个请求均可发送超过 1000 次。 正如图片４所展示的，目标系统是 Windows 系统，我关闭了系统防火墙，然后再次执行扫描。现在，我们看到了 997 个已关闭端口不是 997 个被过滤端口。目标系统上的 135 端口之前被防火墙禁止了，现在也是开启的。 图片４ TCP Connect() 扫描 （-sT） 尽管 TCP SYN 扫描需要 Root 权限，但 TCP Connect() 扫描并不需要。在这种扫描中会执行一个完整的“三次握手”。因为不需要 Root 权限，所以在无法获取 Root 权限的网络上，这种扫描非常有用。 TCP Connect() 扫描的工作方式也是执行“三次握手”。正如上面描述过的，“三次握手”发生在两个系统之间。源系统发送一个同步（SYN）请求到目标系统。然后，目标系统将通过同步／应答（SYN/ACK）来响应。最后，源系统通过应答（ACK）来响应，从而建立起连接，然后便可在两个系统之间传输数据。 TCP Connect 扫描通过执行下面的步骤来工作： 源系统发送一个同步（SYN）请求到目标系统，该请求中包含一个端口号。 如果上一步所请求的端口是开启的，那么目标系统将通过同步/应答（SYN/ACK）来响应源系统。 源系统通过应答（ACK）来响应目标系统从而完成会话创建。 然后，源系统向目标系统发送一个重置（RST）包来关闭会话。 目标系统可以通过同步/应答（SYN/ACK）来响应源系统。 若步骤 2 执行了，那么源系统就知道在步骤 1 中的指定端口是开启的。 如果端口是关闭的，那么会发生和 TCP SYN 扫描相同的事。在步骤 2 中，目标系统将会通过一个重置（RST）包来响应源系统。 可以使用命令 nmap -sT &lt;IP 地址&gt; 来执行扫描。&lt;IP 地址&gt;可以改为一个单一 IP 地址，像图片５那样，或者使用一组 IP 地址。 TCP Connect() 扫描的结果可以在图片５中看到。在这儿，你可以看到，有两个已开启端口：139 和 445，这和 TCP SYN 扫描的发现一样。端口 80 是关闭的。剩下没有显示的端口是被过滤了的。 图片５ 让我们关闭防火墙以后再重新扫描一次，扫描结果展示在图片６中。 图片６ 关闭防火墙以后，我们可以看到，更多的端口被发现了。就和 TCP SYN 扫描一样，关闭防火墙以后，发现 139 端口和 445 端口是开启的。我们还发现，端口 2869 也是开启的。也发现有 996 个端口是关闭的。现在，端口 80 是 996 个已关闭端口的一部分 — 不再被防火墙过滤。 在一些情况下， TCP Connect() 扫描可以在一个更短的时间内完成。和 TCP SYN 扫描相比，TCP Connect() 扫描也可以找到更多的已开启端口 via: https://www.linuxforum.com/threads/nmap-common-scans-part-two.3879/ 作者：Jarret译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"此去经年，应是良辰好景虚设","date":"2017-04-05T13:31:46.000Z","path":"2017/04/05/Miss-You/","text":"前言 如果要我用一句话来形容你是我的什么人那么我会说你是此生唯一的、最最珍贵的知心爱人！ 正文 寒蝉凄切，对长亭晚，骤雨初歇都门帐饮无绪，留恋处，兰舟催发 执手相看泪眼，竟无语凝噎念去去，千里烟波，暮霭沉沉楚天阔 多情自古伤离别，更那堪，冷落清秋节今宵酒醒何处？ 杨柳岸，晓风残月 此去经年，应是良辰好景虚设便纵有千种风情，更与何人说？ －《柳永》 高中的时候，第一次读到《雨霖铃》那时候，并无太多感觉 直到有一天，自己开始了一段无比真挚的爱情并且是一段相距两千公里的爱情我才体会到了词中那份不舍之痛 2017 年 2 月 16 日晚在从昆明去往北京的 Z162 火车上我泪流满面 2017 年 4 月 4 日在从昆明飞往北京的 KN5212 航班上我又一次泪流满面 再次读到《雨霖铃》词中情景竟和我无甚区别 那一句“执手相看泪眼，竟无语凝噎”若非亲自体会怎能知其中滋味 无论何时每当想起分别时刻还是会流泪满面 ４日下午到达北京时北京的天空灰得像哭过 没人喜欢异地恋我也一样但我喜欢你 我舍不得放开你舍不得离开你你也一样 我想一辈子和你在一起你也一样 如果要我用一句话来形容你是我的什么人那么我会说你是此生唯一的、最最珍贵的知心爱人！ 回忆 过去，你以为我喜欢拍照后来，我告诉你只有和你在一起时，我才喜欢拍照： 2017-04-02中午，昆明市君莱酒店 2017-04-03中午，呈贡区傣族人家 2017-04-03中午，呈贡区朝云街 2017-04-03下午，云南中医学院食堂 2017-04-04早，昆明地铁一号线 2017-04-04早，从南部客运站去往长水机场的大巴 2017-04-04早，昆明长水国际机场 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Vim 中进行文本选择操作和使用标志","date":"2017-04-05T13:27:50.000Z","path":"2017/04/05/Text-Select-and-Use-Flag-in-Vim/","text":"基于图形界面的文本或源代码编辑器，提供了一些诸如文本选择的功能。我是想说，可能大多数人不觉得这是一个功能。不过像 Vim 这种基于命令行的编辑器就不是这样。当你仅使用键盘操作 Vim 的时候，就需要学习特定的命令来选择你想要的文本。在这个教程中，我们将详细讨论文本选择这一功能以及 Vim 中的标志功能。 在此之前需要说明的是，本教程中所提到的例子、命令和指令都是在 Ubuntu 16.04 的环境下测试的。Vim 的版本是 7.4。 Vim 的文本选择功能 我们假设你已经具备了 Vim 编辑器的基本知识（如果没有，可以先阅读这篇文章）。你应该知道，d 命令能够剪切/删除一行内容。如果你想要剪切 3 行的话，可以重复命令 3 次。不过，如果需要剪切 15 行呢？重复 d 命令 15 次是个实用的解决方法吗？ 显然不是。这种情况下的最佳方法是，选中你想要剪切/删除的行，再运行 d 命令。举个例子： 假如我想要剪切/删除下面截图中 INTRODUCTION 小节的第一段： 那么我的做法是：将光标放在第一行的开始，（确保退出了 Insert 模式）按下 V（即 Shift+v）命令。这时 Vim 会开启视图模式，并选中第一行。 现在，我可以使用方向键“下”，来选中整个段落。 这就是我们想要的，对吧！现在只需按 d 键，就可以剪切/删除选中的段落了。当然，除了剪切/删除，你可以对选中的文本做任何操作。 这给我们带来了另一个重要的问题：当我们不需要删除整行的时候，该怎么做呢？也就是说，我们刚才讨论的解决方法，仅适用于想要对整行做操作的情况。那么如果我们只想删除段落的前三句话呢？ 其实也有相应的命令 - 只需用小写 v 来代替大写 V 即可。在下面的例子中，我使用 v 来选中段落的前三句话： 有时候，你需要处理的数据由单独的列组成，你的需求可能是选择特定的一列。考虑下面的截图： 假设我们只需选择文本的第二列，即国家的名字。这种情况下，你可以将光标放在这一列的第一个字母上，按 Ctrl+v 一次。然后，按方向键“下”，选中每个国家名字的第一个字母： 然后按方向键“右”，选中这一列。 小窍门：如果你之前选中了某个文本块，现在想重新选中那个文本块，只需在命令模式下按 gv 即可。 使用标志 有时候，你在处理一个很大的文件（例如源代码文件或者一个 shell 脚本），可能想要切换到一个特定的位置，然后再回到刚才所在的行。如果这两行的位置不远，或者你并不常做这类操作，那么这不是什么问题。 但是，如果你需要频繁地在当前位置和一些较远的行之间切换，那么最好的方法就是使用标志。你只需标记当前的位置，然后就能够通过标志名，从文件的任意位置回到当前的位置。 在 Vim 中，我们使用 m 命令紧跟一个字母来标记一行（字母表示标志名，可用小写的 a - z）。例如 ma。然后你可以使用命令 &#39;a （包括左侧的单引号）回到标志为 a 的行。 小窍门：你可以使用“单引号” &#39; 来跳转到标志行的第一个字符，或使用“反引号” ` 来跳转到标志行的特定列。 Vim 的标志功能还有很多其他的用法。例如，你可以先标记一行，然后将光标移到其他行，运行下面的命令： 1 d'[标志名] 来删除当前位置和标志行之间的所有内容。 在 Vim 官方文档中，有一个重要的内容： 每个文件有一些由小写字母（a-z）定义的标志。此外，还存在一些由大写字母（A-Z）定义的全局标志，它们定义了一个特定文件的某个位置。例如，你可能在同时编辑十个文件，每个文件都可以有标志 a，但是只有一个文件能够有标志 A。 我们已经讨论了使用小写字母作为 Vim 标志的基本用法，以及它们的便捷之处。下面的这段摘录讲解的足够清晰： 由于种种局限性，大写字母标志可能乍一看不如小写字母标志好用，但它可以用作一种快速的文件书签。例如，打开 .vimrc 文件，按下 mV，然后退出。下次再想要编辑 .vimrc 文件的时候，按下 &#39;V 就能够打开它。 最后，我们使用 delmarks 命令来删除标志。例如： 1 :delmarks a 这一命令将从文件中删除一个标志。当然，你也可以删除标志所在的行，这样标志将被自动删除。你可以在 Vim 文档 中找到关于标志的更多信息。 总结 当你开始使用 Vim 作为首选编辑器的时候，类似于这篇教程中提到的功能将会是非常有用的工具，能够节省大量的时间。你得承认，这里介绍的文本选择和标志功能几乎不怎么需要学习，所需要的只是一点练习。 via: https://www.howtoforge.com/tutorial/how-to-use-markers-and-perform-text-selection-in-vim/ 作者：Himanshu Arora译者：Cathon校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"10 个常见的 Linux 终端仿真器","date":"2017-04-05T13:23:58.000Z","path":"2017/04/05/10-Common-Linux-Teminator/","text":"对于 Linux 用户来说，最重要的应用程序之一就是终端仿真器。它允许每个用户获得对 shell 的访问。而 Bash 是 Linux 和 UNIX 发行版中最常用的 shell，它很强大，对于新手和高级用户来说，掌握 bash 都很有必要。因此，在这篇文章中，你可以了解 Linux 用户有哪些优秀的终端仿真器可以选择。 1、Terminator 这个项目的目标是创造一个能够很好排列终端的有用工具。它受到一些如 gnome-multi-term、quadkonsole 等程序的启发，重点是以网格的形式排列终端。 特性浏览 以网格形式排列终端 Tab 设定 通过拖放重新排布终端 大量的快捷键 通过 GUI 参数编辑器保存多个布局和配置文件 同时对任意组合的终端进行输入 你可以通过下面的命令安装 Terminator： 1 sudo apt-get install terminator 2、Tilda － 一个可以下拉的终端 Tilda 的独特之处在于它不像一个普通的窗口，相反，你可以使用一个特殊的热键从屏幕的顶部拉下和收回它。另外，Tilda 是高度可配置的，可以自定义绑定热键，改变外观，以及其他许多能够影响 Tilda 特性的选项。 在 Ubuntu 和 Fedora 上都可以使用包管理器安装 Tilda，当然，你也可以查看它的 GitHub 仓库。 3、Guake Guake 是一个和 Tilda 或 yakuake 类似的下拉式终端仿真器。如果你知道一些关于 Python、Git 和 GTK 的知识的话，你可以给 Guake 添加一些新的特性。​Guake 在许多发行版上均可用，所以如果你想安装它，你可以查看你的版本仓库。 特性浏览 轻量 简单易用且优雅 将终端自然地集成到 GUI 之中 当你使用的时候出现，一旦按下预定义热键便消失（默认情况下是 F12） 支持Compiz 透明 多重 Tab 丰富的调色板 还有更多…… 主页: http://guake-project.org/ 4、ROXTerm 如果你正在寻找一个轻量型、高度可定制的终端仿真器，那么 ROXTerm 就是专门为你准备的。这是一个旨在提供和 gnome-terminal 相似特性的终端仿真器，它们都基于相同的 VTE 库。它的最初设计是只占用很小的资源并且能够快速启动，它具有比 gnome-terminal 更强的可配置性，更加针对经常使用终端的 “Power” 用户。 http://roxterm.sourceforge.net/index.php?page=index&amp;lang=en 5、XTerm Xterm 是 Linux 和 UNIX 系统上最受欢迎的终端仿真器，因为它是 X 窗口系统的默认终端仿真器，并且很轻量、很简单。 6、Eterm 如果你正在寻找一个漂亮、强大的终端仿真器，那么 Eterm 是你最好的选择。Eterm 是一个彩色 vt102 终端仿真器，被当作是 Xterm 的替代品。它按照自由选择的哲学思想进行设计，将尽可能多的权利、灵活性和自由交到用户手中。 官网： http://www.eterm.org/ 7、Gnome Terminal Gnome Terminal 是最受欢迎的终端仿真器之一，它被许多 Linux 用户使用，因为它默认安装在 Gnome 桌面环境中，而 Gnome 桌面很常用。它有许多特性并且支持大量主题。 在许多 Linux 发行版中都默认安装有 Gnome Terminal，但你如果没有的话，也可以使用你的包管理器来安装它。 8、Sakura Sakura 是一个基于 GTK 和 VTE 的终端仿真器。它是一个只有很少依赖的终端仿真器，所以你不需要先安装一个完整的 GNOME 桌面才能有一个像样的终端仿真器。 你可以使用你的包管理器来安装它，因为 Sakura 在绝大多数发行版中都是可用的。 9、LilyTerm LilyTerm 是一个基于 libvte 的终端仿真器，旨在快速和轻量，是 GPLv3 授权许可的。 特性浏览 低资源占用 多重 Tab 配色方案丰富 支持超链接 支持全屏 还有更多的…… 10、Konsole 如果你是一名 KDE 或 Plasma 用户，那么你一定知道 Konsole，因为它是 KDE 桌面的默认终端仿真器，也是我最喜爱的终端仿真器之一，因为它很舒适易用。 它在 Ubuntu 和 fedora 上均可用，但如果你在使用 Ubuntu (Unity)，那么你需要选择别的终端仿真器，或者你可以考虑使用 Kubuntu 。 结论 我们是 Linux 用户，根据自己的需求，可以有许多选择来挑选更好的应用。因此，你可以选择最好的终端来满足个人需求，虽然你也可以选择另一个 shell 来满足个人需求，比如你也可以使用 fish shell。 via: http://www.linuxandubuntu.com/home/10-best-linux-terminals-for-ubuntu-and-fedora 作者：Mohd Sohail译者：ucasFL校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"串 - Part 2","date":"2017-03-27T00:50:38.000Z","path":"2017/03/27/String-Part2/","text":"Brute-force 算法 将主串 S 的第 pos 个字符和模式串 P 的第 1个字符比较 若相等,继续逐个比较后续字符; 若不等,则从主串 S 的 (pos+1) 字符起,重新与 P 第 1 个字符比较。 直到主串 S 的一个连续子串字符序列与模式串 P 相等。这时匹配成功,返回 S 与 P匹配的子序列第一个字符的序号,否则,匹配失败,返回值 0 。 KMP 算法 每当一趟匹配过程中出现字符比较不相等时,不回溯主串指针,而是将模式串向右滑动恰当位置,继续比较。 挖掘了模式串内在的关联信息 消除了每趟失配后为实施下一趟比较时对主串指针的回退,避免了对已被匹配过的字符的再检查 提高了模式匹配效率 令主串的长度是 n ,模式串的长度是 m ,则算法的时间复杂度: O(m+n) 引入 next 数组/next 特征向量 next[j] = k ,表示在模式串 P 的 P[0,j) 中,自匹配的真前缀和真后缀的 ( 最大 ) 长度为 k； 当模式串 P 中第 j 个字符与主串 S 中相应字符失配时,在下一次匹配中,模式串 P 应当由 next[j] 位置的字符与主串中刚失配的字符重新继续进行比较； $next $数组的定义 / 给定模式串 P：设模式串 $P = p_0 p1 … p{m-2} p_{m-1}$• 令 SetX={0&lt;k&lt;j | P[0..k) = P[j-k .. j)}• ext[j] = max (SetX) 令 next[j] = k ,表示在模式串 P 的 P[0,j) 中,自匹配的真前缀和真后缀最大长度为 k：那么, next[j+1]= ?分两种情况: 情况 1 :当 P[j] = P[k] , next[j+1] = next[j]+1，即next[j+1]=k+1； 情况 2 :当 P[j] ≠ P[k] ,next[j+1] 等于 在P[0..next[j])的真前缀与 P[0..j+1) 中真后缀匹配的最大长度，即 next[j+1]=next[...next[j]...] +1； C 语言实现 12345678910111213141516171819202122232425262728293031 //计算next数组void GetNext(HString *pattern,int next[])&#123; int j,k; j=0; //j: 模式子串的位置 k= -1; //k: 模式自匹配指针 next[0]= -1; while(j&lt;pattern-&gt;length)&#123; if(k== -1 || pattern-&gt;ch[j] == pattern-&gt;ch[k])&#123; j++;k++; next[j]=k; &#125; // 失配 else k=next[k]; &#125;&#125;//时间复杂度为 O(m)//StrIndexKMPint StrIndexKMP(HString *s,HString *t,int pos) &#123; int next[INITSTRLEN]; GetNext(t,next); int i,j; i=pos-1;j=0; while(i&lt;s-&gt;length &amp;&amp; j&lt;t-&gt;length)&#123; if(j== -1 || s-&gt;ch[i] == t-&gt;ch[j])&#123; i++;j++; &#125; else j=next[j]; &#125; if(j&gt;=t-&gt;length) return i-t-&gt;length+1; else return 0;&#125; 对 next 数组的优化: nextval 将主串的 S[i] 、模式串的 P[k] 进行匹配。若 P[k]=P[j] ,那么匹配一定不成功,串还要右滑,滑到 next[k] 位置。所以,可以直接将 j 的 next 值改成next[k] 。 将 GetNext 中的 next[j]=k; 改成: 123 If(pattern-&gt;ch[j] == pattern-&gt;ch[k]) next[j]=next[k]; else next[j]=k; C 语言实现： 1234567891011121314 void GetNextVal(HString *pattern,int nextval[])&#123; int j,k; j=0;k= -1; nextval[0]= -1; while(j&lt;pattern-&gt;length)&#123; if(k== -1 || pattern-&gt;ch[j] == pattern-&gt;ch[k])&#123; j++;k++; if(pattern-&gt;ch[j] == pattern-&gt;ch[k]) nextval[j]=nextval[k]; else nextval[j]=k; &#125; else k=nextval[k]; &#125;&#125; var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"在独立的 Root 和 Home 硬盘驱动器上安装 Ubuntu","date":"2017-03-24T09:54:10.000Z","path":"2017/03/24/Install-Ubuntu-in-Seperate-Root-and-Home-Drive/","text":"安装 Linux 系统时，可以有两种不同的方式。第一种方式是在一个超快的固态硬盘上进行安装，这样可以保证迅速开机和高速访问数据。第二种方式是在一个较慢但很强大的普通硬盘驱动器上安装，这样的硬盘转速快并且存储容量大，从而可以存储大量的应用程序和数据。 然而，一些 Linux 用户都知道，固态硬盘很棒，但是又很贵，而普通硬盘容量很大但速度较慢。如果我告诉你，可以同时利用两种硬盘来安装 Linux 系统，会怎么样？一个超快、现代化的固态硬盘驱动 Linux 内核，一个容量很大的普通硬盘来存储其他数据。 在这篇文章中，我将阐述如何通过分离 Root 目录和 Home 目录安装 Ubuntu 系统 — Root 目录存于 SSD（固态硬盘）中，Home 目录存于普通硬盘中。 没有多余的硬盘驱动器？尝试一下 SD 卡（内存卡）！ 在多个驱动器上安装 Linux 系统是很不错的，并且每一个高级用户都应该学会这样做。然而，还有一种情况使得用户应该这样安装 Linux 系统 － 在低存储容量的笔记本电脑上安装系统。可能你有一台很便宜、没有花费太多的笔记本电脑，上面安装了 Linux 系统，电脑上没有多余的硬盘驱动，但有一个 SD 卡插槽。 这篇教程也是针对这种类型的电脑的。跟随这篇教程，可以为笔记本电脑买一个高速的 SD 卡来存储 Home 目录，而不是使用另一个硬盘驱动。本教程也适用于这种使用情况。 制作 USB 启动盘 首先去这个网站下载最新的 Ubuntu Linux 版本。然后下载 Etcher- USB 镜像制作工具。这是一个使用起来很简单的工具，并且支持所有主流的操作系统。你还需要一个至少有 2GB 大小的 USB 驱动器。 安装好 Etcher 以后，直接打开。点击 选择镜像Select Image 按钮来制作镜像。这将提示用户浏览、寻找 ISO 镜像，找到前面下载的 Ubuntu ISO 文件并选择。然后，插入 USB 驱动器，Etcher 应该会自动选择它。之后，点击 “Flash!” 按钮，Ubuntu 启动盘的制作过程就开始了。 为了能够启动 Ubuntu 系统，需要配置 BIOS。这是必需的，这样计算机才能启动新创建的 Ubuntu 启动盘。为了进入 BIOS，在插入 USB 的情况下重启电脑，然后按正确的键（Del、F2 或者任何和你的电脑相应的键）。找到从 USB 启动的选项，然后启用这个选项。 如果你的个人电脑不支持 USB 启动，那么把 Ubuntu 镜像刻入 DVD 中。 安装 当用启动盘第一次加载 Ubuntu 时，欢迎界面会出现两个选项。请选择 “安装 Ubuntu” 选项。在下一页中，Ubiquity 安装工具会请求用户选择一些选项。这些选项不是强制性的，可以忽略。然而，建议两个选项都勾选，因为这样可以节省安装系统以后的时间，特别是安装 MP3 解码器和更新系统。（LCTT 译注：当然如果你的网速不够快，还是不要勾选的好。） 勾选了“准备安装 Ubuntu”Preparing to install Ubuntu页面中的两个选项以后，需要选择安装类型了。有许多种安装类型。然而，这个教程需要选择自定义安装类型。为了进入自定义安装页面，勾选“其他”something else选项，然后点击“继续”。 现在将显示 Ubuntu 自定义安装分区工具。它将显示任何/所有能够安装 Ubuntu 系统的磁盘。如果两个硬盘均可用，那么它们都会显示。如果插有 SD 卡，那么它也会显示。 选择用于 Root 文件系统的硬盘驱动器。如果上面已经有分区表，编辑器会显示出来，请使用分区工具把它们全部删除。如果驱动没有格式化也没有分区，那么使用鼠标选择驱动器，然后点击“新建分区表”new partition table。对所有驱动器执行这个操作，从而使它们都有分区表。（LCTT 译注：警告，如果驱动器上有你需要的数据，请先备份，否则重新分区后将永远丢失。） 现在所有分区都有了分区表（并已删除分区），可以开始进行配置了。在第一个驱动器下选择空闲空间，然后点击加号按钮来创建新分区。然后将会出现一个“创建分区窗口”。允许工具使用整个硬盘。然后转到“挂载点”Mount Point下拉菜单。选择 / （Root）作为挂载点，之后点击 OK 按钮确认设置。 对第二个驱动器做相同的事，这次选择 /home 作为挂载点。两个驱动都设置好以后，选择要放入引导装载器的驱动器，然后点击 “现在安装”install now，安装进程就开始了。 从这以后的安装进程是标准安装。创建用户名、选择时区等。 注： 你是以 UEFI 模式进行安装吗？如果是，那么需要给 boot 创建一个 512 MB 大小的 FAT32 分区。在创建其他任何分区前做这件事。确保选择 “/boot” 作为这个分区的挂载点。 如果你需要一个交换分区，那么，在创建用于 / 的分区前，在第一个驱动器上进行创建。可以通过点击 ‘+’ 按钮，然后输入所需大小，选择下拉菜单中的“交换区域”swap area来创建交换分区。 结论 Linux 最好的地方就是可以自己按需配置。有多少其他操作系统可以让你把文件系统分割在不同的硬盘驱动上？并不多，这是肯定的。我希望有了这个指南，你将意识到 Ubuntu 能够提供的真正力量。 安装 Ubuntu 系统时你会用多个驱动器吗？请在下面的评论中让我们知道。 via: https://www.maketecheasier.com/install-ubuntu-with-different-root-home-hard-drives/ 作者：Derrik Diener译者：ucasFL校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"串-Part1","date":"2017-03-22T15:08:32.000Z","path":"2017/03/22/String-Part1/","text":"概念 串 ( 即字符串, string) 是由零个或多个字符组成的有限序列。 串是一类特殊的线性表: 其逻辑结构和线性表极为相似,区别仅在于表中每个数据元素是一个字符; 组成串的字符少,字符数量可以很大,对串的操作种类多且复杂; 串的基本操作和线性表有很大差别: 在线性表的基本操作中,大多以“单个元素”作为操作对象; 在串的基本操作中,通常以“串的整体”作为操作对象:在串中查找子串、插入子串删除子串、替换子串; S=&quot;a_1a_2a_3...a_n&quot; 串的名: s 串的值:双引号里的字符序列,但不包括双引号,双引号是定界符, ai 可以是字母、数字和其他字符 串的长度:串中字符的数目 n 字符在串中的位置:字符在串中的位序 空串 (null string) :零个字符的串,长度为 0 S=“” 空格串 (blank string) :由空格组成的串– S=“ ” 子串:串中任意个连续的字符组成的子序列 主串:包含子串的串 子串在主串中的位置是以子串的第一个字符在主串中的位置来表示的 空串是任意串的子串,任意串是其自身的子串 平凡 (trivial) 子串 vs. 真 (proper) 子串:字符串自身之外的所有非空子串 串的前缀:串中最靠前的若干个字符 串的后缀:串中最靠后的若干个字符 空串是任何串的前缀、后缀,任意串是其自身的前缀、后缀,平凡前缀,平凡后缀,真前缀,真后缀 串的相等:两个串相等当且仅当这两个串的值相等,即,两个串的长度相等,且对应位置的字符均相同 字符相等意味着字符所对应的 ascii 值相等 串的模式匹配 检测问题 /Detection :检测模式串是否出现 定位问题 /Location :首次在哪里出现 计数问题 /Counting :模式串在主串中出现了几次 枚举问题 /Enumeration :模式串分别出现在主串中的哪里 串的具体实现 顺序存储: 定长顺序存储表示:用一组地址连续的存储单元存储串值的字符序列,属静态存储方式 堆分配存储表示:用一组地址连续的存储单元存储串值的字符序列,但存储空间是在程序执行过程中动态分配而得到的 堆:自由存储区, C 语言的动态分配函数从中获得可用的存储空间 链式存储: 串的块链存储表示:链式方式存储 C 语言中的串处理 用字符数组存放串。 C 语言 中的串处理函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445 – char *gets(char *str) ; // 从 stdin 中读取串– int puts(char *str) ; // 向 stdout 输出串– int strlen(char *str); // 返回串的长度– char *strcpy(char *dest, char *src); // 复制串– char *strcat(char *dest, char *src); // 联接串– int strcmp(char *str1, char *str2); // 比较串,s1&lt;s2 时返回负数,相等返回 0 , s1&gt;s2 时返回正数– char *strstr(char *str,char *substr); // 返回子串首次出现的位置- strchr :检索并返回字符 c 在字符串 s 中第一次出现的位置- strrchr :检索并返回字符串 s 中最后一次出现给定字符c 的位置- strspn :检索并返回在 s1 和 s2 中均有的字符个数- strpbrk :检索并返回两个字符串中首个相同字符的位置- strupr :将字符串 s 中的小写字母全部转换成大写字母,并返回转换后的字符串- strlwr :将字符串 s 中的大写字母全部转换成小写字母,并返回转换后的字符串- strtol :将字符串 str 转换成长整型数,并返回这个数- strtod :将字符串 str 转换成双精度数,并返回这个数- strdup :将字符串 s 复制到新建的位置- strrev : 将字符串逆置- strtok :将字符串分割成由定界符隔离的一个个片段- strncat :将字符串 src 中最多 maxlen 个字符复制到字符串 dest 中- strncmp :比较字符串 s1 与 s2 中的前 maxlen 个字符- strncpy :复制 src 中的前 maxlen 个字符到 dest 中- stricmp :以不区分大小写的方式比较字符串 s1 和 s2, 并返回 s1-s2- strnicmp :以不区分大小写的方式比较字符串 s1 与s2 中的前 maxlen 个字符 C 语言实现 12345678910111213141516171819202122232425262728293031323334353637 • #define MAXSTRLEN 255• Typedef unsigned char SString[MAXSTRLEN+1];//串拼接 / 将 s1 和 s2 拼接成 tint StrConcat(SString t,SString s1,SString s2)&#123; int uncut; if (s1[0]+s2[0] &lt;= MAXSTRLEN) &#123; strncpy(&amp;t[1],&amp;s1[1],s1[0]); strncpy(&amp;t[s1[0]+1],&amp;s2[1],s2[0]); t[0]=s1[0]+s2[0]; t[t[0]+1]='\\0'; uncut= TRUE; &#125; else if(s1[0]&lt;MAXSTRLEN) &#123;// s2 被截断 strncpy(&amp;t[1],&amp;s1[1],s1[0]); strncpy(&amp;t[s1[0]+1],&amp;s2[1],MAXSTRLEN-s1[0]); t[0]=MAXSTRLEN; t[MAXSTRLEN+1]='\\0'; uncut=FALSE; &#125; else &#123; //s1[0] = MAXSTRLEN ,故 s2 被截断,仅取 s1 strncpy(&amp;t[1],&amp;s1[1],MAXSTRLEN); t[0]=MAXSTRLEN;t[MAXSTRLEN+1]='\\0'; uncut=FALSE; &#125; return uncut;&#125;// 将 s 中从第 pos 个字符开始的连续 len 个字符放到 sub 中Status StrSubStr(SString sub,SString s,int pos,int len) &#123; if(pos&lt;1 || pos&gt;s[0] || len&lt;0 ||len&gt; s[0]-pos+1) return ERROR; strncpy(&amp;sub[1],&amp;s[pos],len); sub[0]= len; sub[sub[0]+1]='\\0'; return OK;&#125; Brute-force 算法思想: 将主串 s 的第 pos 个字符和模式 t 的第 1 个字符比较 若相等,继续逐个比较后续字符; 若不等,则从主串 s 的 (pos+1) 字符起,重新与 t 第 1 个字符比较。 直到主串 s 的一个连续子串字符序列与模式 t 相等。返回值为 s 中与 T 匹配的子序列第一个字符的序号,即匹配成功,否则,匹配失败,返回值 0 。 123456789101112131415 //串匹配 / 模式匹配int StrIndex(SString s,SString t,int pos)&#123; int i,j; i=pos;j=1; while(i&lt;=s[0] &amp;&amp; j&lt;=t[0])&#123; if(s[i] == t[j]) &#123; i++;j++; &#125; // 继续比较后继字符 else &#123; i=i-j+2;j=1; &#125;// 指针 i 后退 ( 至当前匹配起始位置的下一位置 ) 重新开始匹配 &#125; if(j&gt;t[0]) return i-t[0];// 匹配成功,返回子串 t 的位置 else return 0;&#125; 顺序串 / 堆分配存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 //结构类型定义typedef struct &#123; char *ch; // 若是非空串,则按串长度 +1 分配存储区 int length; // 串长 int strsize; // 存储空间大小,包含串的结束符&#125; HString;//初始化Status StrInit(HString *s)&#123; s-&gt;ch = (char *)malloc(INITSTRLEN *sizeof(char)); if(!s-&gt;ch) return ERROR; s-&gt;ch[0]='\\0'; s-&gt;length = 0; s-&gt;strsize= INITSTRLEN; return OK;&#125;//获取串长度int StrLen(HString *s)&#123; return s-&gt;length;&#125;//判断串是否相等Status IsStrEqual(HString *s1,HString *s2)&#123; int i=0; for(i=0;i&lt;s1-&gt;length &amp;&amp; i&lt; s2-&gt;length; i++) if(s1-&gt;ch[i]!= s2-&gt;ch[i]) return ERROR; if (i&lt;s1-&gt;length || i&lt;s2-&gt;length) return ERROR; else return OK;&#125;//串比较int StrComp(HString *s,HString *t)&#123; for(i=0;i&lt;s-&gt;length &amp;&amp; i&lt;t-&gt;length;i++) if(s-&gt;ch[i] !=t-&gt;ch[i]) return (s-&gt;ch[i]-t-&gt;ch[i]); return s-&gt;length-t-&gt;length;&#125;// 将 s1,s2 拼接成 sStatus StrConcat(HString *s,HString *s1, HString *s2) &#123; int i; if(s-&gt;strsize &lt; (s1-&gt;length + s2-&gt;length)) &#123; s-&gt;ch = (char *)realloc(s-&gt;ch,(s1-&gt;length+s2-&gt;length+1)* sizeof(char)); if(!s-&gt;ch) return ERROR; s-&gt;strsize = s1-&gt;length + s2-&gt;length+1;&#125; i=0; while(i&lt;s1-&gt;length) &#123; s-&gt;ch[i]=s1-&gt;ch[i]; i++; &#125; while(i&lt;s1-&gt;length+s2-&gt;length) &#123; s-&gt;ch[i]=s2-&gt;ch[i-s1-&gt;length]; i++; &#125; s-&gt;ch[i]='\\0'; s-&gt;length = s1-&gt;length+s2-&gt;length; return OK;&#125;// 取子串,将 s 中从第 i 个字符开始的连续 j 个字符放到 subsStatus StrSubstr(HString *subs,HString *s,int i,int j)&#123; int k; if(i&lt;=0 || i&gt; s-&gt;length || j&lt;0 || j&gt;s-&gt;length -i +1) return ERROR; if(subs-&gt;strsize &lt; j) &#123; subs-&gt;ch =(char *)realloc(subs-&gt;ch,(j+1)*sizeof(char)); if(!subs-&gt;ch) return ERROR; subs-&gt;strsize =j+1; &#125; for(k=0;k&lt;j;k++) subs-&gt;ch[k] = s-&gt;ch[i-1+k]; subs-&gt;ch[j]='\\0'; subs-&gt;length=j; return OK;&#125;// 在 s 的第 i 个字符之前 (1&lt;=i&lt;=s-&gt;length+1) 插入字符串 tStatus StrInsert(HString *s,int i,HString *t) &#123; int j; if(i&lt;=0 || i&gt;s-&gt;length+1) return ERROR; // 位置不合法出错 if(s-&gt;strsize &lt; s-&gt;length + t-&gt;length)&#123; // 空间不够 s-&gt;ch = (char *)realloc(s-&gt;ch,(s-&gt;length+t-&gt;length)*sizeof(char)); if(!s-&gt;ch) return ERROR; s-&gt;strsize = s-&gt;length + t-&gt;length; &#125; for(j=s-&gt;length-1;j&gt;=i-1;j--) // 字符后移,腾挪空间 s-&gt;ch[j+t-&gt;length] = s-&gt;ch[j]; for(j=0;j&lt;t-&gt;length;j++) // 插入 t s-&gt;ch[i+j-1] = t-&gt;ch[j]; s-&gt;length +=t-&gt;length; return OK;&#125;// 串替换,将 s 从第 i 个字符开始 j 个连续字符用字符串 t 替换Status StrReplace(HString *s,int i,int j,HString *t)&#123; int k; if(i&lt;=0 || i&gt; s-&gt;length || j&lt;=0 || j&gt;s-&gt;length-i+1) return ERROR; if(j&lt;t-&gt;length) &#123; if(s-&gt;length+t-&gt;length-j&gt;s-&gt;strsize)&#123; s-&gt;ch =(char*)realloc(s-&gt;ch,(s-&gt;length+t-&gt;length-j+1)*sizeo(char)); if(!s-&gt;ch) return ERROR; s-&gt;strsize = s-&gt;length + t-&gt;length –j+1; &#125; for(k=s-&gt;length;k&gt;=i+j-1;k--) // 向后移,挪空间 s-&gt;ch[k-j+t-&gt;length] = s-&gt;ch[k]; &#125; else for(k=i-1+j;k&lt;s-&gt;length;k++) s-&gt;ch[k-j+t-&gt;length] = s-&gt;ch[k]; // 向前移 s-&gt;length = s-&gt;length + t-&gt;length -j; s-&gt;ch[s-&gt;length+1]='\\0'; for(k=0;k&lt;t-&gt;length;k++) s-&gt;ch[k+i-1] = t-&gt;ch[k]; return OK;&#125; 模式匹配 模式匹配:利用 HString 的基本操作:在主串 s 的第 pos 个字符之后寻找与t 相等的子串,找到则返回第一个这样的子串在 S 中的位置,否则返回 0 。t为模式串 12345678910111213141516 int StrIndex(HString *s,HString *t,int pos)&#123; int i,m,n; HString sub; StrInit (&amp;sub); if(pos&gt;0) &#123; i=pos;n=StrLen(s);m=StrLen(t); while(i&lt;=n-m+1) &#123; StrSubstr(&amp;sub,s,i,m); if(!IsStrEqual(&amp;sub,t)) i++; else return i; &#125; &#125; return 0;&#125; 字串替换 利用 HString 的基本操作，用 v 替换主串 s 中出现的所有与 t 相等的不叠的子串。 123456789101112131415161718192021 void StrRepSubstr(HString *s,HString *t,HString *v)&#123; int n,m,pos,i; HString newStr,sub; StrInit(&amp;newStr); StrInit(&amp;sub); n=StrLen(s);m=StrLen(t);pos=1; i=1; while(pos&lt;=n-m+1 &amp;&amp; i)&#123; i=StrIndex(s,t,pos); if(i!=0)&#123; StrSubstr(&amp;sub,s,pos,i-pos); //sub 存放 无需置换的子串 StrConcat(&amp;newStr,&amp;newStr,&amp;sub); StrConcat(&amp;newStr,&amp;newStr,v); pos=i+m; &#125; &#125; if(StrSubstr(&amp;sub,s,pos,n-pos+1)) StrConcat(s,&amp;newStr,&amp;sub); else StrCopy(s,&amp;newStr); return ;&#125; 块链存储 12345678910 #define CHUNKSIZE 80 // 每块大小,由用户定义typedef struct Chunk &#123; // 首先定义结点类型 char ch[CHUNKSIZE];// 每个结点中的数据域 struct Chunk * next ;// 每个结点中的指针域&#125; Chunk;typedef struct &#123; // 定义用链式存储的串类型 Chunk *head;// 头指针 Chunk *tail;// 尾指针 int curLen;// 结点个数&#125; LString; var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"安利一波正在使用的 Vim 插件和配色","date":"2017-03-20T15:08:43.000Z","path":"2017/03/20/Recommand-Some-Vim-Plugins-I-use/","text":"前言 文章更新，我的$Vim$效果图： 2017年12月5日，文章更新……….. 如果从来没使用过 Vim，可以先看一下我的其他关于 Vim 使用的博客： Vim 初学者入门指南 Vim 快捷键速查表 3 个针对高级用户的 Vim 编辑器实用技巧 5 个针对有经验用户的 Vim 实用技巧 插件介绍 我目前正在使用的 Vim 插件有： pathogen auto-pairs nerdcommenter nerdtree supertab syntastic tagbar-master vim-powerline xptemplate ctrlp quick-scope YoucompleteMe vim-multiple-cursors emmet-vim vim-closetag pathogen 为什么先说这一个呢，因为它是一个管理 Vim 插件的插件。当安装了这个插件以后，安装别的插件就变得非常简单了. 安装方法： 12 mkdir -p ~/.vim/autoload ~/.vim/bundlecurl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 然后，把下面这行代码添加到 vimrc 文件中： 1 execute pathogen#infect() 如果你还没有 vimrc 文件，那么，先创建一个 vimrc 文件： 1 vim ~/.vimrc 然后把下面的内容添加到文件中： 123 execute pathogen#infect()syntax onfiletype plugin indent on 当这个插件安装好以后，安装别的插件就很简单了，只需要进入 .vim/bundle/ 文件夹中，然后，把需要安装的插件克隆下来就可以了。 该插件托管在 GitHub。 auto-pairs 该插件说简单点就是实现括号、引号的自动补全，安装好以后就可以用了，没什么特别的地方。 安装： 12 cd .vim/bundlegit clone https://github.com/jiangmiao/auto-pairs.git 该插件的更多用法请看插件在 GitHub 上的README nerdcommenter 安装： 12 cd ~/.vim/bundlegit clone https://github.com/scrooloose/nerdcommenter.git 该插件用于把代码注释了或给代码添加注释。 首先，它的快捷键中用到了 \\,但这样用起来很不习惯，可以把 \\ 换成 ,,只需要在 vimrc 文件中加上下面这行代码： 1 let mapleader=\",\" 注释代码： ,-cc ，即先按下 ,然后再连按两次 c，如果要注释多行,可以在前面加上数字指明行数，比如要注释当前行和之后的 4 行，可以先按下 5，然后再按下 ,-cc； 再行末给代码添加注释：,cA ，即先按下 , 然后再按下c，再按下A，之后直接进入插入模式，可以开始添加注释。 用法： ,cc 注释当前行和选中行； ,cn 没有发现和,cc有区别； ,c&lt;空格&gt; 如果被选区域有部分被注释，则对被选区域执行取消注释操作，其它情况执行反转注释操作； ,cm 对被选区域用一对注释符进行注释，前面的注释对每一行都会添加注释； ,ci 执行反转注释操作，选中区域注释部分取消注释，非注释部分添加注释； ,cs 添加性感的注释，代码开头介绍部分通常使用该注释； ,cy 添加注释，并复制被添加注释的部分； ,c$ 注释当前光标到改行结尾的内容； ,cA 跳转到该行结尾添加注释，并进入编辑模式； ,ca 转换注释的方式，比如： /**/和//； ,cl ,cb 左对齐和左右对其，左右对齐主要针对/**/； ,cu 取消注释； 更多用法请访问GitHub。 nerdtree nerdtree 是一个文件管理插件 安装： 12 cd .vim/bundlegit clone https://github.com/scrooloose/nerdtree.git 键位设置，假设你想把 设置为 nerdtree 的启动键，那么只需把下面一行内容加入 vimrc 文件中： 1 map &lt;F5&gt; :NERDTreeToggle&lt;CR&gt; vim 没有指定文件为参数时自动打开 nerdtree： 12 autocmd StdinReadPre * let s:std_in=1autocmd VimEnter * if argc() == 0 &amp;&amp; !exists(\"s:std_in\") | NERDTree | endif 在一个目录中打开 vim 时自动打开 nerdtree： 12 autocmd StdinReadPre * let s:std_in=1autocmd VimEnter * if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(\"s:std_in\") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif 注：上面所展示的内容都是加入 vimrc 文件中。 下面，是一些默认键位： 和编辑文件一样，通过h j k l移动光标定位； o 打开关闭文件或者目录，如果是文件的话，光标出现在打开的文件中； go 效果同上，不过光标保持在文件目录里，类似预览文件内容的功能； i和s可以水平分割或纵向分割窗口打开文件，前面加g类似go的功能； t 在标签页中打开； T 在后台标签页中打开； p 到上层目录； P 到根目录； K 到同目录第一个节点； J 到同目录最后一个节点； m 显示文件系统菜单（添加、删除、移动操作）； ? 帮助； q 关闭； 窗口间移动：Ctrl+ww，即先按下 Ctrl ，再连按两次 ww； 不过我觉得比较常用的就只有: Ctrl+ww , q , o , go , i , s , F5 这几个； 更多信息，请访问 GitHub。 supertab supertab 是一个补全插件，它能够自动补全之前输入过的东西，比如变量名，函数名等，输入过一次以后之后只需输入几个字母，然后按 Tab 键就可以自动补全。 安装： 12 cd .vim/bundlegit clone https://github.com/ervandew/supertab.git 它的用法很简单，就只需要按下 Tab 键就可以了。 访问 GitHub 仓库。 syntastic syntastic 是一个检查语法错误的插件。 当文件保存以后，有语法错误的行，会在左测栏标记出红色，当把光标移动到该行时，会在底部状态栏下面显示错误信息。 安装： 12 cd .vim/bundlegit clone --depth=1 https://github.com/vim-syntastic/syntastic.git 访问 GitHub 仓库。 tagbar tagbar 可以快速浏览当前文件中的所有函数，定义的结构等 安装： 12 cd .vim/bundlegit clone https://github.com/majutsushi/tagbar.git 设置默认键位： 1 nmap &lt;F7&gt; :TagbarToggle&lt;CR&gt; 将上面这行内容加入 vimrc 文件中以后，在文件中按 F7 键就可以浏览 Tag，再次按下退出。 访问 github 仓库。 TagHighlight TagHighlight 插件能够高亮显示文件中的所有变量名，自定义函数，类型名等。 安装： 12 cd .vim/bundlegit clone https://github.com/magic-dot-files/TagHighlight.git 使用：保存文件，然后在 vim 的 Normal 模式下输入 :UpdateTypesFile 命令。 更新 helptags，在 vim 中运行上面的命令: 1 :call pathogen#helptags() 访问 GitHub 仓库。 vim-powerline vim-powerline 是一个强大的显示 vim 状态栏的插件。 安装： 12 cd .vim/bundlegit clone https://github.com/Lokaltog/vim-powerline.git 访问 GitHub 仓库 xptemplate 到了最后一个-xptemplate，该插件是一个强大的代码段补全插件。 安装： 12 cd .vim/bundlegit clone https://github.com/drmingdrmer/xptemplate.git 当输入一个词比如 for 以后按下 ctrl+\\ 就可以补全 for 循环，然后光标出现在第一个输入的地方，输入好以后按下 Tab 键到达下一个需要输入的地方。 因为我不喜欢它的默认键位： Ctrl+\\ ，所以重新设置了一个默认键位，本来想设置为 Tab 键，但由于 Tab 键已经被 supertab 占用了，所有就设置为 F3 。 在 vimrc 文件中加入下面一行内容： 1 let g:xptemplate_key = '&lt;F3&gt;' 现在，xptemplate 的默认键位就变成 F3 了。 访问 GitHub 仓库。 ctrlp 一个查找文件的插件。 安装： 12 cd ~/.vim/bundlegit clone git@github.com:kien/ctrlp.vim.git 用法： Ctrl+p：进入文件查找模式； ESC：退出； F5：清除当前目录下的缓存，获取新的结构； Ctrl+f/Ctrl+b：在各个模式间转换； Ctrl+d：使用文件名搜索代替全路径搜索； Ctrl+r：使用正则模式； Ctrl+j/Ctrl+k：上下选择文件； Ctrl+t：在新的 Tab 打开选择的文件； Ctrl+v/Ctrl+x：在新的窗口垂直/水平打开文件； Ctrl+y：创建一个新的文件（先输入文件名，然后按下 Ctrl+y）； Ctrl+z：标记或取消标记多个文件，然后使用 Ctrl+o 打开； 访问 GitHub quick-scope 不太懂该插件怎么用，只知道安装后单词首字母被标出。安装： 12 cd .vim/bundlegit clone https://github.com/unblevable/quick-scope.git 访问 GitHub Youcompleteme 这是一个很强大的工具，集成了上面 supertab 和 syntastic 等差件的功能，不过安装起来比较麻烦，当然，网上也有很多安装教程，可自行搜索。 vim-multiple-cursors 从sublime移植过来的实现多行同时编辑的功能，实际中用到的情况并不多。 安装： 12 cd ~/.vim/bundlegit clone https://github.com/terryma/vim-multiple-cursors.git 具体用法可参考官网文档。 emmet-vim 一个强大的前端插件。 安装： 12 cd ~/.vim/bundlegit clone https://github.com/mattn/emmet-vim.git 具体使用参见官网 vim-closetag 一个比较实用的前端插件，实现tag的自动补全。 安装： 12 cd ~/.vim/bunblegit clone https://github.com/alvan/vim-closetag 具体用法参加官网。 Vim 配色 对于一个好的编辑器来说，配色也很重要，我给 Vim 添加了多个配色，启动时默认为molokai，CTRL+C可以切换配色。 我的 vimrc 文件 最后，把我的 vimrc 文件粘贴在下面：或者也可在GitHub上查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279 runtime! debian.vim\" Uncomment the next line to make Vim more Vi-compatible\" NOTE: debian.vim sets 'nocompatible'. Setting 'compatible' changes numerous\" options, so any other options should be set AFTER setting 'compatible'.\"set compatible\" Vim5 and later versions support syntax highlighting. Uncommenting the next\" line enables syntax highlighting by default.if has(\"syntax\") syntax onendif\" If using a dark background within the editing area and syntax highlighting\" turn on this option as well\"set background=dark\" Uncomment the following to have Vim jump to the last position when\" reopening a fileif has(\"autocmd\") au BufReadPost * if line(\"'\\\"\") &gt; 1 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") | exe \"normal! g'\\\"\" | endifendif\" Uncomment the following to have Vim load indentation rules and plugins\" according to the detected filetype.if has(\"autocmd\") filetype plugin indent onendif\" The following are commented out as they cause vim to behave a lot\" differently from regular Vi. They are highly recommended though.\"set showcmd \" Show (partial) command in status line.\"set showmatch \" Show matching brackets.\"set ignorecase \" Do case insensitive matching\"set smartcase \" Do smart case matching\"set incsearch \" Incremental search\"set autowrite \" Automatically save before commands like :next and :make\"set hidden \" Hide buffers when they are abandoned\"set mouse=a \" Enable mouse usage (all modes)\" Source a global configuration file if availableif filereadable(\"/etcimimrc.local\") source /etcimimrc.localendif set backupset backupdir=~/.backupdirset backupext=.bakset tabstop=4set softtabstop=4set shiftwidth=4set autoindentset cindentset cinoptions=&#123;0,1s,t0,n-2,p2s,(03s,=,5s,&gt;1s,=1s,:1sset nuif &amp;term==\"xterm\"set t_Co=8set t_Sb=^[[4%dmset t_Sf=^[[3%dmendifset fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp836,latin1execute pathogen#infect()\"let g:vim_markdown_frontmatter=1\"let g:molokai_original = 1nmap &lt;F7&gt; :TagbarToggle&lt;CR&gt; set pastetoggle=&lt;F7&gt; \"粘贴时保持缩进filetype plugin onlet g:NERDCompactSexyComs = 1let g:NERDDefaultAlign = 'left'let g:NERDAltDelims_java = 1\"let g:NERDCustomDelimiters = &#123; 'c': &#123; 'left': '/*','right': '*/' &#125; &#125;let g:NERDCustomDelimiters = &#123; 'c':&#123;'left': '//','right':''&#125; &#125;let g:NERDCommentEmptyLines = 1let g:NERDTrimTrailingWhitespace = 1let mapleader=\",\" \"将nerdcommter的默认换行键改为,let g:xptemplate_key = '&lt;F3&gt;' \"设置F3为xpcomplate默认键位autocmd StdinReadPre * let s:std_in=1 \"启动vim没有文件时自动启动nerdtreeautocmd VimEnter * if argc() == 0 &amp;&amp; !exists(\"s:std_in\") | NERDTree | endifautocmd StdinReadPre * let s:std_in=1autocmd VimEnter * if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(\"s:std_in\") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif \"vim在目录中打开时自动启动nerdtreemap &lt;F5&gt; :NERDTreeToggle&lt;CR&gt; \"按F5启动nerdtreeautocmd bufenter * if (winnr(\"$\") == 1 &amp;&amp; exists(\"b:NERDTree\") &amp;&amp; b:NERDTree.isTabTree()) | q | endif \"当只剩下nerdtree时自动关闭窗口\"nmap &lt;F8&gt; :SCCompile&lt;cr&gt;\"nmap &lt;F9&gt; :SCCompileRun&lt;cr&gt;syntax onfiletype plugin indent onsyntax on\" \" Javascript syntax hightlightsyntax enable\"\" Set syntax highlighting for specific file typesautocmd BufRead,BufNewFile Appraisals set filetype=rubyautocmd BufRead,BufNewFile *.md set filetype=markdownautocmd Syntax javascript set syntax=jquery\" Highlight current lineau WinLeave * set nocursorline nocursorcolumnau WinEnter * set cursorline cursorcolumnset cursorline cursorcolumn\"powerlineset guifont=PowerlineSymbols\\ for\\ Powerlineset nocompatibleset t_Co=256set encoding=utf-8set laststatus=2set fillchars+=stl:\\ ,stlnc:\\colorscheme molokailet g:rehash256 = 1let g:ycm_server_python_interpreter='/usr/bin/python'let g:ycm_global_ycm_extra_conf='~/.vim/.ycm_extra_conf.py'\"colorscheme null\"colorscheme jellybeans\"colorscheme guepardo\"colorscheme vividchalk\"colorscheme Tomorrow\"colorscheme Tomorrow-Night\"新建.v,.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.v,*.cpp,*.[ch],*.sh,*.java,*.py exec \":call SetTitle()\" \"\"定义函数SetTitle，自动插入文件头 func SetTitle() \"如果文件类型为.sh文件 if &amp;filetype == 'sh' call setline(1,\"\\#########################################################################\") call append(line(\".\"), \"\\# File Name: \".expand(\"%\")) call append(line(\".\")+1, \"\\# Author: Lv Feng\") call append(line(\".\")+2, \"\\# mail: lvfeng97@outlook.com\") call append(line(\".\")+3, \"\\# Date: \".strftime(\"%Y-%m-%d\")) call append(line(\".\")+4, \"\\#########################################################################\") call append(line(\".\")+5, \"\\#!/bin/bash\") call append(line(\".\")+6, \"\") elseif &amp;filetype == 'python' call append(line(\".\"), \"\\# -*- coding:utf-8 -*-\") call append(line(\".\")+1, \"\\# Filename: \".expand(\"%\")) call append(line(\".\")+2, \"\\# Author: Lv Feng\") call append(line(\".\")+3, \"\\# E-mail: lvfeng97@outlook.com\") call append(line(\".\")+4, \"\\# Date: \".strftime(\"%Y-%m-%d\")) call append(line(\".\")+5, \"\\# Description: \") call append(line(\".\")+6, \"\") else call setline(1, \"/*************************************************************************\") call append(line(\".\"), \" &gt; Filename: \".expand(\"%\")) call append(line(\".\")+1, \" &gt; Author: Lv Feng\") call append(line(\".\")+2, \" &gt; Mail: lvfeng97@outlook.com\") call append(line(\".\")+3, \" &gt; Date: \".strftime(\"%Y-%m-%d\")) call append(line(\".\")+4, \" ************************************************************************/\") call append(line(\".\")+5, \"\") endif if &amp;filetype == 'cpp' call append(line(\".\")+6, \"#include&lt;iostream&gt;\") call append(line(\".\")+7, \"using namespace std;\") call append(line(\".\")+8, \"\") endif if &amp;filetype == 'c' call append(line(\".\")+6, \"#include&lt;stdio.h&gt;\") call append(line(\".\")+7, \"\") endif \"新建文件后，自动定位到文件末尾 autocmd BufNewFile * &lt;esc&gt;G endfunc \"C，C++ 按F6编译运行map &lt;F6&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc()exec \"w\"if &amp;filetype == 'c'exec \"!g++ % -o %&lt;\"exec \"!time ./%&lt;\"elseif &amp;filetype == 'cpp'exec \"!g++ % -o %&lt;\"exec \"!time ./%&lt;\"elseif &amp;filetype == 'java' exec \"!javac %\" exec \"!time java %&lt;\"elseif &amp;filetype == 'sh':!time bash %elseif &amp;filetype == 'python'exec \"!python %\" elseif &amp;filetype == 'html' exec \"!firefox % &amp;\" elseif &amp;filetype == 'go'\" exec \"!go build %&lt;\" exec \"!time go run %\" elseif &amp;filetype == 'mkd' exec \"!~/.vim/markdown.pl % &gt; %.html &amp;\" exec \"!firefox %.html &amp;\"endifendfunc\"C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb()set magic \" 设置魔术exec \"w\"exec \"!g++ % -g -o %&lt;\"exec \"!gdb ./%&lt;\"endfunc set grepprg=grep\\ -nH\\ $*let g:tex_flavor='latex'set iskeyword+=:autocmd BufEnter *.tex set sw=2inoremap &lt;C-d&gt; &lt;esc&gt;ddinoremap &lt;C-W&gt; &lt;esc&gt;dwfunc ChangeColor() if g:colors_name == 'molokai' colorscheme vividchalk elseif g:colors_name == 'vividchalk' colorscheme one-dark elseif g:colors_name == 'one-dark' colorscheme one elseif g:colors_name == 'one' colorscheme Tomorrow elseif g:colors_name == 'Tomorrow' colorscheme Tomorrow-Night elseif g:colors_name == 'Tomorrow-Night' colorscheme guepardo elseif g:colors_name == 'guepardo' colorscheme jellybeans elseif g:colors_name == 'jellybeans' colorscheme null else colorscheme molokai endifendfuncnnoremap &lt;C-c&gt; :call ChangeColor()&lt;cr&gt;inoremap &lt;C-c&gt; :call ChangeColor()&lt;cr&gt;inoremap jk &lt;esc&gt; inoremap &lt;left&gt; &lt;nop&gt;nnoremap &lt;left&gt; &lt;nop&gt;inoremap &lt;up&gt; &lt;nop&gt;\"nnoremap &lt;up&gt; &lt;nop&gt;inoremap &lt;down&gt; &lt;nop&gt;\"nnoremap &lt;down&gt; &lt;nop&gt;inoremap &lt;right&gt; &lt;nop&gt;nnoremap &lt;right&gt; &lt;nop&gt;set hlsearch\"let g:pymode_python = 'python3'\"let g:pymode_rope_goto_definition_bind = '&lt;C-S-g&gt;'let g:user_emmet_leader_key='&lt;C-Z&gt;' 配置脚本 下载自动配置脚本。 或直接在命令行执行下面的命令： curl https://ucasfl.me/scripts/vim_config | bash 该脚本可配置上面除了 Youcompleteme 之后的所有插件和配色。 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Linux 中安装最新的 Python 3.6 版本","date":"2017-03-19T11:29:39.000Z","path":"2017/03/19/How-to-Install-Latest-Python3.6-in-Linux/","text":"在这篇文章中，我将展示如何在 CentOS/RHEL 7、Debian 以及它的衍生版本比如 Ubuntu（最新的 Ubuntu 16.04 LTS 版本已经安装了最新的 Python 版本）或 Linux Mint 上安装和使用 Python 3.x 。我们的重点是安装可用于命令行的核心语言工具。 然后，我们也会阐述如何安装 Python IDLE － 一个基于 GUI 的工具，它允许我们运行 Python 代码和创建独立函数。 在 Linux 中安装 Python 3.6 在我写这篇文章的时候（2017 年三月中旬），在 CentOS 和 Debian 8 中可用的最新 Python 版本分别是 Python 3.4 和 Python 3.5 。 虽然我们可以使用 yum 和 aptitude（或 apt-get）安装核心安装包以及它们的依赖，但在这儿，我将阐述如何使用源代码进行安装。 为什么？理由很简单：这样我们能够获取语言的最新的稳定发行版（3.6），并且提供了一种和 Linux 版本无关的安装方法。 在 CentOS 7 中安装 Python 之前，请确保系统中已经有了所有必要的开发依赖： 12 # yum -y groupinstall development# yum -y install zlib-devel 在 Debian 中，我们需要安装 gcc、make 和 zlib 压缩/解压缩库： 1 # aptitude -y install gcc make zlib1g-dev 运行下面的命令来安装 Python 3.6： 12345 # wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tar.xz# tar xJf Python-3.6.0.tar.xz# cd Python-3.6.0# ./configure# make &amp;&amp; make install 现在，放松一下，或者饿的话去吃个三明治，因为这可能需要花费一些时间。安装完成以后，使用 which 命令来查看主要二进制代码的位置： 12 # which python3# python3 -V 上面的命令的输出应该和这相似： 查看 Linux 系统中的 Python 版本 要退出 Python 提示符，只需输入： 123 quit()或exit() 然后按回车键。 恭喜！Python 3.6 已经安装在你的系统上了。 在 Linux 中安装 Python IDLE Python IDLE 是一个基于 GUI 的 Python 工具。如果你想安装 Python IDLE，请安装叫做 idle（Debian）或 python-tools（CentOS）的包： 12 # apt-get install idle [On Debian]# yum install python-tools [On CentOS] 输入下面的命令启动 Python IDLE： 1 # idle 总结 在这篇文章中，我们阐述了如何从源代码安装最新的 Python 稳定版本。 最后但不是不重要，如果你之前使用 Python 2，那么你可能需要看一下 从 Python 2 迁移到 Python 3 的官方文档。这是一个可以读入 Python 2 代码，然后转化为有效的 Python 3 代码的程序。 via: http://www.tecmint.com/install-python-in-linux/ 作者：Gabriel Cánepa译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"队列","date":"2017-03-18T12:04:54.000Z","path":"2017/03/18/Queue/","text":"定义 队列 (Queue) 也是运算受限的线性表。 只允许在表的一端进行插入,而在另一端进行删除； 队头 (front) :允许进行删除的一端； 队尾 (rear) :允许进行插入的一端； 空队列:队列中没有元素； 特性： 先进先出 (First In First Out , FIFO) ,先进入队列的成员总是先离开队列； 在空队列中依次加入元素 a 1 , a 2 , … , a n 之后, a 1 是队头元素, a n 是队尾元素,而退出队列的序只能是 a 1 , a 2 , … , an； 队列的链式表示和实现 链队列:用链表表示的队列 数据元素结点,头结点； 队列的队头指针和队尾指针； C 语言实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 #define OK 1#define ERROR 0typedef int ElemType ;typedef int Status;typedef struct Node &#123; ElemType data; struct Node *next;&#125;QNode;typedef struct &#123; QNode *front; QNode *rear;&#125;LinkedQueue;//链队列的基本操作// 链队列的初始化,构造一个空队列Status InitQueue(LinkedQueue *lq)&#123; lq-&gt;front=lq-&gt;rear=(QNode *)malloc(sizeof(QNode)); if(!lq-&gt;front) return ERROR; lq-&gt;front-&gt;next=NULL; return OK;&#125;//队列判空int IsQueueEmpty(LinkedQueue *lq)&#123; if(lq-&gt;front == lq-&gt;rear) return 1; else return 0;&#125;//取队头元素Status GetFront(LinkedQueue *lq,ElemType *e)&#123; if(lq-&gt;front == lq-&gt;rear) return ERROR;//队列为空 *e=lq-&gt;front-&gt;next-&gt;data;return OK; &#125;// 入队:插入元素 e 为队列的新的队尾元素Status Enqueue(LinkedQueue *lq,ElemType e)&#123; QNode *p; p=(QNode *)malloc(sizeof(QNode)); if(!p) return ERROR; p-&gt;data =e; p-&gt;next=NULL; lq-&gt;rear-&gt;next=p; // 修改尾指针 lq-&gt;rear=p; return OK;&#125;// 出队:若队列不空,则删除队列的队头元素,// 用 e 返回其值,并返回 OK ;否则返回 ERRORStatus Dequeue(LinkedQueue *lq,ElemType *e)&#123; QNode *p; if (lq-&gt;front == lq-&gt;rear) return ERROR; // 空队列的话,则出错 p = lq-&gt;front-&gt;next; // 修改头指针 *e = p-&gt;data; lq-&gt;front-&gt;next =p-&gt;next; if(lq-&gt;rear==p) lq-&gt;rear=lq-&gt;front; // 修改尾指针 free(p); return OK;&#125; 队列的顺序表示和实现 顺序队列:利用一组连续的存储单元 ( 一维数组 ) 依次存放从队头到队尾的各个元素； C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839 //静态顺序队列的定义:#define MAXQUEUESIZE 100typedef struct queue &#123; ElemType Queue_array[MAXQUEUESIZE] ; int front; // 队头指针 int rear; // 队尾指针 int queueSize;// 队列空间的大小&#125;SqQueue;//初始化Status Init_SqQueue(SqQueue *ql)&#123; ql-&gt;front=ql-&gt;rear=0; ql-&gt;queuesize=MAXQUEUESIZE; return OK; &#125;//插入元素Status Insert_SqQueue(SqQueue *ql,ElemType e)&#123; ql-&gt;Queue_array[ql-&gt;rear]=e; ql-&gt;rear++; return OK;&#125;//取队头元素Status Get_SqQueue(SqQueue *ql, ElemType *e)&#123; if(ql-&gt;front==ql-&gt;rear) return ERROR; //队列为空 *e=ql-&gt;Queue_array[ql-&gt;front]; ql-&gt;front++; return OK;&#125;//队列判空Status IsSqQueueEmpty(SqQueue *ql)&#123; if(ql-&gt;front==ql-&gt;rear) return OK; else return ERROR;&#125; 循环队列 循环队列:将为队列分配的向量空间看成为一个首尾相接的圆环； 在循环队列中进行出队、入队操作时,队头、队尾指针仍要加 1； 但当队头、队尾指针到达 MAXQUEUESIZE-1时,其加 1 操作的结果是指向 0； 判断队满的条件: 队空和队满时,头尾指针均相等； 无法通过 front==rear 来判断队列“空”还是“满”； 少用一个元素空间,约定:以“队列头指针在队尾指针的下一个位置上”为队满的标志； C 语言实现 12345678910111213141516171819202122232425262728293031323334353637 //定义#define MAXQUEUESIZE 100typedef struct queue &#123; ElemType *base; // 动态分配的存储空间 int front; // 队头指针,若队列不空,指向队列头元素 int rear; // 队尾指针,若队列不空,指向队列尾元素 的下一个位置&#125; CircularQueue;// 队列初始化,构造一个空循环队列Status InitQueue(CircularQueue *cq)&#123; cq-&gt;base=(ElemType *)malloc(MAXQUEUESIZE*sizeof(ElemType)); if(!cq-&gt;base) return ERROR; cq-&gt;front=cq-&gt;rear=0; return OK;&#125;// 返回队列的元素个数,即队列的长度int GetLen(CircularQueue *cq) &#123; return ((cq-&gt;rear - cq-&gt;front + MAXQUEUESIZE)%MAXQUEUESIZE);&#125;// 插入元素 e 为 Q 的新的队尾元素Status Enqueue(CircularQueue *cq,ElemType e) &#123; if((cq-&gt;rear+1)%MAXQUEUESIZE == cq-&gt;front) return ERROR; // 队列满 cq-&gt;base[cq-&gt;rear]=e; cq-&gt;rear=(cq-&gt;rear+1)%MAXQUEUESIZE; return OK;&#125;// 若队列不空,则删除 Q 的队头元素,// 用 e 返回其值,并返回 OK; 否则返回 ERRORStatus Dequeue(CircularQueue *cq,ElemType *e) &#123; if(cq-&gt;front == cq-&gt;rear) return ERROR; *e=cq-&gt;base[cq-&gt;front]; cq-&gt;front=(cq-&gt;front +1)%MAXQUEUESIZE; return OK;&#125; var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Vim 快捷键速查表","date":"2017-03-18T07:35:23.000Z","path":"2017/03/18/Vim-Shortcut-Sheet/","text":"本文是 Vim 用户指南 系列的其中一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 技巧 3 个针对高级用户的 Vim 编辑器实用技巧 Vim 编辑器是一个基于命令行的工具，是传奇编辑器 vi 的增强版。尽管图形界面的富文本编辑有很多，但是熟悉 Vim 对于每一位 Linux 的使用者都能有所帮助——无论你是经验丰富的系统管理员，还是刚上手树莓派的新手用户。 这个轻量级的编辑器是个非常强大的工具。在有经验的使用者手中，它能完成不可思议的任务。除了常规的文本编辑功能以外，它还支持一些进阶特性。例如，基于正则表达式的搜索和替换、编码转换，以及语法高亮、代码折叠等的编程特性。 使用 Vim 时有一个非常重要的一点需要注意，那就是按键的功能取决于编辑器当前的“模式”。例如，在“普通模式”输入字母j时，光标会向下移动一行。而当你在“插入模式”下输入字符，则只是正常的文字录入。 下面就是速查表，以便于你充分利用 Vim。 基本操作 快捷键 功能 Esc 从当前模式转换到“普通模式”。所有的键对应到命令。 i “插入模式”用于插入文字。回归按键的本职工作。 : “命令行模式” Vim 希望你输入类似于保存该文档命令的地方。 方向键 快捷键 功能 h 光标向左移动一个字符 j 或 Ctrl + J 光标向下移动一行 k 或 Ctrl + P 光标向上移动一行 l 光标向右移动一个字符 0 （数字 0）移动光标至本行开头 $ 移动光标至本行末尾 ^ 移动光标至本行第一个非空字符处 w 向前移动一个词 （上一个字母和数字组成的词之后） W 向前移动一个词 （以空格分隔的词） 5w 向前移动五个词 b 向后移动一个词 （下一个字母和数字组成的词之前） B 向后移动一个词 （以空格分隔的词） 5b 向后移动五个词 G 移动至文件末尾 gg 移动至文件开头 浏览文档 快捷键 功能 ( 跳转到上一句 ) 跳转到下一句 { 跳转到上一段 } 跳转到下一段 [[ 跳转到上一部分 ]] 跳转到下一部分 [] 跳转到上一部分的末尾 ][ 跳转到上一部分的开头 插入文本 快捷键 功能 a 在光标后插入文本 A 在行末插入文本 i 在光标前插入文本 o （小写字母 o）在光标下方新开一行 O （大写字母 O）在光标上方新开一行 特殊插入 快捷键 功能 :r [filename] 在光标下方插入文件 [filename] 的内容 :r ![command] 执行命令 [command] ，并将输出插入至光标下方 删除文本 快捷键 功能 x 删除光标处字符 dw 删除一个词 d0 删至行首 d$ 删至行末 d) 删至句末 dgg 删至文件开头 dG 删至文件末尾 dd 删除该行 3dd 删除三行 简单替换文本 快捷键 功能 r{text} 将光标处的字符替换成 {text} R 进入覆写模式，输入的字符将替换原有的字符 复制/粘贴文本 快捷键 功能 yy 复制当前行至存储缓冲区 [&quot;x]yy 复制当前行至寄存器 x p 在当前行之后粘贴存储缓冲区中的内容 P 在当前行之前粘贴存储缓冲区中的内容 [&quot;x]p 在当前行之后粘贴寄存器 x 中的内容 [&quot;x]P 在当前行之前粘贴寄存器 x 中的内容 撤销/重做操作 快捷键 功能 u 撤销最后的操作 Ctrl+r 重做最后撤销的操作 搜索和替换 快捷键 功能 /search_text 检索文档，在文档后面的部分搜索 search_text ?search_text 检索文档，在文档前面的部分搜索 search_text n 移动到后一个检索结果 N 移动到前一个检索结果 :%s/original/replacement 检索第一个 “original” 字符串并将其替换成 “replacement” :%s/original/replacement/g 检索并将所有的 “original” 替换为 “replacement” :%s/original/replacement/gc 检索出所有的 “original” 字符串，但在替换成 “replacement” 前，先询问是否替换 书签 快捷键 功能 m {a-zA-Z} 在当前光标位置设置书签，书签名可用一个大小写字母（{a-zA-Z}） :marks 列出所有书签 {a-zA-Z} 跳转到书签 {a-zA-Z} 选择文本 快捷键 功能 v 进入逐字可视模式 V 进入逐行可视模式 Esc 退出可视模式 改动选中文本 快捷键 功能 ~ 切换大小写 d 删除一个词 c 变更 y 复制 &gt; 右移 &lt; 左移 ! 通过外部命令进行过滤 保存并退出 快捷键 功能 :q 退出 Vim，如果文件已被修改，将退出失败 :w 保存文件 :w new_name 用 new_name 作为文件名保存文件 :wq 保存文件并退出 Vim :q! 退出 Vim，不保存文件改动 ZZ 退出 Vim，如果文件被改动过，保存改动内容 ZQ 与 :q! 相同，退出 Vim，不保存文件改动 下载 Vim 快捷键速查表 仅仅是这样是否还不足以满足你？别担心，我们已经为你整理好了一份下载版的速查表，以备不时之需。 点此下载（英文） via: https://www.maketecheasier.com/vim-keyboard-shortcuts-cheatsheet/ 作者：Himanshu Arora译者：martin2011qi校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Vim 初学者入门指南","date":"2017-03-18T07:34:57.000Z","path":"2017/03/18/Vim-Beginner-Tutorial/","text":"这篇文章是 VIM 用户指南 系列文章中的一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 技巧 3 个针对高级用户的 Vim 编辑器有用技巧 对一个程序员来说，选择一个文本编辑器是一件非常重要的事。因为不同编辑器之间有着不少的差异：图形界面或者非图形界面、不同的快捷键、不同的编程语言支持、不同的插件以及自定义设置等等。我建议不是去搜索最棒的编辑器，而是去选择最适合你的习惯且最适应你的任务的那一个。假如你打算在一个团体中工作，那么最好和你的共事者选择一样的编辑器。这样的话，一旦你在使用中遇到问题，你就可以去向他们寻求帮助。 这正是我在几年之前开始使用 Vim 的原因。通常来说，Vim 会被置于传说中的 Emacs 的对立面。我承认我对 Emacs 知之甚少，但是对于它俩，你需要知道的是它们都可以被深度定制，并且在初学时也都非常令人困惑。这个教程并不会介绍有关 Vim 的所有内容，而是将介绍一些基础以使你在最初就能正确使用它，随后还会展示一些小技巧，借此（希望能）让你有能力自己去探索学习。 Vim 一词来源于 “VI iMproved”。Vi 是一个被广泛安装于 Unix 系统的非图形界面文本编辑器，并且它也被默认安装在了 Linux 系统中。Vim 是这个原始编辑器的增强版，但是不同于 Vi，并不是每个发行版都默认安装了它。 安装 在 Ubuntu 中可以使用如下命令来安装 Vim： 1 sudo apt-get install vim 如果你已经对某些插件有了兴趣，使用以下命令： 1 sudo apt-cache search vim 这命令将给你输出一个很长的和 Vim 有关的包列表。在这之中，有针对不同编程语言的工具，有插件管理器，等等。 在这系列教程中，我将会在 Ubuntu 上使用最新版的 Vim（7.3.154，LCTT 译注：现在最新版为 8.0）。当然你也可以使用其它任何版本。 热身 在终端输入 vim 命令，你将会看到一个非常棒的欢迎界面。 （LCTT 译注：看到了欢迎界面中那行“Help poor children in Uganda!” 了吗？） 如果你之前从未使用过 Vi 或者 Vim，那么你很可能甚至不知道该怎么退出它… 是的，这是事实。任何你常用的快捷键在 Vim 中都将失去原有的效果。（LCTT 译注：网上有个流传的笑话——“如何制造乱码”，“让新手退出 vi”） 首先，要使用任何命令式的功能，像保存（save）或者退出（exit），你都先得输入一个冒号（:）。保存是 :w 而退出是 :q。如果你想不保存文件就退出，那么就要使用强制退出命令 :q!。Vim 中非常棒的一点是你不需要分开输入各个命令，换言之，如果你想保存然后退出，你就可以直接使用 :wq。 现在，我们退出 Vim 再打开一个文本文件。为此，你只需把想要编辑的文件名加在命令后面即可： 1 vim [文本文件名] 一般而言，当你打开一个文本文件，你将会处在查看模式。这使得 Vim 与众不同并且最初会让人感到困惑。Vim 主要由两种模式构成：查看模式和编辑模式。查看模式用于查看内容并且使用一些命令。想要进入编辑模式，只需按 i 键进行插入（insert）或者 a 键进行添加（add）。想要返回到查看模式或者进行命令式功能的操作，按 Escape 键即可。插入（insert）和添加（add）的差异仅仅在于你是想在光标位置之前还是在光标之后进入编辑模式并进行文字输入。要想彻底地明白，你应该亲自去尝试一下。我的建议是：仅在行尾使用添加（add），而在其它时候使用插入（insert）。 （LCTT 译注：此段落中“查看模式”原文是 “visual mode”，疑为“view mode”，在此模式下可以查看文本，但是不能进行编辑；而“visual mode” 是编辑模式的一种，可以按 v 键进入，然后就可以用方向键从当前光标位置开始进行选择，并以反白的视觉效果显示，通常选择后可以按 y 进行复制、按 d 进行剪切等操作。） 要想在文本之中移动光标，你通常可以使用键盘上的方向键，它们无论是在查看模式还是在编辑模式都可以生效。不过，一个真正的纯粹主义者将会告诉你使用按键 h 向左，j 向下，k 向上，l 向右来（在查看模式）进行移动。 现在你已经明白了如何和简单地控制 Vim，我们再来更加深入一些。 一些简单命令 现在你已经熟悉了在正常模式和插入模式之间进行切换，下面是一些可以在正常模式中使用的命令： x：删除一个字符 u：撤销一个操作（相当与 Ctrl+z） dd：删除一行内容 dw：删除一个单词 yy：复制一行内容 yw：复制一个单词 p：粘贴一个之前删除或复制的行或者单词 e：跳到下个单词（LCTT 译注：词尾）（比单纯用方向键更快） r：替换一个字母（按 r，松开，然后再按新字母） 当然不止这些，不过这些对现在来说已经足够了。如果你掌握了上面的全部，你将能你很顺溜地使用 Vim 了。 对于那些还想知道更多的人，我再多提一下。你可以在任何这些命令之前加上一个数值，那么这个命令将被重复执行相应的次数。例如，5x 将在当前行连续删除 5 个字母，而 3p 将会粘贴 3 次。 高级命令 最后，作为对你自己继续探索的鼓励和示例，这里给出几个高级且常用的命令： /所搜索的内容：在文中搜索特定内容 :sp 文本文件名：将屏幕水平分割成上下两半，新文件展示在另一半。想要在两侧切换焦点，可以使用 Ctrl+w 快捷键。 :vsp 文本文件名：同上，但是是垂直分割屏幕 Ctrl+Shift+C 和 Ctrl+Shift+V：在终端中复制和粘贴文本 :! 命令名：在 Vim 中运行 Vim 外的终端命令，直接发送给 shell。例如，:! ls 将在不退出编辑器的同时，显示你当前目录内的文件。 结论 我觉得你现在应该已经有了足够的准备来开始使用 Vim。你还可以通过安装各种插件，编辑 ~.vimrc 文件，或者在 shell 中输入 vimtutor 命令来使用交互式教程以学到更多。 如果你有任何你想分享的关于 Vim 的其它命令，请在评论中告知我们。 via: https://www.maketecheasier.com/start-with-vim-linux/ 作者：Himanshu Arora译者：Yinr校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Free：一个在 Linux 中检查内存使用情况的标准命令","date":"2017-03-18T02:15:31.000Z","path":"2017/03/18/Free-Command-in-Linux/","text":"我们都知道， IT 基础设施方面的大多数服务器（包括世界顶级的超级计算机）都运行在 Linux 平台上，因为和其他操作系统相比， Linux 更加灵活。有的操作系统对于一些微乎其微的改动和补丁更新都需要重启，但是 Linux 不需要，只有对于一些关键补丁的更新， Linux 才会需要重启。 Linux 系统管理员面临的一大挑战是如何在没有任何停机时间的情况下维护系统的良好运行。管理内存使用是 Linux 管理员又一个具有挑战性的任务。free 是 Linux 中一个标准的并且被广泛使用的命令，它被用来分析内存统计（空闲和已用）。今天，我们将要讨论 free 命令以及它的一些有用选项。 推荐文章： smem － Linux 内存报告/统计工具 vmstat － 一个报告虚拟内存统计的标准而又漂亮的工具 Free 命令是什么 free 命令能够显示系统中物理上的空闲（free）和已用（used）内存，还有交换（swap）内存，同时，也能显示被内核使用的缓冲（buffers）和缓存（caches）。这些信息是通过解析文件 /proc/meninfo 而收集到的。 显示系统内存 不带任何选项运行 free 命令会显示系统内存，包括空闲（free）、已用（used）、交换（swap）、缓冲（buffers）、缓存（caches）和交换（swap）的内存总数。 12345 # free total used free shared buffers cachedMem: 32869744 25434276 7435468 0 412032 23361716-/+ buffers/cache: 1660528 31209216Swap: 4095992 0 4095992 输出有三行： 第一行：表明全部内存、已用内存、空闲内存、共用内存（主要被 tmpfs（/proc/meninfo 中的 Shmem 项）使用）、用于缓冲的内存以及缓存内容大小。 全部：全部已安装内存（/proc/meminfo 中的 MemTotal 项） 已用：已用内存（全部计算 － 空间＋缓冲＋缓存） 空闲：未使用内存（/proc/meminfo 中的 MemFree 项） 共用：主要被 tmpfs 使用的内存（/proc/meminfo 中的 Shmem 项） 缓冲：被内核缓冲使用的内存（/proc/meminfo 中的 Buffers 项） 缓存：被页面缓存和 slab 使用的内存（/proc/meminfo 中的 Cached 和 SSReclaimable 项） 第二行：表明已用和空闲的缓冲/缓存 第三行：表明总交换内存（/proc/meminfo 中的 SwapTotal 项）、空闲内存（/proc/meminfo 中的 SwapFree 项）和已用交换内存。 以 MB 为单位显示系统内存 默认情况下， free 命令以 KB - Kilobytes 为单位输出系统内存，这对于绝大多数管理员来说会有一点迷糊（当系统内存很大的时候，我们中的许多人需要把输出转化为以 MB 为单位，从而才能够理解内存大小）。为了避免这个迷惑，我们在 ‘free’ 命令后面加上 -m 选项，就可以立即得到以 ‘MB - Megabytes’ 为单位的输出。 12345 # free -m total used free shared buffers cachedMem: 32099 24838 7261 0 402 22814-/+ buffers/cache: 1621 30477Swap: 3999 0 3999 如何从上面的输出中检查剩余多少空闲内存？主要基于已用（used）和空闲（free）两列。你可能在想，你只有很低的空闲内存，因为它只有 10%， 为什么？ 全部实际可用内存 ＝ （全部内存 － 第 2 行的已用内存） 全部内存 ＝ 32099 实际已用内存 ＝ 1621 （ = 全部内存 - 缓冲 - 缓存） 全部实际可用内存 ＝ 30477 如果你的 Linux 版本是最新的，那么有一个查看实际空闲内存的选项，叫做可用（available） ，对于旧的版本，请看显示 -/+ buffers/cache 那一行对应的空闲（free）一列。 如何从上面的输出中检查有多少实际已用内存？基于已用（used）和空闲（free）一列。你可能想，你已经使用了超过 95% 的内存。 全部实际已用内存 ＝ 第一列已用 － （第一列缓冲 ＋ 第一列缓存） 已用内存 ＝ 24838 已用缓冲 ＝ 402 已用缓存 ＝ 22814 全部实际已用内存 ＝ 1621 以 GB 为单位显示内存 默认情况下， free 命令会以 KB - kilobytes 为单位显示输出，这对于大多数管理员来说会有一些迷惑，所以我们使用上面的选项来获得以 MB - Megabytes 为单位的输出。但是，当服务器的内存很大（超过 100 GB 或 200 GB）时，上面的选项也会让人很迷惑。所以，在这个时候，我们可以在 free 命令后面加上 -g 选项，从而立即得到以 GB - Gigabytes 为单位的输出。 12345 # free -g total used free shared buffers cachedMem: 31 24 7 0 0 22-/+ buffers/cache: 1 29Swap: 3 0 3 显示全部内存行 默认情况下， free 命令的输出只有三行（内存、缓冲/缓存以及交换）。为了统一以单独一行显示（全部（内存＋交换）、已用（内存＋（已用－缓冲/缓存）＋交换）以及空闲（内存＋（已用－缓冲/缓存）＋交换），在 ‘free’ 命令后面加上 -t 选项。 123456 # free -t total used free shared buffers cachedMem: 32869744 25434276 7435468 0 412032 23361716-/+ buffers/cache: 1660528 31209216Swap: 4095992 0 4095992Total: 36965736 27094804 42740676 按延迟运行 free 命令以便更好的统计 默认情况下， free 命令只会显示一次统计输出，这是不足够进一步排除故障的，所以，可以通过添加延迟（延迟是指在几秒后再次更新）来定期统计内存活动。如果你想以两秒的延迟运行 free 命令，可以使用下面的命令（如果你想要更多的延迟，你可以按照你的意愿更改数值）。 下面的命令将会每 2 秒运行一次直到你退出： 123456789101112131415 # free -s 2 total used free shared buffers cachedMem: 32849392 25935844 6913548 188 182424 24632796-/+ buffers/cache: 1120624 31728768Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25935288 6914104 188 182424 24632796-/+ buffers/cache: 1120068 31729324Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25934968 6914424 188 182424 24632796-/+ buffers/cache: 1119748 31729644Swap: 20970492 0 20970492 按延迟和具体次数运行 free 命令 另外，你可以按延迟和具体次数运行 free 命令，一旦达到某个次数，便自动退出。 下面的命令将会每 2 秒运行一次 free 命令，计数 5 次以后自动退出。 12345678910111213141516171819202122232425 # free -s 2 -c 5 total used free shared buffers cachedMem: 32849392 25931052 6918340 188 182424 24632796-/+ buffers/cache: 1115832 31733560Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931192 6918200 188 182424 24632796-/+ buffers/cache: 1115972 31733420Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931348 6918044 188 182424 24632796-/+ buffers/cache: 1116128 31733264Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931316 6918076 188 182424 24632796-/+ buffers/cache: 1116096 31733296Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931308 6918084 188 182424 24632796-/+ buffers/cache: 1116088 31733304Swap: 20970492 0 20970492 人类可读格式 为了以人类可读的格式输出，在 free 命令的后面加上 -h 选项，和其他选项比如 -m 和 -g 相比，这将会更人性化输出（自动使用 GB 和 MB 单位）。 1234 # free -h total used free shared buff/cache availableMem: 2.0G 1.6G 138M 20M 188M 161MSwap: 2.0G 1.8G 249M 取消缓冲区和缓存内存输出 默认情况下， 缓冲/缓存 内存输出是同时输出的。为了取消缓冲和缓存内存的输出，可以在 free 命令后面加上 -w 选项。（该选项在版本 3.3.12 上可用） 注意比较上面有缓冲/缓存的输出。 1234 # free -wh total used free shared buffers cache availableMem: 2.0G 1.6G 137M 20M 8.1M 183M 163MSwap: 2.0G 1.8G 249M 显示最低和最高的内存统计 默认情况下， free 命令不会显示最低和最高的内存统计。为了显示最低和最高的内存统计，在 free 命令后面加上 -l 选项。 1234567 # free -l total used free shared buffers cachedMem: 32849392 25931336 6918056 188 182424 24632808Low: 32849392 25931336 6918056High: 0 0 0-/+ buffers/cache: 1116104 31733288Swap: 20970492 0 20970492 阅读关于 free 命令的更过信息 如果你想了解 free 命令的更多可用选项，只需查看其 man 手册。 123 # free --helpor# man free via: http://www.2daygeek.com/free-command-to-check-memory-usage-statistics-in-linux/ 作者：MAGESH MARUTHAMUTHU译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Ubuntu 下安装和配置 FTP 服务器","date":"2017-03-18T02:13:07.000Z","path":"2017/03/18/How-to-Install-and-configure-FTP-in-Ubuntu/","text":"FTP（文件传输协议）是一个较老且最常用的标准网络协议，用于在两台计算机之间通过网络上传/下载文件。然而， FTP 最初的时候并不安全，因为它仅通过用户凭证（用户名和密码）传输数据，没有进行加密。 警告：如果你打算使用 FTP， 需要考虑通过 SSL/TLS（将在下篇文章中讨论）配置 FTP 连接。否则，使用安全 FTP，比如 SFTP 会更好一些。 推荐阅读：如何在 CentOS 7 中安装并保护 FTP 服务器 在这个教程中，我将向你们展示如何在 Ubuntu 中安装、配置并保护 FTP 服务器（VSFTPD 的全称是 “Very Secure FTP Deamon”），从而拥有强大的安全性，能够防范 FTP 漏洞。 第一步：在 Ubuntu 中安装 VSFTPD 服务器 1、首先，我们需要更新系统安装包列表，然后像下面这样安装 VSFTPD 二进制包： 12 $ sudo apt-get update$ sudo apt-get install vsftpd 2、一旦安装完成，初始情况下服务被禁用。因此，我们需要手动开启服务，同时，启动它使得在下次开机时能够自动开启服务： 123456 ------------- On SystemD -------------# systemctl start vsftpd# systemctl enable vsftpd------------- On SysVInit -------------# service vsftpd start# chkconfig --level 35 vsftpd on 3、接下来，如果你在服务器上启用了 UFW 防火墙（默认情况下不启用），那么需要打开端口 20 和 21 —— FTP 守护进程正在监听它们——从而才能允许从远程机器访问 FTP 服务，然后，像下面这样添加新的防火墙规则： 123 $ sudo ufw allow 20/tcp$ sudo ufw allow 21/tcp$ sudo ufw status 第二步：在 Ubuntu 中配置并保护 VSFTPD 服务器 4、让我们进行一些配置来设置和保护 FTP 服务器。首先，我们像下面这样创建一个原始配置文件 /etc/vsftpd/vsftpd.conf 的备份文件： 1 $ sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.orig 接下来，打开 vsftpd 配置文件。 123 $ sudo vi /etc/vsftpd.confOR$ sudo nano /etc/vsftpd.conf 把下面的这些选项添加/改成所展示的值： 12345678910111213 anonymous_enable=NO # 关闭匿名登录local_enable=YES # 允许本地用户登录write_enable=YES # 启用可以修改文件的 FTP 命令local_umask=022 # 本地用户创建文件的 umask 值dirmessage_enable=YES # 当用户第一次进入新目录时显示提示消息xferlog_enable=YES # 一个存有详细的上传和下载信息的日志文件connect_from_port_20=YES # 在服务器上针对 PORT 类型的连接使用端口 20（FTP 数据）xferlog_std_format=YES # 保持标准日志文件格式listen=NO # 阻止 vsftpd 在独立模式下运行listen_ipv6=YES # vsftpd 将监听 ipv6 而不是 IPv4，你可以根据你的网络情况设置pam_service_name=vsftpd # vsftpd 将使用的 PAM 验证设备的名字userlist_enable=YES # 允许 vsftpd 加载用户名字列表tcp_wrappers=YES # 打开 tcp 包装器 5、现在，配置 VSFTPD ，基于用户列表文件 /etc/vsftpd.userlist 来允许或拒绝用户访问 FTP。 注意，在默认情况下，如果通过 userlist_enable=YES 启用了用户列表，且设置 userlist_deny=YES 时，那么，用户列表文件 /etc/vsftpd.userlist 中的用户是不能登录访问的。 但是，选项 userlist_deny=NO 则反转了默认设置，这种情况下只有用户名被明确列出在 /etc/vsftpd.userlist 中的用户才允许登录到 FTP 服务器。 123 userlist_enable=YES # vsftpd 将会从所给的用户列表文件中加载用户名字列表userlist_file=/etc/vsftpd.userlist # 存储用户名字的列表userlist_deny=NO 重要的是，当用户登录 FTP 服务器以后，他们将进入 chrooted 环境，即当在 FTP 会话时，其 root 目录将是其 home 目录。 接下来，我们来看一看两种可能的途径来设置 chrooted（本地 root）目录，正如下面所展示的。 6、这时，让我们添加/修改/取消这两个选项来将 FTP 用户限制在其 home 目录 12 chroot_local_user=YESallow_writeable_chroot=YES 选项 chroot_local_user=YES 意味着本地用户将进入 chroot 环境，当登录以后默认情况下是其 home 目录。 并且我们要知道，默认情况下，出于安全原因，VSFTPD 不允许 chroot 目录具有可写权限。然而，我们可以通过选项 allow_writeable_chroot=YES 来改变这个设置 保存文件然后关闭。现在我们需要重启 VSFTPD 服务从而使上面的这些更改生效： 1234 ------------- On SystemD -------------# systemctl restart vsftpd------------- On SysVInit -------------# service vsftpd restart 第三步：在 Ubuntu 上测试 VsFTP 服务器 7、现在，我们通过使用下面展示的 useradd 命令创建一个 FTP 用户来测试 FTP 服务器： 12 $ sudo useradd -m -c \"Aaron Kili, Contributor\" -s /bin/bash aaronkilik$ sudo passwd aaronkilik 然后，我们需要像下面这样使用 echo 命令和 tee 命令来明确地列出文件 /etc/vsftpd.userlist 中的用户 aaronkilik： 12 $ echo \"aaronkilik\" | sudo tee -a /etc/vsftpd.userlist$ cat /etc/vsftpd.userlist 8、现在，是时候来测试上面的配置是否具有我们想要的功能了。我们首先测试匿名登录；我们可以从下面的输出中很清楚的看到，在这个 FTP 服务器中是不允许匿名登录的： 12345678 # ftp 192.168.56.102Connected to 192.168.56.102 (192.168.56.102).220 Welcome to TecMint.com FTP service.Name (192.168.56.102:aaronkilik) : anonymous530 Permission denied.Login failed.ftp&gt; bye221 Goodbye. 9、接下来，我们将测试，如果用户的名字没有在文件 /etc/vsftpd.userlist 中，是否能够登录。从下面的输出中，我们看到，这是不可以的： 12345678 # ftp 192.168.56.102Connected to 192.168.56.102 (192.168.56.102).220 Welcome to TecMint.com FTP service.Name (192.168.56.10:root) : user1530 Permission denied.Login failed.ftp&gt; bye221 Goodbye. 10、现在，我们将进行最后一项测试，来确定列在文件 /etc/vsftpd.userlist 文件中的用户登录以后，是否实际处于 home 目录。从下面的输出中可知，是这样的： 12345678910 # ftp 192.168.56.102Connected to 192.168.56.102 (192.168.56.102).220 Welcome to TecMint.com FTP service.Name (192.168.56.102:aaronkilik) : aaronkilik331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls 在 Ubuntu 中确认 FTP 登录 警告：设置选项 allow_writeable_chroot=YES 是很危险的，特别是如果用户具有上传权限，或者可以 shell 访问的时候，很可能会出现安全问题。只有当你确切的知道你在做什么的时候，才可以使用这个选项。 我们需要注意，这些安全问题不仅会影响到 VSFTPD，也会影响让本地用户进入 chroot 环境的 FTP daemon。 因为这些原因，在下一步中，我将阐述一个更安全的方法，来帮助用户设置一个非可写本地 root 目录。 第四步：在 Ubuntu 中配置 FTP 用户的 Home 目录 11、现在，再次打开 VSFTPD 配置文件。 123 $ sudo vi /etc/vsftpd.confOR$ sudo nano /etc/vsftpd.conf 然后像下面这样用 # 把不安全选项注释了： 1 #allow_writeable_chroot=YES 接下来，为用户创建一个替代的本地 root 目录（aaronkilik，你的可能和这不一样），然后设置目录权限，取消其他所有用户对此目录的写入权限： 123 $ sudo mkdir /home/aaronkilik/ftp$ sudo chown nobody:nogroup /home/aaronkilik/ftp$ sudo chmod a-w /home/aaronkilik/ftp 12、然后，在本地 root 目录下创建一个具有合适权限的目录，用户将在这儿存储文件： 123 $ sudo mkdir /home/aaronkilik/ftp/files$ sudo chown -R aaronkilk:aaronkilik /home/aaronkilik/ftp/files$ sudo chmod -R 0770 /home/aaronkilik/ftp/files/ 之后，将 VSFTPD 配置文件中的下面这些选项添加/修改为相应的值： 12 user_sub_token=$USER # 在本地 root 目录中插入用户名local_root=/home/$USER/ftp # 定义各个用户的本地 root 目录 保存文件并关闭。然后重启 VSFTPD 服务来使上面的设置生效： 1234 ------------- On SystemD -------------# systemctl restart vsftpd------------- On SysVInit -------------# service vsftpd restart 13、现在，让我们来最后检查一下，确保用户的本地 root 目录是我们在他的 Home 目录中创建的 FTP 目录。 12345678910 # ftp 192.168.56.102Connected to 192.168.56.102 (192.168.56.102).220 Welcome to TecMint.com FTP service.Name (192.168.56.10:aaronkilik) : aaronkilik331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls FTP 用户 Home 目录登录 via: http://www.tecmint.com/install-ftp-server-in-ubuntu/ 作者：Aaron Kili译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"栈","date":"2017-03-16T00:12:58.000Z","path":"2017/03/16/Stack/","text":"定义 栈 (Stack) 是限制在线性表的一端进行插入和删除操作的线性表,也称为后进先出(LIFO, Last In First Out) 或先进后出(FILO, First In Last Out) 线性表。 栈顶 (Top) :允许进行插入、删除操作的一端,也称为表尾，用栈顶指针来指示栈顶元素； 栈底 (Bottom/Base) :固定端,也称为表头； 空栈:当表中没有元素时称为空栈； 设栈 S=(a1, a2, …,an) ,则 a1 称为栈底元素, an 为栈顶元素。栈中元素按 a1 , a2,… an 的次序进栈,出栈的第一个元素应为栈顶元素,即栈的修改是按后进先出的原则进行的。 动态顺序栈 采用动态一维数组来存储栈； 所谓动态指的是栈的大小可以根据需要增加； 用 base 表示栈底指针,栈底固定不变的； 栈顶则随着进栈和退栈操作而变化,用 top( 称为栈顶指针 ) 指向数组中的下一个空闲存储位置； 用 top==base 作为栈空的标记； 进栈：首先将数据元素保存到栈顶 (top 所指的当前位置 ),然后,执行 top加 1 ,使 top 指向栈顶的下 一个存储位置； 出栈：首先执行 top 减 1，使 top 指向栈顶元素的存储位置，然后将栈顶元素取出； 静态顺序栈 采用静态一维数组来存储栈； 栈底固定不变的,而栈顶则随着进栈和退栈操作变化的； 用一个整型变量 top( 称为栈顶指针 ) 指向当前栈顶位置； 用 top=0 表示栈空的初始状态,每次 top 指向栈顶元素在数组中的存储位置； 若栈的数组有 Maxsize 个元素,则 top=Maxsize-1 时栈满； 进栈：先执行 top 加 1,使 top 指向新的栈顶位置,然后将数据元素保存到栈顶 (top 所指的当前位置 )；出栈：先把 top 指向的栈顶元素取出,然后执行 top 减 1 ,使 top 指向新的栈顶位置； C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 //动态顺序栈#define INITSIZE 100 // 栈空间初始分配量#define INCREMENTSIZE 10 // 栈空间分配增量#define OK 1#define ERROR 0typedef int ElemType ;typedef int Status;typedef struct &#123; int top;// 栈顶指针 ElemType *base; // 栈不存在时值为 NULL int stacksize ; //当前已分配空间&#125;SqStack ;//构造空栈Status InitStack(SqStack *s)&#123;// 构造一个空栈 s s-&gt;base=(ElemType *)malloc(INITSIZE * sizeof(ElemType)); if (!s) return ERROR; s-&gt;top=0; s-&gt;stacksize=INITSIZE; return OK;&#125;//返回栈的长度int GetLen(SqStack *s)&#123; return (s-&gt;top);&#125;//查看栈顶元素，不修改Status GetTop(SqStack *s,ElemType *e) &#123; // 只查看,不修改栈 if(s-&gt;top==0) return ERROR; // 栈空,返回出错标志 *e=s-&gt;base[s-&gt;top-1]; return OK;&#125;//push 元素进栈Status Push(SqStack *s,ElemType e)&#123; if(s-&gt;top &gt;= s-&gt;stacksize) &#123;//若栈已满,则增加INCREMENTSIZE 个存储单元 s-&gt;base=(ElemType *)realloc(s-&gt;base,(s-&gt;stacksize + INCREMENTSIZE)*sizeof(ElemType)); if(!s-&gt;base) return ERROR; //存储分配失败 s-&gt;stacksize+=INCREMENTSIZE;&#125; s-&gt;base[s-&gt;top++]=e; //e成为新的栈顶元素,栈顶指针加1 return OK;&#125;//pop 元素出栈Status Pop(SqStack *s,ElemType *e)&#123; if(s-&gt;top==0) return ERROR; // 栈空,返回出错标志 *e=s-&gt;base[--s-&gt;top]; // 等于s-&gt;top--; *e=s-&gt;base[s-&gt;top]; return OK;&#125;//判断栈空int IsStackEmpty(SqStack *s)&#123; if(s-&gt;top == 0) return 1; else return 0;&#125;//遍历Status StackTraverse(SqStack *s, void visit(ElemType *e))&#123; int i; if(s-&gt;top==0) return ERROR; for(i=s-&gt;top-1;i&gt;=0;i--) visit(&amp;s-&gt;base[i]); return OK;&#125;//数制转换void Conversion(int n,int d)&#123;// 将十进制整数 n 转换为 d 进制数 ElemType e; SqStack s; if(!InitStack(&amp;s)) return ERROR; while(n!=0) &#123; // 将余数逐一进栈 Push(&amp;s,n%d); n=n/d; &#125; while(!IsStackEmpty(&amp;s)) &#123; Pop(&amp;s,&amp;e); printf(\"%d \",e); &#125;&#125;//静态存储栈#define MAX_STACK_SIZE 100 // 栈的大小typedef int ElemType ;typedef struct &#123; ElemType stack_array[MAX_STACK_SIZE]; int top;&#125; SqStack;//链式栈typedef struct Node&#123; ElemType data; struct Node *next;&#125; LinkedStack;// 创建一个带头结点的空栈LinkedStack *InitStack(void)&#123; LinkedStack *s; s=(LinkedStack *)malloc(sizeof(LinkedStack)); s-&gt;next=NULL; return s;&#125;//求栈长int GetLen(LinkedStack *s)&#123; int i=0; LinkedStack *p; p=s-&gt;next; while(p)&#123; i++;p =p-&gt;next;&#125; return i;&#125;//元素进栈Status Push(LinkedStack *s,ElemType e)&#123; LinkedStack *p; p=(LinkedStack *)malloc(sizeof(LinkedStack)); if(!p) return ERROR;//存储分配失败 p-&gt;data = e; p-&gt;next=s-&gt;next; // 新结点插入到头结点之后 s-&gt;next=p; return OK;&#125;//元素出栈Status Pop(LinkedStack *s,ElemType *e)&#123; LinkedStack *p; if(!s-&gt;next) return ERROR; p=s-&gt;next; *e=p-&gt;data; // 取栈顶元素 s-&gt;next=p-&gt;next; // 修改栈顶指针 free(p); return OK;&#125; 栈的运用：递归 栈的一个重要应用是在程序设计语言中实现递归调用； 编译器依靠“栈”来管理递归函数的调用； 递归调用:一个函数 ( 或过程 ) 直接或间接地调用自己本身,简称递归 (Recursive)； 递归是程序设计中的一个强有力的工具。因为递归函数结构清晰,程序易读,正确性很容易得到证明； 为了使递归调用不至于无终止地进行下去,实际上有效的递归调用函数 ( 或过程 ) 应包括两部分:递推规则 ( 方法 ) ,终止条件； 举例：求单链表表尾元素 1234567891011 struct LNode &#123; ElemType data;struct Lnode *next;&#125;;LNode *L;ElemType FoundTail(LNode *L)&#123; if ( L-&gt;next == NULL ) return L.data; else return FoundTail(L-&gt;next);&#125; 递归算法优缺点 优点 结构清晰,程序易读； 编写容易,因为编译程序代替用户完成了栈的管理； 正确性容易得到证明；缺点 往往比较耗时耗空间。这是由于递归函数会不断进行函数的调用操作,而函数的调用是比较消耗资源的； 可将递归函数转化为非递归函数； 递归实现:函数调用 在一个函数的运行期间调用另一个函数时,在运行该被调用函数之前,需先完成三项任务： 将所有的实在参数、返回地址等信息传递给被调用函数保存； 为被调用函数的局部变量分配存储区； 将控制转移到被调用函数的入口； 从被调用函数返回调用函数之前,要完成下列三项任务： 保存被调用函数的计算结果； 释放被调用函数的数据区； 依照被调函数保存的返回地址将控制转移到调用函数； 递归实现 递归函数的执行过程可视为同一函数进行嵌套调用；调用层次 递归工作栈:整个递归调用过程期间使用的数据存储区； 递归工作记录:每一层递归所需的信息 ( 包括:实参,局部变量和上一层的返回地址 ) 合成一个记录； 每进入一层递归,就产生一个新的工作记录压入栈顶;每退出一层递归,就从栈顶弹出一个工作记录； 当前活动记录:栈顶记录,指示当前层的执行情况； 当前环境指针:递归工作栈的栈顶指针； 从被调函数返回调用函数的一般步骤： 若栈为空,则执行正常返回； 从栈顶弹出一个工作记录； 将“工作记录”中的参数值、局部变量值赋给相应的变量;读取返回地址； 将函数值赋给相应的变量； 转移到返回地址；59 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"你好呀，Next！","date":"2017-03-14T09:32:02.000Z","path":"2017/03/14/Hello-Next/","text":"最后，还是去除了博客的 header 背景，博客又回到了之前的样子。在背景这件事上，花费了很多的时间，当然，时间主要花费在找图片上：posts,header,sidebar$。最开始是三个地方都打算添加上背景图片，后来由于$posts$和$sidebar添加上背景影响阅读，所以就只保留了header的背景，终于在今天，把header的背景也去了，又恢复了原来的样子。 搭建该博客没记错的话是2016-12-15号晚上，基本就是看着网上的教程来。网上关于Hexo+GitHub搭建博客的教程有一堆，但是，当自己亲自来搭建的时候还是不可避免会遇到一些错误。$Hexo$的默认主题是landscape。因此，搭建好以后第一步就是找一个自己喜欢的主题。百度上一搜，看到有人在知乎上的一个回答，列出了$Hexo$主题的 star 排行榜，这大概就代表着主题的受欢迎程度吧，当然，排在第一的就是我现在所用的next主题。但是，开始的时候可能不太懂next主题吧，所以没用该主题，于是用了$star$排名第五的yilia，当然，我觉得该主题还是一个很优雅的主题，不过该主题当时还存在一些$bug$，不知现在有没有修复，比如头像问题，当然，在项目$issues$那儿有人给出了解决办法。当时因为该问题折腾了很久，甚至因此博客搭建好又被毁，只好重新搭建。 博客基本搭建满意是在$17$号六级考试前的一个小时，差不多就是这样，还好六级考的还不错，不然我大概会归罪于考前没复习，忙着干这事。之后，我自己也写了一篇关于Hexo+GitHub 搭建博客的教程。博客搭建基本告一段落。之后yilia主题用了两个多月。 然后，这学期开学才又心血来潮决定改用next主题，关于该主题的美化，也是花了很多功夫，具体的一些美化教程可以看我博客，在两个周前又注册了域名，所以博客域名就变成了：https://ucasfl.me/ 。 我在一篇博客中写了关于该主题的$posts,header,sidebar$的背景设置，只是现在我又把背景都去除了。可能说到底，next 主题追求的就是简洁、优雅，当给这些地方加上背景以后，反而变得不那么自然，反而失去了主题原有的美感。当然，也有一些比较好的美化，比如动态线条和鼠标点击小红心以及更改网站字体外观。在接下来的日子里，大概很长一段时间不会再对博客动刀了，也不愿再折腾了。 什么是美，什么是丑，很难给出一个具体的准则，有的东西因为拥有华丽的外表才显得很美，比如玫瑰；有的东西，简简单单，朴朴素素，但还是会觉得很美，就像白开水一样；王勃的文章比如《滕王阁序》辞藻华丽，优雅而又不落俗套，所以传唱至今；白居易的诗平易近人，人人都能读懂，但依旧能够名传千古，当然是因为诗美。所以，美与丑不可轻易下定论。 当经历了一些人生的波折，爱情的起伏之后，那些平淡的东西反而显得如此难能可贵。今天在微信上看到一句话说，如果你对一个人的爱可以用理性来衡量的话，那就不叫爱。细细想来，非常有道理，和之前很喜欢的一句话有异曲同工之妙：我说不出我为什么爱你，但我知道，你就是我不会再爱上别人的理由！ 和我家小狗在一起快两个月了，不过我们认识的时间已经快八年了，八年，不是一个很短的时间，为什么会突然走到一起，其实，在我们彼此看来，这一切并不突然。八年来，我们是最好的朋友，又像亲人一样，到最后发现，彼此谁也离不开谁了。还记得跟她表白的时候，很紧张，因为无论在我心里，她一直很重要，我很害怕，并不仅仅是害怕被拒绝，而是害怕拒绝以后连朋友也做不成，即使做不成情侣，我也想一直做一位弟弟。我觉得我很幸运，也很幸福，我表白之后的一两分钟里，她便接受我了，我们在一起了！ 那一刻感觉像是在做梦一样，那是2017年1月22号。还记得第一次吻她是2017年1月29号，第一次和她分别情绪失控是2017年2月16号，第一次大晚上打电话给她说了无数的情话是2017年2月28号…还有无数个第一次。忙起来的时候，我觉得一切和过去一样，但每天晚上静下来以后，无尽的思念便会侵入五脏六腑，我只想说：如果你没真正爱过，你不会懂这种滋味；如果你没有品尝过异地的爱恋，你更不会懂！ 现在，我们很了解彼此，很懂彼此，很理解彼此，更重要的是，我们很爱彼此，这一切已经足够让我们在人生的道路上一直走下去了。 两个周前，一个好兄弟发消息说自己好像不爱女友了，想分手，经过我的一番劝说，和好了；几天前，他又发消息来说分手了，于是我便说既然不爱，分了也好，甚至还去劝他女友放弃吧，既然他不爱不如干脆放手，可过了一天，他们又在一起了。我不知道该说什么。 除了我家小狗，我觉得，我的生命中不会再出现下一个人了！但对于爱情，我认为：不够了解，就千万别在一起；不够相爱，更不能在一起！ 否则，最后结局如何，我不知道… var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Linux 是什么","date":"2017-03-10T07:34:06.000Z","path":"2017/03/10/What-Is-Linux/","text":"正如上面的问题所述，我们将要了解： Linux 是什么？ 简单来说， Linux 是一个基于 Unix 的开源操作系统。 就像 Windows 或者 Mac OS 一样。 1991 年 10 月 5 日， Linus Torvalds 首次发布 Linux 内核。 Linux 内核是 Linux 系统的一个非常重要的组成部分。目前， Linux 主要用于多种服务器和超级计算机等。它也被用于手机操作系统，比如 Android 操作系统是基于 Linux 内核的。 在早期，Linux 作为一个免费的操作系统被用于基于 Intel ×86 的个人电脑上。因为 Linux 是一个开源操作系统，所以它的源代码可以被修改或使用，也可以在有 GPL（通用公共许可证）这样许可证下被任何人发布。简而言之，如果具备一定知识，知道自己在干什么，那么任何人都可以从 Linux 那儿获得自己的操作系统。正因此，才有了许多 Linux 发行版。 那么， Linux 发行版是什么？ 它是基于 Linux 内核的一个操作系统。它带有用户可以使用的软件集合。更多的，它还包含系统管理包。目前有许多 Linux 发行版。因为我们不能数清目前所有的 Linux 发行版，所以我们来看一下一些有名的版本：Ubuntu、Fedora、Opensuse、Red hat Linux 和 Debian 等是几个非常受欢迎的 Linux 发行版。 Ubuntu， 一个非常受欢迎的 Linux 发行版和第三受欢迎的操作系统 Linux 发行版是一个已经准备好可以在个人电脑上安装的完整包。一旦用户在桌面或者服务器上安装了 Linux 发行版，就可以使用各种现成的软件和应用程序。现在，很多 Linux 发行版都具有很好的图形用户界面（GUI），这使得它们成为 Windows 系统或 Mac 系统的一个很好的替代品。 目前， Linux 发行版在性能、界面、可访问性以及最重要的 - 用户友好性等方面都有了很大的提高。一些发行版比如 Ubuntu 和 Linux mint 等，随着用户数量的一天天增加，赢得了很好的市场地位。 Ubuntu 是紧随 Windows 和 Mac 第三受欢迎的操作系统。 对以上做个总结，那就是 Linux 是一个非常强大的操作系统（是的，它很强大）。日复一日，它将获得更多的用户影响力和声誉。所以，如果你还没有在你的电脑上尝试过使用任何 Linux 系统，那么我建议你尝试一下。我们敢保证， Linux 一定不会让你失望的。 via: http://www.techphylum.com/2014/05/what-is-linux-brief-description.html?m=1 作者：sumit rohankar译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Debian 和 Ubuntu 上安装 MariaDB 10","date":"2017-03-09T08:27:59.000Z","path":"2017/03/09/How-to-Install-MariaDB-10-in-Debian-and-Ubuntu/","text":"MariaDB 是深受欢迎的数据库管理服务器软件 MySQL 的一个自由开源的分支。它由 MySQL 的原开发者在 GPLv2（通用公共许可证 2 版）下开发，并保持开源。 它被设计来实现 MySQL 的高兼容性。对于初学者，可以阅读 MariaDB vs MySQL 来了解关于它们的特性的更多信息。更重要的是，它被一些大公司/组织使用，比如 Wikipedia、WordPress.com 和 Google plus ，除此之外还有更多的。 在这篇文章中，我将展示如何在 Debian 和 Ubuntu 发行版中安装 MariaDB 10.1 稳定版。 在 Debian 和 Ubuntu 上安装 MariaDB 1、在安装之前 MariaDB 之前，你需要通过下面的命令导入仓库密匙并获取 MariaDB 仓库 在 Debian 10 (Sid) 上 123 $ sudo apt-get install software-properties-common$ sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 0xF1656F24C74CD1D8$ sudo add-apt-repository 'deb [arch=amd64,i386] http://www.ftp.saix.net/DB/mariadb/repo/10.1/debian sid main' 在 Debian 9 (Stretch) 上 123 $ sudo apt-get install software-properties-common$ sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 0xF1656F24C74CD1D8$ sudo add-apt-repository 'deb [arch=amd64] http://www.ftp.saix.net/DB/mariadb/repo/10.1/debian stretch main' 在 Debian 8 (Jessie) 上 123 $ sudo apt-get install software-properties-common$ sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 0xcbcb082a1bb943db$ sudo add-apt-repository 'deb [arch=amd64,i386,ppc64el] http://www.ftp.saix.net/DB/mariadb/repo/10.1/debian jessie main' 在 Debian 7 (Wheezy) 上 123 $ sudo apt-get install python-software-properties$ sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 0xcbcb082a1bb943db$ sudo add-apt-repository 'deb [arch=amd64,i386] http://www.ftp.saix.net/DB/mariadb/repo/10.1/debian wheezy main' 在 Ubuntu 16.10 (Yakkety Yak) 上 123 $ sudo apt-get install software-properties-common$ sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8$ sudo add-apt-repository 'deb [arch=amd64,i386] http://www.ftp.saix.net/DB/mariadb/repo/10.1/ubuntu yakkety main' 在 Ubuntu 16.04 (Xenial Xerus) 上 123 $ sudo apt-get install software-properties-common$ sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8$ sudo add-apt-repository 'deb [arch=amd64,i386,ppc64el] http://www.ftp.saix.net/DB/mariadb/repo/10.1/ubuntu xenial main' 在 Ubuntu 14.04 (Trusty) 上 123 $ sudo apt-get install software-properties-common$ sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xcbcb082a1bb943db$ sudo add-apt-repository 'deb [arch=amd64,i386,ppc64el] http://www.ftp.saix.net/DB/mariadb/repo/10.1/ubuntu trusty main' 2、 然后，更新系统安装包列表，并像下面这样安装 MariaDB 服务器： 12 $ sudo apt-get update$ sudo apt-get install mariadb-server 安装过程中，将会请求你配置 MariaDB 服务器；在下面的页面中设置一个安全的 root 用户密码： 为 MariaDB 设置新的 Root 密码 再次输入密码并按下回车键来继续安装。 再次输入 MariaDB 密码 当 MariaDB 安装包安装完成以后，启动数据库服务器守护进程，同时启用它，使得在下次开机时它能够像下面这样自动启动： 12345678910 ------------- On SystemD Systems -------------$ sudo systemctl start mariadb$ sudo systemctl enable mariadb$ sudo systemctl status mariadb------------- On SysVinit Systems -------------$ sudo service mysql start$ chkconfig --level 35 mysql onOR$ update-rc.d mysql defaults$ sudo service mysql status 开启 MariaDB 服务 4、 然后，运行 mysql_secure_installation 脚本来保护数据库，在这儿你可以： 设置 root 密码（如果在上面的配置环节你没有进行设置的话）。 禁止远程 root 登录 移除测试数据库 移除匿名用户 重载权限配置 1 $ sudo mysql_secure_installation 保护 MariaDB 安装 5、 一旦数据库服务器受保护以后，可以使用下面的 shell 命令查看已安装版本和登录 MariaDB： 12 $ mysql -V$ mysql -u root -p 查看 MariaDB 版本 开始学习 MySQL/MariaDB， 请阅读： MySQL / MariaDB 初学者学习指南 — Part 1 MySQL / MariaDB 初学者学习指南 — Part 2 MySQL 基本数据库管理命令 — Part III 针对数据库管理员的 20 个 MySQL (Mysqladmin) 命令 — Part IV via: http://www.tecmint.com/install-mariadb-in-ubuntu-and-debian/ 作者：Aaron Kili译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"《Linux 命令行大全》学习笔记 - Part 2","date":"2017-03-05T05:02:11.000Z","path":"2017/03/05/Linux-Command-Line-learning-notes-Part2/","text":"第二部分 配置与环境 Chapter 11 环境 检查环境 1234567 $ printnev : 显示环境变量，可以在后面跟变量名，如： printnev USER$ set : 不带参数时，显示 shell 变量、环境变量和已定义 shell 函数$ echo $variable_name : 查看单个变量的值$ alias : 不带参数，查看别名 一些变量 DISPLAY : 运行图形界面环境时界面的名称 EDITOR : 用于文本编辑的程序名称 SHELL : 本机 shell 名称 HOME : 本机主目录路径名 LANG : 定义了本机语言的字符集和排序规则 OLD_PWD : 先前工作目录 PAGER : 用于分页输出的程序名称，一般为 /usr/bin/less PATH : 以冒号分割的一个目录列表 PS1 : 提示符字符串 1 PWD : 当前工作目录 TERM : 终端类型名称 TZ : 指定本机所处的时区 USER : 用户名 环境建立 login shell 启动文件： /etc/pofile ~/.bash_profile ~/.bash_login ~/.profile non-login shell 启动文件： /etc/bash.bashrc ~/.bashrc ： 用户个人启动文件 修改环境 一般修改 .bashrc 文件，比如设置别名。 激活修改：可以有两种方法：一种是关闭 shell 重新启动；另一种是强制启动，运行命令$ source .bashrc。 123 - $ export : 将环境导入随后要运行的程序中，如 export PATH；- $ alias new_name='command' : 设置别名，保存到 .bashrc 文件中以后永久起效； Chapter 12 VI 简介 启动和退出 12345 - $ vi/vi &lt;file&gt; : 启动；- $ q : 退出；- $ q! : 强制退出； 编辑模式 1234567 - 按&lt;i&gt;键 : 进入插入模式；- 按&lt;ESC&gt;键 ： 返回命令模式；- :w :保存文件（命令模式下）；- :wq :保存并退出； 移动光标（命令模式下） 1234567891011121314151617181920212223242526272829 - L ：右移一位==右方向键；- H ：左移一位==左方向键；- J ：下移一行==下方向键；- K ：上移一行==上方向键；- 数字 0 ：至本行行首；- ^ ：至本行第一个非空字符；- $ ：至本行的末尾；- 小写 w：至下一单词或标点的开头；- 大写 W：至下一单词的开头，忽略标点；- 小写 b：至上一单词或标点开头；- 大写 B：至上一单词开头，忽略标点；- Ctrl+F/Page Down：下翻一页；- Ctrl+B/Page Up：上翻一页；- number+G(大写)：至第number行- G(大写)：至文件最后一行； 基本编辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 添加文本- a ：将光标移动到行尾然后按&lt;a&gt;就可以越过行尾开始编辑；- A ：直接将光标移动到行尾并越过行尾进行编辑；行插入- 小写 o：插入一行，在当前行的下方；- 大写 O：插入一行，在当前行的上方；注：按&lt;ESC&gt;退回命令模式并按&lt;u&gt;可取消上面的行插入操作；u 键可撤回操作，每按一次撤销一次；删除文本- x：当前字符；- nx：当前字符和之后n-1个字符（指定删除字符数）；- dd：当前行；- ndd：当前行和之后n-1行；- dw：当前字符到下一单词的起始；- d$：当前字符到当前行的末尾；- d0：当前字符到当前行的起始；- d^：当前字符到当前行下一个非空字符；- dG：当前行到文件末尾；- dnG：当前行到文件第n行；注：命令d不只是删除文本，而是杂剪切文本，用户每次使用d命令之后，都会复制删除的内容进缓存，然后可以使用p（小写）命令将内容粘贴到光标之后，或使用P(大写)将内容粘贴到光标之前；复制命令- yy：当前行；- nyy：当前行和之后n-1行；- yW：当前字符到下一单词的起始；- y$：当前字符到当前行的末尾；- y0：当前字符到当前行的起始；- y^：当前字符到当前行下一个非空字符；- yG：当前行到文件末尾；- ynG：当前行到文件第n行；合并行- J：合并行； 查找和替换 12345678910111213141516 行内搜索&lt;f&gt; : 行内搜索，比如先后按下 fa 会将光标移到本行下一个出现 a 的地方；输入分号可以重复上一次搜索；搜索整个文件命令 / 可以完成对单词或短语的搜索，比如输入 /line 然后回车，会在文件中搜索字符串 line ;#### 全局搜索和替换:%s/Line/line/g : 将文件中的每一个 Line 替换为 line注： % 确定操作的范围，单独表示从第一行到最后一行，还可具体指定，比如 1,5 表示从第一行到第五行；1,$ 表示从第一行到文件最后一行；s 指定操作为替换操作；/Line/line 为搜索和替换的文本；g 代指全局-global，表示对每一行每一个都替换，如果缺失，只替换每一行的第一个； 编辑多个文件 vi file1 file2 file3... 切换文件：:n 切换到下一个文件；:N 切换回上一个文件；当用户从一个文件切换到另一个文件时，vi 会要求用户先保存对当前文件的修改，若不想保存，可以在命令后面添加感叹号； :buffers 查看正在编辑的文件列表 :buffers 2 切换到第二个文件 :e file 在现有编辑会话中添加另一个文件来进行编辑 文件之间内容复制：先切换到第一个文件:buffers 1，然后复制比如一行 yy，然后切换到第二个文件:buffers 2 ，然后粘贴 p； 插入整个文件先打开一个文件，然后把光标移到要插入的文件前，然后 :r anotherfile ，将把文件内容插入光标前 文件保存 ZZ(大写)：保存并退出:wq 保存并退出w filename 另存为filename Chapter 13 定制提示符 略… Part 2 结束！ var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"链式线性表","date":"2017-03-02T07:58:45.000Z","path":"2017/03/02/Link-List/","text":"线性表的链式表示和实现 线性表的链式存储是指用一组任意的 ( 连续的或不连续的 ) 存储单元存储线性表中的数据元素； 为了正确表示数据元素与其直接后续数据元素之间的逻辑关系，在存储每个元素值的同时，还必须存储指示其直接后继的地址 ( 或位置 )，称为指针 (pointer) 或链 (link)，这两部分组成了链表中的结点； 分类 单链表：每一个结点只包含一个指向直接后继的指针域； 双向链表：每一个结点包含两个指针域,其一指向直接后继,另一指向直接前驱； 循环链表：整个链表的指针域链接成一个或多个环； 双向循环链表：将头结点和尾结点链接起来的双向链表； 为操作方便,总是在链表的第一个结点之前附设一个头结点:头结点的数据域可以不存储任何信息 ( 或存储链表长度等信息 ),头结点的指针域存储指向第一个结点的指针 ( 即第一个结点的存储位置 )。 C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//宏定义#define OK 1#define ERROR 0#define OVERFLOW -1#define LESS -1#define GREATER 1#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量#define LISTINCREMENT 10 //线性表存储空间的分配增量typedef int Status;typedef int ElemType;//结点的类型定义typedef struct Lnode&#123; ElemType data; /* 数据域,保存结点的值 */ struct Lnode *next; /* 指针域 */ &#125;Lnode, LinkList;/* 结点的类型 *///结点赋值LNode *p;p=(LNode*)malloc(sizeof(LNode));p-&gt;data=20; p-&gt;next=NULL ;//创建单链表LinkList *CreateList_L(int n) &#123;// 逆序输入随机生成的 n 个元素的值// 建立带表头结点的单链表 LLinkList *L,*p; int i;// 先建立一个带头结点的空单链表L = (LinkList *)malloc(sizeof(LNode));L-&gt;next = NULL;for (i=n; i&gt;0; --i) &#123;p = (LinkList *)malloc(sizeof(LNode)); // 生成新结点p-&gt;data =random(200);// 随机生成一个 200 以内的数字p-&gt;next = L-&gt;next; L-&gt;next = p; // 插入到表头&#125;return L;&#125; // CreateList_L//单链表的插入Status ListInsert_L(LinkList *L, int i, ElemType e) &#123; // 在带头结点的单链表 L 的第 i 个元素之前插入元素e LinkList *p, *s; p = L; int j = 0; while (p &amp;&amp; j &lt; i-1) &#123;// 寻找第 i-1 个结点度、 p = p-&gt;next； ++j; &#125;// i 小于 1( 导致 j&gt;i-1 成立 ) 或者大于表长 ( 导致 p 为 NULL) if(!p || j &gt; i-1) return ERROR; s = (LinkList *)malloc(sizeof(LNode)); // 生成新结点 s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入 L 中 p-&gt;next = s; return OK;&#125; // LinstInsert_L//单链表的删除Status ListDelete_L(LinkList *L, int i, ElemType *e) &#123;// 在带头结点的单链表 L 中删除第 i 个元素,并由 e 返回其值 int j = 0; LinkList *p,*q; p = L; while (p-&gt;next &amp;&amp; j &lt; i-1) &#123; // 寻找第 i 个结点,并令 p 指向其前趋 p = p-&gt;next; ++j; &#125; // i 小于 1( 导致 j&gt;i-1 成立 ) 或者大于表长 ( 导致 p-&gt;next 为 NULL) if (!(p-&gt;next) || j &gt; i-1) return ERROR; q = p-&gt;next; p-&gt;next = q-&gt;next; // 删除并释放结点 e = q-&gt;data; free(q); return OK;&#125; // ListDelete_L//单链表查找Status GetElem_L(LinkList *L,int i, ElemType *e) &#123;// L 为带头结点的单链表的头指针// 当第 i 个元素存在时,其值赋给 e 并返回 OK ,否则返回 ERROR// 初始化, p 指向第一个结点, j 为计数器 LinkList *p; p = L-&gt;next; int j = 1; while (p &amp;&amp; j&lt;i) &#123; // 顺指针向后查找,直到 p 指向第 i 个元素或 p 为空 p = p-&gt;next; ++j; &#125; if ( !p || j&gt;i ) return ERROR; // 第 i 个元素不存在 *e = p-&gt;data; // 取第 i 个元素 return OK;&#125; // GetElem_L//合并有序链表LinkList *MergeList_L(LinkList *La, LinkList *Lb) &#123;// 合并 两非递减单链表 La 和 Lb ,成新的单链表 Lc , Lc的元素也按值非递减排列。 pa, pb 为两个链表的当前结点。 LinkList *Lc, *pa, *pb, *pc; //pc 为合并后链表的最后一个结点 pa = La-&gt;next; pb = Lb-&gt;next; Lc = pc = La; // 用 La 的头结点作为 Lc 的头结点 while (pa &amp;&amp; pb) &#123; if (pa-&gt;data &lt;= pb-&gt;data) &#123; pc-&gt;next = pa; pc = pa; pa = pa-&gt;next; &#125; else &#123; pc-&gt;next = pb; pc = pb; pb = pb-&gt;next; &#125; &#125; pc-&gt;next = pa ? pa : pb; // 插入剩余段 free(Lb); // 释放 Lb 的头结点 Return Lc;&#125; // MergeList_L 当前链表存在的问题： 链表的表长是隐含的； 若要在链表的最后一个元素之后插入元素,那么要遍历整个链表； 结点的当前位置很重要； 改进的措施： 增加变量,分别表示:表长、表尾、当前位置； 将操作中的参数“位序 i ” 改为“当前位置”； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254 //改进的单链表// 结点类型typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; Link, Position;// 链表类型typedef struct &#123; // head, tail 分别指向头结点和最后一个结点的指针 Link *head, *tail;// current 指向当前被访问的结点的指针// Link *current; // 其初始位置指向头结点// int curpos; // 指示当前指针位置 , 初值为 0 int len;// 指示链表长度&#125; LinkList;//构造新链表LinkList *InitList()&#123; LinkList *L; Link *p; L=(LinkList *)malloc(sizeof(LinkList)); if (!L) return NULL; p=(Link *)malloc(sizeof(LNode)); if(!p) return NULL; L-&gt;len=0; L-&gt;head=L-&gt;tail=p; return L;&#125;// 使得 p 指向 L 的第 i 个结点,并返回 pLink *LocatePos(LinkList *L, int i)&#123; Link *cur; int j=1; cur=L-&gt;head; while(cur &amp;&amp; j&lt;=i) &#123; // 寻找第 i 个结点 cur=cur-&gt;next; j++; &#125; if (!cur) return NULL; return cur;&#125;// 将 s 所指结点插入在链表 L 的 h 所指的结点之后Status InsAfter (LinkList *L, Link *h, Link *s)&#123; if(!L-&gt;head) return ERROR; L-&gt;len++; if (L-&gt;tail==h) L-&gt;tail=s; s-&gt;next=h-&gt;next; h-&gt;next=s; return OK;&#125;//在链表L的第i个结点前插入元素Status ListInsert_L(LinkList *L, int i, ElemType e)&#123; // 在链表 L 的第 i 个结点之前插入元素 e Link *p,*s; int j=0; p=L-&gt;head; while (p &amp;&amp; j&lt;i-1) &#123;// 寻找第 i-1 个结点 p=p-&gt;next;j++; &#125; if(!p || j&gt;i-1) return ERROR; s= MakeNode(e); if (!s) return ERROR; if(L-&gt;tail==p) L-&gt;tail=s; L-&gt;len++; s-&gt;next=p-&gt;next; p-&gt;next=s; return OK;&#125;//单链表运用-一元多项式// 用带头结点的有序链表表示多项式typedef struct node&#123;int c; // 多项式,系数, 可以用 float 类型int e; // 多项式,指数struct node *next;&#125;Polynomial;//创建一元多项式// 输入 m 项的系数和指数,建立表示一元多项式的有序链表PPolynomial *Create(int m)&#123; Polynomial *head,*p,*q; int i;// 生成头结点 p=head=(Polynomial*) malloc(sizeof(Polynomial)); for(i=1;i&lt;=m;i++)&#123; // 依次输入 m 个非零项 q=(Polynomial *)malloc(sizeof(Polynomial)); scanf(“%d %d”,&amp;q-&gt;c,&amp;q-&gt;e); p-&gt;next = q; p=q; &#125; p-&gt;next=NULL; return head;&#125; // Create//多项式相加void Plus(Polynomial *pa,Polynomial *pb)&#123; Polynomial*h,*p1,*p2,*q; h=pa; p1=pa-&gt;next;p2=pb-&gt;next; //p1,p2 分别指向 pa 和 pb 的第一个结点 while(p1!=NULL &amp;&amp; p2!=NULL) switch(Compare(p1-&gt;e, p2-&gt;e)) &#123; case 1: &#123; //p1 所指结点的指数值大,将 p2 的结点连接到 h h-&gt;next=p2; h=p2; p2=p2-&gt;next; break; &#125; case -1: &#123;//p2 所指结点的指数大,将 p1 的结点连接到 h h-&gt;next=p1; h=p1; p1=p1-&gt;next; break; &#125; case 0: &#123; // p1, p2 的指数一样大 if(p1-&gt;c + p2-&gt;c !=0) &#123; // 系数相加,和不为 0 ,修改 p1 的系数 p1-&gt;c =p1-&gt;c +p2-&gt;c; h-&gt;next=p1; h=p1; p1=p1-&gt;next; q=p2; p2=p2-&gt;next; free(q); &#125; else &#123; // 系数相加,和为 0 ,则去掉结点 q=p1;p1=p1-&gt;next;free(q); q=p2;p2=p2-&gt;next;free(q); &#125; Status Compare(int a,int b)&#123; if(a&gt;b) return 1; if(a&lt;b) return -1; return 0; &#125; &#125;&#125; if(p1!=NULL) h-&gt;next =p1; else h-&gt;next= p2; free(pb);&#125;//单链表的 C 数组实现:静态链表#define MAXSIZE 1000typedef struct SLinked&#123;ElemType data;int cur;&#125; SLinkedList[MAXSIZE];SLinkedList s;//静态链表初始化void InitList(SLinkedList space)&#123; for(int i=0;i&lt;MAXSIZE-1;i++) space[i].cur=i+1; space[MAXSIZE-1].cur=0;&#125;// 创建一个含有 n 个结点的静态链表,返回表头在存储数组的位置int CreateList(SLinkedList space,int n)&#123; int head,k,s,i; k=AllocNode(space); // 从空闲链表中取得一个空结点 head=k; for(i=1;i&lt;=n;i++)&#123; s=AllocNode(space); scanf(\"%d\",&amp;space[s].data); space[k].cur=s; k=s; &#125; space[k].cur=0; return head;&#125;//从空闲链表中分配一个结点和释放一个结点// 若空闲链表非空,则返回分配的结点下标,否则返回 0int AllocNode(SLinkedList space)&#123;int i;i=space[0].cur;if(i==0) return 0;space[0].cur=space[i].cur;return i;&#125;// 将下标为 i 的空闲结点回收到备用链表void FreeNode(SLinkedList space,int i)&#123;space[i].cur=space[0].cur;space[0].cur=i;&#125;// 在以 head 为表头的静态链表中,在第 i 个结点之前插入一个值为 x 的新结点int Insert(SLinkedList space,int head,int i,ElemType x)&#123; int j,k,m; if(i&lt;1) return 0; k=head;j=0; while (k!=0 &amp;&amp; j&lt;i-1)&#123; // 查找第 i-1 个结点 j++;k=space[k].cur; &#125; if(k==0) return 0; m=AllocNode(space); // 从空闲链表中获取结点, m 为该结点下标 if (m!=0)&#123; space[m].data=x; space[m].cur=space[k].cur; space[k].cur=m; return 1; &#125; else return 0;&#125;// 在以 head 为表头的静态链表中,删除第 i 个结点int Delete(SLinkedList space,int head,int i, ElemType *e)&#123; int j,k,m; if(i&lt;1) return 0; k=head;j=0; while (k!=0 &amp;&amp; j &lt;i-1)&#123; // 查找第 i-1 个结点 j++;k=space[k].cur; &#125; if(k==0) return 0; m=space[k].cur; space[k].cur=space[m].cur; *e=space[m].data; FreeNode(space,m); return 1;&#125;//在以 head 为表头的静态链表中,确定第 1 个值为 x的结点的位置// 若找到,则返回它在存储数组中的位置,否则返回 0int Locate(SLinkedList space, int head,ElemType x)&#123; int k; k=space[head].cur; // k 指示静态链表中的第一个结点 while(k!=0 &amp;&amp; space[k].data!=x) k=space[k].cur; // 顺链查找 return k;&#125;//集合合并void MergeAB(SLinkedList A, int ha,SLinkedList B, int hb)&#123; int i,j,k,m; ElemType x; j=B[hb].cur; while(j!=0)&#123; // 对 hb 中的每个结点,进行下面的步骤 x=B[j].data; i=Locate(A,ha,x); // 链表 ha 中查找有无 hb 中的元素 if(i==0) Insert(A,ha,1,x); // 将该元素插入 ha ,成为 ha的第一个元素 else &#123; // ha 有 hb 中的元素,则将该元素从 ha 中删除 m=0;k=ha; while(k!=i)&#123; m++;k=A[k].cur; &#125; Delete(A,ha,m,&amp;x); &#125; j=B[j].cur; &#125;&#125; 双向链表：构成链表的每个结点中设立两个指针域,一个指向其直接前趋的指针域 prior ,一个指向其直接后继的指针域 next； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 typedef struct node &#123; ElemType data ; struct node *prior , *next ;&#125; DoubleLinkedList;//创建长度为n的双向链表DoubleLinkedList *CreateDoubleLinkedList(int n)&#123; DoubleLinkedList *head,*p,*s; int i; // 创建头结点 p=head=(DoubleLinkedList *)malloc(sizeof(DoubleLinkedList)); for(i=1;i&lt;=n;i++)&#123; s=(DoubleLinkedList *) malloc(sizeof(DoubleLinkedList)); scanf(\"%d\",&amp;s-&gt;data); s-&gt;prior=p; p-&gt;next=s; p=s; &#125; p-&gt;next= head; head-&gt;prior = p; return head;&#125;//在双向链表中查找第 1 个值为 e 的结点DoubleLinkedList *Locate(DoubleLinkedList *head,ElemType e)&#123; DoubleLinkedList *p; p=head-&gt;next; //p 指向第一个结点 while(p!=head &amp;&amp; p-&gt;data !=e) p=p-&gt;next; if(p==head) return NULL; else return p;&#125;//在双向链表中查找第 1 个值为 e 的结点// 返回指向第 i 个结点的指针DoubleLinkedList *GetElemP(DoubleLinkedList *head,int i) &#123; DoubleLinkedList *p;int j; if(i&lt;1) return 0; p=head-&gt;next; // 初始化, p 指向第一个结点 j=1; //j 为计数器 while(p!=head &amp;&amp; j&lt;i)&#123; // 顺指针向后查找,直到 p 指向第 i 个结点或 p 为空 p=p-&gt;next; j++; &#125; if(p==head &amp;&amp; j&lt;i) return NULL; // 第 i 个元素不存在 return p;&#125;//在双向链表第 i 个结点之前插入元素 eint InsertElem(DoubleLinkedList *head,int i,ElemType e)&#123; DoubleLinkedList *p,*q;int j; if(i&lt;1) return 0; // i 的合法值为 1≤i≤ 表长 +1 p=head;j=0; while(p-&gt;next!=head &amp;&amp; j&lt;i-1)&#123; // 在 L 中确定第 i 个元素的位置指针 p p=p-&gt;next;j++; &#125; if(p-&gt;next!=head || (p-&gt;next == head &amp;&amp; j==i-1))&#123; q=(DoubleLinkedList *)malloc(sizeof(DoubleLinkedList)); q-&gt;data=e; q-&gt;next=p-&gt;next; q-&gt;prior=p; p-&gt;next-&gt;prior=q; p-&gt;next=q; return 1; &#125; else return 0; // 第 i 个元素不存在&#125;//在双向链表中删除第 i 个结点// 当第 i 个结点存在时,删除它并返回其值,否则返回 NULLint DeleteNode(DoubleLinkedList *head,int i,ElemType *e)&#123; DoubleLinkedList *p,*q; int j=0; if(i&lt;1) return 0; p=head-&gt;next; // p 指向第一个结点 while(p != head &amp;&amp; j&lt;i)&#123;// 顺指针向后查找,直到 p 指向第 i 个结点或 p 为空 p=p-&gt;next; j++; &#125; if(p ==head &amp;&amp; j&lt;i ) return 0; // 第 i 个结点不存在 p-&gt;prior-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=p-&gt;prior; *e=p-&gt;data; free(p); return 1;&#125; var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"顺序线性表","date":"2017-02-28T10:45:44.000Z","path":"2017/02/28/SqList/","text":"线性表（Linear list）定义 线性表是由 n(n&gt;=0) 个数据元素组成的有限序列，且该序列中的所有结点具有相同的数据类型。 线性表的逻辑结构 线性表中的结点可以是单值元素 ( 每个元素只有一个数据项） 线性表中的结点可以是记录型元素 ( 记录 )：每个记录含有多个数据项，每个项称为结点的一个域；每个记录有一个可以唯一标识每个结点的数据项组，称为关键字； 线性表的顺序表示 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素; 用存储位置相邻来表示数据元素之间的有序关系； 顺序线性表的 C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//宏定义#define OK 1#define ERROR 0#define OVERFLOW -1#define LESS -1#define GREATER 1#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量#define LISTINCREMENT 10 //线性表存储空间的分配增量typedef int Status;typedef int ElemType;//----线性表动态分配顺序存储结构----typedef struct&#123; ElemType *elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量&#125;SqList;//------构造一个空列表L-------Status InitList_Sq(SqList *L)&#123; L-&gt;elem=(ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType)); if(!L-&gt;elem) exit(OVERFLOW); //存储分配失败 L-&gt;length=0; //空表长度为0 L-&gt;listsize=LIST_INIT_SIZE; //初始存储容量 return OK;&#125;//InitList_Sq//------元素插入-------Status ListInsert_Sq(SqList *L,int i,ElemType e)&#123; //在顺序线性表L的第i个位置之前插入一个新元素e //i的合法值为1&lt;=i&lt;=ListLength_Sq(L)+1 if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; //i值不合法 if(L-&gt;length &gt;=L-&gt;listsize)&#123; //当前存储空间已满，增加分配 ElemType *newbase; newbase=(ElemType *)realloc(L-&gt;elem,(L-&gt;listsize+LISTINCREMENT)*sizeof(ElemType)); if(!newbase) exit(OVERFLOW); //存储分配失败 L-&gt;elem=newbase; //新基址 L-&gt;listsize+=LISTINCREMENT; //增加存储容量 &#125; ElemType *p,*q; q=&amp;(L-&gt;elem[i-1]); //q为插入位置 for(p=&amp;(L-&gt;elem[L-&gt;length-1]);p&gt;=q;--p) *(p+1)=*(p); //插入位置及之后元素右移 *q=e; //插入e ++L-&gt;length; //表长增1 return OK;&#125;//ListInsert_Sq//------元素删除------Status ListDelete_Sq(Sqlist *L,int i,ElemType *e)&#123; //删除第i个元素，并用e返回其值 if(i&lt;1||i&gt;L-&gt;length) return ERROR;//i值不合法 ElemType *p,*q; p=&amp;(L-&gt;elem[i-1]); //p 为被删除元素的位置 *e=*p; //被删除元素赋给p q=L-&gt;elem+L-&gt;length-1; //表尾元素的位置 for(++p;p&lt;=q;++q) *(p-1)=*p; //被删除元素之后元素左移 --L-&gt;length; return OK;&#125;//ListDelete_Sq//--------元素查找-----Status LocateElem_Sq(Sqlist *L,ElemType e,Status (*compare)(ElemType, ElemType))&#123; int i=1; //第一个元素的位序 ElemType *p=L-&gt;elem; while(i&lt;=L-&gt;length&amp;&amp;(*compare)(*p++,e)) ++i; if(i&lt;=L-&gt;length) return i; else return 0;&#125;//LocateElem_SqStatus (*compare)(ElemType a, ElemType b)&#123; if (a&lt;b) return LESS; if (a&gt;b) return GREATER; return 0;&#125;//-----顺序表的合并-------void MergeList_Sq(SqList *La,SqList *Lb,SqList *Lc)&#123; //已知顺序线性表La和Lb的元素按值非递减排列 //归并La和Lb得到新的顺序线性列表Lc,Lc也按非递减排列 ElemType *pa,*pb,*pc,*pa_last,*pb_last; pa=La-&gt;elem; pb=Lb-&gt;elam; Lc-&gt;listsize=Lc-&gt;length=La-&gt;length+Lb-&gt;length; pc=Lc-&gt;elem=(ElemType *)malloc(Lc-&gt;listsize*sizeof(ElemType)); if(!Lc-&gt;elem) exit(OVERFLOW); //存储分配失败 pa_last=La-&gt;elem+La-&gt;length-1; pb_last=Lb-&gt;elem+Lb-&gt;length-1; while(pa&lt;=pa_last&amp;&amp;pb&lt;pb_last)&#123; if(*pa&lt;=*pb) *pc++=*pa++; else *pc++=*pb++; &#125;//归并 while(pa&lt;=pa_last) *pc++=*pa++; //插入La的剩余元素 while(pb&lt;=pb_last) *pc++=*pb++; //插入Lb的剩余元素&#125;//MergeList_Sq//-------打印列表-----void PrintList(SqList L)&#123; for(int i=0;i&lt;L-&gt;length;i++)&#123; printf(\"%d\\t\",l-&gt;elem+i);//L-&gt;elem为首位置 &#125; printf(\"\\n\");&#125; var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何不用重命名在文件管理器中隐藏文件和文件夹","date":"2017-02-20T10:43:16.000Z","path":"2017/02/20/How-to-Hidden-File-and-Dir-Without-Rename/","text":"如果一个系统被多个用户使用，你或许出于个人原因想在文件管理器中隐藏一些文件或文件夹不让其他人看到（绝大多数用户不会对 Linux 系统进行深入了解，所以他们只会看到文件管理器列出的文件和文件夹），我们有三种方法可以来做这件事。此外，（除了隐藏）你还可以使用密码保护文件或文件夹。在这个教程中，我们将讨论如何用非重命名的方法在文件管理器中隐藏文件和文件夹。 我们都知道，通过以 点（“.”）前缀重命名一个文件或文件夹的方式，可以在 Linux 中将该文件或文件夹隐藏。但这不是隐藏文件或文件夹的正确/高效方式。一些文件管理器也隐藏文件名以波浪号（“~”）结尾的文件，那些文件被认为是备份文件。 在文件管理器中隐藏文件或文件夹的三种方法： 给文件或文件夹名添加一个 点（“.”）前缀。 创建一个叫做 .hidden 的文件，然后把需要隐藏的文件或文件夹加到里面。 使用 Nautilus Hide 扩展 通过点（“.”）前缀隐藏文件或文件夹 这是每个人都知道的方法，因为默认情况下文件管理器和终端都不会显示以点（“.”）作为前缀的文件或文件夹。要隐藏一个现有文件，我们必须重命名它。这种方法并不总是一个好主意。我不推荐这种方法，在紧急情况下你可以使用这种方法，但不要特意这样做。 为了测试，我将创建一个叫做 .magi 的新文件夹。看下面的输出，当我使用 ls -lh 命令时，不会显示以点（“.”）作为前缀的文件或文件夹。在文件管理器中你也可以看到相同的结果。 12345 # mkdir .magi# ls -lhtotal 36K-rw-r--r-- 1 magi magi 32K Dec 28 03:29 nmon-old 文件管理器查看。 为了澄清一下，我在 ls 命令后面加上 -a 选项来列出被隐藏文件（是的，现在我可以看到文件名 .magi 了）。 123456 # ls -latotal 52drwxr-xr-x 4 magi magi 4096 Feb 12 01:09 .drwxr-xr-x 24 magi magi 4096 Feb 11 23:41 ..drwxr-xr-x 2 magi magi 4096 Feb 12 01:09 .magi-rw-r--r-- 1 magi magi 32387 Dec 28 03:29 nmon-old 为了查看文件管理器中的被隐藏文件，只需按 Ctrl+h 快捷键，再次按 Ctrl+h 又可以把这些文件隐藏。 用非重命名方法，通过 “.hidden” 文件的帮助隐藏文件或文件夹 如果你想用非重命名的方法隐藏一个文件，或者一些应用不允许重命名。在这种情况下，你可以使用 .hidden 文件，它可能是最适合你的选择。 一些文件管理器，比如 Nautilus、Nemo、Caja 和 Thunar，提供了一种很原始的方法来隐藏文件，不需要重命名。怎样做？只需在想要隐藏文件的地方创建一个叫做 .hidden 的文件，然后把想隐藏的文件和文件夹列表一行一个地加进来。最后，刷新文件夹，那些文件将不显示出来。 为了测试，我将在同一目录下创建一个叫做 .hidden 的文件和两个分别叫做 2g、2daygeek 的文件/文件夹，然后把它们加到 .hidden 文件中。 123456 # touch 2g# mkdir 2daygeek# nano .hidden2g2daygeek 将两个文件加到 .hidden 文件之前。 将两个文件加到 .hidden 文件之后。 通过按 Ctrl+h 显示所有文件。 Nautilus Hide 扩展 Nautilus Hide 是针对 Nautilus 文件管理器的一个简单的 Python 扩展，它在右键菜单中增加了隐藏或显示被隐藏文件的选项。 要在 Ubuntu 及其衍生版上安装 Nautilus 和 Namo 的 Hide 扩展，我们可以在 Ubuntu 及其衍生版上通过运行下面的命令： 12345 $ sudo apt install nautilus-hide$ nautilus -q$ sudo apt install nemo-hide$ nemo -q 对于基于 DEB 的系统，可以按照下面的步骤安装 Nautilus Hide 扩展： 1234567 $ sudo apt install cmake gettext python-nautilus xdotool$ mkdir build$ cd build$ cmake ..$ sudo make$ sudo make install$ nautilus -q 对于基于 RPM 的系统，按照下面的步骤安装 Nautilus Hide 扩展： 1234567 $ sudo [yum|dnf|zypper] install cmake gettext nautilus-python xdotool$ mkdir build$ cd build$ cmake ..$ sudo make$ sudo make install$ nautilus -q 这个扩展其实就是简单的使用 .hidden 文件来隐藏文件。当你选择隐藏一个文件时，它的名字就加入到 .hidden 文件。当你选择对它解除隐藏（为解除隐藏，按 Ctrl+h 快捷键来显示包括点（“.”）前缀在内的所有文件，然后选择解除隐藏文件Unhide Files）时，它的名字就从 .hidden 文件中移除（当把所有列在 .hidden 文件中的文件都解除隐藏以后， .hidden 文件也就随之消失了）。如果文件没有被隐藏/显示，请按 F5 来刷新文件夹。 你可能会问，方法二也能完成相同的事情，为什么我还要安装 Nautilus Hide 扩展。在方法二中，我需要在要隐藏文件的地方手动创建一个 .hidden 文件，然后必须把需要隐藏的文件加到其中，但在这儿一切都是自动的。简单的右键单击，然后选择隐藏或取消隐藏（如果 .hidden 文件还不存在，它会自动创建 ）。 使用 Nautilus Hide 扩展来隐藏一个文件。 看下面的屏幕截图，我们使用 Nautilus Hide 扩展来隐藏一个文件。 使用 Nautilus Hide 扩展来解除文件隐藏。 看下面的屏幕截图，我们使用 Nautilus Hide 扩展解除对一个文件的隐藏（通过按 Ctrl+h， 你可以查看所有的被隐藏文件和文件夹）。 via: http://www.2daygeek.com/how-to-hide-files-and-folders-in-file-manager-without-renaming/ 作者：MAGESH MARUTHAMUTHU译者：ucasFL校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"2016 年十大顶级开源项目","date":"2017-02-14T10:37:24.000Z","path":"2017/02/14/10-Top-Open-Source-Projects-of-2016/","text":"在我们今年的年度顶级开源项目列表中，让我们回顾一下作者们提到的几个 2016 年受欢迎的项目，以及社区管理员选出的钟爱项目。 我们持续关注每年新出现的、成长、改变和发展的优秀开源项目。挑选 10 个开源项目到我们的年度顶级项目列表中并不太容易，而且，也没有哪个如此短的列表能够包含每一个应该包含在内的项目。 为了挑选 10 个顶级开源项目，我们回顾了作者们 2016 年涉及到的流行的开源项目，同时也从社区管理员收集了一些意见。经过管理员的一番推荐和投票之后，我们的编辑团队选定了最终的列表。 它们就在这儿， 2016 年 10 个顶级开源项目： Atom Atom 是一个来自 GitHub 的可魔改的（hackable）文本编辑器。Jono Bacon 在今年的早些时候为它的“简单核心”写了一篇文章，对该开源项目所给用户带来的选择而大加赞赏。 “Atom 带来了大多数用户想要的主要核心特性和设置，但是缺失了一些用户可能想要的更加高级或独特的特性。……Atom 提供了一个强大的框架，从而允许它的许多部分都可以被改变或扩展。” 如果打算开始使用 Atom， 请先阅读这篇指南。如果想加入到用户社区，你可以在 GitHub、Discuss 和 Slack 上找到 Atom 。 Atom 是 MIT 许可的，它的源代码托管在 GitHub 上。 Eclipse Che Eclipse Che 是下一代在线集成开发环境（IDE）和开发者工作区。Joshua Allen Holm 在 2016 年 11 月为我们点评了 Eclipse Che，使我们可以一窥项目背后的开发者社区，Eclipse Che 创新性地使用了容器技术，并且开箱即用就支持多种流行语言。 “Eclipse Che 集成了就绪即用（ ready-to-go）的软件环境（stack）覆盖了绝大多数现代流行语言。这包括 C++、Java、Go、PHP、Python、.NET、Node.js、Ruby on Rails 和 Android 开发的软件环境。软件环境仓库（Stack Library ）如果不够的话，甚至还提供了更多的选择，你可以创建一个能够提供特殊环境的定制软件环境。” 你可以通过网上的托管账户、本地安装，或者在你常用的云供应商上测试 Eclipse Che。你也可以在 GitHub 上找到它的 源代码，发布于 Eclipse 公开许可证之下。 FreeCAD FreeCAD 是用 Python 写的，是一款电脑辅助设计工具（或叫电脑辅助起草工具），可以用它来为实际物体创建设计模型。 Jason Baker 在 3 款可供选择的 AutoCAD 的开源替代品一文中写到关于 FreeCAD ： “FreeCAD 可以从各种常见格式中导入和导出 3D 对象，其模块化结构使得它易于通过各种插件扩展基本功能。该程序有许多内置的界面选项，这包括从草稿到渲染器，甚至还有一个机器人仿真能力。” FreeCAD 是 LGPL 许可的，它的源代码托管在 GitHub 上。 GnuCash GnuCash 是一个跨平台的开源桌面应用，它可以用来管理个人和小型商业账户。 Jason Baker 把 GnuCash 列入了我们针对个人金融的 Mint 和 Quicken 的开源替代品的综述列表中： GnuCash “具有多项记账的特性，能从多种格式导入数据，处理多重汇率，为你创建预算，打印支票，创建定制计划报告，并且能够直接从网上银行导入和拉取股票行情。” 其发布于 GPL 版本 2 或版本 3 许可证下，你可以在 GitHub 上找到 GnuCash 的源代码。 一个值得一提的 GnuCash 可选替代品是 KMyMoney，它也得到了该列表的提名，是另一个在 Linux 上管理财务的好选择。 Kodi Kodi 是一个开源媒体中心应用，之前叫做 XBMC，它能够在多种设备上工作，是一个用来 DIY 播放电影、TV、音乐的机顶盒的工具。 Kodi 高度可定制化，它支持多种皮肤、插件和许多遥控设备（包括它自己定制的 Android remote 应用）。 尽管今年我们没有深入地报道 Kodi， 但依旧出现在许多关于创建一个家用 Linux 音乐服务器、媒体管理工具的文章中，还出现在之前的一个关于最喜爱的开源 视频播放器的投票中（如果你在家中使用 Kodi，想要写一些自己的体验，请让我们知道）。 其发布于 GPLv2 许可证下，你可以在 GitHub 上找到 Kodi 的源代码。 MyCollab MyCollab 是一套针对顾客关系管理（CRM）、文档管理和项目管理的工具。社区管理员 Robin Muilwijk 在他的综述 2016 年 11 个顶级的项目管理工具一文中详细阐述了 MyCollab-Project 的细节： “MyCollab-Project 包含许多特性，比如甘特图、里程碑、时间跟踪和事件管理。它有 Kanban 板功能，因而支持敏捷开发模式。 MyCollab-Project 有三个不同的版本，其中社区版是自由且开源的。” 安装 MyCollab 需要 Java 运行环境和 MySQL 环境的支持。请访问 MyCollab 网站来了解如何对项目做贡献。 MyCollab 是 AGPLv3 许可的，它的源代码托管在 GitHub 上。 OpenAPS OpenAPS 是社区管理员在 2016 年发现的另一个有趣的项目，我们也深入报道过它。 OpenAPS，即 Open Artificial Pancreas System 项目，是一个致力于提高 1 型糖尿病患者生活质量的开源项目。 该项目包含“一个专注安全的典范（reference）设计、一个工具箱和一个开源的典范（reference）实现，它们是为设备制造商或者任何能够构造人工胰腺设备的个人设计的，从而能够根据胰岛素水平安全地调节血液中葡萄糖水平。尽管潜在用户在尝试亲自构建或使用该系统前应该小心地测试该项目并和他们的健康护理医生讨论，但该项目的创建者希望开放技术能够加速医疗设备行业的研究和开发步伐，从而发现新的治疗方案并更快的投入市场。” OpenHAB OpenHAB 是一个具有可插拔体系结构的家用自动化平台。社区管理员 D Ruth Bavousett 今年购买该平台并尝试使用以后为 OpenHAB 写到： “我所发现的其中一个有趣的模块是蓝牙绑定；它能够发现特定的已启用蓝牙的设备（比如你的智能手机、你孩子的那些设备）并且在这些设备到达或离开的时候采取行动－关门或开门、开灯、调节恒温器和关闭安全模式等等” 查看这个能够与社交网络、即时消息和云 IoT 平台进行集成和通讯的绑定和捆绑设备的完整列表。 OpenHAB 是 EPL 许可的，它的源代码托管在 GitHub 上。 OpenToonz OpenToonz 是一个 2D 动画生产软件。社区管理员 Joshua Allen 在 2016 年 3 月报道了它的开源版本，在 Opensource.com 网站的其他动画相关的文章中它也有被提及，但是我们并没有深入介绍，敬请期待。 现在，我们可以告诉你的是， OpenToonz 有许多独一无二的特性，包括 GTS，它是吉卜力工作室（Studio Ghibli ）开发的一个生成工具，还有一个用于图像处理的效果插件 SDK。 如果想讨论开发和视频研究的话题，请查看 GitHub 上的论坛。 OpenToonz 的源代码托管在 GitHub 上，该项目是以 BSD 许可证发布。 Roundcube Roundcube 是一个现代化、基于浏览器的邮件客户端，它提供了邮箱用户使用桌面客户端时可能用到的许多（如果不是全部）功能。它有许多特性，包括支持超过 70 种语言、集成拼写检查、拖放界面、功能丰富的通讯簿、 HTML 电子邮件撰写、多条件搜索、 PGP 加密支持、会话线索等。 Roundcube 可以作为许多用户的邮件客户端的偶尔的替代品工作。 在我们的 Gmail的开源替代品 综述中， Roundcube 和另外四个邮件客户端均被包含在内。 其以 GPLv3 许可证发布，你可以在 GitHub 上找到 Roundcube 的源代码。除了直接下载、安装该项目，你也可以在许多完整的邮箱服务器软件中找到它，如 Groupware、iRedMail、Mail-in-a-Box 和 mailcow。 这就是我们的列表了。在 2016 年，你有什么喜爱的开源项目吗？喜爱的原因呢？请在下面的评论框发表。 作者简介： Jen Wike Huger - Jen Wike Huger 是 Opensource.com 网站的内容管理员。她负责日期发布、协调编辑团队并指导新作者和已有作者。请在 Twitter 上关注她 @jenwike， 并在 Jen.io 上查看她的更多个人简介。 via: https://opensource.com/article/16/12/yearbook-top-10-open-source-projects 作者：Jen Wike Huger译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"再见，为了再见","date":"2017-02-13T15:38:20.000Z","path":"2017/02/13/Goodbye-for-Goodbye/","text":"一个月前的现在我大概刚到教学楼不久在考完期末考的第一天晚上 通宵赶作业一个月过去了抓不住的是时光 明天 又要走了又要离开家乡一路向北 去往远方那座寒冷的城 看得出爸妈的不舍很晚还非要陪我多坐一会儿我也不舍 留恋爸妈留恋这片土地这里的每一寸土地都认识我我也认识这里的每一寸土地爷爷出生的时候它们就在这儿父亲出生的时候它们还在这儿我出生的时候它们依旧在这儿 还有我的挚爱谢谢你选择我庆幸我选择你对你的不舍甚至超过亲人我愿为你倾吾一生 亲爱的我还是很喜欢你像风走了八千里不问归期 再见 为了再见 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"《Linux 命令行大全》学习笔记 - Part 1","date":"2017-02-03T13:12:16.000Z","path":"2017/02/03/Linux-Command-Line-learnig-notes-Part1/","text":"前言 因对 Linux 命令行的喜爱，故入手《Linux 命令行大全》一书，打算从头至尾阅读、学习一遍，并将书中每一章节的命令集中整理如下。 第一部分：学习 shell Chapter 1 学习 shell $ date : 显示当前系统的时间和日期 $ cal : 显示日历 $ df : 查看磁盘驱动器可用空间 $ free : 显示可用内存 $ exit : 关闭终端窗口 Chapter 2 导航 $ pwd : 显示当前工作目录 $ ls : 列出当前工作目录的文件和目录 $ cd : 更改当前工作目录（路径名） 绝对路径名： 从根目录开始，通向目标目录 相对路径名： 从工作目录开始，通向目标目录 .. : 代表工作目录的父目录 . : 代表工作目录 $ cd .. : 进入工作目录的父目录 $ cd : 将工作目录变成主目录 $ cd - : 将工作目录变成先前工作目录 $ cd ~username : 将工作目录变成 username 的主目录 注：以 . 字符开头的文件名是隐藏的，用 ls 命令无法列出；如需列出，需使用 ls -a 命令（ls 和 -a 之间有空格）。 Chapter 3 Linux 系统 $ ls : 列出可见文件和目录 ls 命令选项 -a : 列出所有文件和目录（包括被隐藏的） -d : 查看目录信息，不列出目录内容（在指定了目录的情况下） -F : 在列出的名字后面加上类型指示符 -h : 以长格式列出，以可读方式显示文件大小 -l : 使用长格式显示结果 -r : 以降序显示结果（默认以升序显示） -S : 按文件大小排序 -t : 按修改时间排序 $ file filename : 文件类型简单说明 $ less filename : 查看文件内容(按 q 退出) less 命令的一些功能键 向下箭头键 : 向下一行 G : 跳转到文本尾 g : 跳转到文本头 /charecters: 向前查找指定字符串 n : 向前查找下一个之前的指定字符串 h : 显示帮助屏幕 q : 退出 less 命令、 注：命令行中复制粘贴文件的方法：双击文件名复制，中键单击将可将其粘贴进命令行 Chapter 4 操作文件和目录 通配符 * : 匹配任意多个字符 ? : 匹配任意单个字符 [charecters] : 匹配任意一个属于字符集中的字符 [!charecters] : 匹配任意一个不属于字符集中的字符 [[:class:]] : 匹配任意一个属于指定字符类中的字符 常用字符集 [:alnum:] : 匹配任意一个字母或数字 [:alpha:] : 匹配任意一个字母 [:digit:] : 匹配任意一个数字 [:lower:] : 匹配任意一个小写字母 [:upper:] : 匹配任意一个大写字母 创建目录 $ mkdir dir1/mkdir dir1 dir2 dir3 : 创建目录 复制文件 $ cp item1 item2 : 将单个文件或目录 item1 复制到文件或目录 item2 中 $ cp item… directory : 将多个项目（文件或目录）复制进一个目录中 cp 命令选项 -a : 复制文件和目录及其属性 -i : 在覆盖一个已存在文件前，提示用户确认 -r : 递归复制目录及其内容 -u : 当将文件从一个目录复制到另一个目录时，只复制目标目录中不存在的文件或更新文件 -v : 复制文件时，显示信息性消息 移动/重命名文件 $ mv item1 item2 : 将文件（目录） item1 移动（重命名）为 item2 $ mv item… directory : 将一个或多个条目从一个目录移动到另一个目录下 mv 命令选项 -i : 覆盖一个已存在文件前，提示用户确认 -u : 将文件从一个目录移动到另一个目录，只移动目标目录中不存在的文件或更新文件 -v : 移动文件时显示信息性消息 删除文件和目录 $ rm item… : 删除一个或多个文件或目录 rm 命令选项 -i : 删除一个已存在文件前，提示用户确认 -r : 递归删除目录 -f : 忽略不存在的文件并无需提示确认（该选项会覆盖 -i 选项） -v : 删除文件时显示信息性消息 创建链接 $ ln file link : 创建硬链接 $ ln -s item link : 创建符号链接 注：硬链接： 一个文件的一个或多个文件名，与文件本身无区别，多个文件，均指向同一硬盘地址，会同步更新。符号链接： 又称软链接，一类特殊文件，该文件包含另一文件的路径名，类似 Windows 的快捷方式。 Chapter 5 命令的使用 命令的四种情况 可执行程序 shell 内置命令 shell 函数 alias 命令 显示命令类型 $ type command : 查看命令类型 显示可执行程序位置 $ which pragram : 查看程序位置 获取 shell 内置命令的帮助文档 $ help command : 获取帮助文档，如： help cd 显示命令使用信息 $ command –help : 显示命令使用信息，如： mkdir –help 显示程序的手册页 $ man program : 显示程序手册页 man 手册文档的组织结构 1 : 用户命令 2 : 内核系统调用的程序接口 3 : C 库函数程序接口 4 : 特殊文件 5 : 文件格式 6 : 游戏和娱乐 7 : 其他杂项 8 : 系统管理命令另一种查询方式： $ : man section search_term 比如： man 5 passwd $ apropos command : 显示合适命令，搜索参考条目 $ whatis command : 显示命令的简要描述 显示程序的 info 条目 $ info/info command info 命令 ? : 显示命令帮助 PAGE UP/BACKSPACE : 返回上一页 PAGE DOWN/Spacebar : 翻到下一页 n : 显示下一个节点 p : 显示上一个节点 u : 显示目前显示节点的父节点 ENTER : 进入光标所指的超链接 q : 退出 系统软件包文档文件存放位置： /usr/share/doc 使用别名创建自己的命令 tip : 将多条命令输在同一行中： command1;command2;command3… 创建别名： $ alias name=’command_string’如： alias foo=’cd/usr;ls;cd -‘，则之后就可以用 foo 表示等号后面的命令，可以用 type 命令查看。 删除别名： $ unalias name如： unalias foo ，现在别名就消失了。 Chapter 6 重定向 标准输出重定向 $ command &gt; filename : 将命令的输出结果保存到文件 filename 中 注：若文件不存在，则会创建一个新文件；若文件存在，会从文件开始的地方写入，即会覆盖之前的文件内容，因此，可通过重定向清除文件内容或创建新文件，方法如下： $ &gt; filename : 文件存在则清除了文件内容；文件不存在则创建了一个新文件 （另一重定向符）从文件尾追加输出内容： $ : command &gt;&gt; filename : 命令可以为空；当文件不存在时，和 &gt; 作用相同 标准错误重定向 文件描述符 0 : 标准输入文件 1 : 标准输出文件 2 : 标准错误文件 $ command 2&gt; filename : 将文件描述符紧放在重定向符前面即可将标准错误重定向 stdout 和 stderr 重定向到同一个文件 有两种方法可完成该任务： $ command &gt; filename 2&gt;&amp;1 : 旧版本 shell $ command &amp;&gt; filename : 最近的 bash 版本 处理不想要的输出 将输出重定向到文件 ‘/dev/null’ 中： $ command &gt; /dev/null 或 command 2&gt; /dev/null : 该文件接受输入但不对输入做任何处理 标准输入重定向 cat - 合并文件 $ cat filename : 读取、显示文件内容 $ cat : 后面不跟参数时，它从标准输入读取内容，默认情况下即等待键盘输入 cat 可拼接文件，假设有文件 file.001，file.002，…file.099，要拼接成一个文件 file ，可执行命令： $ cat file.0* &gt; file ：将按顺序拼接文件 $ cat &gt; filename : 从键盘输入内容到文件 filename 中 $ cat &lt; filename : 将标准输入源从键盘变为 filename 管道 $ command1 | command2 : 将 command1 的标准输出传送到 command2 的标准输入中 过滤器 sort : 排序列表 同时多个命令，如： $ ls -l | sort | less : 产生一个排好序的列表 uniq : 报告或忽略文本中重复的行如： $ ls -l | sort | uniq | less : 删除 sort 命令的输出中任意重复的行 wc : 打印行数、字数和字节数 $ wc filename : 依次打印出行数、字数和字节数 多命令，如： $ ls | sort | uniq | wc -l : -l 选项限制命令只报告行数 grep : 打印匹配行 grep pattern file : 打印出所有包含 pattern 的行 多命令，如： $ ls -l | grep zip : 打印出所有包含 zip 的行 grep 选项 -i : 忽略大小写，默认情况下区分大小写 -v : 输出不匹配行 head/tail : 打印文件的开头部分（前 10 行）/结尾部分（后 10 行）可用 ‘-n’ 选项调整行数，命令格式为： $ head/tail -n line_number filename : 输出文件的开头或结尾 line_number 行内容 命令选项也可用于管道中： $ ls | tail -n 5 tail 命令的 ‘-f’ 选项： 实时查看内容，如： $ tail -f /var/logg/messages : 持续监视该文件，一旦添加新行，新行立即显示在屏幕上 tee :从 stdin 读取数据，并同时输出到 stdout 和文件中如： $ ls | tee ls.txt : 将整个目录列表输入到 ls.txt 文件中 Chapter 7 透过 Shell 看世界 扩展 $ echo command : echo 把文本参数打印到标准输出 注：在每次输入命令 ENTER 键时， bash 都会在执行命令前对文本进行多重处理，称为扩展。 路径名扩展 example: $ echo charecter** : 显示以字符 charecter* 开头的所有文件 $ echo *charecter : 显示以字符 charecter 结尾的所有文件 $ echo [[:upper:]]* : 显示所有以大写字母开头的文件 波浪线扩展 ~ : 当把波浪线用在单词的开头，它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录 example: $ echo ~fenglv : 扩展为用户 fenglv 的主目录 算数扩展 shell 支持通过扩展来运行算数表达式，因此可把 shell 提示符当计算器使用： $ echo $((2+2)) : 在标准输出打印出 4;扩展的格式为： $((expression)) 算数运算符 : 加 : 减 : 乘 / : 除 % : 取余 ** : 取幂 注： 表达式可嵌套：echo $(($((52)) * 3))，可改写为：echo $(((52) * 3)) 花括号扩展 花括号扩展的模式信息包括前导字符和附言，最普遍应用为创建一系列的文件和目录。example: $ echo Front-{A,B,C}-BackFront-A-Back Front-B-Back Front-C-Back $ echo Number_{1..5}Number_1 Number_2 Number_3 Number_4 Number_5 $ mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12} $ ls2009-01 2010-01 2011-012009-02 2010-02 2011-02. . .2009-12 2010-12 2011-12 参数扩展 $ echo \\$variable : 触发参数扩展，显示变量内容 $ printenv | less : 查看变量列表 命令替换 命令替换可以把一个命令的输出作为一个扩展模式使用： example: $ echo \\$(ls) : 打印出文件和目录 $ ls -l \\$(which cp) : 显示 cp 所在目录的长信息， which cp 命令的运行结果作为了 ls 命令的一个参数 $ file \\$(ls /usr/bin/* |grep zip) : 管道输出作为 file 的参数 引用 shell 提供了一种引用机制，有选择性的避免不想要的扩展。 example: $ echo this(多空格) is a test: 打印时会除去多余的空白 $ echo The total is \\$100.00 : 打印结果为： The total is 00.00；\\$1 为未定义变量，故被替换为空字符。 双引号 如果把文本放在双引号中，那么特殊字符均会失效（\\$(美元符号)、\\ (反斜杠)、’(反引号) 三者除外）。可用双引号阻止单词分割： $ ls -l two book.txt : 会被当成两个参数，显示错误正确命令： $ ls -l “two book.txt” 注： 参数扩展、算数扩展和命令替换在双引号中依然起用 无引号时，空格、制表符、以及换行均只被当做分割符，但如果加上引号，就变成参数的一部分 单词分割机制会把换行符当成界定符：注意下面两个命令个输出的区别$ echo \\$(cal)$ echo “\\$(cal)” 单引号 单引号会抑制所有的扩展，在单引号中所有的字符都会变成普通字符。 转移字符 当要引用单个字符时，可通过在字符前加反斜杠来实现：（与 C 语言类似） 注： echo 中加 ‘-e’ 选项可以解释转义字符 $ sleep 10 : 等待 10 s(和 C 语言中类似) Chapter 8 高级键盘技巧 编辑命令行 bash 使用了一个名为 Readline 的库，来实现命令行的编辑。 光标移动组合键 Ctrl+A : 移动光标到行首 Ctrl+E : 移动光标到行尾 Ctrl+F : 光标向前移动一个字符＝＝右箭头键 Ctrl+B : 光标向后移动一个字符＝＝左箭头键 Alt+F : 光标向前移动一个字 Alt+B : 光标向后移动一个字 Ctrl+L : 清屏并把光标移到左上角＝＝clear 修改文本 Ctrl+D : 删除光标处的字符 Ctrl+T : 使光标处的字符和它前面的字符对调位置 Alt+T : 使光标处的字和它前面的字对调位置 Alt+L : 把从光标到字尾的字符转换为小写字母形式 Alt+U : 把从光标到字尾的字符转换为大写字母形式 剪切和粘贴 Readline 文档中使用 killing 和 yanking 来指代剪切和粘贴，被剪切内容被放在叫做 king-ring 的缓冲区中。 Ctrl+K : 剪切从光标到行尾的文本 Ctrl+U : 剪切从光标到行首的文本 Alt+D : 剪切从光标到当前词尾的文本 Alt+BACKSPACE: 剪切从光标到词头的文本；如果光标在词头，则剪切前一个单词 Ctrl+Y : 把被剪切到缓冲区中的文本粘贴到光标位置 注：Alt 键相当于元键，按下并释放 Esc 键等同于长按 Alt 键。 自动补全 输入一部分命令后按下 Tab 键，会自动补全当补全内容唯一时。自动补全可针对变量、用户名、命令和主机名等。 两个 Tab : 显示所有可能的补全列表＝＝Alt+$ Alt+* : 插入所有的匹配项 使用历史命令 bash 会保存使用过的命令的历史记录，这些命令的历史记录列表会被保存在用户主目录的 .bash_history 文件中。 搜索历史命令 $ history | less : 查看历史记录的内容列表 默认情况下， bash 会保存用户最近使用过的 500 个命令。 $ history | grep /usr/bin : 找出用来列出 /usr/bin 目录下内容的命令 历史记录命令 Ctrl+P : 移动到前一条历史记录＝＝向上箭头键 Ctrl+N : 移动到后一条历史记录＝＝向下箭头键 Alt+&lt; : 移动到历史记录列表的开始处 Alt+&gt; : 移动到历史记录列表的结尾处，即当前命令行 Ctrl+R : 逆向递增搜索。从当前命令行向前递增搜索 Alt+P : 逆向非递增搜索。按下该组合键，接着输入待搜索字符串，然后按下 Enter 键，才开始搜索 Alt+N : 向前非递增搜索 Ctrl+O : 执行历史记录中的当前项，执行完跳转到下一项 历史记录扩展 $ !! : 重复最后一个执行的命令＝＝先按向上箭头键，再按 Enter 键；后者更简单 $ !number : 重复历史记录中第 number 行的命令 $ ! string : 重复最近以 string 开头的历史记录 $ !?string : 重复最近包含 string 的历史记录 注： Linux 中包含一个 script 程序，该程序记录下 shell 的整个会话并将会话保存到一个文件中，基本语法如下： $ script file : 不指定文件时，默认使用文件 typescript 。 Chapter 9 权限 所有者、组成员和其他所有用户 $ id : 查看用户身份标示的相关信息 读取、写入和执行 当以 ls -l 命令列出文件时，前 10 个字符表示文件属性： 1 : 文件类型 2~4 : 所有者权限 5~7 : 组权限 8~10 : 其他用户权限 文件类型 - : 普通文件 d : 目录文件 l : 符号链接 c : 字符设备文件 b : 块设备文件 权限属性 r : 允许打开和读取文件 w : 允许写入或截短文件，但不允许重命名和删除 r : 允许执行文件 更改文件模式 我们可以使用 chmod 命令来更改文件或目录的模式（权限），但需要注意的是只有文件所有者或者超级用户才能进行更改。 文件模式的八进制和二进制表示法(八进制/二进制：文件模式) 0/000 : — 1/001 : –x 2/010 : -w- 3/011 : -wx 4/100 : r– 5/101 : r-x 6/110 : rw- 7/111 : rwx 可以用三位八进制数字分别设置文件所有者、组成员和其他所有用户的文件权限，如： $ chmod 603 file : 6 表示文件所有者权限；0 表示组成员权限；3 表示其他所有用户权限 符号表示法 chmod 支持符号表示法来指定文件模式。该表示法分为三部分：更改会影响谁、要执行哪个操作以及要设置哪种权限。 u : 表示目录或目录的所有者（user） g : 文件所属群组（group） o : 其他所有用户（other） a : all 简写，以上三者组合 注： 如果没有指定字符，则假定使用 ‘all’; 操作符 ‘+’ 表示添加一种权限； 操作符 ‘-‘ 表示删除一种权限； “=” 表示只有指定的权限可用，其他所有的权限都被删除；example: $ chmod u+x file : 为文件所有者添加可执行权限 $ chmod +x file : 为所有用户添加可执行权限 $ chmod o-rw file : 删除其他所有用户的读写权限 $ chmod u+x,go=rx file : 为文件所有者添加执行权限，同时设置所属群组和其他所有用户具有读权限和可执行权限（指定多种权限时，需用逗号隔开，除逗号外，权限之间不能有空格） 采用 GUI 设置文件模式 右键 － propeties － 进行相关设置更改 使用 umask 命令设置默认权限 umask 命令控制着创建文件时指定给文件的默认权限，它使用八进制表示法来表示从文件模式属性中删除一个位掩码。？ $ umask xxxx : 设置默认权限（xxxx 为四个八进制数字） 四位八进制数，展开成二进制后，对应的文件模式上， 1 出现的位置的权限被隐去/除(不常用)。 更改身份 转化身份的三种方法： 注销系统然后以其他用户身份登录 使用 su 命令 使用 sudo 命令 su - 以其他用户和组 ID 的身份来运行 shell $ su -1 user : 以指定用户 user 来登录 shell 界面，指定用户的 shell 运行环境将被加载；-1 选项常写为 - ，且后者更常用 $ su - : 进入超级用户，需要输入超级用户的密码（结束时输入 exit 退出） $ su -c ‘command’ : 使用执行单个命令，必须要有单引号 sudo - 以另一个用户的身份执行命令 sudo 在很多方面和 su 类似；其中，管理员可以通过配置 sudo 命令，使系统以另一种可控的方式，允许一个普通用户以一个不同的身份（通常是超级用户）执行命令；另外，使用 sudo 命令并不需要输入超级用户密码，用户只需要输入自己的命令来认证。 $ sudo -s : 进入超级用户，需要输入用户自己的密码（同样 exit 退出） $ sudo command : 以超级用户执行命令 $ sudo -l : 查看 sudo 命令可以授予哪些权限 注： su 和 sudo 还有一个不同的地方，su 执行命令时命令是传递到另一个 shell 中执行，因此命令需要用单引号引起来，而 sudo 执行命令时不需要启动一个新的 shell ，因此不需要引号。 chown - 更改文件所有者和所属群组 chown 命令用来更改文件或者目录的所有者和所属群组，使用这个命令需要超级用户权限。 chown 的语法： $ chown owner:group file : 即把文件所有者改为用户 owner，改为属于群组 group;可以直接在前面加 sudo 来执行，参数 owner 和 group 可以为空 chgrp - 更改所属群组 早些时候，chown 只能用来更改所有者，所以更改所属群组要使用命令 chgrp； 该命令的使用方法和 chown 几乎一样，但限制多一些（不常用）。 更改用户密码 $ passwd : 当输入该命令以后， shell 会提醒用户输入旧密码和新密码 该命令有一个很有趣的地方，它会试着强迫用户输入一个“强”密码，因此，它会拒绝短密码、与之前密码相似密码、字典中单词或容易猜到的密码。？在 Ubuntu 系统上测试时发现并非如此机智！！！？ Chapter 10 进程 现代操作系统通常都支持多重任务处理（multitasking）。多重任务处理是指系统通过快速切换运行中的程序来实现多任务的同时执行。 Linux 内核通过进程来管理多重任务。进程是 Linux 用来安排不同程序等待 CPU 调度的一种阻止方式。 进程如何工作 系统启动 － 程序初始化（init）－ 脚本初始化（init script） ps - 查看进程信息 $ ps : 查看进程信息 $ ps x : 显示所有进程 ps x 命令的输出中会有一个新的项： STAT，它是 state 的缩写，表示进程状态： R : 运行状态 S : 睡眠状态 D : 不可中断的睡眠状态 T : 暂停状态 Z : 无效状态 &lt; : 高优先级状态；被赋予更多重要性，分配更多 CPU 时间 N : 低优先级状态 $ ps aux : 显示更多信息 ps aux 的显示信息项（列标题）： USER : 用户 ID，表示进程所有者 %CPU : CPU 使用百分比 %MEM : 内存使用百分比 VSZ : 虚拟耗用内存大小 RSS : 实际使用内存大小 START : 进程开启的时间 top - 动态查看进程信息 ps 命令只是显示 ps 命令执行时刻的进程信息；要查看动态视图，可以使用 top 命令： $ top top 命令以列表形式持续更新进程的当前信息；主要用于查看系统“最高”进程的运行情况；top 命令显示的信息包含两部分：总体＋个体； top 命令的两个常用键盘指令： h : 显示程序的帮助界面 q : 退出命令 注： top 命令输出的信息和 Windows 的任务管理器的运行方式类似，但 top 命令运行的更快，消耗资源要少得多。 控制进程 中断进程 $ xlogo : 显示 logo Ctrl+C : 中断程序 使进程在后台运行 $ app &amp; : 程序 app 将在后台运行，输出显示： [number1] number2 ，其中，number1 为作业编号，Number2 为 PID ? $ jobs : 查看从终端启动的所有作业 使进程回到前台运行 后台运行的进程不会受到任何键盘输入的影响，包括视图中断进程的 Ctrl+C ；要想使进程回到前台来运行，可使用 fg 命令来实现： $ fg %number1 : 即 fg 后面跟百分号和作业编号，两者之间没空格，运行该命令后再按 Ctrl+C 即可结束进程 停止（暂停）进程 当一个进程运行以后，按下 Ctrl+Z 可以暂停进程，比如先在终端启动 xlogo ，然后在按下该组合键，进程就暂停了； 使用 fg (上) 命令可使暂停进程回到前台运行； 使用 bg 命令可使暂停进程到后台运行， bg 命令的语法和 fg 命令相同； 信号 $ kill PID : 终止进程， PID 即为上面的 Number2，也可用 \\$ kill %number1 来终止 使用 kill 命令发送信号到进程 kill 语法： $ kill -signal_number/-signal_name PID/%number1 : signal_number 为信号编号； signal_name 为信号名； 如果不指定信号，则默认发送 TERM（终止）信号。 常用信号： 信号编号：信号名：含义 1 : HUP : 挂起信号 2 : INT : 中断信号 9 : KILL : 杀死信号 15 : TERM : 终止信号 18 : CONT : 继续运行信号 19 : STOP : 暂停信号 注：进程也有所有者，只有进程所有者或超级用户才能使用 kill 命令来给进程发送信号。 其他常用信号： 3 : QUIT : 退出信号 11 : SEGV : 段错误信号 20 : TSTP : 终端暂停信号 28 : WINCH : 窗口改变信号 查看完整的信号列表： $ kill -l 使用 kill 命令发送信号给多个进程 使用 killall 命令可以给指定程序或指定用户的多个进程发送信号；语法如下： $ killall -u user -signal name… 可以有缺省。 注： killall 命令同样需要有超级用户特权。 更多与进程相关的信号 其他与进程相关的命令： pstree : 以树状模式输出进程列表 vmstat : 输出系统资源使用情况的快照，包括内存，交换空间和磁盘 I/O xload : 用来绘制显示系统时间负载情况图形的一种图形化界面程序 tload : 类似 xload ，但图形在终端绘制 Part 1 结束！ var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"3 个针对高级用户的 Vim 编辑器实用技巧","date":"2017-01-27T10:33:13.000Z","path":"2017/01/27/3-Vim-Tricks-for-Advanced-Users/","text":"这篇文章是 Vim 用户指南系列文章中的一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 技巧 3 个针对高级用户的 Vim 编辑器实用技巧 毫无疑问， Vim 是一个很强大的文本编辑器。它提供了大量的特性，这意味着学习并记住 Vim 的所有功能实际上是不可能的。但是我们至少可以不断学习简单的方法来完成事情，从而随着时间的增长，我们使用编辑器的经验将会变得更好。 请记住，在这篇文章中我们将讨论的一些 Vim 编辑器技巧是针对高级用户的。 注：如果你是第一次接触 Vim，你可以首先阅读我们的入门指南。对于已经使用过 Vim 编辑器的用户，我确信 Vim 快捷键速查表将会对你很有帮助。如果你已经是一名有经验的用户，你可能对 一些针对有经验用户的技巧比较感兴趣。 请注意文中提到的所有技巧绝大多数都是在简单、易于理解的代码环境中进行阐述的，因为它们在软件开发中确实很实用。但这并不意味着普通用户(非程序员、没有把 Vim 作为一般的文本编辑器)在他们的工作中用不到。 1、为文件设置特定的变量 有时候，在一个特定文件中，你可能想把输入的制表符用空格代替，或者想要把源代码文件使用两个空格缩进，即便编辑器的默认缩进是四个空格。 基本上我们在这儿讨论对针对文件的的更改。 Vim 提供的这个特性允许你对一个指定的文件更改特定的设置。这个特性叫做 “模式行（Modeline）” 。 比如，如果你想把输入的每一个制表符（Tab）用空格代替，那么你只需要在文件的前几行或最后几行加入下面的模式行： 1 # vim: set expandtab: 如果想把默认缩进从 4 个空格变成 2 个空格，可以在源文件中添加下面的模式行： 1 // vim: noai:ts=2:sw=2 在使用模式行时，请记住下面这几个重要的点： 模式行只能添加在文件中的前五行或者最后五行。 为了使用模式行这个特性，必须在 .vimrc 文件中添加 :set modeline 。 在以 root 用户身份对文件进行编辑的时候该特性失效。 了解更多的信息，请阅读该特性的官方文档。 2、 关键字补全 当你开始写的复杂代码越来越多或者开始在一个大的源文件上编辑时，你会遇到一些变量名字。有时，要记住所有的变量名字不太容易，所以当需要输入变量名字的时候，你通常从已经使用过的地方复制过来。 幸运的是，使用 Vim 你只需要输入变量的几个起始字母即可。在’插入模式’中，按 Ctrl + n 或者 Ctrl + p 可以得到一个匹配的关键词列表。 Ctrl + n 用来插入下一个匹配词； Ctrl + p 给出一个之前匹配的关键词列表。 下图是该特性的一个展示： 正如上面的屏幕截图清晰展示的那样，列表中也会出现其他源文件中包含的词。关于该特性的更多信息，请访问这儿。 3、 搜索 假设你正在调试代码，其中一个需要做的工作是快速查看一个变量在一个文件中所有出现的地方。一个常用的方法是退出‘插入模式’，输入 /[变量名字] 命令，按回车 ，然后返回‘插入模式’，使用 n 和 p 在关键字之间导航。 上面讲到的这种方法没毛病，但是还有一种更简单、更快捷的方法可以来完成这样的搜索。使用这种方法，首先你需要退出‘插入模式’，然后把光标移动到你想要搜索的词/变量下面，这并不费时。接下来，你只需要按 Shift + * 即可。 重复这样做，然后编辑器将会带你找到在文件中所有使用了这个词/变量的地方。 结论 尽管是针对高级用户，但文章中讨论的这些技巧并不难理解，也比较容易使用。如果你具有一定的基础，那么你能够从中获益很多。不必多说，无论是任何新特性或观念，你需要勤于练习这些技巧才能够把它们变成一种习惯。 via: https://www.maketecheasier.com/vim-tips-tricks-advanced-users/ 作者：Himanshu Arora译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"5 个针对有经验用户的 Vim 实用技巧","date":"2017-01-26T10:30:05.000Z","path":"2017/01/26/5-Practical-Skills-of-Vim-for-Experienced-Users/","text":"这篇文章是 Vim 用户指南系列文章中的一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 实用技巧 3 个针对高级用户的 Vim 编辑器实用技巧 Vim 编辑器提供了很多的特性，要想全部掌握它们很困难。然而，花费更多的时间在命令行编辑器上总是有帮助的。毫无疑问，和 Vim 用户们进行交流能够让你更快地学习新颖有创造性的东西。 注： 本文中用到的例子，使用的 Vim 版本是 7.4.52 。 1、 同时编辑多个文件 如果你是一名软件开发者或者把 Vim 作为主要的编辑器，那么可能很多时候你需要同时编辑多个文件。“紧跟（following）”是在同时编辑多个文件时可用的实用技巧。 不需要在多个 shell 界面中打开多个文件，你可以通过把多个文件的文件名作为 Vim 命令的参数从而在一个 shell 界面中打开多个文件。比如： 1 vim 文件1 文件2 文件3 第一个文件（例子中的文件1）将成为当前文件并被读入缓冲区。 在编辑器中，使用 :next 或 :n 命令来移动到下一个文件，使用 :prev 或 :N 命令返回上一个文件。如果想直接切换到第一个文件或最后一个文件，使用 :bf 和 :bl 命令。特别地，如果想打开另外的文件并编辑，使用 :e 命令并把文件名作为参数（如果该文件不在当前目录中则需要完整路径做为参数）。 任何时候如果需要列出当前打开的所有文件，使用 :ls 命令。看下面展示的屏幕截图。 注意 ”%a” 表示文件在当前活动窗口，而 “#” 表示上一个活动窗口的文件。 2、 通过自动补全节约时间 想节约时间并提高效率吗？使用缩写吧。使用它们能够快速写出文件中多次出现、复杂冗长的词。在 Vim 中缩写命令写就是 ab 。 比如，当你运行下面的命令以后： 1 :ab asap as soon as possible 文件中出现的每一个 asap 都会被自动替换为 as soon as possible ，就像你自己输入的一样。 类似地，你可以使用缩写来更正常见的输入错误。比如，下面的命令 1 :ab recieve receive 将会自动更正拼写错误，就像你自己输入的一样。如果在一次特殊情况下你想阻止缩写展开或更正发生，那么你只需要在输入一个单词的最后一个字母以后按 Ctrl + V ，然后按空格键。 如果你想把刚才使用的缩写保存下来，从而当你下次使用 Vim 编辑器的时候可以再次使用，那么只需将完整的 ab 命令(没有起始的冒号)添加到 /etc/vim/vimrc 文件中。如果想删除某个缩写，你可以使用 una 命令。比如： una asap 。 3、 切分窗口便于复制/粘贴 有时，你需要从一个文件将一段代码或文本的一部分复制到另一个。当使用 GUI（图形界面）编辑器的时候，这很容易实现，但是当使用一个命令行编辑器的时候，这就变得比较困难并且很费时间。幸运的是， Vim 提供了一种高效、节约时间的方式来完成这件事。 打开两个文件中的一个然后切分 Vim 窗口来打开另一个文件。可以通过使用 split 命令并以文件名作为参数来完成这件事。比如： 1 :split test.c 上面的命令将分离窗口并打开文件 “test.c” 注意到 split 命令水平分离 Vim 窗口。如果你想垂直分离窗口，那么你可以使用 vsplit 命令。当同时打开了两个文件并从一个文件中复制好内容以后，按 Ctrl + W 切换到另一个文件，然后粘贴。 4、 保存一个没有权限的已编辑文件 有时候当你对一个文件做了大量更改以后才会意识到你对该文件仅有 只读 权限。 虽然把文件关闭，获取权限以后再重新打开是一种解决方法。但是如果你已经做了大量更改，这样做会很浪费时间，因为在这个过程中所有的更改都会丢失。 Vim 提供了一种方式来处理这种情况：你可以在编辑器中在保存文件前更改文件权限。命令是： 1 :w !sudo tee % 这个命令将会向你询问密码，就像在命令行中使用 sudo 一样，然后就能保存更改。 一个相关的技巧：在 Vim 中编辑一个文件的时候，如果想快速进入命令行提示符，可以在编辑器中运行 :sh 命令，从而你将进入一个交互的 shell 中。完成以后，运行 exit 命令可以快速回到 Vim 模式中。 5、 在复制/粘贴过程中保持缩进 大多数有经验的程序员在 Vim 上工作时都会启用自动缩进。虽然这是一个节约时间的做法，但是在粘贴一段已经缩进了的代码的时候会产生新的问题。比如，下图是我把一段已缩进代码粘贴到一个在自动缩进的 Vim 编辑器中打开的文件中时遇到的问题： 这个问题的解决方法是 pastetoggle 选项。在 /etc/vim/vimrc 文件中加入下面这行内容： 1 set pastetoggle=&lt;F2&gt; 然后当你在 插入 模式中准备粘贴代码前先按 F2 键，就不会再出现上图中的问题，这样会保留原始的缩进。注意，你可以用其他的任何键来代替 F2，如果它已经映射到了别的功能上。 结论 更进一步的提高你的 Vim 编辑器技巧的唯一方法是，在你日复一日的工作中使用命令行编辑器。留意那些耗时多的操作，然后尝试去寻找是否有编辑器命令可以很快地完成这个操作。 via: https://www.maketecheasier.com/vim-tips-tricks-for-experienced-users/ 作者：Himanshu Arora译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"给 Linux 新手的最佳发行版","date":"2017-01-22T10:35:26.000Z","path":"2017/01/22/the-Best-Linux-System-for-Beginners/","text":"Jack Wallen 为来自不同环境的新手们挑选出专门为他们设计的发行版。CC0社区。 一个很古老的问题，找到适合的 Linux 发行版比简单的指出哪种 Linux 版本受欢迎更重要。为什么这么说？ 让我们设置一个情景：你有一位用户，很有可能，他过去大多数时候都是在 Windows 或者 Mac 系统上工作，他们想让你给他们一个选择的替代品。现在，你想要在很短的时间里直截了当的说明 Linux 系统的工作方式并突出它的强大性和灵活性。 但是，请记住，最重要的一个方面是他们必须能够 get it，即开箱即用。 这就是为什么我们经常需要花费时间来找出哪种版本是最适合新手的 – 因为把新手们带入 Linux 系统是传播 Linux 并增加 Linux 用户的最好方式。 对于新手来说最好的版本是什么？这次，我将要花费一定时间来说明对于来自不同环境的用户哪种版本才是最适合的。此外，你也可以查看我在 2017 最好的发行版中列出的发行版。 从 Windows 7 到 Linux：ZorinOS 当 Windows 8 发布以后，有一个理由让如此多的用户依然坚持使用 Windows 7， 那就是熟悉度。用户们已经在相同的桌面环境上工作了十几年，他们不想转移到 Windows 8 这种更以触摸屏为主的平台上。所以，你会去选择哪种版本呢？你首先必须要考虑的是桌面环境。为什么？因为这是你能够立刻吸引上这些 Windows 7 用户的地方。对于这个任务，还有什么版本会比 ZorinOS 更好呢？ ZorinOS 就是专门作为 Windows 和 Mac 系统的替代品而设计的，所以它下了很大的功夫来模仿 Windows 和 Mac 桌面的外观和感觉。事实上，除了 ZorinOS 以外，你很难找到一个别的 Linux 版本，能够完美的从 Windows 7 转移到 Linux 系统上，同时保留 Linux 系统如此强大、灵活的平台。 除了桌面环境（图片 1）以外， 因为 ZorinOS 完全基于 Ubuntu 系统，所以在其“外表”下面， ZorinOS 和 Ubuntu 以同样的方式工作（所以基本不用去担心硬件不能够被检测到）。同时伴有已经就绪的软件，你便有了针对来自 Windows 7 用户的最完美的 Linux 版本。 图片 1：类 Windows 7 的 ZorinOS 桌面，准备开始服务。使用许可 请注意：然而， ZorinOS 有两个版本： Zorin Ultimate 和 Zorin Core 。 Zorin Core 是免费的，但它不包含几乎所有你能够在 Zorin Ultimate 中找到的软件。如果你想要一个适合于所有来自 Windows 7 用户的开箱即用的版本，那么我强烈推荐购买 Zorin Ultimate（大约需要花费 20 美元）。当然，如果你不想花钱购买 Ultimate 版本，你也可以从 Core 版本包含的软件包管理工具中安装几乎所有你需要的东西。 从 Windows 8 到 Linux ： Ubuntu GNOME 让我们来看看 Windows 8， 它带来了一个以触摸屏为中心的环境，改变了用户与电脑互动的方式。老式的启动菜单、面板、系统托盘桌面已经被触摸屏环境界面所取代。如果你正在找一个能给 Linux 新手们带来不同体验的最好环境，同时功能也要是最好的，那么没有比 Ubuntu GNOME 更合适的了。 Ubuntu GNOME 是 Ubuntu 和 GNOME（图 2）这两个世界之间最好的融合。用一个现代、优雅、简洁并且用户友好的桌面代替了 Unity 界面， 因此 Ubuntu GNOME 不会给任何来自 Windows 8 的用户造成太多的麻烦。该版本不仅基于最新的长期支持版的 Ubuntu 发行版（支持期会很长），同时使用了 GNOME 桌面的最新稳定版本 － 这意味着用户将能够享受到难以置信的稳定体验。 图片 2 ：在 Ubuntu GNOME 中可以发现，在优雅而又简洁。 使用许可 从 Mac 到 Linux ： Elementary OS 毫无疑问，这一场的绝对赢家是 Elementary OS。尽管 Elementary OS 在外观和感觉上所达到的效果和 OS X 桌面非常相似，但实际还有更多优秀的地方。 Elementary OS 同样是基于 Linux 系统的，只不过是它采取了很多 Mac X 桌面的设计元素。 任何的 Mac 用户使用 Elementary OS 的桌面环境（图片 3）都会感觉就像是“在家一样”（使用 Mac 一样）。伴有如此熟悉的文档，同时包含一个熟悉的应用菜单， Elementary OS 总是位于我的‘最佳发行版列表’的顶部。如果我们正在和 Mac 用户讨论迁移，那么没有比 Elementary OS 更好的 Mac 替代品了。 图片 3 ：Elementary OS 桌面的荣耀。使用许可 有一件事情 Mac 用户们将会非常感激，那就是 Elementary OS 的开发者们很好的保持了桌面的一致性。从 dock， 到面板、菜单、到包括的应用，你找不到任何一个看起来或感觉没有归属感的单一元素。 我将在这儿说一个关于 Elementary OS 的预警。你需要安装一个好的浏览器（因为它自带安装的 Epiphany-a 浏览器没有得到许多常用站点的支持），同时，你需要从官方的 LibreOffice 网站下载安装包来安装 LibreOffice （因为在 Elementary OS 的软件中心找到的安装包已经有些过时了）。 从 Android 到 Linux：Ubuntu 这似乎有点像是一个延伸话题，但考虑到 Android 在全球市场中占主导地位，所以你可能遇到一个来自以移动设备为中心的用户，他可能需要一个 Linux 桌面，从而让他一直感觉像是‘在家’一样。对于我来说， Ubuntu 是最显然的赢家。为什么？和其他系统相比， Ubuntu Unity 在桌面上做出了很杰出的工作，它使得桌面感觉像是一个包罗万象的界面。如果你愿意，那么可以包含在线搜索结果（默认情况下禁用），这是在几乎每个移动环境中均可找到的东西。同样， Unity HUD 菜单系统（图片 4）是在任何界面系统中所能找到的最独一无二的菜单系统之一。通过 Unity HUD 菜单系统，用户可以更少的依赖鼠标（就像他们过去在 Android 支持的移动设备上工作一样）。 图片 4： 使用中的 Unity HUD 。使用许可 当然， Ubuntu 也提供了市场上最稳定的桌面平台，所以用户体验近乎完美。 总有一款 Linux 发行版适合你 有一件很重要的事情需要记住，那就是总有一款 Linux 发行版适合你。但是对于那些来自特殊环境的人，我强烈推荐找到一个最喜爱的 Linux 版本，从而能够帮助他们无缝过渡。给自己一个机会尝试一下，看看你是否可以轻松体验到开源和 Linux 的强大。 via: https://www.linux.com/news/best-linux-distributions-new-users 作者：JACK WALLEN译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"五子棋之五元组评分算法","date":"2017-01-07T15:18:59.000Z","path":"2017/01/07/The-Algorithm-of-Gomoku/","text":"前言 本学期，开始学习 $C$ 语言编程课，期末大作业是一个用 C 语言写的五子棋游戏，该大作业占最后期末成绩的百分之五十，所以不容忽视。最后的成绩高低是所有同学进行比赛，看谁的 $AI$ 厉害，然后根据比赛结果评分，冠军组 $100$ 分，而最后一个普通组只有 $65$ 分，分数相差较大。 大概从 $11$ 月中旬就开始写五子棋，当然，整个程序最关键的部分就是 $AI$ ，大概 $12$ 月份刚开始的时候就按照老师讲的算法写出了一个感觉还不错的程序，之后一直没再调试。比赛前最后一周，感觉自己的 $AI$ 还是很弱，于是，开始进行调参，可是花了一周的时间，没什么效果，反而越调越傻。 昨天晚上，也就是比赛前最后一个晚上，到隔壁一个宿舍，问到他们的五子棋情况，发现大家的好像都很厉害，他们都是用博弈树算法搜了很多层，才意识到自己的真的很菜，一周的调参没起到任何效果。然后又听说他们宿舍的另一位搞 $ACM$ 的大神用了一种很好的算法进行评分，搜了 $8$ 步，可以秒杀电脑上五子棋游戏的大师级别。听了那个评分算法，似乎不是很难实现。原本昨天晚上是想继续调参的，但想想按照之前的算法调参好像真的没什么用，干脆按他们说这个算法重新写一个 $AI$ ，说不定效果更好，虽然不一定能写出来，不过豁出去试一试。于是，七点多的时候，回到宿舍，上网搜了一下，发现有人写了一篇关于这种算法的博客，不过，要说很重要的是这篇博客给出了一个比较完美的该算法评分参数，后来，我在该参数的基础上进行了一些修改，我觉得应该比之前好一些。 从 $7$ 点多开始，先思考了一会怎么实现该算法，然后便开始写，大概写了 $3$ 个多小时， $10$ 点多的时候写好，整个 $AI$ 只有 $213$ 行代码。但不幸的是，存在 $bug$ ，调了半个多小时 $bug$ ，终于可以正常下了。简直不可置信，就进行一个评分，然后完全秒杀之前写的 $AI$ ，效果比我想象中要好很多很多。甚是激动，于是奖励自己玩了两个小时手机，所以一不小心就到了凌晨两点半才睡。 今天早上 $10$ 点多醒来，一点半比赛，于是决定再测试一下程序。没想到却发现了两个致命 $bug$ 。第一个是选择最高分时判断是禁手以后忘记把该点赋为 $0$ ，导致程序进入死循环，就不会再落子。这个 $bug$ 解决了以后，又出现了新的 $bug$ ，$AI$ 一次落了两个子，后来找出 $bug$ ：在判断是否禁手时我先进行试探落子，之后忘记恢复，所以才出现一次落了两个子。 于是早饭、午饭都没吃，直接到时间了去教室参加比赛。最后结果 $4$ 胜 $1$ 负进入冠军组，然后又打败老师给的之前一个研究生写的五子棋，直接满分，所以现在 $C$ 语言期末已经有了 $50$ 分，再加上 $20$ 分作业分，就算不参加期末考也已经及格了。 正题 下面，开始说这个算法，其实很简单。 在这之前，先说一下之前的算法：对棋盘上空的点评分，判断在该点落子之后四个方向的格局，比如胜利、活四、半活四、活三等等，然后再判断对手在该点落子以后四个方向的格局，各种情形分别赋分，算出总的分，然后落子，不得不说，这个评分方法真是弱爆了，首先，因为评分偏差，我写了无数个很长 $if$ ，对一些特殊情况单独处理， $AI$ 部分写了 $500$ 多行代码；其次，这种评分在中间位置还好，一旦到了边界，它就会在一些已经不可能形成五连的无意义点落子。 五元组评分算法：所谓五子棋，就是要五子连成线才取得胜利，正规比赛以及我们该比赛的棋盘都是 $15\\times15$ 大小的，所以整个棋盘上有 $572$ 个五元组，每一个点都被包含在 $20$ 个五元组中（边界情况例外）。于是，对点的评分改为：已经被落子的点，直接赋值为 $-1$ ，对于没有被落子的点，计算包含它的所有五元组的情况，然后进行评分，评分方法很简单：看每个五元组里面有几个自己的子以及对手的子，然后给分，不用去管具体位置是什么样的。 算法就是这样。 下面，是我的评分表，我直接把头文件黏贴过来： #ifndef MY_HEAD_H #define MY_HEAD_H #define SIZE 15 #define PLAYER1 1 #define PLAYER2 2 #define FIRST_PLAYER 1 #define SECOND_PLAYER 2 #define M1 35 #define M2 800 #define M3 15000 #define M4 800000 #define O1 20 #define O2 500 #define O3 4000 #define O4 300000 #define VO 7 #define PU 0 #define NO 0 #endif 说明一下，只看 M1 到 M4 和 O1 到 O4 以及最后三个。 Mi表示该五元组上有 $i$ 个自己的子； Oi 表示该五元组上有 $i$ 个对手的子； VO 表示该五元组上没有子，为什么没有子分不是 $0$ ，因为还有更坏的情况：PU 表示五元组上既有自己的子，又有对手的子，所以这时该五元组已经被 污染，不可能再形成五连； NO 表示不存在五连，这是考虑边界情况，这样定义，方便函数的实现和调用。 个人觉得，该评分已经比较完美，也许会有更好的评分。 当然，如果要进行多层搜索的话需要对全局进行评分，试探落子，然后计算所有五元组得分之和，多步试探，最后还是要用到博弈树算法，还不懂具体怎么实现，等到假期再来研究。 $C$ 语言实现的五子棋代码在 $GitHub$ 上：https://github.com/ucasFL/Gomoku/ var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Linux 下安装 PyCharm","date":"2016-12-31T10:20:19.000Z","path":"2016/12/31/How-to-Install-PyCharm-in-Linux/","text":"简介 Linux 经常被看成是一个远离外部世界，只有极客才会使用的操作系统，但是这是不准确的，如果你想开发软件，那么 Linux 能够为你提供一个非常棒的开发环境。 刚开始学习编程的新手们经常会问这样一个问题：应该使用哪种语言？当涉及到 Linux 系统的时候，通常的选择是 C、C++、Python、Java、PHP、Perl 和 Ruby On Rails。 Linux 系统的许多核心程序都是用 C 语言写的，但是如果离开 Linux 系统的世界， C 语言就不如其它语言比如 Java 和 Python 那么常用。 对于学习编程的人来说， Python 和 Java 都是不错的选择，因为它们是跨平台的，因此，你在 Linux 系统上写的程序在 Windows 系统和 Mac 系统上也能够很好的工作。 虽然你可以使用任何编辑器来开发 Python 程序，但是如果你使用一个同时包含编辑器和调试器的优秀的集成开发环境（IDE）来进行开发，那么你的编程生涯将会变得更加轻松。 PyCharm 是由 Jetbrains 公司开发的一个跨平台编辑器。如果你之前是在 Windows 环境下进行开发，那么你会立刻认出 Jetbrains 公司，它就是那个开发了 Resharper 的公司。 Resharper 是一个用于重构代码的优秀产品，它能够指出代码可能存在的问题，自动添加声明，比如当你在使用一个类的时候它会自动为你导入。 这篇文章将讨论如何在 Linux 系统上获取、安装和运行 PyCharm 。 如何获取 PyCharm 你可以通过访问https://www.jetbrains.com/pycharm/获取 PyCharm 。 屏幕中央有一个很大的 ‘Download’ 按钮。 你可以选择下载专业版或者社区版。如果你刚刚接触 Python 编程那么推荐下载社区版。然而，如果你打算发展到专业化的编程，那么专业版的一些优秀特性是不容忽视的。 如何安装 PyCharm 下载好的文件的名称可能类似这种样子 ‘pycharm-professional-2016.2.3.tar.gz’。 以 “tar.gz” 结尾的文件是被 gzip 工具压缩过的，并且把文件夹用 tar 工具归档到了一起。你可以阅读关于提取 tar.gz 文件指南的更多信息。 加快速度，为了解压文件，你需要做的是首先打开终端，然后通过下面的命令进入下载文件所在的文件夹： 1 cd ~/Downloads 现在，通过运行下面的命令找到你下载的文件的名字： 1 ls pycharm* 然后运行下面的命令解压文件： 1 tar -xvzf pycharm-professional-2016.2.3.tar.gz -C ~ 记得把上面命令中的文件名替换成通过 ls 命令获知的 pycharm 文件名。（也就是你下载的文件的名字）。上面的命令将会把 PyCharm 软件安装在 home 目录中。 如何运行 PyCharm 要运行 PyCharm， 首先需要进入 home 目录： 1 cd ~ 运行 ls 命令查找文件夹名： 1 ls 查找到文件名以后，运行下面的命令进入 PyCharm 目录： 1 cd pycharm-2016.2.3/bin 最后，通过运行下面的命令来运行 PyCharm： 1 sh pycharm.sh &amp; 如果你是在一个桌面环境比如 GNOME 、 KDE 、 Unity 、 Cinnamon 或者其他现代桌面环境上运行，你也可以通过桌面环境的菜单或者快捷方式来找到 PyCharm 。 总结 现在， PyCharm 已经安装好了，你可以开始使用它来开发一个桌面应用、 web 应用和各种工具。 如果你想学习如何使用 Python 编程，那么这里有很好的学习资源值得一看。里面的文章更多的是关于 Linux 学习，但也有一些资源比如 Pluralsight 和 Udemy 提供了关于 Python 学习的一些很好的教程。 如果想了解 PyCharm 的更多特性，请点击这儿来查看。它覆盖了从创建项目到描述用户界面、调试以及代码重构的全部内容。 via: https://www.lifewire.com/how-to-install-the-pycharm-python-ide-in-linux-4091033 作者：Gary Newell译者：ucasFL校对：oska874 本文由 LCTT 组织编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"PyCharm - Linux 下最好的 Python IDE","date":"2016-12-29T10:18:17.000Z","path":"2016/12/29/PyCharm-The-Best-Python-IDE-in-Linux/","text":"/about/pycharm2-57e2d5ee5f9b586c352c7493.png) 介绍 在这篇指南中，我将向你介绍一个集成开发环境 - PyCharm， 你可以在它上面使用 Python 编程语言开发专业应用。 Python 是一门优秀的编程语言，因为它真正实现了跨平台，用它开发的应用程序在 Windows、Linux 以及 Mac 系统上均可运行，无需重新编译任何代码。 PyCharm 是由 Jetbrains 开发的一个编辑器和调试器，Jetbrains 就是那个开发了 Resharper 的人。不得不说，Resharper 是一个很优秀的工具，它被 Windows 开发者们用来重构代码，同时，它也使得 Windows 开发者们写 .NET 代码更加轻松。Resharper 的许多原则也被加入到了 PyCharm 专业版中。 如何安装 PyCharm 我已经写了一篇关于如何获取 PyCharm 的指南，下载、解压文件，然后运行。 欢迎界面 当你第一次运行 PyCharm 或者关闭一个项目的时候，会出现一个屏幕，上面显示一系列近期项目。 你也会看到下面这些菜单选项： 创建新项目 打开项目 从版本控制仓库检出 还有一个配置设置选项，你可以通过它设置默认 Python 版本或者一些其他设置。 创建一个新项目 当你选择‘创建一个新项目’以后，它会提供下面这一系列可能的项目类型供你选择： Pure Python Django Flask Google App Engine Pyramid Web2Py Angular CLI AngularJS Foundation HTML5 Bolierplate React Starter Kit Twitter Bootstrap Web Starter Kit 这不是一个编程教程，所以我没必要说明这些项目类型是什么。如果你想创建一个可以运行在 Windows、Linux 和 Mac 上的简单桌面运行程序，那么你可以选择 Pure Python 项目，然后使用 Qt 库来开发图形应用程序，这样的图形应用程序无论在何种操作系统上运行，看起来都像是原生的，就像是在该系统上开发的一样。 选择了项目类型以后，你需要输入一个项目名字并且选择一个 Python 版本来进行开发。 打开一个项目 你可以通过单击‘最近打开的项目’列表中的项目名称来打开一个项目，或者，你也可以单击‘打开’，然后浏览到你想打开的项目所在的文件夹，找到该项目，然后选择‘确定’。 从源码控制进行查看 PyCharm 提供了从各种在线资源查看项目源码的选项，在线资源包括 GitHub、CVS、Git、Mercurial 以及 Subversion。 PyCharm IDE（集成开发环境） PyCharm IDE 中可以打开顶部的菜单，在这个菜单下方你可以看到每个打开的项目的标签。 屏幕右方是调试选项区，可以单步运行代码。 左侧面板有项目文件和外部库的列表。 如果想在项目中新建一个文件，你可以鼠标右击项目的名字，然后选择‘新建’。然后你可以在下面这些文件类型中选择一种添加到项目中： 文件 目录 Python 包 Python 包 Jupyter 笔记 HTML 文件 Stylesheet JavaScript TypeScript CoffeeScript Gherkin 数据源 当添加了一个文件，比如 Python 文件以后，你可以在右边面板的编辑器中进行编辑。 文本是全彩色编码的，并且有黑体文本。垂直线显示缩进，从而能够确保缩进正确。 编辑器具有智能补全功能，这意味着当你输入库名字或可识别命令的时候，你可以按 ‘Tab’ 键补全命令。 调试程序 你可以利用屏幕右上角的’调试选项’调试程序的任何一个地方。 如果你是在开发一个图形应用程序，你可以点击‘绿色按钮’来运行程序，你也可以通过 ‘shift+F10’ 快捷键来运行程序。 为了调试应用程序，你可以点击紧挨着‘绿色按钮’的‘绿色箭头’或者按 ‘shift+F9’ 快捷键。你可以点击一行代码的灰色边缘，从而设置断点，这样当程序运行到这行代码的时候就会停下来。 你可以按 ‘F8’ 单步向前运行代码，这意味着你只是运行代码但无法进入函数内部，如果要进入函数内部，你可以按 ‘F7’。如果你想从一个函数中返回到调用函数，你可以按 ‘shift+F8’。 调试过程中，你会在屏幕底部看到许多窗口，比如进程和线程列表，以及你正在监视的变量。 当你运行到一行代码的时候，你可以对这行代码中出现的变量进行监视，这样当变量值改变的时候你能够看到。 另一个不错的选择是使用覆盖检查器运行代码。在过去这些年里，编程界发生了很大的变化，现在，对于开发人员来说，进行测试驱动开发是很常见的，这样他们可以检查对程序所做的每一个改变，确保不会破坏系统的另一部分。 覆盖检查器能够很好的帮助你运行程序，执行一些测试，运行结束以后，它会以百分比的形式告诉你测试运行所覆盖的代码有多少。 还有一个工具可以显示‘类函数’或‘类’的名字，以及一个项目被调用的次数和在一个特定代码片段运行所花费的时间。 代码重构 PyCharm 一个很强大的特性是代码重构选项。 当你开始写代码的时候，会在右边缘出现一个小标记。如果你写的代码可能出错或者写的不太好， PyCharm 会标记上一个彩色标记。 点击彩色标记将会告诉你出现的问题并提供一个解决方法。 比如，你通过一个导入语句导入了一个库，但没有使用该库中的任何东西，那么不仅这行代码会变成灰色，彩色标记还会告诉你‘该库未使用’。 对于正确的代码，也可能会出现错误提示，比如在导入语句和函数起始之间只有一个空行。当你创建了一个名称非小写的函数时它也会提示你。 你不必遵循 PyCharm 的所有规则。这些规则大部分只是好的编码准则，与你的代码是否能够正确运行无关。 代码菜单还有其它的重构选项。比如，你可以进行代码清理以及检查文件或项目问题。 总结 PyCharm 是 Linux 系统上开发 Python 代码的一个优秀编辑器，并且有两个可用版本。社区版可供临时开发者使用，专业版则提供了开发者开发专业软件可能需要的所有工具。 via: https://www.lifewire.com/pycharm-the-best-linux-python-ide-4091045 作者：Gary Newell译者：ucasFL校对：wxy 本文由 LCTT 组织编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Debian 和 Ubuntu 系统上自动安装安全更新","date":"2016-12-24T10:22:53.000Z","path":"2016/12/24/How-to-Auto-Perform-Security-Update-in-Ubuntu-and-Debian/","text":"之前已经说过，一些最优秀的系统管理员看上去（注意这里使用的词是 seem（看上去））总是很“懒”的，这句话我再同意不过了。 虽然这句话听起来有点荒谬，但我敢打赌在大多数情况下它是对的－不是因为他们不去做他们原本应该做的事情，而是因为他们已经让系统自动去完成这样的事情了。 对于 Linux 系统来说，一个最关键的需求是为相应的 Linux 版本保持更新最新的安全补丁。 在这篇文章中，我们将讨论如何在 Debian 和 Ubuntu 系统上进行设置，从而实现自动安装或更新重要的安装包或补丁。 其他的 Linux 版本：CentOS/RHEL 配置自动安装安全更新 不必多说，为了执行这篇文章中所讲到的任务，你需要有超级用户特权。 在 Debian/Ubuntu 上配置自动安全更新 首先，安装下面这些安装包： 1 # aptitude update -y &amp;&amp; aptitude install unattended-upgrades apt-listchanges -y apt-listchanges 将会通知你在升级过程中发生的改变。 接下来，用你最喜欢的文本编辑器打开 /etc/apt/apt.conf.d/50unattended-upgrades，然后在 Unattended-Upgrade::Origins-Pattern 块中间加入下面这行内容： 1 Unattended-Upgrade::Mail \"root\"; 最后，执行下面的命令来生成所需的配置文件（/etc/apt/apt.conf.d/20auto-upgrades），从而激活自动更新： 1 # dpkg-reconfigure -plow unattended-upgrades 当提示安装自动升级时，选择 ‘Yes’： 在 Debian 上配置自动安装更新 然后检查下面这两行是否已经加入到文件 /etc/apt/apt.conf.d/20auto-upgrades 中了： 12 APT::Periodic::Update-Package-Lists \"1\";APT::Periodic::Unattended-Upgrade \"1\"; 增加下面这行内容使通知更加详细： 1 APT::Periodic::Verbose \"2\"; 最后，检查 /etc/apt/listchanges.conf 来确保通知能被发送给 root 用户。 在 Debian 系统上提示安全更新 在这篇文章中，我们讨论了如何确保你的系统定期更新最新的安全补丁。另外，你也学习了如何设置提示，从而确保应用了新的补丁时你能够被通知到。 你有任何关于这篇文章的问题吗？你可以在下面的评论栏留下你的问题。我们期待收到你的回复。 via: http://www.tecmint.com/auto-install-security-updates-on-debian-and-ubuntu 作者：Gabriel Cánepa译者：ucasFL校对：wxy 本文由 LCTT 组织编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"C 语言指针误用总结","date":"2016-12-20T06:07:41.000Z","path":"2016/12/20/the-Error-Summary-of-C-Pointer-Part1/","text":"前言 一早上的时间折腾在一个很简单的题上，最后发现是指针误用，差点吓得我以后都不敢再用指针了，故作此总结。 在这儿，我把问题简化，只看关键出错地方。 正题 首先，我们看一下， C 语言中的指针是什么：指针是一个保存变量地址的变量，它同时也是一个变量。 看下面一行代码： char *str=&quot;hello,world!&quot; 这行代码表示，str 是一个指针，它指向一个字符串（实际上是指向字符串的第一个字符）。 如果想把该字符串输出，我们可以： printf(&quot;%s\\n&quot;,str); 重点来了，因为对该知识点的错误理解，造成了第一个致命错误，看下面两段代码： 首先，第一段代码是正确的， s[10] 是一个字符串数组，然后通过 scanf 函数读取一串（不超过它长度）字符存入其中。 再看第二段带码，这时候 s 定义成一个字符串指针，所以它只能用来指向一个字符串，然而，我却要读取一段字符串存入其中，而且传递给 scanf 函数的还不是该指针的地址，更是错上加错。 另外，注：上面 str 所指向的字符串是只读的。 接下来，看一个关于交换值的问题，在 C 语言中，函数形参值的改变不会改变实参的值，所以我们要交换两个变量的值时，需要通过指针来访问形参操作数。于是，在这个地方，再次出现严重错误（结构是可以取址，可以整体赋值的）。看下面一段代码： 现在很清楚了，我在函数中交换了两个指针的值，但并没有交换它们所指向的变量的值，所以两个结构的值不会被交换。 于是，我改了一下代码，没想到却把自己推向了更可怕的深渊：segmentation fault。 看下面的代码： 瞬间感觉自己就是一个 ZZ， 很明显，我相当于把一个结构的内容赋给一个指针变量。 正确的代码如下： 后记 一上午的时间就这样过去了，但能够纠正如此严重的一个错误，总算是值得的。 今后对指针的理解会更深，也会更加小心使用了 ^-^ var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Sudo Apt Update失败的解决办法","date":"2016-12-19T08:23:02.000Z","path":"2016/12/19/the-Solution-of-sudo-apt-update-Failed/","text":"在 ubuntu 系统上，当我们通过 apt 软件包安装新的软件时，都要先进行软件包更新： ~$ sudo apt update 但有时候，会出现 error， 如下图所示： 这时候，我们只需要把 /var/lib/apt/lists 目录中的文件全部删除，然后再重新更新就好了： ~$ rm -r /var/lib/apt/lists ~$ sudo apt update OK ~ 问题解决 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"个人博客搭建：GitHub+Hexo","date":"2016-12-18T04:06:50.000Z","path":"2016/12/18/Deploy-Blog-with-Hexo-and-GitHub-Pages/","text":"本文中用到的工具有： Linux(是操作系统就行) GitHub Hexo Git Nodejs Markdown(写博客） 前期准备 GitHub 账号申请和建库： 先到GitHub官网： https://github.com/ 申请一个账号。 登录账号，点击页面右上角的+号，然后选择 New repository 新建仓库，仓库名为： user.github.io（注： user 为你的 GitHub 用户名） Git 安装： 安装： ~$ sudo apt update ~$ sudo apt install git 这是在 Linux 系统下的安装，Windows 系统下的安装都一个样，不必多说。之后讲到的命令如果是 Linux 系统，则是在 Linux 命令行下操作；如果是 Windows 系统则是在 Git Bash 下操作。 初始设置： ~$ git config --global user.name &quot;Firstname Lastname&quot; ~$ git config --global user.email &quot;your_email@example.com&quot; 上面的双引号里面的内容是你自己想设置的名字和邮箱。 设置 SSH key： 运行下面命令创建 SSH key： ~$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; Generating public/private rsa key pair Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 按回车键 Enter passphrase (empty for no passphrase): 输入密码 Enter same passphrase again: 再次输入密码 接着会出现以下结果： Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub The key fingerprint is: fingerprint值 your_email@example.com The key&apos;s randomart imageis: 一个图片(略) 添加公开密匙： 点击 GitHub 账户右上角的账户设定： Settings选择： SSH keys 然后会出现 Title 和 Key 两个输入框，第一个输入自己喜欢的名称即可。Key 部分需要粘贴 id_rsa.pub 文件中的内容，内容查看方法如下： ~$ cat ~/.ssh/id_rsa.pub ssh-rsa 公开密匙内容 your_email@example.com 将全部内容复制到 Key 里面，然后点击绿色的 Add SSH Key，完成。 安装 Nodejs： 由于 Hexo 需要 Nodejs 模块的支持，因此，在搭建博客以前需要先安装 Nodejs。 Windows 系统同样直接下载安装即可。 Linux 系统下，我采用的是从源代码编译安装，所以直接到 Nodejs 官网： https://nodejs.org/en/ 下载源代码。 然后到源代码压缩包所在目录，首先解压缩： ~$ tar -zxf node-v6.9.2.tar.gz 然后进入解压后的文件夹，配置、编译、安装： ~$ ./configure ~$ make ~$ make install 前期准备工作至此结束。 搭建博客： 安装 Hexo ~$ sudo npm install hexo-cli -g 初始化：（假设博客根目录即为 blogs） ~$ hexo init blogs ~$ cd blogs/ ~$ sudo npm install 新建博客： ~$ hexo new &quot;title&quot; 生成静态文件： ~$ hexo g(==hexo generate) 预览： ~$ hexo s(==hexo server) 现在，打开浏览器，输入 http://localhost:4000/，然后，就可以看到你的博客了 接下来的步骤很很关键：把博客部署到 GitHub 上。 在博客根目录 blogs 里面有一个 _config.yml 文件，这是博客的配置文件，你可以在里面修改网站名称、作者等。 打开 _config.yml，翻到最下面，修改下面的内容： deploy: type: 改为（实际上是加东西）： deploy: type: git repository: git@github.com:user/user.github.io.git branch: master 注意： user 部分为你的 GitHub 用户名；冒号后面要有一个空格，这是 yml 语法。 然后，安装 hexo-deployer-git： ~$ sudo npm install hexo-deployer-git --save 部署到 GitHub 上面： ~$ hexo d(==hexo deploy) 部署好以后，在浏览器打开 https://user.github.io/ 就可以看到你自己的博客了（同上，user 为你的用户名） 搭建好以后，写博客和发布都很简单方便。 新建： ~$ hexo new &quot;title&quot; 之后便会在 source/_posts/ 目录里生成一个 Markdown 文件，这就是你要写的文章。 文章写好以后，先删除之前的发布内容： ~$ hexo clean 生成： ~$ hexo g(==hexo generate) 预览： ~$ hexo s(==hexo server) 发布： ~$ hexo d(==hexo deploy) 错误总结： ERROR Deployer not found:git解决方法： ~$ sudo npm install hexo-deployer-git --save ERROR Plugin load failed: hexo-server解决方法： ~$ sudo npm install hexo-server /usr/bin/env:node: No such file or directory解决方法： ~$ sudo ls /usr/bin/nodejs/usr/bin/node 好了，整个博客的搭建差不多就完成了。 更改主题： 下面，写一点关于主题的更改，以我现在用的主题 hexo-theme-yilia 为例。 首先进入 themes 目录： ~$ cd blogs/themes/ 然后把你想要的主题克隆下来： ~$ git clone https://github.com/litten/hexo-theme-yilia.git 然后替换主题。进入博客根目录的配置文件 _config.yml，更改主题，将 theme: lanscape 改为： theme: hexo-theme-yilia 至此，主题就替换了。 主题里面也有一个配置文件 _comfig.yml，你可以在里面进行一些更加个性化的配置。 下面，说一个问题，是关于头像的，我在这上面花费了大量时间，结果最后才发现解决办法很简单。 首先，要设置头像路径。 在根目录里面的 source 目录里面新建一个目录： assets ，然后将你想设置的头像拷入该目录，假设头像名为： profile.jpg 然后，打开主题的配置文件 _config.yml ，在 avatar 那儿添加头像路径： avatar: /assets/profile.jpg 下面，需要再修改两个文件: 打开 layout/_partial/left-col.ejs 文件，将 6,7 行改为： &lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar show&quot;&gt; &lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar show&quot; style=&quot;width: 100%;height: 100%;opacity: 1;&quot;&gt; 同样地，再打开 layout/_patial/mobile-nav.ejs ，相应位置也改成上面那样。 文章截断按钮：一般来说我们不希望文章在主页上全文显示，所以我们可以在想截断的地方加上： &lt;!--more--&gt; 这样，文章就不会在主页上全文显示，会出现一个 more&gt;&gt; 按钮，如下图所示。 至此，主题更改完成。 关于主题的问题的解决方法，基本都可以在该主题的 GitHub 项目的 issue 那儿找到：https://github.com/litten/hexo-theme-yilia/issues 后记 写到这儿，基本把需要写的东西都写完了。 最后提一句，博客的写作采用 Markdown 语言。不得不说，恐怕很难找到比 Markdown 更简单的语言了，不然我也不可能随便看了几分钟就开始写这样一篇博客了。 关于 Markdown 语法，请参考： http://www.appinn.com/markdown/ 添加多说评论 首先，需要到多说创建一个站点。 登录网站。 登录后点击我要安装 之后会出现以下界面： 然后填写相关信息创建站点。 多说域名一项即填写duoshuo_shortname。 站点创建完成以后，到主题配置文件中，找到： 12 # Duoshuo ShortNameduoshuo_shortname: 在duoshuo_shortname后面填上刚才创建站点的信息。 域名绑定 当用 Hexo+GitHub 搭建好博客以后，域名为：username.github.io 。但是很多人包括我都会觉得这个域名过于太长，还好 GitHub 支持域名绑定，因此你可以选择一个自己喜欢的域名绑定到博客上，之后，便可通过该域名访问博客。 首先购买一个自己喜欢的域名； 然后进行域名解析； 解析时，需要添加三条记录：两条 A 记录和一条 CNAME 记录； 两条 A 记录的对应值为 GitHub 服务器 ip：分别为：192.30.252.153 和 192.30.252.154，两条都要添加上；CNAME 的对应值为你的博客域名，即username.github.io； 解析完成如下图所示： 然后，到博客根目录的 sources 文件夹新建文件 CNAME，文件内容即为你购买的域名，不需要前缀http://； 之后再重新部署到 GitHub 上就可以通过你购买的域名访问博客了。 添加背景图片 假设背景图片为beijing.jpg，格式不限； 首先，将背景图片放到目录/themes/next/source/images/目录下； 然后，在文件/themes/next/source/css/_custom/custom.styl文件中添加下面一行内容： 1 body &#123; background:url(/images/beijing.jpg);&#125; 注：/images/beijing.jpg即为背景图片的路径。 此时，背景会随着页面移动，要使背景不随页面移动，可改为： 1234 body &#123; background:url(/images/back.jpg); background-attachment: fixed;&#125; 但是，经过一段时间，发现，添加日志背景严重影响阅读，所以便取消了。 页眉背景 假设背景图片为header.jpg; 同样先把图片放到目录/themes/next/source/images/下； 然后在文件/themes/nex/source/CSS/_common/components/header/header.styl中加上下面这行内容： 1 .header &#123; background: url(/images/header.jpg); &#125; 侧栏背景 假设图片为side.jpg 放到同上目录中； 然后在文件/themes/nex/source/CSS/_common/components/sidebar/sidebar.styl中加上下面这行内容： 1 .sidebar &#123; background: url(/images/side.jpg);&#125; 添加动态背景 修改 _layout.swig 模块； 模块位置：themes/next/layout/\\_layout.swig 在末尾加上下面的内容： 123 &lt;!--动态背景－－》&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\" count=\"50\" zindex=\"-2\" opacity=\"1\" color=\"0,104,183\"&gt;&lt;/script&gt; 注： 设置的线条默认为灰色线条和浅绿色线条。 然后在目录 themes/next/source/js/src/ 下新建文件particle.js，文件中写入以下代码： 1 !function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(\"script\"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,\"zIndex\",-1),o:n(i,\"opacity\",.5),c:n(i,\"color\",\"0,0,0\"),n:n(i,\"count\",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=\"rgba(\"+m.c+\",\"+(t+.2)+\")\",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement(\"canvas\"),m=t(),d=\"c_n\"+m.l,l=u.getContext(\"2d\"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText=\"position:fixed;top:0;left:0;z-index:\"+m.z+\";opacity:\"+m.o,e(\"body\")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 鼠标点击小红心 在themes/next/source/js/src/下新建文件love.js，然后在文件中添加以下代码： 1 !function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 下一步，回到themes/next/layout/\\_layout.swig文件，添上以下内容： 12 &lt;!-- 小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt; ###"},{"title":"用数据科学搭建一个实时推荐引擎","date":"2016-12-14T10:14:40.000Z","path":"2016/12/14/Build-a-Recommand-Engine-With-Data-Sciences/","text":"编者注：本文是 2016 年 4 月 Nicole Whilte 在欧洲 GraphConnect 时所作。这儿我们快速回顾一下她所涉及的内容： 图数据库推荐基础 社会化推荐 相似性推荐 集群推荐 今天我们将要讨论的内容是数据科学和图推荐（graph recommendations）： 我在 Neo4j 任职已经两年了，但实际上我已经使用 Neo4j 和 Cypher 工作三年了。当我首次发现这个特别的图数据库（graph database）的时候，我还是一个研究生，那时候我在奥斯丁的德克萨斯大学攻读关于社交网络的统计学硕士学位。 实时推荐引擎是 Neo4j 中最广泛的用途之一，也是使它如此强大并且容易使用的原因之一。为了探索这个东西，我将通过使用示例数据集来阐述如何将统计学方法并入这些引擎中。 第一个很简单 - 将 Cypher 用于社交推荐。接下来，我们将看一看相似性推荐，这涉及到可被计算的相似性度量，最后探索的是集群推荐。 图数据库推荐基础 下面的数据集包含所有达拉斯 Fort Worth 国际机场的餐饮场所，达拉斯 Fort Worth 国际机场是美国主要的机场枢纽之一： 我们把节点标记成黄色并按照出入口和航站楼给它们的位置建模。同时我们也按照食物和饮料的主类别将地点分类，其中一些包括墨西哥食物、三明治、酒吧和烤肉。 让我们做一个简单的推荐。我们想要在机场的某一确定地点找到一种特定食物，大括号中的内容表示是的用户输入，它将进入我们的假想应用程序中。 这个英文句子表示成 Cypher 查询： 这将提取出该类别中用户所请求的所有地点、航站楼和出入口。然后我们可以计算出用户所在位置到出入口的准确距离，并以升序返回结果。再次说明，这个非常简单的 Cypher 推荐仅仅依据的是用户在机场中的位置。 社交推荐（Social Recommendations） 让我们来看一下社交推荐。在我们的假想应用程序中，用户可以登录并且可以用和 Facebook 类似的方式标记自己“喜好”的地点，也可以在某地签到。 考虑位于我们所研究的第一个模型之上的数据模型，现在让我们在下面的分类中找到用户的朋友喜好的航站楼里面离出入口最近的餐饮场所： MATCH 子句和我们第一次 Cypher 查询的 MATCH 子句相似，只是现在我们依据喜好和朋友来匹配： 前三行是完全一样的，但是现在要考虑的是那些登录的用户，我们想要通过 :FRIENDS_WITH 这一关系来找到他们的朋友。仅需通过在 Cypher 中增加一些行内容，我们现在已经把社交层面考虑到了我们的推荐引擎中。 再次说明，我们仅仅显示了用户明确请求的类别，并且这些类别中的地点与用户进入的地方是相同的航站楼。当然，我们希望按照登录并做出请求的用户来滤过这些目录，然后返回地点的名字、位置以及所在目录。我们也要显示出有多少朋友已经“喜好”那个地点以及那个地点到出入口的确切距离，然后在 RETURN 子句中同时返回所有这些内容。 相似性推荐（Similarity Recommendations） 现在，让我们看一看相似性推荐引擎： 和前面的数据模型相似，用户可以标记“喜好”的地点，但是这一次他们可以用 1 到 10 的整数给地点评分。这是通过前期在 Neo4j 中增加一些属性到关系中建模实现的。 这将允许我们找到其他相似的用户，比如以上面的 Greta 和 Alice 为例，我们已经查询了他们共同喜好的地点，并且对于每一个地点，我们可以看到他们所设定的权重。大概地，我们可以通过他们的评分来确定他们之间的相似性大小。 现在我们有两个向量： 现在让我们按照欧几里得距离（Euclidean distance）的定义来计算这两个向量之间的距离： 我们把所有的数字带入公式中计算，然后得到下面的相似度，这就是两个用户之间的“距离”： 你可以很容易地在 Cypher 中计算两个特定用户的“距离”，特别是如果他们仅仅同时“喜好”一个很小的地点子集。再次说明，这儿我们依据两个用户 Alice 和 Greta 来进行匹配，并尝试去找到他们同时“喜好”的地点： 他们都有对最后找到的地点的 :LIKES 关系，然后我们可以在 Cypher 中很容易的计算出他们之间的欧几里得距离，计算方法为他们对各个地点评分差的平方求和再开平方根。 在两个特定用户的例子中上面这个方法或许能够工作。但是，在实时情况下，当你想要通过和实时数据库中的其他用户比较，从而由一架飞机上的一个用户推断相似用户时，这个方法就不一定能够工作。不用说，至少它不能够很好的工作。 为了找到解决这个问题的好方法，我们可以预先计算好距离并存入实际关系中： 当遇到一个很大的数据集时，我们需要成批处理这件事，在这个很小的示例数据集中，我们可以按照所有用户的迪卡尔乘积（Cartesian product）和他们共同“喜好”的地点来进行匹配。当我们使用 WHERE id（u1） &lt; id（u2） 作为 Cypher 询问的一部分时，它只是来确定我们在左边和右边没有找到相同的对的一个技巧。 通过用户之间的欧几里得距离，我们创建了他们之间的一种关系，叫做 :DISTANCE，并且设置了一个叫做 euclidean 的欧几里得属性。理论上，我们可以也通过用户间的一些关系来存储其他相似度从而获取不同的相似度，因为在确定的环境下某些相似度可能比其他相似度更有用。 在 Neo4j 中，的确是对关系属性建模的能力使得完成像这样的事情无比简单。然而，实际上，你不会希望存储每一个可能存在的单一关系，因为你仅仅希望返回离他们“最近”的一些人。 因此你可以根据一些临界值来存入前几个，从而你不需要构建完整的连通图。这允许你完成一些像下面这样的实时的数据库查询，因为我们已经预先计算好了“距离”并存储在了关系中，在 Cypher 中，我们能够很快的攫取出数据。 在这个查询中，我们依据地点和类别来进行匹配： 再次说明，前三行是相同的，除了登录用户以外，我们找出了和他们有 :DISTANCE 关系的用户。这是我们前面查看的关系产生的作用 - 实际上，你只需要存储处于前几位的相似用户 :DISTANCE 关系，因此你不需要在 MATCH 子句中攫取大量用户。相反，我们只攫取和那些用户“喜好”的地方有 :DISTANCE 关系的用户。 这允许我们用少许几行内容表达较为复杂的模型。我们也可以攫取 :LIKES 关系并把它放入到变量中，因为后面我们将使用这些权重来评分。 在这儿重要的是，我们可以依据“距离”大小将用户按照升序进行排序，因为这是一个距离测度。同时，我们想要找到用户间的最小距离因为距离越小表明他们的相似度最大。 通过其他按照欧几里得距离大小排序好的用户，我们得到用户评分最高的三个地点并按照用户的平均评分高低来推荐这些地点。换句话说，我们先找出一个活跃用户，然后依据其他用户“喜好”的地点找出和他最相似的其他用户，接下来按照这些相似用户的平均评分把那些地点排序在结果的集合中。 本质上，我们通过把所有评分相加然后除以收集的用户数目来计算出平均分，然后按照平均评分的升序进行排序。其次，我们按照出入口距离排序。假想地，我猜测应该会有交接点，因此你可以按照出入口距离排序然后再返回名字、类别、出入口和航站楼。 集群推荐（Cluster Recommendations） 我们最后要讲的一个例子是集群推荐，在 Cypher 中，这可以被想像成一个作为临时解决方案的离线计算工作流。这可能完全基于在欧洲 GraphConnect 上宣布的新方法，但是有时你必须进行一些 Cypher 2.3 版本所没有的算法逼近。 在这儿你可以使用一些统计软件，把数据从 Neo4j 取出然后放入像 Apache Spark、R 或者 Python 这样的软件中。下面是一段把数据从 Neo4j 中取出的 R 代码，运行该程序，如果正确，写下程序返回结果的给 Neo4j，可以是一个属性、节点、关系或者一个新的标签。 通过持续把程序运行结果放入到图表中，你可以在一个和我们刚刚看到的查询相似的实时查询中使用它： 下面是用 R 来完成这件事的一些示例代码，但是你可以使用任何你最喜欢的软件来做这件事，比如 Python 或 Spark。你需要做的只是登录并连接到图表。 在下面的例子中，我基于用户的相似性把他们聚合起来。每个用户作为一个观察点，然后得到他们对每一个目录评分的平均值。 假定用户对酒吧类评分的方式和一般的评分方式相似。然后我攫取出喜欢相同类别中的地点的用户名、类别名、“喜好”关系的平均权重，比如平均权重这些信息，从而我可以得到下面这样一个表格： 因为我们把每一个用户都作为一个观察点，所以我们必须巧妙的处理每一个类别中的数据，这些数据的每一个特性都是用户对该类中餐厅评分的平均权重。接下来，我们将使用这些数据来确定用户的相似性，然后我将使用聚类（clustering）算法来确定在不同集群中的用户。 在 R 中这很直接： 在这个示例中我们使用 K-均值（k-means）聚类算法，这将使你很容易攫取集群分配。总之，我通过运行聚类算法然后分别得到每一个用户的集群分配。 Bob 和 David 在一个相同的集群中 - 他们在集群二中 - 现在我可以实时查看哪些用户被放在了相同的集群中。 接下来我把集群分配写入 CSV 文件中，然后存入图数据库： 我们只有用户和集群分配，因此 CSV 文件只有两列。 LOAD CSV 是 Cypher 中的内建语法，它允许你从一些其他文件路径或者 URL 调用 CSV ，并给它一个别名。接下来，我们将匹配图数据库中存在的用户，从 CSV 文件中攫取用户列然后合并到集群中。 我们在图表中创建了一个新的标签节点：Cluster ID， 这是由 K-平均聚类算法给出的。接下来我们创建用户和集群间的关系，通过创建这个关系，当我们想要找到在相同集群中的实际推荐用户时，就会很容易进行查询。 我们现在有了一个新的集群标签，在相同集群中的用户和那个集群存在关系。新的数据模型看起来像下面这样，它比我们前面探索的其他数据模型要更好： 现在让我们考虑下面的查询： 通过这个 Cypher 查询，我们在更远处找到了在同一个集群中的相似用户。由于这个原因，我们删除了“距离”关系： 在这个查询中，我们取出已经登录的用户，根据用户-集群关系找到他们所在的集群，找到他们附近和他们在相同集群中的用户。 我们把这些用户分配到变量 c1 中，然后我们得到其他被我取别名为 neighbor 变量的用户，这些用户和那个相同集群存在着用户-集群关系，最后我们得到这些附近用户“喜好”的地点。再次说明，我把“喜好”放入了变量 r 中，因为我们需要从关系中攫取权重来对结果进行排序。 在这个查询中，我们所做的改变是，不使用相似性距离，而是攫取在相同集群中的用户，然后对类别、航站楼以及我们所攫取的登录用户进行声明。我们收集所有的权重：来自附近用户“喜好”地点的“喜好”关系，得到的类别，确定的距离值，然后把它们按升序进行排序并返回结果。 在这些例子中，我们可以进行一个相当复杂的处理并且将其放到图数据库中，然后我们就可以使用实时算法结果-聚类算法和集群分配的结果。 我们更喜欢的工作流程是更新这些集群分配，更新频率适合你自己就可以，比如每晚一次或每小时一次。当然，你可以根据直觉来决定多久更新一次这些集群分配是可接受的。 via: https://neo4j.com/blog/real-time-recommendation-engine-data-science/ 作者：Nicole White译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"不常见但是很有用的 GCC 命令行选项（二）","date":"2016-12-13T10:28:13.000Z","path":"2016/12/13/Uncomman-But-Useful-gcc-Command-Line-Options-2/","text":"gcc 编译器提供了几乎数不清的命令行选项列表。当然，没有人会使用过或者精通它所有的命令行选项，但是有一些命令行选项是每一个 gcc 用户都应该知道的 - 即使不是必须知道。它们中有一些很常用，其他一些不太常用，但不常用并不意味着它们的用处没前者大。 在这个系列的文章中，我们集中于一些不常用但是很有用的 gcc 命令行选项，在第一节已经讲到几个这样的命令行选项。 不知道你是否能够回想起，在这个系列教程的第一部分的开始，我简要的提到了开发者们通常用来生成警告的 -Wall 选项，并不包括一些特殊的警告。如果你不了解这些特殊警告，并且不知道如何生成它们，不用担心，我将在这篇文章中详细讲解关于它们所有的细节。 除此以外，这篇文章也将涉及与浮点值相关的 gcc 警告选项，以及在 gcc 命令行选项列表变得很大的时候如何更好的管理它们。 在继续之前，请记住，这个教程中的所有例子、命令和指令都已在 Ubuntu 16.04 LTS 操作系统和 gcc 5.4.0 上测试过。 生成 -Wall 选项不包括的警告 尽管 gcc 编译器的 -Wall 选项涵盖了绝大多数警告标记，依然有一些警告不能生成。为了生成它们，请使用 -Wextra 选项。 比如，下面的代码： 1234567891011121314 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i=0; /* ... some code here ... */ if(i); return 1; return 0;&#125; 我不小心在 if 条件后面多打了一个分号。现在，如果使用下面的 gcc 命令来进行编译，不会生成任何警告。 1 gcc -Wall test.c -o test 但是如果同时使用 -Wextra 选项来进行编译： 1 gcc -Wall -Wextra test.c -o test 会生成下面这样一个警告： 123 test.c: In function ‘main’:test.c:10:8: warning: suggest braces around empty body in an ‘if’ statement [-Wempty-body] if(i); 从上面的警告清楚的看到， -Wextra 选项从内部启用了 -Wempty-body 选项，从而可以检测可疑代码并生成警告。下面是这个选项启用的全部警告标记。 -Wclobbered -Wempty-body -Wignored-qualifiers -Wmissing-field-initializers -Wmissing-parameter-type （仅针对 C 语言） -Wold-style-declaration （仅针对 C 语言） -Woverride-init -Wsign-compare -Wtype-limits -Wuninitialized -Wunused-parameter （只有和 -Wunused 或 -Wall 选项使用时才会启用） -Wunused-but-set-parameter (只有和-Wunused或-Wall` 选项使用时才会生成） 如果想对上面所提到的标记有更进一步的了解，请查看 gcc 手册。 此外，遇到下面这些情况， -Wextra 选项也会生成警告： 一个指针和整数 0 进行 &lt;， &lt;=， &gt;， 或 &gt;= 比较 （仅 C++）一个枚举类型和一个非枚举类型同时出现在一个条件表达式中 （仅 C++）有歧义的虚拟基底 （仅 C++）寄存器类型的数组加下标 （仅 C++）对寄存器类型的变量进行取址 （仅 C++）基类没有在派生类的复制构建函数中进行初始化 浮点值的等值比较时生成警告 你可能已经知道，浮点值不能进行确切的相等比较（如果不知道，请阅读与浮点值比较相关的 FAQ)。但是如果你不小心这样做了， gcc 编译器是否会报出错误或警告？让我们来测试一下： 下面是一段使用 == 运算符进行浮点值比较的代码： 12345678910111213141516 #include&lt;stdio.h&gt;void compare(float x, float y)&#123; if(x == y) &#123; printf(\"\\n EQUAL \\n\"); &#125;&#125;int main(void)&#123; compare(1.234, 1.56789); return 0;&#125; 使用下面的 gcc 命令（包含 -Wall 和 -Wextra 选项）来编译这段代码： 1 gcc -Wall -Wextra test.c -o test 遗憾的是，上面的命令没有生成任何与浮点值比较相关的警告。快速看一下 gcc 手册，在这种情形下可以使用一个专用的 选项。 12 下面是包含这个选项的命令： gcc -Wall -Wextra -Wfloat-equal test.c -o test 12 下面是这条命令产生的输出： test.c: In function ‘compare’:test.c:5:10: warning: comparing floating point with == or != is unsafe [-Wfloat-equal] if(x == y) 123456789101112 正如上面你所看到的输出那样， `-Wfloat-equal` 选项会强制 gcc 编译器生成一个与浮点值比较相关的警告。这儿是[gcc 手册][8]关于这一选项的说明：&gt; 这背后的想法是，有时，对程序员来说，把浮点值考虑成近似无限精确的实数是方便的。如果你这样做，那么你需要通过分析代码，或者其他方式，算出这种计算方式引入的最大或可能的最大误差，然后进行比较时（以及产生输出时，不过这是一个不同的问题）允许这个误差。特别要指出，不应该检查是否相等，而应该检查两个值是否可能出现范围重叠；这是用关系运算符来做的，所以等值比较可能是搞错了。### 如何更好的管理 gcc 命令行选项如果在你使用的 gcc 命令中，命令行选项列表变得很大而且很难管理，那么你可以把它放在一个文本文件中，然后把文件名作为 gcc 命令的一个参数。之后，你必须使用 `@file` 命令行选项。比如，下面这行是你的 gcc 命令： gcc -Wall -Wextra -Wfloat-equal test.c -o test 12 然后你可以把这三个和警告相关的选项放到一个文件里，文件名叫做 `gcc-options`： $ cat gcc-options-Wall -Wextra -Wfloat-equal 12 这样，你的 gcc 命令会变得更加简洁并且易于管理： gcc @gcc-options test.c -o test``` 下面是 gcc 手册关于 @file 的说明： 从文件中读取命令行选项。读取到的选项随之被插入到原始 @file 选项所在的位置。如果文件不存在或者无法读取，那么这个选项就会被当成文字处理，而不会被删除。 文件中的选项以空格分隔。选项中包含空白字符的话，可以用一个由单引号或双引号包围完整选项。任何字符（包括反斜杠: ‘\\’）均可能通过一个 ‘\\’ 前缀而包含在一个选项中。如果该文件本身包含额外的 @file 选项，那么它将会被递归处理。 结论 在这个系列的教程中，我们一共讲解了 5 个不常见但是很有用的 gcc 命令行选项： -Save-temps、-g、 -Wextra、-Wfloat-equal 以及 @file。记得花时间练习使用每一个选项，同时不要忘了浏览 gcc 手册上面所提供的关于它们的全部细节。 你是否知道或使用其他像这样有用的 gcc 命令行选项，并希望把它们在全世界范围内分享？请在下面的评论区留下所有的细节。 via: https://www.howtoforge.com/tutorial/uncommon-but-useful-gcc-command-line-options-2/ 作者：Ansh译者：ucasFL校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"如何在 Linux 中恢复一个删除了的文件","date":"2016-11-21T10:06:25.000Z","path":"2016/11/21/How-to-Recover-a-Deleted-File-in-Linux/","text":"你曾经是否遇到这样的事？当你发现的时候，你已经通过删除键，或者在命令行中使用 rm 命令，错误的删除了一个不该删除的文件。 在第一种情况下，你可以到垃圾箱，搜索那个文件，然后把它复原到原始位置。但是第二种情况又该怎么办呢？你可能知道，Linux 命令行不会把删除的文件转移到任何位置，而是直接把它们移除了，biu~，它们就不复存在了。 在这篇文章里，将分享一个很有用的技巧来避免此事发生。同时，也会分享一个工具，不小心删除了某些不该删除的文件时，也许用得上。 把删除创建为 rm -i 的别名 当 -i 选项配合 rm 命令（也包括其他文件处理命令比如 cp 或者 mv）使用时，在删除文件前会出现一个提示。 这同样也可以运用到当复制，移动或重命名一个文件，当所在位置已经存在一个和目标文件同名的文件时。 这个提示会给你第二次机会来考虑是否真的要删除该文件 - 如果你在这个提示上选择确定，那么文件就被删除了。这种情况下，很抱歉，这个技巧并不能防止你的粗心大意。 为了 rm -i 别名替代 rm ，这样做： 1 alias rm='rm -i' 运行 alias 命令可以确定 rm 现在已经被别名了： 为 rm 增加别名 然而，这只能在当前用户的当前 shell 上有效。为了永久改变，你必须像下面展示的这样把它保存到 ~/.bashrc 中（一些版本的 Linux 系统可能是 ~/.profile）。 在 Linux 中永久增添别名 为了让 ~/.bashrc（或 ~/.profile）中所做的改变立即生效，从当前 shell 中运行文件： 1 . ~/.bashrc 在 Linux 中激活别名 取证工具 － Foremost 但愿你对于你的文件足够小心，当你要从外部磁盘或 USB 设备中恢复丢失的文件时，你只需使用这个工具即可。 然而，当你意识到你意外的删除了系统中的一个文件并感到恐慌时－不用担心。让我们来看一看 foremost，一个用来处理这种状况的取证工具。 要在 CentOS/RHEL 7 中安装 Foremost，需要首先启用 Repoforge： 12 # rpm -Uvh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm# yum install foremost 然而在 Debian 及其衍生系统中，需这样做： 1 # aptitude install foremost 安装完成后，我们做一个简单的测试吧。首先删除 /boot/images 目录下一个名为 nosdos.jpg 的图像文件： 12 # cd images# rm nosdos.jpg 要恢复这个文件，如下所示使用 foremost（要先确认所在分区 - 本例中， /boot 位于 /dev/sda1 分区中）。 1 # foremost -t jpg -i /dev/sda1 -o /home/gacanepa/rescued 其中，/home/gacanepa/rescued 是另外一个磁盘中的目录 － 请记住，把文件恢复到被删除文件所在的磁盘中不是一个明智的做法。 如果在恢复过程中，占用了被删除文件之前所在的磁盘分区，就可能无法恢复文件。另外，进行文件恢复操作前不要做任何其他操作。 当 foremost 执行完成以后，恢复的文件（如果可以恢复）将能够在目录 ·/home/gacanepa/rescue/jpg` 中找到。 总结 在这篇文章中，我们阐述了如何避免意外删除一个不该删除的文件，以及万一这类事情发生，如何恢复文件。还要警告一下， foremost 可能运行很长时间，时间长短取决于分区的大小。 如果您有什么问题或想法，和往常一样，不要犹豫，告诉我们。可以给我们留言。 via: http://www.tecmint.com/recover-deleted-file-in-linux/ 作者：Gabriel Cánepa译者：ucasFL校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"通过安装扩展让 KDE Plasma 5 桌面看起来感觉就像 Windows 10 桌面","date":"2016-11-20T10:11:36.000Z","path":"2016/11/20/KDE-use-guide-Like-Windows10/","text":"通过一些步骤，我将告诉你如何把 KDE Plasma 5 桌面变成 Windows 10 桌面。 除了菜单， KDE Plasma 桌面的许多地方已经和 Win 10 桌面非常像了。因此，只需要一点点改动就可以使二者看起来几乎是一样。 开始菜单 让 KDE Plasma 桌面看起来像 Win 10 桌面的首要以及可能最有标志性的环节是实现 Win 10 的 ‘开始’ 菜单。 通过安装 Zren’s Tiled Menu，这很容易实现。 安装 1、 在 KDE Plasma 桌面上单击右键 -&gt; 解锁窗口部件（Unlock Widgets） 2、 在 KDE Plasma 桌面上单击右键 -&gt; 增添窗口部件（ Add Widgets） 3、 获取新窗口部件 -&gt; 下载新的 Plasma 窗口部件（Download New Plasma Widgets） 4、 搜索“Tiled Menu” -&gt; 安装（Install） 激活 1、 在你当前的菜单按钮上单击右键 -&gt; 替代……（Alternatives…） 2、 选择 “TIled Mune” -&gt;点击切换（Switch） KDE Tiled 菜单扩展 主题 弄好菜单以后，下一个你可能需要的就是主题。幸运的是， K10ne 提供了一个 WIn 10 主题体验。 安装： 1、 从 Plasma 桌面菜单打开“系统设置（System Settings）” -&gt; 工作空间主题（Workspace Theme） 2、 从侧边栏选择“桌面主题（Desktop Theme）” -&gt; 获取新主题（Get new Theme） 3、 搜索“K10ne” -&gt; 安装（Install） 激活 1、 从 Plasma 桌面菜单选择“系统设置（System Settings）” -&gt; 工作空间主题（Workspace Theme） 2、 从侧边栏选择“桌面主题（Desktop Theme）” -&gt; “K10ne” 3、 应用（Apply） 任务栏 最后，为了有一个更加完整的体验，你可能也想拥有一个更加 Win 10 风格的任务栏， 这次，你需要的安装包，叫做“Icons-only Task Manager”， 在大多数 Linux 发行版中，通常会默认安装。如果没有安装，需要通过你的系统的合适通道来获取它。 激活 1、 在 Plasma 桌面上单击右键 -&gt; 打开窗口部件（Unlock Widgets） 2、 在 Plasma 桌面上单击右键 -&gt; 增添部件（Add Widgets） 3、 把“Icons-only Task Manager”拖放到你的桌面面板的合适位置。 via: https://iwf1.com/make-kde-plasma-5-desktop-look-feel-like-windows-10-using-these-extensions/ 作者：Liron译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"理解 Linux 下 Shell 命令的不同分类及它们的用法","date":"2016-09-25T09:33:20.000Z","path":"2016/09/25/Different-Shell-Command-in-Linux/","text":"当你打算真正操纵好你的 Linux 系统，没有什么能比命令行界面更让你做到这一点。为了成为一个 Linux 高手，你必须能够理解 Shell 命令的不同类型，并且会在终端下正确的使用它们。 在 Linux 下，命令有几种类型，对于一个 Linux 新手来说，知道不同命令的意思才能够高效和准确的使用它们。因此，在这篇文章里，我们将会遍及各种不同分类的 Linux Shell 命令。 需要注意一件非常重要的事：命令行界面和 Shell 是不同的，命令行界面只是为你提供一个访问 Shell 的方式。而 Shell ，它是可编程的，这使得它可以通过命令与内核进行交流。 下面列出了 Linux 下命令的不同种类： 1. 程序可执行文件（文件系统 中的命令） 当你执行一条命令的时候，Linux 通过从左到右搜索存储在 $PATH 环境变量中的目录来找到这条命令的可执行文件。 你可以像下面这样查看存储在 $PATH 中的目录： 12 $ echo $PATH/home/aaronkilik/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 在上面的命令中，目录 /home/aaronkilik/bin 将会被首先搜索，紧跟着是 /usr/local/sbin，然后一直接着下去。在搜索过程中，搜索顺序是至关重要的。 比如在 /usr/bin 目录里的文件系统中的命令： 1 $ ll /bin/ 样本输出： 1234567891011121314151617181920212223242526 total 16284drwxr-xr-x 2 root root 4096 Jul 31 16:30 ./drwxr-xr-x 23 root root 4096 Jul 31 16:29 ../-rwxr-xr-x 1 root root 6456 Apr 14 18:53 archdetect*-rwxr-xr-x 1 root root 1037440 May 17 16:15 bash*-rwxr-xr-x 1 root root 520992 Jan 20 2016 btrfs*-rwxr-xr-x 1 root root 249464 Jan 20 2016 btrfs-calc-size*lrwxrwxrwx 1 root root 5 Jul 31 16:19 btrfsck -&gt; btrfs*-rwxr-xr-x 1 root root 278376 Jan 20 2016 btrfs-convert*-rwxr-xr-x 1 root root 249464 Jan 20 2016 btrfs-debug-tree*-rwxr-xr-x 1 root root 245368 Jan 20 2016 btrfs-find-root*-rwxr-xr-x 1 root root 270136 Jan 20 2016 btrfs-image*-rwxr-xr-x 1 root root 249464 Jan 20 2016 btrfs-map-logical*-rwxr-xr-x 1 root root 245368 Jan 20 2016 btrfs-select-super*-rwxr-xr-x 1 root root 253816 Jan 20 2016 btrfs-show-super*-rwxr-xr-x 1 root root 249464 Jan 20 2016 btrfstune*-rwxr-xr-x 1 root root 245368 Jan 20 2016 btrfs-zero-log*-rwxr-xr-x 1 root root 31288 May 20 2015 bunzip2*-rwxr-xr-x 1 root root 1964536 Aug 19 2015 busybox*-rwxr-xr-x 1 root root 31288 May 20 2015 bzcat*lrwxrwxrwx 1 root root 6 Jul 31 16:19 bzcmp -&gt; bzdiff*-rwxr-xr-x 1 root root 2140 May 20 2015 bzdiff*lrwxrwxrwx 1 root root 6 Jul 31 16:19 bzegrep -&gt; bzgrep*-rwxr-xr-x 1 root root 4877 May 20 2015 bzexe*lrwxrwxrwx 1 root root 6 Jul 31 16:19 bzfgrep -&gt; bzgrep*-rwxr-xr-x 1 root root 3642 May 20 2015 bzgrep* 2. Linux 别名 这些是用户定义的命令，它们是通过 shell 内置命令 alias 创建的，其中包含其它一些带有选项和参数的 shell 命令。这个意图主要是使用新颖、简短的名字来替代冗长的命令。 创建一个别名的语法像下面这样： 1 $ alias newcommand='command -options' 通过下面的命令，可以列举系统中的所有别名： 123456789 $ alias -palias alert='notify-send --urgency=low -i \"$([ $? = 0 ] &amp;&amp; echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\\''s/^\\s*[0-9]\\+\\s*//;s/[;&amp;|]\\s*alert$//'\\'')\"'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l='ls -CF'alias la='ls -A'alias ll='ls -alF'alias ls='ls --color=auto' 要在 Linux 中创建一个新的别名，仔细阅读下面的例子。 123 $ alias update='sudo apt update'$ alias upgrade='sudo apt dist-upgrade'$ alias -p | grep 'up' 然而，上面这些我们创建的别名只能暂时的工作，当经过下一次系统启动后它们不再工作。你可以像下面展示的这样在 ‘.bashrc’ 文件中设置永久别名。 添加以后，运行下面的命令来激活： 1 $ source ~/.bashrc 3. Linux Shell 保留字 在 shell 程序设计中，if、then、fi、for、while、case、esac、else、until 以及其他更多的字都是 shell 保留字。正如描述所暗示的，它们在 shell 中有特殊的含义。 你可以通过使用下面展示的 type 命令来列出所有的 shell 关键字： 12345678910 $ type if then fi for while case esac else untilif is a shell keywordthen is a shell keywordfi is a shell keywordfor is a shell keywordwhile is a shell keywordcase is a shell keywordesac is a shell keywordelse is a shell keyworduntil is a shell keyword 4. Linux shell 函数 一个 shell 函数是一组在当前 shell 内一起执行的命令。函数有利于在 shell 脚本中实现特殊任务。在 shell 脚本中写 shell 函数的传统形式是下面这样： 12345 function_name() &#123;command1command2......&#125; 或者像这样： 12345 function function_name &#123;command1command2......&#125; 让我们看一看如何在一个名为 shell_functions.sh 的脚本中写 shell 函数。 12345678 #!/bin/bash#write a shell function to update and upgrade installed packagesupgrade_system()&#123;sudo apt update;sudo apt dist-upgrade;&#125;#execute functionupgrade_system 取代通过命令行执行两条命令：sudo apt update 和 sudo apt dist-upgrade，我们在脚本内写了一个像执行一条单一命令一样来执行两条命令的 shell 函数 upgrade_system。 保存文件，然后使脚本可执行。最后像下面这样运行 shell 函数： 12 $ chmod +x shell_functions.sh$ ./shell_functions.sh 5. Linux Shell 内置命令 这些是在 shell 中内置的 Linux 命令，所以你无法在文件系统中找到它们。这些命令包括 pwd、cd、bg、alias、history、type、source、read、exit 等。 你可以通过下面展示的 type 命令来列出或检查 Linux 内置命令： 12345678910 $ type pwdpwd is a shell builtin$ type cdcd is a shell builtin$ type bgbg is a shell builtin$ type aliasalias is a shell builtin$ type historyhistory is a shell builtin via: http://www.tecmint.com/understanding-different-linux-shell-commands-usage/ 作者：Aaron Kili译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"},{"title":"Linus 之女谈计算机、大学、女权主义和提升技术界的多元化","date":"2016-09-19T08:48:56.000Z","path":"2016/09/19/Talk-of-the-Daughter-Linus/","text":"图片来源：照片来自 Becky Svartström， Opensource.com 修改 Patricia Torvalds 暂时还不像她的父亲 Linus 一样闻名于 Linux 和开源领域。 在她 18 岁的时候，Patricia 已经是一个有多项技术成就、拥有开源行业经验的女权主义者，而且她已经把目标放在进入杜克大学普拉特工程学院的新学期上了。当时她以实习生的身份在位于美国奥勒冈州伯特兰市的 Puppet 实验室工作。但不久后，她就将前往北卡罗纳州的达拉莫，开始秋季学期的大学学习。 在这次独家采访中，Patricia 谈到了使她对计算机科学与工程学感兴趣的（剧透警告：不是因为她的父亲）原因，她所在高中学校在技术教学上所采取的“正确”方法，女权主义在她的生活中扮演的重要角色，以及对技术缺乏多元化的思考。 ###是什么使你对学习计算机科学与工程学发生兴趣？### 我在技术方面的兴趣主要来自于高中时代。我曾一度想投身于生物学，这种想法一直维持到大约大学二年级的时候。大二结束以后，我在波特兰 VA 做网页设计实习生。与此同时，我参加了一个叫做“探索冒险家（Exploratory Ventures，XV）”的工程学课程，在我大二学年的后期，我们把一个水下机器人送入了太平洋。但是，转折点大概是在我大三学年的中期被授予“NCWIT 的计算机之理想”奖的地区冠军和全国亚军的时候出现的（LCTT 译注：NCWIT - National Center for Women &amp; IT，女性与 IT 国家中心）。 这个奖项的获得让我感觉到确立了自己的兴趣。当然，我认为最重要的部分是我加入到一个由所有获奖者组成的 Facebook 群。女孩们获奖很难想象，因此我们彼此非常支持。由于在 XV 和 VA 的工作，我在获奖前就已经确实对计算机科学发生了兴趣，但是和这些女孩们的交谈更加坚定了这份兴趣，使之更加强烈。再后来，后期大三、大四年级的时候执教 XV 也使我体会到工程学和计算机科学的乐趣。 ###你打算学习什么？你已经知道自己毕业后想干什么了吗？### 我希望要么主修机械，要么是电子和计算机工程学，以及计算机科学，并且辅修女性学。毕业以后，我希望在一个支持社会公益或者为其创造技术的公司工作，或者自己开公司。 ###我的女儿在高中有一门 Visual Basic 的编程课。她是整个班上唯一的一个女生，并且以困扰和痛苦的经历结束了这门课程。你的经历是什么样的呢？### 我的高中在高年级的时候开设了计算机科学的课程，我也学习了 Visual Basic！这门课不是很糟糕，但我的确是 20 多个人的班级里仅有的三四个女生之一。其他的计算机课程似乎也有相似的性别比例差异。然而，我所在的高中极其小，并且老师对技术包容性非常支持，所以我并没有感到困扰。希望在未来的一些年里这些课程会变得更加多样化。 ###你的学校做了哪些促进技术的举措？它们如何能够变得更好？### 我的高中学校给了我们长时间接触计算机的机会，老师们会突然在不相关的课程上安排技术相关的任务，有几次我们还为社会实践课程建了一个网站，我认为这很棒，因为它使我们每一个人都能接触到技术。机器人俱乐部也很活跃并且资金充足，但是非常小，不过我不是其中的成员。学校的技术/工程学项目中一个非常重要的组成部分是一门叫做”探索冒险家（Exploratory Ventures）“的由学生自己教的工程学课程，这是一门需要亲自动手的课程，并且每年换一个工程学或者计算机科学方面的难题。我和我的一个同学在这儿教了两年，在课程结束以后，有学生上来告诉我他们对从事工程学或者计算机科学发生了兴趣。 然而，我的高中没有特别的关注于让年轻女性加入到这些课程中来，并且在人种上也没有呈现多样化。计算机的课程和俱乐部大量的主要成员都是男性白人学生。这的确应该需要有所改善。 ###在成长过程中，你如何在家运用技术？### 老实说，小的时候，我使用我的上机时间（我的父亲 Linus 设置了一个跟踪装置，当我们上网一个小时就会断线）来玩尼奥宠物和或者相似的游戏。我想我本可以搞乱跟踪装置或者在不连接网络的情况下玩游戏，但我没有这样做。我有时候也会和我的父亲做一些小的科学项目，我还记得有一次我和他在电脑终端上打印出几千个“Hello world”。但是大多数时候，我都是和我的妹妹一起玩网络游戏，直到高中的时候才开始学习计算机。 ###你在高中学校的女权俱乐部很活跃，从这份经历中你学到了什么？现在对你来说什么女权问题是最重要的？### 在高中二年级的后期，我和我的朋友一起建立了女权俱乐部。刚开始，我们受到了很多人对俱乐部的排斥，并且这从来就没有完全消失过。到我们毕业的时候，女权主义思想已经彻底成为了学校文化的一部分。我们在学校做的女权主义工作通常是在一些比较直接的方面，并集中于像着装要求这样一些问题。 就我个人来说，我更关注于新女性主义（ intersectional feminism），这是一种致力于（消除）其它方面压迫（比如，种族歧视和阶级压迫等）的女权主义。Facebook 上的 Gurrilla Feminism 专页是新女性主义一个非常好的例子，并且我从中学到了很多。我目前管理着波特兰分会。 在技术多样性方面女权主义对我也非常重要，尽管作为一名和技术世界有很强联系的高年级白人女性，女权主义问题对我产生的影响相比其他人来说少得多，我所参与的新女性主义也是同样的。《Model View Culture》的出版非常鼓舞我，谢谢 Shanley Kane 所做的这一切。 ###你会给想教他们的孩子学习编程的父母什么样的建议？### 老实说，从没有人推着我学习计算机科学或者工程学。正如我前面说的，在很长一段时间里，我想成为一名遗传学家。大二结束的那个夏天，我在 VA 做了一个夏天的网页设计实习生，这彻底改变了我之前的想法。所以我不知道我是否能够充分回答这个问题。 我的确认为真正的兴趣很重要。如果在我 12 岁的时候，我的父亲让我坐在一台电脑前，教我配置一台网站服务器，我认为我不会对计算机科学感兴趣。相反，我的父母给了我很多可以支配的自由时间让我去做自己想做的事情，绝大多数时候是我在为我的尼奥宠物游戏编写糟糕的 HTML 网站。比我小的妹妹们没有一个对工程学或计算机科学感兴趣，我的父母也不在乎。我感到很幸运的是我的父母给了我和我的妹妹们鼓励和资源去探索自己的兴趣。 仍然要讲的是，在我成长过程中我也常说未来职业生涯要“像我爹一样”，尽管那时我还不知道我父亲是干什么的，只知道他有一个很酷的工作。另外，中学的时候有一次我告诉我的父亲这件事，然后他没有发表什么看法只是告诉我高中的时候不要想这事。所以我猜想这从一定程度上鼓励了我。 ###对于开源社区的领导者们，你有什么建议给他们来吸引和维持更加多元化的贡献者？### 我实际上在开源社区并不是特别积极和活跃，我更喜欢和其它女性讨论计算机。我是“NCWIT 的计算机之理想”成员之一，这是我对技术持久感到兴趣的一个重要方面，同样也包括 Facebook 的”Ladies Storm Hackathons” 群。 我认为对于吸引和留住那些天才而形形色色的贡献者，安全的空间很重要。我曾经看到过在一些开源社区有人发表关于女性歧视和种族主义的评论，当人们指出这一问题随后该人就被解职了。我认为要维持一个专业的社区必须就骚扰事件和不正当行为有一个高标准。当然，人们已经有而且还会有，关于在开源社区或其他任何社区能够表达什么意见的更多的观点。然而，如果社区领导人真的想吸引和留住形形色色的天才们，他们必须创造一个安全的空间并且以高标准要求社区成员们。 我也觉得一些社区领导者不明白多元化的价值。很容易觉得在技术上是唯才是举的，并且这个原因有一些是技术上不处于中心位置的人是他们不在意的，问题来自于发展的早期。他们争论如果一个人在自己的工作上做得很好，那么他的性别或者民族还有性取向这些情况都变得不重要了。这很容易反驳，但我不想看到为这些错误找的理由。我认为多元化的缺失是一个错误，我们应该为之负责并尽力去改善这件事。 注：本文文章内容虽无多少意义，但这是我加入LCTT后翻译的第一篇文章，所以^_^ via: http://opensource.com/life/15/8/patricia-torvalds-interview 作者：Rikki Endsley译者：ucasFL校对：LinuxBars, wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出 var gitment = new Gitment({ owner: 'ucasFL', repo: 'BlogComments', oauth: { client_id: 'ef399b43f01e072241fd', client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5', }, }) gitment.render('container');"}]