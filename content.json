[{"title":"2020","date":"2019-12-31T16:48:40.000Z","path":"2020/01/01/2019to2020/","text":"2020年到了来北京的第五个元旦回想起来好像除了2017年每年的元旦都是一个人在寝室度过的吧倒也挺享受这一份孤独 接下来的这一年没什么特别大的愿望只希望能找到一个真正喜欢的方向并为之努力希望技术水平能有更大的提升希望能够有时间多回家陪陪爸爸妈妈希望每天都快乐 好像这个愿望还蛮大的希望能实现吧"},{"title":"C++ 笔记","date":"2019-09-28T15:03:36.000Z","path":"2019/09/28/Cpp-notes/","text":"1234567 #include &lt;type_traits&gt;std::is_same&lt;T, U&gt; // 判断两个类型是否相同std::is_same&lt;T, U&gt;::value // 返回 true 或 falsestd::decay_t&lt;T&gt; // 返回类型信息，去除 const,引用等。std::decay_t&lt;decltype(obj)&gt; 12345 #include &lt;typeinfo&gt;typeid(type)typeid(expr) // 返回 class type_infotypeid(expr).name() // 返回 type 的名字c-str 属性指示符： 123 [[noreturn]] //表示函数不返回值[[maybe_unused]] //抑制未使用变量的警告[[fallthrough]] //出现在switch语句中，抑制上一句case没有break而引起的fallthrough的警告 12345678910111213 // enable_if 可能的实现，若B为真，则 std::enable_if//有一个与T相等的public typedef类型#include &lt;type_traits&gt;template&lt;bool B, class T = void&gt;struct enable_if &#123;&#125;;template&lt;class T&gt;struct enable_if&lt;true, T&gt; &#123; typedef T type; &#125;;//Since C++14template&lt; bool B, class T = void &gt;using enable_if_t = typename enable_if&lt;B,T&gt;::type; 12345678910111213141516171819202122232425 //C++17#include&lt;type_traits&gt;template&lt;typename... T&gt;struct disjunction; //短路实例化//若sizeof...(T) == 0, 则为std::false_type//membervalue // type //最终类型template&lt;class... B&gt;inline constexpr bool disjunction_v = disjunction&lt;B...&gt;::value;template&lt;class B&gt;strcut negation //构建类型特性 B 的逻辑否定。template&lt;typename... T&gt;strcut conjunction;//若sizeof...(T) == 0，则胃std::true_type, 否则为首个bool(Bi::value) == false 的Bi, 若不存在，则为BNtemplate&lt; class T, T v &gt;struct integral_constant;//包装特定类型的静态常量//C++ 17template &lt;bool B&gt;using bool_constant = integral_constant&lt;bool, B&gt;; C++ 中const 对象只能引用const成员函数。"},{"title":"Git 合并多个 Commit","date":"2019-07-11T06:02:02.000Z","path":"2019/07/11/Git-Merge-Commits/","text":"总是记不住 Git 合并 Commit 的命令，故今天记录一下。 1 git rebase -i HEAD~2 2 为合并的 Commit 的个数，如果合并 3 个 Commit，则改为 3，同理。 之后，可能会出现如下内容： 123456789101112131415161718192021 pick 7bb83e2 commit 1pick ae60558 commit 2# Rebase f59dfd0..ae60558 onto f59dfd0 (2 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like \"squash\", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out commit 1 和 commit 2 为 commit 的消息，commit 1 在前，commit 2 在后。 之后，修改如下： 123456789101112131415161718192021 pick 7bb83e2 commit 1squash ae60558 commit 2# Rebase f59dfd0..ae60558 onto f59dfd0 (2 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like \"squash\", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 即，将 commit 2 的 pick 改为 squash。然后保存退出，之后还会出现 commit 消息的修改，修改完保存退出即可。 如果前一个 commit 已经 push 到了远程仓库中，那么还需要 force push 一下： 1 git push -f"},{"title":"CPython 学习笔记","date":"2019-02-22T03:09:19.000Z","path":"2019/02/22/CPython-Summary/","text":"本文为查阅相关资料的过程中随手记录的，故内容较为杂乱，无任何章节可言。 Python 源代码执行流程： Python 基于栈式执行，CPython 主要使用三种类型的栈： call stack：一个 frame 表示一个活动的函数调用 data stack：也称作 evaluation stack，每一个函数对应一个 data stack，函数在其中进行数据操纵，包括函数参数，返回地址等 block stack：用于跟踪控制结构的确定类型：如循环，try/except 块，with 块等 反汇编Python字节码：dis 库，例如： 123456 import disdef hello(): print('hello, world!')dis.dis(hello) 输出如下： 123456 2 0 LOAD_GLOBAL 0 (print) 2 LOAD_CONST 1 ('hello') 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 0 (None) 10 RETURN_VALUE 可通过 __code__ 属性访问函数 code object，如 hello.__code__，同时，code 对象拥有如下一些属性： co_consts：由函数中出现的任何文字(如常数、字符串)组成的元组 co_varnames：一个包含所有函数体中使用到的局部变量的名字的元组 co_names：一个包含任何函数中引用过的非局部名字的元组，包括变量名，调用的函数名等 co_code：原始字节码 Python 解释器是一个字节码解释器，模拟真实计算机的软件。 解释器在执行字节码时操作的是数据栈。 Frame：一个 frame 是一些信息的集合和代码的上下文。frame 在 Python 代码执行时动态地创建和销毁，每个 frame 对应函数的一次调用，所以每个 frame 只有一个 code object 与之关联，相反，一个 code object 可以有多个 frame，如递归函数。总的来说，Python 程序的每个作用域有一个 frame，比如每个模块，每个函数调用，每个类定义。 每个 frame 都有自己特定的 data stack 和 block stack 。 例如： 1234567891011 &gt;&gt;&gt; def bar(y):... z = y + 3 # &lt;--- (3) ... and the interpreter is here.... return z...&gt;&gt;&gt; def foo():... a = 1... b = 2... return a + bar(b) # &lt;--- (2) ... which is returning a call to bar ......&gt;&gt;&gt; foo() # &lt;--- (1) We're in the middle of a call to foo ...3 假设此时，解释器正在 foo 函数的调用中，紧接着调用 bar ，则 call stack，data stack，block stack 的示意图如下： 现在，解释器在 bar 函数的调用中，call stack 中有三个 frame，一旦 bar 返回，与之对应的 frame 就会被弹出并丢弃。 字节码指令RETURN_VALUE告诉解释器在 frame 间传递一个值。首先，它把位于调用栈栈顶的 frame 中的 data stack 的栈顶值弹出。然后把整个 frame 弹出丢弃，最后把这个值压到下一个 frame 的 data stack 中。 Python 代码编译过程： 解析源代码生成解析树(parse tree) 将解析树转换成抽象语法树 AST 生成符号表 根据 AST 生成 code object：AST -&gt; 控制流图 -&gt; code object 使用 parser 模块可以获得 Python 代码的 parse tree： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 &gt;&gt;&gt;code_str = \"\"\"def hello_world(): return 'hello world' \"\"\"&gt;&gt;&gt; import parser&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; st = parser.suite(code_str)&gt;&gt;&gt; pprint(parser.st2list(st))[257,[269,[294,[263, [1, 'def'], [1, 'hello_world'], [264, [7, '('], [8, ')']], [11, ':'], [303, [4, ''], [5, ''], [269, [270, [271, [277, [280, [1, 'return'], [330, [304, [308, [309, [310, [311, [314, [315, [316, [317, [318, [319, [320, [321, [322, [323, [3, '\"hello world\"']]]]]]]]]]]]]]]]]]]], [4, '']]], [6, '']]]]],[4, ''],[0, '']]&gt;&gt;&gt; 使用 ast 模块来获取 Python 代码的 AST： 1234567891011 &gt;&gt;&gt;code_str = \"\"\"def hello_world(): return 'hello world' \"\"\"&gt;&gt;&gt; import ast&gt;&gt;&gt; import pprint&gt;&gt;&gt; node = ast.parse(code_str, mode=\"exec\")&gt;&gt;&gt; ast.dump(node)(\"Module(body=[FunctionDef(name='hello_world', args=arguments(args=[], \"'vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), '\"body=[Return(value=Str(s='hello world'))], decorator_list=[], \"'returns=None)])') Names and binding in Python：在 Python 中，对象通过名字引用，binding 即名字与对象的绑定，名字仅仅是与对象相联系的符号，是对象的引用，没有类型，对象具有类型。 Code Blocks: A code block is a piece of program code that is executed as a single unit in python. Modules, functions and classes are all examples of code blocks. Commands typed in interactively at the REPL, script commands run with the -c option are also code blocks. Namespaces：在 Python 中，名字空间通过字典映射实现，包含所有内建函数的内建名字空间可通过 __builtins__.__dict__ 访问。 Python Objects Python 中的所有对象，函数、变量等，都是 PyObject ，或者说 PyObject 是所有 Python 对象的超类。 PyObject 定义： 12345 typedef struct _object &#123; _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type;&#125; PyObject; _PyObject_HEAD_EXTRA 是一个宏，ob_refcnt 用于内存管理，表明该对象的引用次数，ob_type 是指向 type object 的指针。一个有趣的事,type 函数的 type 就是 type，因此，type 函数的 ob_type 域指向自身。 type 类型是所有内建类型的元类型 object 类型是所有用户自定义类型的元类型 Code Objects Code Objects 是已编译可执行 Python 代码，其中包含可运行的字节码指令。 给定一个函数，我们可以通过 __code__ 属性访问函数体的 code object： 12345 &gt;&gt;&gt; def hello():... print(\"hello, world!\")...&gt;&gt;&gt; hello.__code__&lt;code object hello at 0x7fd58d3b4ed0, file \"&lt;stdin&gt;\", line 1&gt; Code Object 的 co_code 属性包含字节码指令序列： 12 &gt;&gt;&gt; hello.__code__.co_codeb't\\x00d\\x01\\x83\\x01\\x01\\x00d\\x00S\\x00' 字节码指令的大小为两字节，一字节为 opcode(现为两字节大小)，另一字节为 opcode 的参数。如果 opcode 不需要参数，则对应参数部分为 0。 Frames Objects Frame object 为 code object 的执行提供上下文信息。 通过 sys._getframe() 访问 frame object： 123456 &gt;&gt;&gt; import sys&gt;&gt;&gt; f = sys._getframe()&gt;&gt;&gt; f&lt;frame object at 0x7fd580fd0b28&gt;&gt;&gt;&gt; dir(f)['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'f_back', 'f_builtins', 'f_code', 'f_globals', 'f_lasti', 'f_lineno', 'f_locals', 'f_trace'] 在一个 code object 执行前，都需要创建一个 frame object，该 frame object 包含该 code object 执行需要的所有名字空间，一个指向当前执行的线程的引用，data stack，block stack，以及其它 code object 执行需要的重要信息。 在 Python 代码执行过程中，需要通过调用 PyFrame_New 函数创建很多次 frame object，为了减少函数调用带来的开销，采用了两种优化方式： Code object 有一个域 co_zombieframe ，当一个 object 执行过后，对应的 frame 不会立刻释放，而会保存到 co_zombieframe 中，从而当下次执行相同的 code object 时，不需要再次分配内存创建新的 frame； Python 虚拟机维护一个预分配好的空闲 frame 列表，供 code object 使用； 解释器状态和线程状态 Interpreter state 保存一个 Python 进程中一系列协作线程共享的全局状态。 一个 thread state 与一个正在运行的 Python 进程的 native OS thread 相联系。 解释器状态、线程状态和 frame 之间的关系： The evaluation loop, ceval.c Python 虚拟机循环迭代 code object 的每一条指令并执行：Python/ceval.c，关键函数：PyEval_EvalFrameEx。 在 PyEval_EvalFrameEx 函数执行 Python 字节码之前，需要进行大量的设置工作，包括错误检查、frame 创建和初始化等(_PyEval_EvalCodeWithName 函数)。 Block Stack 通过 block stack，能够很方便地实现异常处理，且仅用于处理循环和异常。PyFrame_BlockSetup 函数创建一个一个新的 block 并 push 到 block stack。 从 Class code 到字节码 创建类的过程大致如下： 将类定义语句放入一个 code object 中 确定该类实例的合适元类 为该类的名字空间准备一个字典 在该名字空间内执行上述对应的 code object 通过实例化元类创建类对象 元类确定： 如果没有给定基类或明确的元类，则使用 type() 如果给定了明确的元类但不是 type() 的实例，则使用该元类 如果给定了 type() 的实例作为明确元类，或者定义了基类，则使用最派生的元类。 Generator 生成器对象包含一个 frame object 和 code object，当生成器函数被调用时，它并不会运行，而是返回一个生成器对象，只有将生成器对象作为一个参数传入内建的 next 函数时，生成器对象才能够运行：即在生成器对象所包含的 frame object 内调用 PyEval_EvalFrameEx 函数。 当生成器函数执行遇到 YIELD_VALUE opcode 时，该 opcode 会使得执行暂停，并将栈顶值返回给调用者。暂停意味着当前正在执行的 frame 退出了，但是它并不会被释放，因为该 frame 还在被生成器对象引用，并且能够再次执行，即再次以该 frame 作为参数调用 PyEval_EvalFrameEx 函数时。 References Inside the Python virtual machine An introduction to Python bytecode A Python Interpreter Written in Python"},{"title":"向量量化与乘积量化简介","date":"2019-01-13T05:36:07.000Z","path":"2019/01/13/VQ-and-PQ-introduction/","text":"向量量化-VQ 向量量化（Vector Quantization）是一个常见的压缩技术，广泛用于信号处理和数据压缩等领域。VQ 一个比较正式的定义是将一个向量空间中的点用其中的一个有限子集来进行编码的过程。它是一种基于块编码规则的有损数据压缩方法，基本思想是：将若干个标量数据组构成一个矢量，然后在矢量空间给以整体量化，从而压缩了数据而不损失多少信息。 VQ实际上就是一种逼近，它的思想和“四舍五入”有异曲同工之妙，都是用一个和一个数最接近的整数来近似表示这个数。用二维图像压缩来说明，将图像的每个像素点当作一个数据，跑一下 K-means 聚类，假设将图像聚为k类，就会得到每类的质心centroids，共k个，然后用这些质心的像素值来代替对应的类里的所有点的像素值。这样就起到了压缩的目的，因为只需要编码k个像素值（和图像每个像素点对这k个值的索引）就可以表示整张图像了。当然，这会存在失真。最偏激的情况是原图像每个像素就是一个类，那就没有失真了，当然也没有了压缩。 VQ 问题可以描述如下：给定一个已知统计属性的矢量源（也就是训练样本集，每一个样本是一个矢量）和一个失真测度，同时给定码矢的数量（也就是我们要把这个矢量空间划分为多少部分，或者说量化为多少种值），然后寻找一个具有最小平均失真度的码书（所有码矢的集合）和空间的划分。简单描述为：给定T（训练集）和N（码矢数目），找到能使Dave（平均失真度）最小的C（码书）和P（空间划分）。 如果 C 和 P 是上面最小化问题的一个解，那么需要满足两个条件： 最近邻条件 质心条件 乘积量化-PQ 乘积量化（Product quantization），这里的乘积是指笛卡尔积，其思想是把原向量空间分解为若干个低维向量空间的笛卡尔积，并对分解得到的低维向量空间分别做量化，这样每个向量就能由多个低维向量的量化 code 表示。 PQ 本质上是一种数据压缩表达方法，可用于相似搜索、模型压缩等领域，特别是深度神经网络的模型压缩上。PQ 算法可以理解为对 VQ 做了一次分治，首先把原始向量空间分解为 m 个低维向量空间的笛卡尔积，并对分解得到的低维向量空间分别做量化。对低维向量空间的量化同样是使用 K-means 算法。换句话描述就是，把原始 D 维向量（比如 D = 128 ）分成 m 组（比如 m = 4 ），每组就是 D’ = D / m 维的子向量（比如 D’ = D / m = 128 / 4 = 32 ），各自用 K-means 算法学习到一个码本，然后这些码本的笛卡尔积就是原始 D 维向量对应的码本。"},{"title":"华为校招面试总结","date":"2018-10-15T10:15:13.000Z","path":"2018/10/15/huawei-interview-summary/","text":"前天晚上参加了华为的校招笔试，结果昨天早上刚睡醒就收到短信通知今天面试… 今天去参加了面试，现在把面试中的一些问题总结一下。虽然我对这次面试并不满意，估计也不太可能拿到 offer 拿到华为 offer 了，如果考研失败就滚去搬砖(18年11月6号)。 399 分，所以研究生应该稳了(19年2月22日)。 面试貌似是三轮，两轮业务面试，一轮综合面试，但是不知道为什么，我面了一轮业务面试之后，就直接通知综合面试了。 接下来，说一说面试的情况吧。 业务面试 不知道是面试官的原因，还是华为的面试就是这样，感觉整个业务面试没有问太多很有深度的问题，也没有考算法，只问了一些操作系统，C++，数据结构方面的基础知识。 问题 首先问的是几个操作系统方面的问题。 “操作系统有哪几个主要模块?”“进程管理，虚存管理，文件管理/文件系统，输入输出系统“ 操作系统课上学的大概就这几个模块吧，同步与通信不知道算不算一个单独的模块。 “内核是什么？”“内核是操作系统最重要的组成部分，是计算机软件与硬件的接口……” 回答记不太清了，这个问题当时我还真不知道怎么回答，内核是什么是知道的，却没有想好怎么描述比较好，但是我觉得回答的不太好总比什么都不说好。百度百科关于内核的定义是这样的：操作系统内核是指大多数操作系统的核心部分。它由操作系统中用于管理存储器、文件、外设和系统资源的那些部分组成。操作系统内核通常运行进程，并提供进程间的通信。后来想想，当时的回答最大的缺点是少了一句：管理计算机资源的系统软件 “虚地址通过什么转换成物理地址，如何转换？”“MMU，转换时，先从虚地址中取出段号，从段表中到对应的段，然后取出页号，从页表中找出对应的页表项，从而得到物理页号，加上偏移得到物理地址” 我回答的实际上是“段页式”管理的转换方法。MMU 的转换分“硬件控制的 TLB” 和”软件控制的 TLB“ 两种。 硬件控制的 TLB： 软件控制的 TLB： “写程序时，你看到的是虚地址还是物理地址？”“虚地址” 下面问了几个 C++ 的问题。 “虚函数是什么？”“带有 virtual 关键字的成员函数，基类中定义的虚函数可以在派生类中重新实现。” “有一个虚函数在基类和派生类中均有实现，现在用一个基类指针指向一个派生类对象，当调用该虚函数时，会调用基类的虚函数还是派生类的虚函数？”“派生类，因为虚函数支持动态绑定。” “它是如何调用的？”“通过查虚函数表。”“通过什么指针调用？”“不知道。” 说实话，这两个问题我是有点懵的，这似乎是要问 C++ 底层的东西了，虽然我也大概知道一些关于虚函数表，虚函数调用的东西，但是并不是很清楚，于是没有回答上来。然后，面试官在纸上写了一个，通过 this 指针调用。原来这个问题他想要的答案只是通过 this 指针调用，是我自己把问题想复杂了。 “纯虚函数是什么？”“纯虚函数就是只定义不实现的虚函数。” “含有虚函数的类可以实例化吗？”“不可以” 含有纯虚函数的类是抽象类，不可以实例化。只有实现了该纯虚函数的派生类才可以实例化。 最后问了几个数据结构方面的问题。 “栈和队列的区别是什么?““栈是先进后出，队列是先进先出。” “什么是平衡二叉树。”“平衡二叉树首先是一棵二叉树，然后满足左右子树的高度差不超过 1，并且这是一个递归定义，即子树的左右子树高度差也不能超过 1。” “二叉树有几种遍历方式？”“三种，前序遍历，中序遍历，后序遍历。” 其实，当时想起来了还有层次遍历，但是当时不知道脑子中了什么邪，就是没有接着说层次遍历。然后，面试官在纸上画了一棵三层的满二叉树。让我写出三种遍历方式对应的遍历序列。写完后，他看了看，对我说是不是有点不太对，我又看了一遍，没问题啊，然后他说可能是我记不太清了… 大概就问了这些问题，之后他问我有没有什么想问的问题，我问了下关于新员工的入职培训，近期项目，以及新员工的薪资：13k~16k X 15。看来网上流传的白菜价大概八九不离十吧。 业务面试就结束了，让我等待后续的面试通知。 综合面试 综合面试没有问什么技术问题。大概问了这么些问题： 最近有做过些什么项目？项目是干什么的？你在项目中做了什么工作？收获了什么？ 这个问题问的算是最具体的一个，我觉得自己回答的并不好。 大学里学了些什么课程？入职之后遇到困难你会怎么办？刚入职时可能会要接触很多新的东西，之前不会的东西，你怎么看？如果有一个任务，在规定期限你完成不了你会怎么办？未来五年的人生你想达到什么目标？十年呢？你对华为了解多吗，以你的了解，华为是一家什么样的公司？对加班有什么看法？你希望华为带给你什么？你认为你能够给华为带来什么？假如有别的公司和华为同时给了你 offer，你会如何选，选择的时候你会看重公司的什么方面？比如一个 BAT 公司和华为同时给了你 offer？ 大概还记得的就这么多问题，都是一些开放性的问题，说不上有什么标准答案。后面面试官又问我有没有在准备考研，如果考上研了和工作会选择什么？这个问题我没有回答。首先，问我有没有在准备考研我没有想撒谎，就实话说了，然后问我选什么没有回答上，于是就结束了，告诉我等待后续通知。 总结 最后，总结一下自己的经验吧： 自己的专业知识要掌握扎实，这是前提条件，否则笔试都过不了，更别提面试了。 项目经历很重要， HR 不仅要考察你的专业能力，还要看你过去做过些什么东西，如果你有参与过一些比较大的项目，并且能够把项目描述清楚，以及你在项目中所做的贡献和从中的收获，那么会是很大的加分项。 良好的表达能力和沟通能力，要能够清晰明确的回答出问题，尤其是一些观点性问题，由于答案不是唯一的，此时，表达能力尤为重要。 放平心态，千万不要因为紧张导致原本知道的东西都回答不上来。但是也不要一听完问题就急于回答，可以稍微思考一下，组织一下语言。 公司除了看你的能力，还要看你对工作的态度，对公司的看法等各方面的情况，因此这些方面的问题不容忽视，尤其要能够清楚地让对方知道你能够为公司带来什么。"},{"title":"华为校招笔试总结","date":"2018-10-13T13:00:54.000Z","path":"2018/10/13/huawei-Application-Summary/","text":"今天晚上参加了华为今年的校招笔试（软件类）。华为的笔试题只有三个算法题，三个题相对来说都比较简单，没有太大难度。 1. n个人（n &gt;= 1) 站成一个环，编号为 1 ~ n，即编号为 n 的人与编号为 1 的人相邻，从第一个人开始报数，假如编号为 x 的报数为 m ，则该人出局，出局后不再参加报数，出局这一个人的后面一个人从 1 开始继续报数，直到所有人都出局，要求输出出局的编号序列。 该题为著名的约瑟夫环问题，实现方法很多。可通过模拟，也可通过数学公式推导，网上有现成的代码，不过考试的时候我没有上网找，是自己实现的，算是一个数学推导的方法吧。 考试时的 AC 代码： 123456789101112131415161718192021222324252627282930313233343536373839 /************************************************************************* &gt; Filename: dele.cpp &gt; Author: Lv Feng &gt; Mail: lvfeng97@outlook.com &gt; Date: 2018-10-13 ************************************************************************/#include&lt;bits/stdc++.h&gt;using namespace std;void Solve(const int &amp;n, const int &amp;m)&#123; vector&lt;int&gt; people; for(int i = 1; i &lt;= n; ++ i) people.push_back(i); vector&lt;int&gt;::iterator cur = people.begin(); int loc; while(people.size() &gt; 1)&#123; loc = (cur - people.begin() + m) % people.size() - 1; if (loc == -1)&#123; loc = people.size() - 1; &#125; cout &lt;&lt; people[loc] &lt;&lt; ' '; cur = people.erase(people.begin() + loc); &#125; cout &lt;&lt; people[0] &lt;&lt; endl;&#125;int main()&#123; int num; cin &gt;&gt; num; int data[num][2]; for(int i = 0; i != num; ++i)&#123; cin &gt;&gt; data[i][0] &gt;&gt; data[i][1]; &#125; for(int i = 0; i != num; ++i)&#123; Solve(data[i][0], data[i][1]); &#125; return 0;&#125; n 个数用 vector 存储，每次确定一个出列的数，然后输出该数并将该数从 vector 中删除，算法时间复杂度为 O(n)。main 函数中的 num 变量表示测试数据的组数。 2. 给定一个 10X10 的方格，数组中的数均为 0 或 1，每一个为 1 的方格的面积为 1，要求求出 1 的连通区域的最大面积（连通区域由上下左右为 1 的方格组成，不包括对角线） 本题中，10x10 的方格可以看成是一个二维数组，每次从一个没有遍历过的为 1 的元素出发，向四周遍历，所有为 1 的元素都遍历一遍就可求出最大连通面积。 考试时的 AC 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /************************************************************************* &gt; Filename: max.cpp &gt; Author: Lv Feng &gt; Mail: lvfeng97@outlook.com &gt; Date: 2018-10-13 ************************************************************************/#include&lt;bits/stdc++.h&gt;using namespace std;const int Len = 10;int data[10][10];int visited[Len][Len];inline void input()&#123; for(int i = 0; i != Len; ++i) for(int j = 0; j != Len; ++j) cin &gt;&gt; data[i][j];&#125;int getS(int m, int n)&#123; int s = 0; if(data[m][n] == 0 || visited[m][n]) return 0; else&#123; s += 1; visited[m][n] = 1; if (m - 1 &gt;= 0)&#123; s += getS(m-1, n); &#125; if (m + 1 &lt; Len)&#123; s += getS(m+1, n); &#125; if (n - 1 &gt;= 0)&#123; s += getS(m, n-1); &#125; if (n + 1 &lt;Len)&#123; s += getS(m, n+ 1); &#125; &#125; return s;&#125;void Solve()&#123; int maxS = 0; int tmp; int i, j; for(i = 0; i != Len; ++i)&#123; for(j = 0; j != Len; ++j)&#123; memset(visited, 0, 100); tmp = getS(i, j); maxS = (tmp &gt; maxS)? tmp: maxS; &#125; &#125; cout &lt;&lt; maxS &lt;&lt;endl;&#125;int main()&#123; input(); Solve(); return 0;&#125; 上面的代码实现中，从每一个元素开始都进行了一次遍历，实际上是不需要的，比如，对于值为 0 的元素，不需要从它开始进行遍历，另外，对于每一个 1 ，实际上也只需要遍历一次，但这儿遍历了多次，因为从每一个 1 出发都进行了一次遍历，如果数组不是 10x10，比如是 1000x1000 ，那么这样可能会导致超时。 优化后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /************************************************************************* &gt; Filename: max.cpp &gt; Author: Lv Feng &gt; Mail: lvfeng97@outlook.com &gt; Date: 2018-10-13 ************************************************************************/#include&lt;bits/stdc++.h&gt;using namespace std;const int Len = 10;int data[10][10];int visited[Len][Len];inline void input()&#123; for(int i = 0; i != Len; ++i) for(int j = 0; j != Len; ++j) cin &gt;&gt; data[i][j];&#125;int getS(int m, int n)&#123; int s = 0; if(!data[m][n] || visited[m][n]) return 0; else&#123; s += 1; visited[m][n] = 1; if (m - 1 &gt;= 0)&#123; s += getS(m-1, n); &#125; if (m + 1 &lt; Len)&#123; s += getS(m+1, n); &#125; if (n - 1 &gt;= 0)&#123; s += getS(m, n-1); &#125; if (n + 1 &lt;Len)&#123; s += getS(m, n+ 1); &#125; &#125; return s;&#125;void Solve()&#123; int maxS = 0; int tmp; int i, j; for(i = 0; i != Len; ++i)&#123; for(j = 0; j != Len; ++j)&#123; if(!data[i][j] || visited[i][j]) continue; tmp = getS(i, j); maxS = (tmp &gt; maxS)? tmp: maxS; &#125; &#125; cout &lt;&lt; maxS &lt;&lt;endl;&#125;int main()&#123; input(); Solve(); return 0;&#125; 实际上，只是在 for 循环里面多了一个 if 判断，这样对于为 0 的元素，就不用进入函数，减少了函数调用的开销，同时，不需要从每一个 1 都开始进行一次遍历，因此，不需要每次循环都对 visited 数组进行一次 memset 。 3. 如果一个整数序列从前往后读和从后往前读序列相同，则称该序列为回文序列，如 (1)，(1, 3, 1) ，(23, 25, 25, 23)，给定一个整数序列，定义对该整数序列的一次操作如下：从该序列中选出两个数，将两个数相加，将相加后的和放入原来两个数在的位置（只放一个和），问任意给定一个序列，需要多少次这样的操作可将该序列变成一个回文序列。 例如，序列为 (1, 1, 1, 3)，则两次操作可将其变为回文序列：(1, 1, 1, 3) -&gt;(2, 1, 3) -&gt; (3, 3)，即先将 1,2 两个数相加，再将 1,2 两个数相加。显然任意给定一个包含 n 个数的序列，最多进行 n-1 次操作即可将其变为回文序列，此时，序列中只有一个数。 一个序列要是回文序列，那么前后的数要分别相同，因此，我们设置两个指针，分别指向第一个数和最后一个数，如果第一个数和最后一个数相同，那么第一个指针加一，第二个指针减一，继续判断，如果不等，则将小的哪一端的数加到与它相邻的数上面，并将指针加一… 重复下去，直到第一个指针不小于第二个指针为止，此时的序列即为回文序列，这样便可求出操作次数。 Input : data[n]; output : OpTime; Optime = 0; low = 0, high = n - 1; if (low &lt; high) if (data[low] == data[high]) low = low + 1, high = high - 1, goto 2; else if (data[low] &lt; data [high]) data[low + 1] = data[low+1] + data[low], OpTime = OpTime + 1, low = low + 1, goto 2; else data[high - 1] = data[high-1] + data[high], OpTime = OpTime + 1, high = high - 1, goto 2 else return OpTime; AC 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 /************************************************************************* &gt; Filename: huiwen.cpp &gt; Author: Lv Feng &gt; Mail: lvfeng97@outlook.com &gt; Date: 2018-10-13 ************************************************************************/#include&lt;bits/stdc++.h&gt;using namespace std;int n;const int MaxNum = 50;int data[MaxNum];void input()&#123; cin &gt;&gt; n; for(int i = 0; i != n; ++i)&#123; cin &gt;&gt; data[i]; &#125;&#125;int Solve()&#123; int Time = 0; int low = 0, high = n - 1; while(low &lt; high)&#123; if (data[low] == data[high])&#123; ++low; --high; continue; &#125; else if(data[low] &lt; data[high])&#123; ++Time; data[low+1] += data[low]; ++low; continue; &#125; else&#123; ++Time; data[high-1] += data[high]; --high; &#125; &#125; return Time;&#125;int main()&#123; input(); cout &lt;&lt; Solve() &lt;&lt;endl; return 0;&#125;"},{"title":"操作系统知识整理","date":"2018-09-10T14:00:00.000Z","path":"2018/09/10/os-review/","text":"Chapter01 操作系统简介 什么是操作系统 在应用和硬件之间的一层软件 对上层软件提供硬件的抽象 对底层硬件进行管理：共享和隔离 对底层硬件的处理：细节实现 操作系统概观 典型Unix操作系统结构 用户层 应用：程序员编写并编译后的用户程序 库：精心设计的代码，预编译好的对象，通过头文件定义，通过链接器引入，类似函数调用程序加载时必须定位 核心层 可移植层：系统调用功能的集合 机器相关层：启动，初始化，中断和例外，I/O设备驱动，内存管理，处理器调度，模式切换 四个段 代码段：指令序列 数据段：全局数据，可能需要初始化 代码段/数据段由编译器静态分配，产生名字和符号索引 链接器翻译索引和重定位地址 加载器最终完成在内存的布局 堆 链接器和加载器确定起始地址 由库函数malloc()/free()等进行分配和释放 应用程序通过库函数进行管理，可能随机分配 栈 由编译器布局 进程创建或结束时分配/释放 相对于栈指针寻址，局部 中断 由外部事件触发 中断处理程序运行在核心态 最中恢复被中断的进程 操作系统结构 保护机制 CPU 核心有能力把用户的CPU抢走，避免用户永久占用 用户不能拥有这种能力 内存 防止一个用户修改其他用户的代码和数据 防止用户修改内核的代码和数据结构 I/O：防止用户执行非法的I/O操作 1.体系结构的支持：特权态 X86 Protection Rings 2.层次结构：不同层之间隐藏信息，层间存在依赖关系 优点：层功能独立 缺点：效率低、不灵活 3.一体结构（宏内核） 所以操作系统函数是一体的 系统调用接口 例子：Linux, BSD Unix, Windows 优点L：共享内核地址空间，性能高 缺点：不稳定，不灵活 4.微内核 操作系统服务作为常规的进程 用户通过消息获取服务进程的服务 例子：Mach, L4, MacOS 优点：灵活，故障隔离 缺点：效率低（需要穿越多个边界），保护机制不完整，内核和服务不方便共享数据 5.库操作系统（LibOS) 应用程序直接通过库与底层硬件交互 例子：ExoKernel, EXOS 优点：效率高 缺点：通用性差 6.虚拟机 虚拟机管理器：虚拟硬件，运行多个OS 例子：IBM VM/370, Java VM, Vmware, Xen 两种实现VMM的例子 OS状态切换 7.系统调用机制 假设： 用户代码 是任意的 用户无法修改核心内存 设计考虑： 系统调用参数传递 系统模式从用户态切换到核心态 执行系统调用功能 返回结果，切换到用户态 8.中断与异常 中断源： 硬件（外部设备） 软件 INT n 例外： 程序错误：fault, trap, abort 软件生成：INT 3 硬件检查例外（machine check） 9.系统调用 操作系统的API：应用和操作系统之间的接口 种类： 进程管理 内存管理 文件管理 设备管理 通信 10.参数传递 寄存器传参： 寄存器个数 可用寄存器个数 系统调用参数个数 编译器填充的代码 内存向量（数组）传参 一个寄存器传递起始地址 向量位于用户地址空间 堆栈传参 类似内存向量 遵循过程调用的约定 Chapter02 进程和线程 进程 1.进程的起源 IBM 7090 机器上第一次实现了多个程序共同运行，”进程”开始登上历史舞台。 2.进程的概念 进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程 进程刻画了一个程序运行所需要的资源 进程 VS 程序： 进程 &gt; 程序 程序只是进程状态的一部分 例子：多个用户可以运行相同的程序 进程 &lt; 程序 一个程序可以创建多个进程 例子：创建新进程 3.并发性和进程 并发性： 一个系统中有上百个作业”同时“运行 CPU是共享的，I/O设备也是 每一个作业都希望能拥有自己的计算机 进程并发性： 将复杂的问题分解为多个简单的问题 用进程来代表简单的问题 一次只处理一个问题 每一个进程就好像拥有了自己的计算机 4.进程并发性 虚拟化： 每个进程运行一段时间 使得一个CPU变成”多个“ 每一个进程就好像拥有了自己的CPU I/O并行性 CPU计算与I/O操作交叠 每一个进程运行的很快，就如同拥有了自己的计算机 减少了总共的完成时间 CPU并行性 多个CPU 进程并行的运行 加速 5.最简单的进程 顺序执行： 在进程内部没有并发性 一切都是顺序发生 需要一些协调机制 进程状态：寄存器，内存，I/O设备（文件系统，通信端口）… 6.进程的表示 进程在内核中的表示 每个进程的创建和销毁都由内核负责，每个进程都需要在内核登记信息 内核用进程控制块（PCB）来保存进程的信息 PCB是进程在内核中的表示，也是一种索引 进程控制块包含的信息 进程标识信息 与各种资源相关的信息： CPU相关的进程管理信息： 状态： 就绪态：准备运行 运行态：正在运行 阻塞态：等待资源 寄存器：EFLAGS，以及其他的CPU状态 内存管理信息： 栈、代码段和数据段 段、页表、统计信息等 I/O和文件管理：通信端口、目录、文件描述符等 7.进程的原语 创建和终止：Exec, Fork, Wait, Kill 信号：动作，返回，信号处理函数 操作：阻塞，放弃CPU控制权 同步 构造一个进程 创建进程：创建与初始化PCB 将数据和代码加载至内存 创建一个空的调用栈 初始化进程的状态 把进程状态标志为就绪态 克隆：复制与修改PCB 停止当前进程，并保存其状态 备份当前代码、数据、栈和OS的状态 把备份后的进程标志为就绪态 8.进程的状态 进程的声明周期： 非抢占式内核： 进程创建 进程执行 进程等待 进程结束 抢占式内核： 进程创建 进程执行 进程等待 进程抢占 进程唤醒 进程结束 进程创建： 何时创建进程？ 系统初始化时 用户请求创建一个新进程 正在运行的进程执行了创建进程的系统调用 进程执行： 内核选择一个就绪的进程，为它分配一个处理器的时间片，并开始执行（时间片倒计时） 进程等待： 进程进入等待（阻塞）的情况： 请求并等待系统服务，无法马上完成 启动某种操作，无法马上完成 需要的数据没有到达 只有进程自身才能知道何时需要等待某种事件的发生 进程抢占： 进程会被抢占的情况： 高优先级进程就绪 进程的时间片用完 进程唤醒： 唤醒进程的情况： 被阻塞进程需要的资源可被满足 被阻塞进程等待的事件到达 进程只能被别的进程或操作系统唤醒 进程结束： 进程结束的情况： 正常退出（自愿的） 错误退出（自愿的） 致命错误（强制性的） 被其他进程所杀（强制性的） 进程的状态转换图如下： sleep()系统调用对应的进程状态变化： 9.进程上下文切换 保存上下文：所有寄存器，所有协同处理器的状态 开始新的上下文：相反的操作过程 线程 1.线程的概念 IBM System/360 引入线程 线程是进程的一部分，描述指令流执行状态，是CPU调度的基本单位 线程在同一进程的地址空间内，可共享变量 2.线程与并发性 线程： 位于进程内部的一段顺序执行流 位于进程内部的所有线程共享地址空间 线程并发性： 相较信号，用线程更容易实现I/O交叠 人们更愿意一次做多件事情：web服务器 服务器服务多个请求 多个CPU共享内存 3.线程的表示 线程控制块（TCB）： 状态： 就绪态：准备运行 运行态：正在运行 阻塞态：等待资源 寄存器 程序计数器 栈 代码 典型的线程API： 创建：fork, join 互斥：acquire, release 条件变量：wait, signal, broadcast 警报：alert, alertwait, testalert 最简单的进程只有一个线程 4.进程 VS 线程 地址空间： 进程之间一般不会共享内存 进程切换会切换页表和其他内存机制 进程中的线程共享整个地址空间 权限： 进程拥有自己的权限，如文件访问权限 进程中的线程共享所有的线程 线程上下文切换： 保存上下文： 所有寄存器 所有协同处理器的状态 开始新的上下文：相反的操作过程 可能触发进程的上下文切换 过程调用： 调用者或者被调用者保存部分上下文 5.线程 VS 过程 线程可能会乱序的恢复 不能用栈保存状态 每一个线程都有自己的栈 线程切换不会太频繁 不会划分寄存器 线程有“自己”的CPU 线程可以是异步的 过程可以利用编译器异步地保存状态 线程可以异步的运行 多线程 多线程可以并行的在多个CPU上运行 过程调用是线性的 6.线程的分类 用户线程：由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等 内核线程：由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理 轻量级进程：内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持 用户线程和内核线程的关系： 一对一：每一个用户级线程都拥有自己的内核栈 多对一：一个进程的所有线程共享同一个内核栈 不同映射关系的对比： 总结 进程：应用并发性的抽象 线程：应用内部并发性的抽象 非抢占式调度与抢占式调度 7.非抢占式线程 宏内核结构： 内核拥有自己的地址空间，并与所有的进程共享 内核包含： 引导加载程序 BIOS 核心驱动 线程 调度器 调度器： 使用就绪队列来存放所有的就绪线程 线程上下文切换在相同的地址空间进行调度 进程上下文切换在新的地址空间进行调度 非抢占式调度状态转换图： 非抢占式调度器： 非抢占式调度器的启动： block() yield() 最简单的形式（调度器）： 保存当前进程/线程状态 选择下一个待运行的进程/线程 分派（加载并跳转到相应PCB/TCB） 保存线程上下文： 在线程的栈上保存上下文： 许多处理器有专门的指令来高效的保存上下文 但是，需要处理溢出的问题 保存前需要检查： 确保栈上没有溢出的问题 把上下文保存到TCB中 效率不是很高，但是没有溢出的问题 8.抢占式线程 通过中断进行抢占 为什么要抢占： 利用时钟中断进行CPU管理 异步I/O和计算交叠在一起 中断： 发生在指令之间 发生在一条指令执行期间（非原子指令） 操纵中断 关闭中断 开启中断 Non-Masking Interrupts (NMI) 抢占式调度的状态转换图： 抢占式调度的中断处理： I/O中断处理： 保存当前进程/线程到它们的PCB/TCB 进行I/O 调用调度器 时间中断处理： 保存当前进程/线程到它们的PCB/TCB 关中断，增加计数器，检查当前状态是否处于用户态，如果是，则首先进入内核，然后进行中断处理，否则（处于内核态），直接返回（内核态不能被中断） 调用调度器 问题： 打开/关闭中断 确保在多处理器环境下也可以工作 抢占式调度面临的问题： 问题： 中断随时随地都可能发生 简单方法：时刻关注是否发生中断或抢占 目标： 不要时刻关注抢占和中断 底层行为被封装在“原语”中 同步“原语“关注抢占 OS和应用使用同步原语 9.用户线程 VS 内核线程 用户级线程： 用户级线程库实现线程上下文切换 时间中断会引入抢占 当用户级线程被I/O阻塞时，整个进程都会被阻塞 内核级线程： 内核级线程被内核调度器调度 由于跨域了保护边界，内核级线程的上下文切换开销远大于用户级线程 混合：有可能实现一个混合的调度器，但是会很复杂 总结： 非抢占式线程： 调度器 上下文保存的位置 抢占式线程： 中断随时都可能发生 用户线程 VS 内核线程： 主要的区别是所选择的调度器 CPU调度 1.调度器工作： 保存当前进程/线程状态（PCB/TCB） 选择下一个待运行的进程/线程 分派（加载并跳转到相应PCB/TCB） 2.何时调度？ 进程/线程创建 进程/线程退出 I/O阻塞、同步 I/O中断 时间中断 3.调度准则 假设： 一个用户运行一个程序，一个程序创建一个线程 程序之间是独立的 批处理和实时交互系统设计目标： 保证公平性 每个作业都有机会运行，没有人会“饥饿” 最大化CPU资源利用率 最大化吞吐率：最小化开销，最大化资源利用率 最小化周转时间 批处理作业：执行时间（从提交到完成） 缩短响应时间 交互式作业：响应时间 均衡性：满足用户需求 4.先到先服务（FCFS）算法 一直运行到结束（过去） 一直运行到阻塞或主动放弃CPU 用于非抢占式调度 优点： 实现简单 缺点： 平均响应时间波动大 I/O资源和CPU资源的利用率较低 5.最短时间优先（STCF) 非抢占式调度 6.最短剩余时间优先（SRTCF) 选择就绪队列中剩余时间最短进程占用CPU进入运行状态 就绪队列按剩余时间来排序 优点： 平均响应时间短 缺点： 可能会造成饥饿：连续的短进程流会使长进程无法获得CPU资源 需要预知未来 7.时间片轮转算法（RR） 和FCFS算法类似，但是增加了时间片 时间片结束时，调度器按FCFS算法切换到下一个就绪进程 轮转调度是抢占式调度 时间片长度选择： 大时间片： 等待时间过长 极端情况下退化为FCFS 小时间片： 响应时间快 产生大量上下文切换，影像系统吞吐 经验规则：选择一个合适的时间片，使上下文切换开销处于1%以内 8.虚拟轮转算法（VRR） 引入辅助队列FIFO（先入先出） I/O密集型进程会进入辅助队列而不是就绪队列以备调度 引入优先级：辅助队列比就绪队列有更高的优先级 9.多级队列（MQ）与优先级 将就绪队列分为多个独立的子队列，每个队列可有自己的调度算法：前台RR，后台FCFS 队列之间 每个队列分配一个优先级和相应时间片 队列间按照时间片调度 10.多级反馈队列（MLFQ）算法 进程可在不同队列中移动的多级队列算法 特征： 时间片大小由优先级级别增加而增加 进程在当前的时间片没有完成，则降到下一个优先级 CPU密集型进程的优先级下降很快，I/O密集型进程停留在高优先级 11.彩票调度 动机：SRTCF可以保证平均响应延迟，但是不公平 彩票方法： 给每个作业一定数量的彩票 随机抽取一张中奖彩票（运行相应进程） 为了近似SRTCF，给短作业更多的彩票 为了避免“饥饿”，给每个作业至少一张彩票 相互合作的进程可以交换彩票 12.公平共享调度（FSS） FSS控制用户对系统资源的访问 一些用户组比其他用户组更重要 保证不重要的组无法垄断资源 未使用的资源按比例分配 没有达到资源使用率目标的组获得更高的优先级 13.调度算法总结 先到先服务调度算法：不公平，平均响应时间差 最短时间优先调度算法： 不公平，平均响应时间短 需要预测未来 可能导致饥饿 时间片轮转调度算法：公平，平均响应时间较差 虚拟轮转算法：公平，平均响应时间短 多级反馈队列算法：集成多种调度算法 彩票调度算法：公平，平均响应时间好 公平共享调度算法：公平第一位 14.多处理器/集群调度 设计 问题：进程/线程到处理器分配 协同调度： 一个进程的多个线程共同运行 一个应用的多个进程共同运行 专用的处理器分配：线程会在一个专用的处理器上运行直到完成 15.实时调度 两种类似的实时： 硬实时：必须满足，否则会导致错误 软实时：大多时候满足，没有强制性 接纳控制： 只有当系统能够保证所有进程的实时性的前提下，新的实时进程才会被接纳 如果满足下面的条件，作业就是可调度的： $$\\sum\\frac{C_I}{T_i} \\le 1$$，其中，$C_i=$计算时间，$T_i=$周期 16.速率单调调度 假设： 每个进程必须在其周期内完成 进程之间没有依赖关系 每个进程在每个周期内需要的CPU时间相同 非周期性进程没有截止日期 进程抢占瞬间发生（没有开销） 基本思想： 给每个进程分配一个固定的优先级=出现频率 运行最高优先级的进程 证明是最优的 17.最早最终时速优先调度（EDS） 假设： 当进程需要CPU时间时，它会宣布其最终时限 不一定是周期性进程 需要的CPU时间可以变化 EDS的基本思想： 根据最终时限对就绪的进程进行排序 运行列表中的第一个进程（最早最终时限优先） 当新的进程就绪时，并且其最终时限快来临时，它会抢占当前进程 18.BSD多队列调度 “一秒钟”抢占：进程如果在一秒内没有阻塞或者完成，就会被抢占 优先级每秒重新计算 19.Linux中的调度 分时共享调度： 每个进程都会有优先级和Credits I/O事件会提升优先级 拥有最多Credits的进程会优先运行 时间中断会减少进程的Credits 如果所有进程的Credits都耗尽了，内核会重新给进程分配：Credits = Credits / 2 + Priority 实时调度： 软实时 内核不会被用户代码抢占 20.Windows中的调度 分类和优先级 优先级驱动的调度器 多处理器调度 调度前沿扩展 NUMA调度 分布式调度 虚拟机调度 Chapter03 同步与通信 临界区与原子操作 1.同步与通信的概念 通信的两大作用： 并发进程/线程之间需要进行信息同步和数据传输 信息同步： 保障多进程/多线程正确的使用共享资源 共享资源可以是： 一个变量 一块缓冲区 一个文件 一个设备等 数据传输： 便于将单个任务切分、模块化提高并发度 2.临界区 临界区：进程中访问临界资源的一段需要互斥执行的代码 进入临界区： 检查可否进入临界区的一段代码 如可进入，设置相应“正在访问临界区”的标志 退出临界区：清除“正在访问临界区”标志 3.原子操作 原子操作是指一次不存在任何中断或失败的操作 要么操作成功完成 或者操作没有执行 不会出现部分执行的状态 对临界区的操作必须是原子操作 操作系统需要利用同步机制在并发执行的同时，保证一些操作是原子操作 同步机制设计 识别出共享资源与使用者 设计合适的同步机制 验证临界区是否符合原子操作 4.临界区的保障 基于软件 硬件中断 原子操作指令与互斥锁 基于软件的方法 线程可通过共享一些共有变量来同步它们的行为 Peterson算法：满足线程Ti和Tj之间互斥的经典的基于软件的解决办法： 共享变量： 12 int turn;//表示该谁进入临界区bool flag[];//表示进程是否准备好进入临界区 进入区代码： 123 flag[i] = true;turn = j;while(flag[j] &amp;&amp; turn = j) 退出区代码： 1 flag[i] = false; Dekkers算法 缺点： 复杂：需要两个进程/线程之间的共享数据项 需要“忙等待”：浪费CPU时间 禁用中断实现互斥 使用中断： 实现抢占式CPU调度 通过在acquire和release之间禁止上下文切换来提供互斥 两种类型的事件能引起切换： 内部事件：放弃CPU控制权 外部事件：使得CPU重新调度 禁用中断以屏蔽外部事件： 引入不可中断的代码区域 大多数时候用串行思维 延迟处理外部事件 缺点： 禁用中断后，进程无法被停止： 整个系统都会为此停下来 可能导致其他进程处于“饥饿”状态 临界区可能很长：无法确定响应中断所需要的时间（可能存在硬件影响） 原子操作指令 现代CPU都提供一些特殊的原子操作指令 测试和置位（TAS/TS）指令： 从内存单元中读取值 测试该值是否为1，然后返回真或假 内存单元值设置为1 12345 bool TestAndSet(bool *Target)&#123; bool rv = *Target; *Target = true; return rv;&#125; 交换指令： 交换寄存器与内存： 12345 void Exchange(bool *a, bool *b)&#123; bool tmp = *a; *a = *b; *b = tmp;&#125; Fetch-and-Add或Fetch-and-Op： 用于大型共享内存多处理器系统的原子指令 Load Linked 和Conditional Store（LL - SC）： 在一条指令中读一个值（LL） 做一些操作 Store时，检查LL之后，值是否被修改过。如果没有，则OK，否则，从头再来 使用TAS指令实现锁 忙等待： 12345678910111213 class Lock&#123; int value = 0;&#125;Lock::Acquire()&#123; //如果锁被释放，TAS读取0并将值设置为1：锁被设置为忙并且需要等待完成 //如果锁处于忙状态，TAS指令读取1并将值设置为1：不改变锁的状态并且需要循环 //返回值为之前的值 while (test-and-set(value)) ;&#125;Lock::Release()&#123; value = 0;&#125; 无忙等待： 123456789101112131415 class Lock&#123; int value = 0; WaitQueue q;&#125;Lock::Acquire()&#123; while (test-and-set(value))&#123; add this TCB to wait queue q; schedule(); &#125;&#125;Lock::Release()&#123; value = 0; remove one thread t from q; wakeup(t);&#125; 优点： 适用于单处理器或者共享主存的多处理器中任意数量的进程同步 简单并且容易证明 支持多临界区 缺点： 忙等待消耗处理器时间 可能导致饥饿：进程离开临界区时有多个等待进程的情况 死锁： 拥有临界区的低优先级进程 请求访问临界区的高优先级进程获得处理器并等待临界区 总结 软件方法：实现复杂 中断： 有很多问题 实现之后，只能用于单核处理器 原子操作指令与锁： 大多数时间在用户层自旋 线程数比处理器数目多 死锁 1.一些定义 进程和线程等价 资源： 可抢占：CPU（可以被夺取） 不可抢占：磁盘，文件，互斥锁… 使用资源：请求，使用，释放 饥饿：进程无限等待 死锁：如果一个进程集合中所有进程都在等待一个事件，且等待的事件只能由集合中其他进程触发，则称该进程集合死锁 2.死锁发生的条件 互斥： 所有资源都被分配给恰好一个进程 占有和等待： 持有资源的进程可以请求新的资源 不可抢占： 资源不可被夺走 环路等待： 进程以环路的方式进行等待 3.策略 忽略问题：是用户的错 检查并恢复：事后修复问题 动态避免：小心的分配资源 预防：破坏四个条件中的一个 4.忽略问题：鸵鸟算法 操作系统内核死锁： 重启 设备驱动死锁： 卸载设备 重启 应用程序挂起： 杀死并重启程序 应用程序运行一段时候后挂起： 给程序设定一个checkpoint 改变运行环境（重启操作系统） 从上一个checkpoint重新开始 5.检测和恢复 检测： 扫描资源分配图 发现圈 恢复（很困难） 杀死进程/线程 回滚死锁线程的操作 6.避免 安全状态： 未发生死锁 存在一个调度方案，使得所有进程能够完成（即使所有进程同时请求最大资源） 银行家算法： 单个资源： 每个进程有一个贷款额度 总的资源可能不能满足所有的贷款额度 跟踪分配的和仍然需要的资源 每次分配时检查安全性 多个资源： 两个矩阵：已分配和仍然需要 7.银行家算法 数据结构： n: 线程数量，m: 资源类型数量 Available（剩余空闲量）：长度为 m 的向量 当前有Available[j]个类型Rj的资源实例可用 Allocation（已分配量）: n x m 矩阵 线程 Ti 当前分配了 Allocation[i, j] 个 Rj 的实例 Need（未来需要量）：n x m 矩阵 线程 Ti 未来需要 Need[i, j] 个 Rj 资源实例 Need[i, j] = Max[i, j] - Allocation[i, j] 算法描述： 初始化： Ri 是线程 Ti 的资源请求向量 Ri[j] 是线程 Ti 请求 Rj 的实例 循环：依次处理线程 Ti, i = 1, 2, 3, … 如果 Ri &lt;= Need[i] ，转到 2，否则，拒绝资源申请，因为线程已经超过了其最大要求 如果 Ri &lt;= Available ，转到 3，否则，Ti 必须等待，因为资源不可用 通过安全状态判断来确定是否分配资源给 Ti ： 首先生成一个需要判断状态是否安全的资源分配环境： 123 Available = Available - Ri;Allocation[i] = Allocation[i] + Ri;Need[i] = Need[i] - Ri; 调用安全状态判断：如果返回是安全，将资源分配给 Ti，如果返回结果是不安全，系统会拒绝 Ti 的资源请求 8.预防 避免互斥： 有些资源物理上不可共享：打印机，磁带等 有些可设计成共享：只读文件，内存等，读写锁 有些可以通过假脱机进行虚拟化： 使用存储，将一个资源虚拟化成多个资源 使用队列进行调度 避免占有和等待： 两阶段加锁： 阶段 I：试图对所有所需的资源加锁 阶段 II：如果成功，使用资源，然后释放资源；否则，释放所有的资源，并从头开始 应用：电信公司的电路交换 允许抢占： 使调度器了解资源分配情况 方法： 如果系统无法满足一个已占有资源的进程的请求，抢占该进程并释放所有的资源 只在系统能满足所有资源时进行调度 其他方法：抢占占有被请求的资源的进程 避免环路等待： 对所有资源制定请求顺序 方法： 对每个资源分配唯一的 id 所有请求必须按 id 升序提出 变种： 对每个资源分配唯一的 id 进程不能请求比当前所占有的资源编号低的资源 9.权衡和应用 对应用程序忽略问题： 处理死锁是应用开发者的问题 OS 提供打破应用程序死锁的机制 内核不应该出现死锁： 使用预防方法 最流行的做法是在所有地方使用避免环路等待原则 信号量、管程与条件变量 1.信号量 信号量是操作系统提供的一种协调共享资源访问的方法 信号量的组成： 一个整形变量：表示系统资源的数量 两个原子操作： P 操作（又称 Down 或 Wait）：等待信号量为正，然后将信号量减一 123456 P(s)&#123; while(s &lt;= 0)&#123; ; &#125; --s;&#125; V 操作（又称 Up 或 Signal）：将信号量加一 123 V(s)&#123; ++s;&#125; 信号量的实现： 123456789101112131415161718 class Semaphore&#123; int sem; WaitQueue q;&#125;;Semaphore::P()&#123; --sem; if (sem &lt; 0)&#123; Add this thread t to q; block(p); &#125;&#125;Semphore::V()&#123; ++sem; if (sem &lt;= 0)&#123; Remove one thread t from q; wakeup(t); &#125;&#125; 信号量的使用： 互斥访问：保护临界区互斥访问，Semaphore(1) 条件同步：多线程之间同步，Semaphore(N &gt;= 0) 用信号量实现有限缓冲区 问题描述： 一个或多个生产者在生成数据后放在一个缓冲区里 单个消费者从缓冲区中取出数据处理 任何时刻只能有一个生产者或消费者可访问缓冲区 问题分析： 互斥访问：任何时候只能有一个线程操作缓冲区 条件同步：缓冲区空时，消费者必须等待生产者；缓冲区满时，生产者必须等待消费者 实现： 12345678910111213141516171819 class BoundedBuffer&#123; mutex = new Semaphore(1); fullBuffers = new Semaphore(0); emptyBuffers = new Semaphore(n);&#125;;BoundedBuffer::Deposit(c)&#123; emptyBuffers-&gt;P(); mutex-&gt;P(); Add c to the buffer; mutex-&gt;V(); fullBuffers-&gt;V();&#125;BoundedBuffer::Remove(c)&#123; fullBuffers-&gt;P(); mutex-&gt;P(); Remove c from buffer; mutex-&gt;V(); emptyBuffers-&gt;V();&#125; 2.管程 管程是一种用于多线程互斥访问共享资源的程序结构 采用面向对象方法，简化了线程间的同步控制 任意时刻最多只有一个线程执行管程代码 正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复 管程的组成： 一个锁：控制管程代码的互斥访问 0 个或多个条件变量：管理共享数据的并发访问 条件变量 条件变量是管程内的等待机制，每个条件变量表示一种等待原因，对应一个等待队列 Wait()操作： 将自己阻塞在等待队列中 唤醒一个等待者或释放管程中的互斥访问 Signal()操作： 将等待队列中的一个线程唤醒 如果等待队列为空，则等同空操作 条件变量额实现： 123456789101112131415161718 class Condition&#123; int numWaiting = 0; WaitQueue q;&#125;;Condition::Wait(Lock)&#123; ++numWaiting; Add this thread t to q; release(Lock); schedule(); acquire(Lock);&#125;Condition::Signal()&#123; if (numWaiting &gt; 0)&#123; Remove one thread t from q; wakeup(t); --numWaiting; &#125;&#125; 用管程实现生产者-消费者问题 12345678910111213141516171819202122232425 class BoundedBuffer&#123; Lock lock; int count = 0; Condition notFull, notEmpty;&#125;;BoundedBuffer::Deposit(c)&#123; lock-&gt;Acquire(); while (count == n)&#123; notFull.Wait(&amp;lock); &#125; Add c to the buffer; ++count; notEmpty.Signal(); lock-&gt;Release();&#125;BoundedBuffer::Remove(c)&#123; lock-&gt;Acquire(); while (count == 0)&#123; notEmpty.Wait(); &#125; Remove c from buffer; --count; notFull.Signal(); lock-&gt;Release();&#125; Signal之后的选择 让被唤醒的线程立刻执行，并挂起发送方（Hoare) 如果发送方有其他工作要做，会很麻烦 很难确定没有其他工作要做，因为 Signal 的实现并不知道它是如何被使用的 退出管程（Hansen)：Signal 必须是管程中的过程的最后一个语句 继续执行(Mesa) 易于实现 然后，被唤醒的进程实际执行时，条件可能不为真 3.Mesa风格管程 将条件变量与一个互斥量关联 Wait(mutex, condition)： 原子解锁 mutex，并加入 condition 对应的队列（阻塞该线程） 被唤醒时，重新锁定（mutex） Signal(condition)： 当没有线程阻塞于该条件变量时，什么也不做 如果有被阻塞的线程，唤醒至少一个 Broadcast：唤醒所有等待的线程 4.屏障原语 功能： 指定一个屏障变量 广播给其他 n - 1 个线程 若屏障变量的值达到 n，则继续 在某些并行计算机上，有硬件支持： 多播网络 计数逻辑 用户级屏障变量 5.等价性 信号量： 适合发送信号 不适合实现 mutex，因为容易引入 bug 管程： 适合调度和 mutex 用作发送信号时，开销可能会比较大 操作系统提供的同步机制总结 进程间通信 1.基本概念 进程间通信（IPC, Inter-Process Communication） 不同进程间进行通信和同步的机制 两个原语： Send(message) Receive(message) 进程通信流程： 建立通信链路 Send/Recv交换数据 2.消息队列 消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制 每个消息（Message）是一个字节序列 相同标识的消息按照先进先出顺序组成一个消息队列 消息队列的系统调用： msgget(key, flags) ：获取消息队列标识 msgsnd(QID, buf, size, flags)：发送消息 msgrcv(QID, buf, size, type, flags)：接收消息 msgctl(...)：消息队列控制 3.共享内存 共享内存是操作系统把同一个物理区域同时映射到多个进程的内存地址空间的通信机制 每个进程将共享内存区域映射到私有地址空间 优点：快速、方便的共享数据 缺点：必须用额外的同步机制来协调数据访问 共享内存系统调用： shmget(key, size, flags)：创建共享段 shmat(shmid, *shmaddr, flags)：把共享段映射到进程地址空间 shmdt(*shmaddr)：取消共享段到进程地址空间的映射 shmctl(...)：共享段控制 需要信号量等机制协调共享内存的访问冲突 4.管道 进程间基于内存文件的通信机制 子进程从父进程继承文件描述符 默认文件描述符：0 为stdin，1为stdout，2为stderr 进程不知道的另一端 可能从键盘，文件，程序读取 可能写入到终端，文件，程序 管道示例 与管道相关的系统调用： 读管道：read(fd, buffer, nbytes) C语言中的scanf()是基于它实现的 写管道：write(fd, buffer, nbytes) C语言中的printf()是基于它实现的 创建管道：pipe(rgfd) rgfd 是 2 个文件描述符组成的数组 rgfd[0] 是读文件描述符 rgfd[1] 是写文件描述符 5.信号 进程间的软件中断通知和处理机制，如 SIGKILL, SIGSTOP, SIGCONT等 信号的接收处理： 捕获：执行进程指定的信号处理函数被调用 忽略：执行操作系统指定的缺省处理，例如进程终止，进程挂起等 屏蔽：禁止进程接收和处理信号（可能是暂时的） 不足：传递的信息量少，只有一个信号类型 信号的实现： 6.缓冲消息 无缓存： 发送方必须等待接收方接收消息 每个消息都要握手 有界缓冲： 缓冲区长度有限 缓冲区满则发送阻塞 使用一个管程 无界缓冲： “无限”长度 发送方永远不阻塞 7.直接通信 只有接收端有缓冲： 多个进程可能向接收方发送消息 从特定的进程接收消息需要遍历整个缓冲区 每个发送者有一个缓冲区： 每个发送者发送给多个接收者 获取消息仍需要遍历缓冲区 8.间接通信 使用信箱： 允许多对多通信 需要打开/关闭信箱 缓冲：在信箱需要有一个缓冲区以及互斥锁和条件变量 消息长度：不确定，可以把大消息切成多个包 信箱和管道对比： 信箱允许多对多通信 管道隐含一个发送一个接收 9.同步和异步 同步： 发送： 如果资源忙则阻塞 启动数据传输 直到源缓冲用完后在阻塞 接收：如果有消息则返回数据 异步： 发送： 如果资源忙则阻塞 启动数据传输并且立即返回 结束： 需要应用检查状态 通知或者向应用发信号 接收： 如果有消息则返回数据 如果无消息则返回状态 10.例外 进程结束： R等待S发来的消息但S已经结束：R会永久阻塞 S发送了一个消息给R，但R已经结束：S没有缓冲，永久阻塞 消息丢失： 使用确认（ack）和超时检测（timeout）和重传消息： 需要接收者每收到一个消息发送一个确认 发送者阻塞知道ack到达或者超时 status = send(dest, msg, timeout) 如果超时发生且没收到确认，重发消息 问题： 重复 丢失确认消息 重传必须处理： 在接收端消息重复 发送端确认乱序 重传： 使用序列号确认是否重复 在接收端删掉重复消息 发送端收到乱序确认时重传 减少确认消息： 批量传送确认 接收者发送no ack 消息损坏： 检测： 发送端计算整个消息的校验并随消息发送校验和 在接收端重新计算校验和并和消息中的校验和对比 纠正： 重传 使用纠错码恢复 Chapter04 虚存管理 虚存和地址转换 1.现有计算机体系结构 冯诺依曼结构 层次化存储结构 内存DRAM：快，但贵，容量小，易失性 外存磁盘：持久化，便宜，容量大，但慢 2.最简单的系统 只有物理内存：应用程序直接使用物理内存 物理内存静态划分 3.进程保护 一个进程出错不能影响其他进程 对每次内存访问都进行检查，只允许合法的内存访问 4.扩展内存和应用透明 一个进程必须能运行在不同的物理内存区域上 一个进程必须能运行在不同的物理内存大小上 5.问题 如何高效使用内存空间？ 同时运行多个进程：系统运行的进程越多越好 保护： 一个用户进程不能读取，更不能修改另一个用户进程的内存 用户进程不能破坏内核的内存 基本内存抽象： 地址空间：进程的内存视图 -&gt; 虚拟视图 透明、高效、安全保护 6.虚拟内存 独立的进程地址空间： 给每个进程一个很大的、静态的虚拟地址空间 虚实地址转换/映射： 当一个进程运行时，每次访存通过地址转换获得实际的物理内存地址 磁盘作为内存的延展（磁盘交换区） 只装载部分地址空间至内存 地址空间 独立的进程地址空间：[0, max - 1]，程序员看到的是虚地址 运行时装载部分地址空间 每次访存：虚地址 -&gt; 物理地址 CPU看到的是虚地址 进程看到的是虚地址 内存与 I/O 设备看到的是物理地址 如果访问到未装载的地址空间：通知OS将它加载进内存空间 虚存的好处 灵活：进程在执行时才放进内存，一部分在内存，另一部分在磁盘 简单：进程的内存访问变得非常简单 高效： 20/80原则：20%的内存承担80%的访问 将20%放进物理内存 7.地址映射 目标： 隐式：对于每个内存访问，转换是隐式的 快速：命中内存时，必须非常快 例外：不命中时触发一个例外 保护：对用户进程的错误进行保护 基址 + 长度：（Cray-1 采用的方法） 连续分配： 为每个进程分配地址连续的内存 用一个二元组来限定其内存区域： 保护：一个进程只能访问[base, base + bound]区间的内存 上下文切换：保存/恢复基址寄存器以及上限寄存器 好处： 简单：重定位时将虚地址和基址相加 支持换出：多进程并发执行 缺点： 外部碎片：随着进程的换入换出，内存产生很多空洞 难以支持进程增大 难以共享内存 8.地址转换实现 早期基于软件的静态地址转换： 针对每个启动的进程，特权软件loader重写其实际物理地址，即将其虚地址转换为物理地址 没有内存保护，无效地址和恶意地址也会被转换 操作系统职责负责虚地址到物理地址转换的硬件单元 内存管理：新进程分配空间，结束的进程回收空间 进程切换时base-bound的管理：保存当前进程的base-bound值，设置即将运行的进程的base-bound值 异常处理：内存越界访问，无效地址等 MMU 负责虚地址到物理地址转换的硬件单元 通常在片内实现，每个CPU有一个base寄存器和一个register寄存器 虚存地址转换为物理地址，每条load和store指令都需要地址转换 内存保护，检查地址是否有效 特殊指令操作base和bound寄存器 CPU发出的是虚地址，内存和I/O设备接收的是物理地址 9.分段 段间不连续分配： 把程序逻辑上划分为若干段：代码、栈、堆 每个段分配连续内存，段间不必连续 每个进程有一张段表：（seg, size） 每个段采用基址 + 长度 如果访问地址的offset &gt;= 段size，则memory violation 如果访问地址所在的seg的valid为0，则segment fault 保护：每个段有（nil, read, write, exec） 上下文切换：保存/恢复段表和指向段表的内核指针 好处：高效，易共享 不足：管理复杂，外部碎片（段间碎片） 10.分页 使用固定大小的映射单元 把虚存划分为固定大小的单元（称为页，page） 把物理内存划分为同样大小的单元（称为页框，page frame） 按需加载 页表： 记录 虚页 -&gt; 物理页的映射 每个进程一个页表 每个表项有若干个控制位：按页保护（read, write, exe） 上下文切换：与分段类似，保存/恢复页表地址 好处：分配简单，易共享 不足：页表很大，进程地址空间有很多空洞，对应的页表项无用 分段 VS 分页 11.页表项 表达一个映射关系：虚页号 -&gt; 物理页 控制位： P：标识该页在内存（Present）或不在内存（Absent） R/W：read, write, exe U/S：user/supervisor，标识用户态进程是否可以访问 A：标识该页是否被访问 D：标识该页是否为脏 G, PAT, PCD, PWT：标识Cache工作方式 页表项（PTE）的数目 假设4KB的页，低12位为页内偏移 32位地址的机器： 每个进程的页表有$2^{20}$个页表项（~ 4MB） 页表所需内存空间 = 进程数量 X $2^{20}$ 如果有10K个进程，内存放不下所有的页表 64位地址的机器： 每个进程的页表有$2^{52}$个页表项 页表所需内存空间 = 进程数量 X $2^{52}$ 一个进程的页表可能磁盘都存不下 12.分段 + 分页 先将进程划分为若干段 每个段采用分页 段表记录它的页表地址 13.多级页表 虚地址除去offset的部分划分为多个段 每段对应一级页表 多个页表 例：二级页表 每个页表4KB，1024个表项 下级页表每一项映射一页（4KB） 上级页表的每一项映射4MB的地址空间 对于大地址空间，大部分程序只需要几个页表 14.反向页表 按物理页索引，记录每个物理页对应的进程ID及虚页 主要思想： 每个物理页一个PTE 地址转换：哈希查找，Hash(Vpage, pid) -&gt; Ppage# 好处： 页表大小与地址空间大小无关，只与物理内存大小有关 对于大地址空间，页表较小 坏处：查找难，管理哈希链等的开销 15.TLB 加速地址转换： 程序只知道虚地址：每个程序或进程的地址空间是[0, Max - 1] 每个虚地址必须进行转换： 可能需要逐级查找多级页表 页表保存在内存中，一个内存访问变成多个内存访问 解决办法：将使用最多的那部分页表项缓存在更快速的存储器中 TLB硬件 所有表项同时查找，速度快 TLB表项的格式 共有（必须的）的位： VP#（虚页号）：与虚地址进行匹配 PP#（物理页号）：转换后的实际地址 Valid位：标识此表项是否有效 访问控制位：允许用户/内核访问，以及何种访问（nil, read, write） 可选的位 进程标签（pid） 访问控制位（R位） 修改标识位（W） 允许缓存否 硬件控制的TLB CPU把一个虚地址VA给MMU进行转换 MMU先查TLB，VA = VP# || offset，将该虚页号同时与TLB中所有表项相比较 TLB hit（命中）：TLB中找到含VP#的表项 如果有效（TLB的valid位为1），取表项中的物理页号 如果无效，则等同于TLB miss 如果TLB miss（不命中）：TLB中没有含VP#的表项 MMU硬件在页表中进行查找，得到PTE 将找到的PTE加载进TLB（如果没有空闲表项，替换一个TLB表项） 并取TLB表项中的物理页号 软件控制的TLB CPU把一个虚地址vaddr给MMU进行转换 MMU先查TLB，vaddr = vpage# || offset，将该虚页号同时与TLB中所有表项进行比较 TLB hit：TLB中找到含vpage#的表项 如果有效，取表项中的物理页号 如果无效，则等同于TLB miss 如果TLB不命中：产生TLB fault 进入内核异常处理程序（软件） 如果没有空闲TLB表项，则替换一个TLB表项 在页表中进行查找，得到PTE 将该PTE加载进TLB 重新执行发生TLB不命中的指令 硬件控制 VS 软件控制 硬件控制： 高效 不灵活 需要更多的空间来保存页表 软件控制： 大大简化了MMU的逻辑，使得CPU芯片上更多的面积用于缓存 灵活 能够处理大的虚地址空间：软件可以使用反向页表，进行哈希映射 16.缓存 VS TLB 相似之处：缓存一部分内存，不命中时替换 不同之处：关联度，一致性：PTE修改 17.TLB设计问题 替换哪个TLB表项：随机或伪LRU 上下文切换时需要做什么： 有进程标签：修改TLB寄存器和进程寄存器的内容 无进程标签：作废整个TLB内容 修改一个页表项时需要做什么： 修改内存中的PTE 将对应的TLB表项置为无效（TLB flush） 减少TLB不命中的开销： 增大TLB：很小的TLB，很好的TLB命中率 不能太大，CPU的面积有限 基于预测的preload 页表缓存：缓存包含TLB表项的页表所在页，由软件管理 一致性问题 缓存：“侦听”协议 维护DRAM的一致性，即使在有DMA的情况下 TLB与DRAM之间的一致性：任何时候修改一个页表项都需要TLB flush TLB “shut down” 在共享内存的多处理器上，有些内存页面同时被多个处理器访问 内核页面、多个进程共享的用户页面，多线程被调度到不同的处理器上 一个处理器修改一个页表项，需要所有处理器都TLB flush 在TLB flush期间，所有处理器都不响应中断 18.总结 虚拟内存：虚拟化使得软件开发变得容易，而且内存资源利用率高 进程地址空间：分离地址空间能够提供保护和错误隔离 地址转换： 虚地址与物理地址 MMU TLB 加速地址转换的专门硬件 但引入一致性问题 地址映射： 基址 + 长度：简单，但有很大的局限性 分段：有用，但太复杂 分页：页与页框，页表与PTE 大页表优化：分段 + 分页，多级页表，反向页表 页替换 1.进程加载 简单办法：将整个进程加载进内存 -&gt; 运行 -&gt; 退出 慢（对于大进程） 浪费空间（一个进程并不是时刻都需要所有的内存） 解决办法： 按需加载页：只将实际使用的页加载进内存 换页：内存中只放频繁使用的那些页 机制：一部分虚存映射到内存，一部分虚存映射到磁盘 2.换页步骤 内存访问（可能导致TLB不命中） 若TLB不命中，进行页表查找，得到PTE 若PTE的valid位 = 0（页不在内存），触发缺页（Page Fault） 虚存管理中的缺页处理接管控制，将页从磁盘读到内存 更新PTE：填入pp#，将valid位置为1 把PTE加载进TLB 重新执行该指令：重新进行内存访问 换页 缺页可能发生在一条指令执行的中途 应用程序透明：必须让用户程序不感知缺页 需要保存状态并从断点处继续执行 页替换 需要的页不在内存里 -&gt; 需换入 -&gt; 需为它分配一个页框 可能此时没有空闲页框 VM需要进行页替换 3.缺页处理 进程A发生缺页，发生缺页的页记为VP 陷入内核，保存进程A的当前状态：PC，寄存器 调用OS的缺页处理程序： 检查地址和操作类型的合法性，不合法，则给进程A发signal或者kill 为VP分配一个物理页框，记为PP: 如果有空闲页框PP1，则用它，PP = PP1 如果没有空闲页框，选择一个状态为used页框PP2 如果它是脏的（M位 = 1），则把它写回磁盘 PTE表项valid位置为0，flush TLB表项 写回完成后，PP = PP2 找到VP对应的磁盘页，把它读到这个页框（PP）中 修改VP的PTE：填入PP#，将valid位置为1，并把该PTE加载进TLB 恢复进程A的状态，重新执行发生缺页的指令 替换算法 1.最优算法（MIN） 算法：替换在未来最长一段时间里不用的页 前提：知道未来所有的访问 好处：最优方案，可作为一种离线分析手段 坏处： 在线系统无法采用，因为不知道未来的访问顺序 没有线性时间复杂度的实现 TLB和页表 用于换页的位： R位：访问标志位，当访问该页中的某个位置时置位 M位：修改标志位，当对该页中某个位置进行写时置位 2.NRU（Not Recently Used） 算法：按下面顺序，随机选择一个页： 未访问过且未修改过 未访问过且修改过 访问过且未修改过 访问过且修改过 好处：可实现 坏处：需要扫描内存中所有页的R位和M位 3.FIFO 算法：选择最老的页换掉 好处：开销最小 坏处：频繁使用的页被替换 4.有第二次机会的FIFO 核心思想： 尽量让频繁使用的页留在内存，不被替换 替换时给访问过的页第二次机会，在内存中呆更长时间 算法： 检查最老页的R位，如果为0，替换它 如果为1，将它清0，并把它移到队尾，继续查找 好处：实现简单 坏处：最坏情况时可能需要很长时间 5.Clock 改进Second Chance在替换时移动页的开销 算法：把所有页框组织成环形链表 用一个表针指向最老的页 发生缺页时，按表针走动方向来检查页 第二次机会： 如果R位为1，将其置为0，且表针向前移一格 如果R位为0，替换它 6.双表针的Clock算法 对Clock的替换加以控制 方法：增加一个表针 前表针扫描页，把R位清0 后表针扫描页，把R位为0的页加入替换页链表 扫描方向相同，扫描速度相同 替换控制 扫描速度： 控制替换速度 空闲内存多，扫描速度慢 空闲内存少，扫描速度快 表针间距： 页框再次被访问的时间窗口 控制页在内存里的最长停留时间 7.LRU 替换最长时间没有使用的页： 将所有页框组织成一个链表 前端为最久未访问的页（LRU端）：替换的页 后端为最近刚访问的页（MRU端）：新加载的页和命令的页 每次命中将页重新插入MRU端 好处：对MIN算法的很好近似 坏处：实现困难 8.近似LRU 记录每个页访问时间戳，替换时间戳最小的页 使用一个硬件计数器，每执行完一条指令，计数器加一 每一个内存访问，将当前计数器值作为时间戳，保存在该页的PTE中 替换时选择时间戳最小的页 坏处：开销太大，不可行 NFU：记录每个页的访问次数，替换访问次数最少的页： 每页有一个访问计数器，用软件模拟 每个时钟中断时，所有页的计数器分别与它的R位值相加 坏处：Never Forget，过去频繁访问，现在不访问的页，替换不出去 9.Aging 消除过去访问的影响 每个时钟中断时，先将所有页计数器右移一位，再将每页计数器最高位与该页的R位相加 替换时，选择计数器值最小的页 Aging与LRU的主要区别： 记录下来的历史更短 无法区分访问的先后顺序 10程序的行为 80/20原则： 80%的访问只涉及20%的内存空间 80%的访问来自20%的代码 空间局部性：相邻的页很可能会被访问 时间局部性：被访问的页很可能在不远的将来再被访问 11.工作集 主要思想： 工作集被定义为在最近K次访问的那些页 把工作集放进内存能大大的减少缺页 工作集的近似：一个进程在过去T秒钟里使用的页 一个算法：记录页的”上次访问时间“ 在缺页时，扫描该进程所有的页 如果R位为1，将该页的上次访问时间设置为当前时间 如果R位为0，计算当前时间与上次访问时间之差$\\Delta$ 如果$\\Delta &gt; T$，该页在过去T秒里没有访问过，则替换它 否则，检查下一页 将发生缺页的页加入工作集 12.WSClock 将页框组织成环形链表 按表针走动顺序来检查页 如果R位为1: 将R位置为0，该页的上次访问时间设置为当前时间 检查下一页 如果R位为0： $\\Delta = $ 当前时间 - 上次访问时间 如果$\\Delta \\le T$，该页在过去T秒里访问过，检查下一页 如果$\\Delta &gt; T$，该页在过去T秒里没有访问过，而且M位为1，将该页加入写回链表，并检查下一页 如果$\\Delta &gt; T$，该页在过去T秒里没有访问过，并且M位为0，替换该页 虚存设计 1.颠簸 频繁发生缺页，运行速度很慢 进程被阻塞，等待页从磁盘取进内存 原因： 进程的工作集 &gt; 可用的物理内存 进程过多，即使单个进程都小于内存 内存没有被很好的回收利用 哪些工作集放进内存 进程分为两组： 活跃组：工作集加载进内存 不活跃组：工作集不加载进内存 如何确定哪些进程是不活跃的 等待事件 等待资源 两个调度器 长期调度器决定： 哪些进程可以同时运行 哪些是不活跃的进程，把它们换出到磁盘 哪些是活跃的进程，把它们换入内存 短期调度器决定把CPU分配给哪个调度器 如何选择被替换的页 全局选择： 从所有进程的所有页框中选择 可替换其它进程的页框 局部选择：只从本进程的页框中选择 全局选择 VS 局部选择 全局选择： 从所有进程的所有页框中选择 可替换其他进程的页框 每个进程运行期间，其内存大小是动态变化的 好处：简单 坏处：没有隔离，受其它进程的页替换干扰，不能控制各个进程的内存使用量 局部选择： 只从本进程自己的页框中选择 一个进程运行期间，其内存大小是不变的 页框池：分配给进程的页框的集合，进程间池大小可不同 好处：隔离，不影响其它进程 坏处：不灵活，进程增大会出现颠簸，难以充分利用内存（每个进程对内存的需求不一样） 2.平衡分配 局部选择 + 池大小动态分配 每个进程有自己的页框池 从自己的池中分配页，且从自己的工作集中替换页 用一种机制来运行时动态调整每个池的大小 进程加载方式：进程换入时 纯粹的按需加载页 -&gt; 大量的page fault -&gt; 加载慢 预加载：先加载部分页 -&gt; 初始池大小 如果初始池大小 ~ 工作集 -&gt; 加载快，减少page fault开销 初始池大小： 固定分配：所有进程都一样 平均分配： 内存总量 / 当前运行态进程数量 进程大小差异很大 根据进程大小按比例分配： （进程大小 / 当前运行态进程的总大小）X 内存数量 当前运行的进程的总大小是变化的 动态调整池大小：进程大小变化 PFF算法 缺页率PFF：进程每秒产生多少次缺页 对于大多数替换策略，PFF随分配给进程的内存增加而减少 根据进程的PFF来调整分配给它的内存量 两个阀值A和B，A为上限，B为下限 当PFF高于A，就增加其内存 当PFF低于B，就减少其内存 3.钉住页（pin/lock） DMA进行过程中，需要传输的页不能被换出，否则CPU就会把新内容写入这些页 系统调用接口： pin：把虚页钉在内存，使它们不会被换出 unpin：取消pin，使它们可以被换出 如何设计： 用一个数据结构来记录所有被钉住的页 换页算法在替换页时检查该数据结构，如果页被钉住，则不替换它，重新选择一页 4.交换空间管理 交换区 后备存储 在磁盘上 专门用于存储进程换出页 交换分区：用专门的磁盘分区 交换文件：用一些文件 交换空间管理： 静态分配 动态分配 静态分配 创建进程时分配，进程结束时回收 大小：进程映像 进程控制表记录交换空间的磁盘地址 绑定：一个虚存页 &lt;–&gt; 一个磁盘页，磁盘页称为shadow page 初始化： 按需换入：进程映像拷贝到交换区 按需换出：进程映像加载进内存 缺点：难以增长 动态分配 创建进程时不分配 页换出时分配，页换入时回收 虚页与磁盘页不绑定，多次换出，分配不同的磁盘页 PTE中记录页的磁盘地址 一个优化：程序正文段 直接用磁盘中的可执行文件作为交换区 换出时直接抛弃 好处：减少了交换区的大小，减少了不必要的拷贝和写回 PTE 虚页 -&gt; 页框和磁盘 如果valid bit = 1，对应物理页号pp# 如果valid bit = 0，对应磁盘页号dp# 换出 将PTE和TLB置为无效 将页拷贝到磁盘 将磁盘页号填入PTE 换入 找一个空闲页框（可能触发替换） 将页从磁盘拷贝到这个页框中 将页框号填入PTE中，并将PTE置为有效 5.清零页 将页清零 把页置为全0 堆和栈的数据都需要初始化 对于数据段和栈段的页，当它们第一次发生page fault时，将它们清零 有一个专门的线程来做清零 6.共享页 两个进程的页表共享一些物理页 7.写时复制（copy on write） 该技术用于创建子进程（fork系统调用） 原理： 子进程的地址空间使用其父进程相同的映射 将所有的页置成read-only 将子进程置成ready 对于读，没有问题 对于写，产生page fault: 修改PTE，映射到一个新的物理页 将页内容全部拷贝到新物理页 重新运行发生缺页的指令 8.UNIX的地址空间 正文段：只读，大小不变 数据段： 初始化数据 未初始化数据：BSS brk区用于增长或缩小 栈段 内存映射文件 将一个文件映射进虚存 mmap和unmap 像访问内存一样访问文件 9.Linux地址空间 32位地址空间：3GB用户空间，1GB内核空间 栈段从3GB位置向下增长，初始时保存进程的环境变量和命令行参数 数据段：大小可变，BSS为未初始化的全局变量，页加载时初始化为0 2.6.11及以后的Linux使用4级页表 物理页分配采用伙伴算法 10.Linux的页替换 方法： 保持一定数量的空闲页 文件缓存，未使用的共享页使用Clock算法 用户进程的内存使用改进的Clock算法 改进的Clock算法： 两条LRU链 Active list：所有进程的工作集 Inactive list：回收的候选页 Refill将页从Active list移动到Inactive list Chapter05 输入/输出 I/O设备 1.输入和输出 计算机的工作是处理数据 计算：CPU，高速缓存，内存 将数据传入及传出计算机系统：数据在I/O设备以及内存之间来回传输 I/O设备面临多种挑战：多种类型、大量产商、需要大量设备驱动，设备驱动运行于内核态，其bug常常引发宕机 OS的目标： 提供一种通用的、一致的、方便的、可靠的方法来访问各种I/O设备 充分发挥I/O设备的性能 2.硬件架构 计算机硬件 CPU核和高速缓存 内存控制器 内存 I/O总线 I/O硬件 I/O总线或互连 I/O设备控制器或适配器 I/O设备 3.设备控制器 控制设备的逻辑：解析主机发来的命令，控制设备进行操作 组成： 与主机的接口：用于与主机之间的信息传递 硬件接口：PCie, SATA, USB 接收主机的命令和数据，或把设备的数据和状态等返回给主机 控制寄存器：1个或多个，用于控制设备操作 写控制寄存器，命令设备干指定的事情，比如传数据、接收数据、开、关 读设备寄存器，获得设备的状态，比如忙、闲、就绪 数据缓冲区：用于数据缓冲或缓存，DRAM 缓冲CPU发给设备的数据 缓存设备的数据 4.与I/O设备进行交互：寻址 I/O端口：独立的I/O端口空间 端口号：8位或16位的数值 只能通过I/O指令访问 I/O指令是特权指令，用户程序不能访问 内存地址空间与I/O地址空间分离 控制线：指示CPU发出的地址是内存空间还是I/O空间 内存映射I/O：使用统一地址空间 预留一部分内存地址空间 内存地址与I/O地址无重叠 CPU发出的地址，所有内存模块和所有设备都要解析 优势：访存指令可以用来访问设备的控制寄存器 编程方便 保护方便、灵活：利用虚存的保护机制，放在内核空间或某个进程的虚空间 高效：减少指令 5.与I/O设备进行数据传输 数据传输 启动设备 + 数据传输 启动时间（开销）：CPU用于启动设备进行操作的时间 带宽：启动设备后数据传输的速率 延迟：传输一字节的时间 = 启动时间 + 将一字节传输到目的地的时间 通用方法： 不同的传输速率 字符设备：对字节流传输的抽象，打印机、网卡等，以若干字节为传输粒度，从而分摊开销 块设备：以块为存储粒度和传输粒度，按块寻址，整块读写 数据传输方式 1.PIO（Programmed I/O） 简单的串行控制器 状态寄存器：就绪，忙… 数据寄存器 查询输出： CPU： 等待设备状态变为非“忙” 写数据到数据寄存器 通知设备“就绪” 设备： 等待直到状态变为“就绪” 清除“就绪”标志，设置“忙”标志 从数据寄存器中拿走数据 清除“忙”标志 PIO的轮询 等待直到设备状态变为非“忙” 轮询：不停的检查设备状态，“忙等” 好处：简单 坏处：慢，浪费CPU 改进：中断机制可避免CPU轮询 2.中断 例子：鼠标 简单的鼠标控制器：状态寄存器 + 数据寄存器 输入： 鼠标： 等待直到设备状态变为“完成” 将$\\Delta X,\\Delta Y$和按键的值保存到数据寄存器 发中断 CPU（中断处理） 清除“完成”标志 将$\\Delta X,\\Delta Y$和按键的值读到内核缓冲区（内存）中 置“完成”标志 调用调度器 3.DMA 例子：磁盘 一个简单的磁盘控制器 状态寄存器 DMA内存地址和字节数 DMA控制寄存器：命令、设备、传输模式及粒度 DMA数据缓冲区 DMA写： CPU： 等待DMA设备状态为“就绪” 清除“就绪” 设置DMA命令为write，地址和大小 设置“开始” 阻塞当前的进程/线程 磁盘控制器： DMA方式将数据传输到缓冲区（count–; addr++） 当count == 0，发中断 CPU（中断处理） 将被该DMA阻塞的进程/线程加到就绪队列 将数据从缓冲区写入磁盘 4.I/O软件栈 5.设备驱动 给操作系统的其他模块提供操作设备的API 与设备控制器交互 与设备控制器进行交互以进行数据传输：命令、参数、数据 主要功能 初始化设备 解析OS发来的命令 多个请求的调度 管理数据传输 接收和处理中断 维护驱动与内核数据的完整性 6.设备驱动操作接口 init(deviceNumber)：初始化硬件 open(deviceNumber)：初始化驱动并分配资源 close(deviceNumber)：清除，回收资源，关闭设备 设备驱动的类型： 字符设备：可变长度的数据传输 字符设备接口： read(deviceNumber, bufferAddr, size)：从字节流设备上读”size”字节数据 write(deviceNumber, bufferAddr, size)：将”bufferAddr”中“size”字节数据写入字符流设备 块设备：以固定大小的块为粒度的数据传输 块设备接口： read(deviceNumber, deviceAddr, bufferAddr)：从设备传输一个块的数据到内存 write(deviceNumber, deviceAddr, bufferAddr)：从内存传输一个块的数据到设备 seek(deviceNumber, deviceAddr)：将磁头移动到指定块 7.UNIX设备驱动接口 init()：初始化硬件 start()：开机时初始化，需要系统服务 halt()：在系统关机前要调用 intr(vector)：在发生硬件中断时由内核调用 read(...), write(...)：数据传输 poll(pri) ioctl(dev, cmd, arg, mode)：特殊请求处理 8.设备驱动的工作流程 准备工作 参数检查，请求格式转换 设备状态检查：忙 -&gt; 请求入队列 可能开设备或上电 操纵设备 将控制命令写入设备的控制寄存器 检查设备状态：就绪 -&gt; 写下一命令 直到设备完成所有命令 阻塞等待 等待设备完成工作 被中断唤醒 有的设备不需要等待，如显示器 错误处理：检查设备返回结果，如果错误，可能重试 返回调用者 9.设计问题 静态安装设备驱动：新设备的启动需要重启OS 动态挂载设备驱动： 不需要重启，而是采用间接指针 将驱动加载进内核空间 安装入口点，维护相关的数据结构 初始化设备驱动 动态绑定设备驱动 间接指针 设备入口点：所有设备的入口点 加载设备驱动： 分配内核空间 存储驱动代码 与入口点关联 删除设备驱动： 删除入口点 释放内核空间 10.设备驱动的利与弊 灵活性： 用户可以下载和安装设备驱动 供应商可以基于开放硬件平台 安全隐患： 设备驱动运行于内核态 有bug的设备驱动会导致内核崩溃，或者引入安全漏洞 如何让设备驱动更安全： 检查设备驱动的代码 为设备驱动构建状态机模型 11.同步I/O与异步I/O 同步I/O： read()和write()将阻塞用户进程，直到读写完成 在一个进程做同步I/O时，OS调度另一个进程执行 异步I/O： aio\\_read()和aio\\_write()不阻塞用户进程 在I/O完成之前，用户进程可以做其他事情 I/O完成将通知用户进程 同步读 异步读 12.为什么内核需要缓冲 生产者与消费者之间速度不匹配 字符设备和块设备等 适配不同的数据传输大小 DMA需要连续的物理内存 I/O设备看到的是物理内存 用户程序使用的是虚拟内存 缓存 服务对同一数据的请求 减少I/O操作 总结 I/O设备 PIO简单，但不高效 中断机制支持CPU和I/O重叠 DMA高效，但需要复杂的软件 设备驱动 直接操纵设备的代码 OS代码量中占主导 设备驱动引入安全漏洞 异步I/O 异步I/O允许用户程序的计算与I/O重叠 磁盘和RAID 1.磁盘 持久化的，大容量，低成本的存储设备：机械，速度慢 多种尺寸 多种容量 多种接口 典型的磁盘控制器 与主机的接口：SATA, SAS, FC 缓存：缓冲数据 控制逻辑： 读写请求 请求调度 缓存替换 坏块检测和重映射 磁盘的结构 盘片：一组，按一定速率旋转 磁道： 用于盘片表面的同心圆 用于记录数据的磁介质 bit沿着每条磁道顺序排列 扇区：磁道划分为固定大小的单元，一般为512字节 磁头：一组，用于读写磁道上的数据 磁臂：一组，用于移动磁头 柱面：由所有盘片上半径相同的磁道组成 Zone： 不同磁道的扇区数目不同：外道多，内道少 所有柱面划分为Zone，同一Zone每条磁道的扇区数目相同 2.磁盘扇区 扇区的创建： 磁盘格式化 逻辑块地址映射到物理块地址 扇区的格式： 头部：ID，损坏标志位… 数据区：实际用于存储数据的区域 尾部：ECC校验码 坏扇区：发现坏扇区，先用ECC纠错，如果不能纠错，用备用扇区替代，坏扇区不再使用 磁盘容量：格式化损坏20%左右（每个扇区的头部、尾部加坏扇区） 读写操作 读写某个柱面的某个扇区： 定位柱面，移动磁臂使磁头对准柱面：寻道seek 等待扇区旋转到磁头下方：旋转rotation 进行数据读写：数据传输 3.磁盘性能 有效带宽 = 数据量 / 耗时 耗时： 寻道时间：把磁头移动到目标柱面的时间 旋转延迟：等待目标扇区旋转到磁头下方的时间 数据传输时间 对于小粒度的访问，时间主要花费在寻道时间和旋转时间上 磁盘的传输带宽被浪费 缓存：每次读写临近的多个扇区，而不是一个扇区 调度算法：减少寻道开销 4.磁盘缓存 方法： 用少量的DRAM来缓存最近访问的块 由控制器管理，OS无法控制 块替换策略：LRU 优点：如果访问具有局部性，读性能收益 缺点：需要额外的机制来保障写的可靠性 请求调度算法 1.FIFO 按照请求到达的先后顺序依次服务 好处：公平性，服务顺序是应用预期的 坏处： 请求到来的随机性，经常长距离的寻道 可能发生极端情况，比如横扫整个磁盘 2.SSF（shortest seek first） 方法：选择磁头移动距离最短的请求，记入旋转时间 好处：试图减少寻道时间 坏处：可能会产生饥饿 3.电梯调度 方法： 磁头按一个方向到另一端，再折回，按反方向回到这端，不断往返 只服务当前移动方向上寻道距离最短的请求 LOOK：如果磁盘移动方向上没有请求，就折回 好处：消除饥饿，请求的服务时间有上限 坏处：反方向的请求需等待更长时间 4.C-Scan（Circular Scan） 方法： 将SCAN改为折回时不服务请求 类似将两类连起来成一个环 C-LOOK 好处：服务时间趋于一致 坏处：折回时不干事 4.RAID 主要思想：由多个磁盘构成一个存储设备 好处： 提高性能：多个磁盘并行工作 提高容量：聚合多个磁盘的空间 提高可靠性：数据冗余，磁盘损坏，数据不损坏 坏处：成本高，控制器变得复杂 牵涉的问题： 块映射：逻辑块LBN -&gt; &lt;磁盘#, 块#&gt; 冗余机制 5.RAID0-0 以条带为粒度映射到N个磁盘（轮转） 1 strip = n个块 无冗余 容量：N X 当个磁盘容量 可靠性：$\\text{(单个磁盘可靠性)}^N$ 性能： 带宽 = N X 单个磁盘带宽 延迟 = 单个磁盘延迟 6.RAID-1 镜像 镜像级别R：数据存R份 通常与RAID-0结合使用：RAID-01或RAID-10 容量：（N X 单个磁盘容量）/ R 可靠性（R = 2） 容忍任何一个磁盘坏 特殊情况下可容忍 N/2 个磁盘坏 带宽： 写带宽：（N X 单个磁盘写带宽）/ 2 读带宽：N X 单个磁盘读带宽 延迟： 读延迟：等于单个磁盘读一块的延迟 写延迟：略大于单个磁盘写一块的延迟 7.RAID-4 条带化 + 一个校验块 所有校验块在同一块磁盘上（校验盘） 缺点：校验块为写性能瓶颈，易坏 每次写都更新校验块： 方法一：读所有数据盘 并行读所有磁盘对应的块 计算新校验块 并行写新块和新校验块 方法二：读一个数据盘和磁盘块 并行读一个旧数据块和旧校验块 计算新校验块：$Pnew = (Bold \\oplus Bnew) \\oplus Pold$ 并行写新块和新校验块 容量：（N - 1）X 当个磁盘容量 可靠性：只容忍任何一个磁盘坏，用XOR重构坏盘数据 延迟：读延迟等于单个磁盘的延迟写延迟约等于2倍单个磁盘延迟 带宽： 读带宽 = （N - 1）X 单个磁盘带宽 校验盘为写瓶颈，所有校验块串行写 写带宽 = 单个磁盘带宽 / 2 8.RAID-5 条带粒度映射 + 一个校验块 校验块分散在不同的磁盘上 Rebuild：复杂，速度慢 写带宽 = （N X 单个磁盘带宽）/ 4，校验块并行写 9.卷管理 虚拟块设备： 将多个磁盘聚集起来，在其上创建一个或多个逻辑卷 逻辑卷：一个虚拟块设备 采用RAID技术将逻辑卷的块地址映射到物理设备 提供虚拟的容量和性能：增大或缩小逻辑卷不影响已存储的数据 提供可靠的块存储： 采用RAID技术容忍物理设备故障 提供块级别的错误发现 实现： OS内核的逻辑卷管理：Windows, MacOS, Linux等 存储设备控制器（存储系统） 10.存储系统的演进 企业数据中心： 数据集中存储 大容量、高可靠、高可用的存储系统 SAN存储系统： SAN：存储专用网络 FC或iSCSI接口 多主机共享 容灾：远程恢复，由备份生成远程镜像，或者将远程镜像合并到备份中 存储架构演进：NAS -&gt; NAS + Dedup -&gt; 全球范围的分布式存储 11.总结 磁盘： 内部很复杂 密度按摩尔定律增长 大块读写才能获得高带宽 需要磁盘调度来减少寻道开销 RAID提高了可靠性和I/O带宽 卷管理提供虚拟块设备 存储系统是一个复杂的专用系统： 硬件&amp;软件（存储设备控制器） 企业存储系统已发展成复杂的分布式系统 SSD 1.闪存（Flash memory） 全电子器件，无机械部件 非易失性存储 2.基于闪存的Solid State Drive（SSD） 用很多闪存芯片来构成一个持久化存储设备SSD 多个闪存芯片：并行I/O，提高I/O性能 与主机的接口：提供标准块设备接口 数据缓存与缓冲：SRAM 闪存控制器固件FTL：控制逻辑 主机命令转换成闪存命令 逻辑块地址转换成闪存的物理地址 缓存替换 页聚合写 3.闪存组织 页： 由数据区和Out of Band(OOB)区组成 数据区用于存储实际数据 OOB区用于记录：ECC，状态信息，逻辑页号 页大小：4KB ~ 16KB 数百页每块 块大小：~MB 4.闪存的操作接口 读：read a page 读的粒度是页 读很快 读延迟与位置无关，也与上一次读的位置无关 擦除：erase a block 把整个块写成全1 擦除的粒度是块，必须整块擦除 很慢 需软件把块内有效数据拷贝到其他地方 写：program a page 擦除后才能写，因为写只能把1写成0 写的粒度是页 写比读慢，比擦除快 页的状态 Invalid, Erased, Valid 初始状态为Invalid 读：不改变页的状态 擦除：块内所有页的状态变为Erased 写：只能写状态为Erased的页，写完后，页状态变为Valid 5.闪存的性能和可靠性 性能： 写延迟比读高十倍多 写延迟波动幅度大 擦除很慢：磁盘定位延迟 延迟随密度增加而增大 可靠性： 磨损：擦写次数有限，随密度增加而减少 干扰：读写一个页，相邻页中一些位的值发生翻转 6.SSD面临问题 一个基本问题：逻辑块与物理块的映射 挑战：擦除后写，读快写慢，毫秒级擦除操作 SSD内部硬件（数据通路）：数据传输，数据读/写/擦除（Flash控制器） SSD内部固件（软件）： Flash Translation Layer（FTL） 地址映射 垃圾回收 环块管理 7.最简单的FTL：直接映射 逻辑块的第N块直接映射到物理页的第N页 读操作很容易：读逻辑第K块 = 读物理第K页 写操作很麻烦：写逻辑第K块 第K页所在闪存块，记为B0 把B0整个块读出来 把B0整个块擦除 B0中的旧页和新的第K页：以顺序方式一页一页再写入B0 缺陷：写性能极差，小粒度随机写性能比磁盘还差 8.Log-Structure FTL：页级映射 核心思想：异地更新 像LFS那样顺序写闪存 每次写页，写到一个新位置，即写到日志末尾 映射表：LBN -&gt; 物理页地址PPA 写一个逻辑页K： 写到当前块中下一个空闲页 在映射表中记录：逻辑页K -&gt; 物理页P 读一个逻辑页K： 查映射表，获得逻辑页K对应的物理页地址P 读物理页P 页级映射表：LBN -&gt; PPA 整个放在内存中 持久化：利用页的OOB区来保存映射表 随着写页而被写到闪存 掉电或重启，扫描OOB区恢复映射表 优点： 性能更好，减少写放大 可靠性更好，自动写所有页 问题： 重写逻辑页产生垃圾页：每次写到新位置，导致原先页的内容无效 内存开销大：映射表全部放在内存，映射表的大小和SSD容量成正比 9.垃圾回收 思想： 选择一个含垃圾页的擦除块 把其中的活页拷贝到日志末尾（读&amp;重写） 回收整个块，并把它擦除 判断页的死活： 每页记录它对应的逻辑块地址（OOB） 查映射表，如果映射表中该逻辑块对应的物理页是该页，则该页是活页 问题：开销非常大 活页需拷贝：读&amp;写 开销与活页所占的比例成正比 10.块级映射 块级映射： 逻辑地址空间划分成chunk，chunk size = 物理块size 映射表：chunk# -&gt; 物理块地址PBA 读一个逻辑页： 逻辑页地址 = chunk# + 偏移 用chunk#查映射表，获得对应的物理块地址PBA 物理页地址 = PBA + 偏移 问题：小粒度写性能差 写粒度小于物理块：拷贝活页，写放大 小粒度写很常见 11.混合映射 思想： 将物理块划分为两类：数据块和日志块 逻辑块都写入日志块 数据块采用块级映射，数据映射表 日志块采用页级映射，日志映射表 适当的时候把日志块合并为数据块 读一个逻辑块： 先查日志映射表，按页级映射的方法 如果没找到，再查数据映射表，按块级映射的方法 switch merge 把日志块直接转成数据块：前提是整个日志块的顺序与chunk一致 把原来的数据块回收擦除 优点：开销小，只修改映射表，无数据拷贝 Partial merge 从数据块拷贝部分页到日志块：日志块前部页序与chunk一致 把日志块转成数据块，把原来的数据块回收擦除 有数据拷贝开销 Full merge 分配一个新的日志块，从数据块和日志块分别拷贝部分页到新日志块 把新日志块转成数据块 把原来的数据块和日志块都回收擦除 开销很大，需要拷贝整个物理块的数据 12.磨损均衡 目标：让所有块被擦除的次数近似 动态磨损均衡： 每次写时，选择擦除次数较少或最少的块 局限性：不同数据的修改频率不同 静态磨损均衡： 不会被回收的物理块：长时间不再修改的逻辑块，冷块 不再重写，不再有磨损 解决办法：FTL定期重写冷块 总结 闪存的特性： 读延迟很低：随机读的性能远优于硬盘 写慢：必须先擦除再写 磨损：每个块擦写次数有上限 FTL的主要功能： Chapter06 文件系统 文件系统基础 1.为什么需要文件系统 持久化保存数据需求 进程结束，关机/关电，宕机，掉电 持久化存储设备：磁盘，SSD等 FS是对持久化数据存储的抽象 给用户和程序开发者提供一个逻辑上的持久化存储：简单，易理解，操作方便 将复杂的、公共的管理功能从用户程序中移出 简化编程 -&gt; 加速计算机应用的发展 对FS的基本需求 能够保存大量复杂多样的信息 -&gt; 管理问题 多个进程同时访问 -&gt; 并发控制，语义问题 多用户共享&amp;私有 -&gt; 保护问题 2.文件系统的用户视图 文件：数据组织的单位 文件是命名的字节数组 用户将数据组织成文件，根据文件名来访问对应的数据 FS不感知文件的内容：使用它的进程解析内容 目录：文件组织的单位 一组文件和目录的命令集合 父目录、子目录 无重名 名字空间：树形层次结构 文件系统的逻辑视图 3.文件 文件名：由字母、数字及某些特殊字符组成的字符串 用户根据文件名来访问文件 大多数OS中文件名不超过255个字符 文件扩展名：描述文件的用户，如 .c, .h, .gz, .tex, .pdf 文件属性： 文件大小、所有者、时间戳、访问权限 文件逻辑地址：指示数据在文件中的地址 文件内容：无结构 OS将文件视为无结构的字符数组 程序开发者可以定义任意结构的文件 文件的类型：常规文件、目录文件、设备文件、可执行文件 文件的访问： 打开文件 &amp; 文件描述符 当前位置：文件逻辑地址，[0, fsize -1] （每个文件） 访问方式：读、写、执行 i-node：FS用来描述文件的数据结构 每个文件用一个i-node来描述 文件元数据 ino：inode number，唯一标识一个文件（在一个FS内） 4.文件访问接口（系统调用） 创建文件：fd = creat(fname, mode)，fd为文件描述符 删除文件：unlink(fname) 打开文件：fd = open(fname, flags, mode) 关闭文件：clode(fd) 读文件：rn = read(fd, buf, count)，从当前位置读count个字节到buf中 写文件：wn = write(fd, buf, count)，从当前位置写count个字节 追加写：用O_APPEND模式打开文件 定位文件：lseek(fd, offset, whence) 写回文件：fsync(fd) 截断文件：truncate(fname, length) 获取属性：stat(fname, attbuf)或fstat(fd, attbuf) 5.文件访问模式 顺序访问： 从头到尾依次访问每个文件块 例子：观看一部电影，阅读一篇文章 顺序访问文件不等于磁盘上顺序访问扇区 随机访问： 每次随机访问一个文件块 例子：读邮箱中的邮件 按关键字访问： 查找包含关键字的文件及段落 FS没有提供此功能 例子：数据库查找和索引 6.目录 路径： 根目录 &amp; 当前目录 .：当前目录 ..：父目录 绝对路径 VS 相对路径 目录：一种特殊的文件 具有名字和属性 目录和文件用相同的数据结构：inode，用一个标志i_mode来区分文件和目录 目录内容：描述它所包含的目录和文件集合 有结构：逻辑上是一张表 目录项：每个成员一项 不同FS采用不同的结构 由FS负责维护和解析目录内容 访问文件 VS 访问目录：不同的系统调用 7.目录访问接口：系统调用 创建目录：mkdir(dirname, mode) 删除目录：rmdir(dirname) 打开目录：fd = open(dirname, flags) 关闭目录：close(fd) 读目录：readdir(fd, direntbuf, count)，从当前位置读count个目录项 硬链接：link(oldpath, newpath) 符号链接：symlink(srcpath, linkpath) 重命名文件：rename(oldpath, newpath) 8.硬链接 多个用户共享一个文件 每个用户有自己的主目录 各自主目录下维护一个文件 -&gt; 多个相同的文件 缺点：浪费空间，文件修改繁琐，一致性问题 为文件共享提供一种手段 link系统调用或ln命令 为文件创建一个新名字，无数据拷贝 多个名字指向同一个文件 一个文件可以有多个名字，甚至可以位于多个目录中 实现：link(oldpath, newpath) 新旧两个名字指向同一个i-node i-node引用计数：记录指向该文件有多少个名字 例子：ln C1/C2/C3/foo /B1/B2/goo 9.符号链接 硬链接的限制： 不允许对目录做link 不能跨FS做link 另一种文件共享的手段： symlink系统调用或ln -s命令 ln -s source link_name 10.rename 只改变文件名字，无数据拷贝 保证原子性 11.文件系统物理结构（磁盘布局） 引导块：启动OS的代码 超级块：定义一个FS及其相关的信息 空闲空间管理相关的信息 i-node表：每个i-node描述一个文件或目录 数据块：文件块或目录块 12.FS相关的接口（系统命令） 创建文件系统：mkfs 删除文件系统：rmfs 挂载文件系统：mount -t fstype dev dir 卸载文件系统：umount dev|dir 显示已安装FS：mount或mount dev|dir 同步文件系统：sync 获取文件系统属性：df … 创建、删除、安装，卸载只允许特权用户调用 13.虚拟文件系统（VFS） 新需求：多种类型文件系统，同时挂载不同类型的FS 面向对象的编程思想： VFS：实现FS接口和通用功能，规定PFS API PFS：磁盘布局、数据结构、磁盘空间管理、名字空间管理… 虚拟文件系统开关表：用于文件系统的挂载与卸载 每一种类型的文件系统有一个表项 文件系统类型的名字 初始化函数指针，用于mount 清除函数指针，用于umount 14.超级块 定义一个文件系统： 数据块的大小 i-node的大小 数据块总数 i-node总数 根目录ino i-node表的起始地址 空闲数据块指针 空闲i-node指针 当前状态： 数据块使用情况：已使用的块数，预留的块数，剩余的块数… i-node使用情况：已使用的个数，剩余的个数… mkfs：创建磁盘布局，初始化超级块，bitmap，根i-node等 15.mount 前提： 文件系统类型必须事先已注册到内核 挂载目录必须已经创建好 步骤： 根据文件系统类型，假设为ext4，查VFS开关表，找到ext4文件系统类型的初始化函数，即ext4_mount() 调用ext4_mount：读取超级块，读取根目录i-node 初始化一些内存数据结构：超级块，根i-node等 16.i-node ino：i-node number，即i-node的ID 文件属性信息： mode：文件类型和访问权限 size：文件大小 nlinks：硬链接数 uid：所有者的user ID gid：所有者的group ID ctime：文件创建的时间戳 atime：上一次访问文件的时间戳 mtime：上一次修改文件的时间戳 文件块的索引信息：文件块的磁盘位置信息，不同FS采用不同的索引机制 17.目录 目录内容为它所包含的所有子目录和文件的名字及其ino，不包含子目录的内容 逻辑上，目录是一张映射表，目录项：文件名 -&gt; ino 路径解析： 根据路径名，获得其ino 逐级目录查找 18.打开文件 fd = open(pname, flags, mode) 打开文件信息表 Open：通过打开文件描述符把进程与文件的i-node进行关联： 参数检查 路径名解析和权限检查，得到pname的ino，读出它的i-node 将i-node拷贝至一个内存i-node结构中 创建一个打开文件描述符 在PCB中分配一个空闲的打开文件指针来指向该打开文件描述符 返回这个指针的下标，即文件描述符fd 总结 FS名字空间是由目录和文件构成的树形层次化结构 文件是无结构的命名字节数组 目录是文件和子目录的命名集合 文件和目录有各自的访问接口 FS磁盘布局和主要数据结构： 超级块：定义一个文件系统 i-node：定义一个文件/目录，根据ino定位i-node的磁盘位置 目录：一种特殊的文件，文件名 -&gt; ino的映射表 文件系统实现 磁盘空间管理 1.连续分配 分配连续的磁盘块给文件 文件粒度分配 位图：找到N个连续的“0” 链表：找到size&gt;=N的区域 文件元数据：记录第一块的地址，以及块的个数N 优点： 顺序访问性能高 随机访问时定位数据块也容易 缺点： 不知道文件最终多大，无论创建时，还是写数据块时 文件难以变大 外部碎片化 2.文件块索引：链表结构 分配不连续的磁盘块给文件：块粒度分配 文件元数据： 记录第一块的地址 每一块指向下一块的地址 最后一块指向NULL 优点： 无外部碎片，而且文件变大很容易 空闲空间链表：与文件块类似 缺点： 随机访问性能极差：定位数据块需要按指针顺序遍历链表 可靠性差：一个块坏掉意味着其余的数据全部”丢失“ 块内有效数据的大小不再是2的幂次，导致额外的磁盘数据拷贝 3.文件块索引：文件分配表（FAT） 一张有N个项的表，假设磁盘有N块 每个磁盘块有一个表项：要么为空，要么为该文件下一块的地址 位于磁盘分区的头部 文件元数据： 记录第一块的地址：链表头指针 每个磁盘块全部存数据，无指针 优点： 简单 文件块大小为2的幂 缺点： 随机访问性能不好：定位数据需要遍历链表 浪费空间：额外的空间存储FAT表 4.文件块索引：单级索引 文件元数据 用户定义文件长度上限max size file header：一个指针数组，指向每个块的磁盘地址 优点： 文件在限制内可变大 随机访问性能高，数据块直接定位 缺点：不灵活，文件长度难以事先知道 5.文件块索引：两级索引 思路： 采用连续分配，允许不连续 不定长分配 文件元数据： 小文件有10个指针，指向10个可变长度段（base, size） 大文件有10个间接指针，每个指向可变长度的间址块 优点：支持文件变大（最大为10GB） 缺点：不灵活，外部碎片 6.文件块索引：多级索引（UNIX） 块粒度分配 文件元数据：13个指针 10个直接指针 11：一级间接指针 12：二级间接指针 13：三级间接指针 优点：小文件访问方便，支持文件变大 缺点：文件大小有上限（16G多），大量寻道 7.文件块索引：Extents Extent是若干个连续磁盘块（长度不固定） 同一extent中的所有块：要么都是空闲块，要么都属于某个文件 extent： XFS提出的方法： 无论文件块还是空闲块都采用extents来组织 文件块索引采用extent B树 每个extent： 文件块号、长度（块数）、磁盘起始块号 文件元数据：记录B树的根节点地址 8.名字空间管理 FS接口： 目录树：多级目录，文件 用户/进程按路径名访问文件或目录 名字空间相关的操作： 目录访问：创建/删除目录，创建/删除文件，链接，重命名，读目录 路径名解析 FS内部： 根据ino定位i-node的磁盘位置 根据i-node定位文件块的磁盘位置（文件块索引） 文件名与i-node分离存储 文件名保存在目录内容中：目录项为 9.创建文件或目录 例：创建文件”/home/example/os/fs_lecture.pdf” 10.删除文件或目录 例：删除文件“/home/test/os/fs_lecture.pdf” 目录实现 1.线性表 原理： &lt;文件名，ino&gt;线性存储 每一项不定长： 创建文件： 先查看是否有重名文件 如果没有，在表末添加一个entry： 删除文件： 用文件名查找 删除匹配的entry 紧缩：将之后的entry都向前移动 优点：空间利用率高 缺点： 大目录性能差：线性查找磁盘I/O多 删除时紧缩很费时 2.B树 原理： 用B树来存储&lt;文件名，ino&gt;，以文件名排序（字典序） 创建/删除/查找：在B树中进行 优点：大目录性能高，B树查找减少磁盘I/O 缺点： 小目录不高效 占用更多空间 实现复杂 3.哈希 原理： 用哈希表将文件名映射到ino： hash_func(filename) -&gt; hval -&gt; bucket 在bucket中线性查找文件名 文件名是变长的 创建/删除需要分配/回收空间 优点：简单，查找速度快 缺点：对于很大的目录，效率不如B树；哈希表浪费空间 4.虚拟页表 VS 文件块索引 页表： 维护进程地址空间与物理内存地址空间的映射关系 虚页号 -&gt; 物理页号 检查访问权限，地址合法性 如果映射关系在TLB中，一个cycle就完成转换 文件块索引： 维护文件块与磁盘逻辑块之间的映射关系 文件和文件内偏移 -&gt; 磁盘逻辑块号 检查访问权限，地址合法性 由软件（OS）实现，可能引入多次I/O 4.文件系统 VS 虚存 相似点： 位置透明性：用户不感知物理地址 固定粒度分配：块/页 保护：读/写/执行权限 FS比VM容易的地方： FS的映射可以慢 文件比较稠密，经常是顺序访问 页表处理的进程地址空间非常稀疏，通常是随机访问 FS比VM难的地方： 每层路径解析都可能引入I/O 文件缓存的空间（内存）总是不够的 文件长度差距大：很多不足10KB，有的又大于GB FS的实现必须是可靠的 5.最初的UNIX FS 简单的磁盘布局： 文件块大小 = 扇区大小（512B) i-node区在前，数据区在后 空闲块/i-node链表：Super Block中记录头指针 文件块索引采用三级间址，目录采用线性表 存在的问题：带宽很低，文件个数有上限 导致带宽低的原因 数据块的存储位置：数据块存储在内存的柱面，i-node存储在外层的柱面 经常要长距离寻道： i-node与其数据块离得很远 同一目录里的文件，其i-node也离得很远 一个文件的数据块散布在磁盘上的任意位置 未考虑给文件分配连续磁盘块： 空闲块采用链表组织 链表上相邻的块其物理地址不连续 磁盘空间碎片：一个文件的数据块散布在磁盘上的任意位置 磁盘碎片整理工具：拷贝数据块&amp;修改i-node 小粒度访问多：采用512B的块 有利于减少块内碎片：小文件不足一个块，最后一个数据块通常不满 无法发挥磁盘带宽：块越大，带宽越高 文件块索引大，索引开销高 6.BSD FFS（Fast File System） 大文件块：4KB或8KB 数据块大小记录在超级块中 空间利用率问题：小文件，大文件的最后一块可能非常小 FFS的解决办法：数据块划分为若干更小的子块（分片），子块为512B 位图（BM）：取代空闲块链表 尽量连续分配 预留10%的磁盘空间 FFS的磁盘布局 柱面组（CG, Cylinder Group） 每N个连续的柱面为一个CG 把磁盘划分为若干个柱面组，将文件和目录分散存储于每个柱面组 每个CG类似一个sub FS FFS的放置策略 减少长距离寻道：把相关的东西放在同一CG 目录放置： 选择CG：目录个数少，空闲i-node个数多，空闲块多 所有的目录尽可能均衡分布在所有CG上 文件放置： 文件块选择其i-node所在的CG 同一目录下的文件选择目录所在的CG FFS的其他优化 大文件： 避免占满一个CG i-node所在CG：前10块（直接指针指向） 每个间址块及其指向的块在同一CG 不同间址块及其指向的块在不同CG 顺序访问性能： 一块一块的顺序读写，避免额外的旋转延迟 FFS：逻辑块到物理块的映射采用间隔方式 文件系统可靠性 文件缓存 1.路径名解析 例子：在UNIX中查找/usr/ast/mbox I/O性能 读一个文件：/home/example/foo，假设读它的第一块： 写一个新文件：/home/example/goo，假设只写入一个块： 2.文件缓存 使用内核空间的一部分内存来缓存磁盘块 读操作：先检查该块是否在缓存中 在：将缓存块的内容拷贝到用户buffer中 不在：分配一个缓存块（可能需要替换），把磁盘块读到缓存，再把缓存块拷贝到用户buffer 写操作：先检查该块是否在缓存中 在：将用户buffer的内容拷贝到缓存块中 不在：分配一个缓存块（可能需要替换），将用户buffer的内容拷贝到缓存块中 将该缓存块写回磁盘（根据缓存管理策略） 缓存设计问题： 缓存什么 缓存大小 何时放进缓存 怎么替换，替换谁 写回策略 缓存大小 文件缓存与VM竞争有限的内存空间 两种方法：固定大小 &amp; 可变大小 如何调整缓存大小： 由用户决定 工作集思想：在不超过阀值时动态调整 为什么缓存位于内核空间 DMA：DMA需要绑定物理内存 多用户进程：共享缓存 经典的替换策略：全局LRU 3.预取 文件访问具有局部性： 空间局部性 时间局部性 最优：在要用之前刚好预取进来 通常的策略： 针对顺序访问的预取：访问第i块时，预取随后的k个块 指针文件块分配连续的磁盘块 Linux采用此方法 针对i-node的预取：在读取目录项时，同时读取对应的i-nodes 高级策略：预取同一目录下的所有小文件 4.替换策略 原理：用过去预测未来，LRU效果好 LRU策略： 哈希表 + 双向链表：MRU端为链头，LRU端为链尾 如果b在缓存，则将它移到链头，返回b 否则，替换链尾的块，从磁盘读取b，将它插入链头 5.写回策略 写与读是不同的：数据必须写到磁盘才能持久化 Write through： 每个写操作，不仅更新缓存块，而且立即更新磁盘块 缓存内容与磁盘块内容是一致的 简单，但是磁盘写没有减少 Write back： 写缓冲：每个写操作只更新缓存块，并将其标记为“dirty” 之后再将它写到磁盘 写操作块，减少磁盘写：缓存吸纳多次写，批量写磁盘 写回的复杂性 丢数据： 宕机时，缓存中的“脏”数据将全部丢失 推迟写磁盘：更好的性能，但损失更大 什么时候写回： 当一个块被替换出缓存时 当文件关闭时 当进程调用fsync时 固定的时间间隔（UNIX是30秒） 问题： 执行写操作的进程并不知道数据什么时候落盘了 fsync：让用户控制写回数据 direct I/O：不使用缓存 上述策略都不足以保证不丢数据：宕机或掉电可能发生在任何时候 文件系统可靠性 1.威胁FS的因素 设备坏 磁盘损坏或磁盘块损坏 超级块：整个FS丢失 位图块，i-node 数据块：目录、文件、间址块损坏 宕机或掉电： 软件bug 缓存中的“脏”数据没有写回磁盘 2.备份与恢复工具 物理备份与恢复：设备级，将磁盘块逐一拷贝到另一个磁盘上（备份盘） 全复制：原始盘与备份盘在物理上一模一样 增量肤质：与上次备份相比，只拷贝发生变化的块 逻辑备份与恢复：文件系统级 遍历文件系统目录树，从根目录开始 把你指定的目录和文件拷贝到备份磁盘 在备份过程中验证文件系统结构 恢复工具：将你指定的文件或目录树恢复出来 也有两种： 全备份：备份整个目录树 增量备份：只备份发生变化的目录和文件 3.持久化与宕机 文件系统给用户提供持久化的数据存储 文件一直要保存完好，除非用户显示删除它们 如果有备份，可以恢复出已经删除的文件 为什么难： 机器可能在任意时刻宕机 宕机使得内存中的数据全部丢失 一个写操作往往修改多个块，但系统只能保证原子修改一个块 4.宕机破坏文件系统的一致性 例：在当前目录/home/test下创建文件testfile 例：在文件/home/test/testfile/文件末尾写入一个数据块 先写元数据、后写数据 先写数据、后写元数据 5.保证一致性的修改 通用方法：按自底向上顺序进行修改 文件数据块 -&gt; 文件的i-node -&gt; 目录文件 -&gt; 目录i-node… 如果有文件缓存： 写回所有的数据块 修改文件的i-node，并把它写回磁盘 修改目录项，并把它写回磁盘 修改目录的i-node，并把它写回磁盘 沿路径向上，直到无修改的目录 缺点： 写性能差：对于磁盘是串行的小粒度随机写，写性能差 FS不一致：宕机后可能产生垃圾块 7.fsck：UNIX FS一致性检查工具 检查并试图恢复FS的一致性：不能解决所有问题，比如数据与元数据不一致 检查superblock：如果fs size &lt; 已分配块，认为它损坏，切换到另一个副本 检查块位图 重构已使用块信息：扫描磁盘上所有的i-node和间址块 重构已使用i-node信息：扫扫描磁盘上所有目录的目录项 检查i-node 通过type域的值来判断i-node是否已经损坏 如果损坏，则清除该i-node及它对应的位图位 检查nlink域 遍历FS的整个目录树，重新计算每个文件的链接数 没有目录项指向的i-node，放到lost+found目录下 检查数据块是否冲突 是否有两个或更多的i-node指向同一个数据块 把这个数据块的内容复制一遍 检查数据块指针：是否指针越界 缺点：恢复时间与FS大小成正比，即使只损坏了几个块，需要扫描整个磁盘和遍历FS目录树 8.恢复磁盘块结构 启动块： 创建一个替代启动块的工具 复制一份启动块以及内核到U盘 超级块：复制多个副本 空闲块结构： 从根目录开始，遍历目录树，得到所有可达文件 不可达的块都为空闲块 9.事务概念 事务概念来自于数据库 事务是一组操作，具有“ACID”性质： Atomicity：原子性，要么所有操作都成功完成，要么一个操作也不曾执行过 Consistency：一致性，事务完成后，所有状态必须是正确的 Isolation：隔离性 事务的中间状态对其他事务不可见 针对并发执行事务，并发执行的结果等同于顺序执行的结果 Durability：持久性 一旦一个事务成功完成，其结果是永久性的 后续事务可基于此结果继续操作 10.事务操作接口 定义构成事务的一组操作 原语： Begin Transaction：标记一个事务的开始 Commit（End Transaction）：标记一个事务的成功 Rollback：回滚，撤销从”Begin Transaction”起发生的所有操作 规则： 事务可以并发执行 回滚可以在任意时刻执行 事务可以嵌套 11.事务的实现：Write-Ahead Log Begin Transaction：在磁盘上记录一条开始日志TxB，标明一个事务开始 事务中的修改： 所有修改都记录日志 事务日志中需要标明事务编号TID Commit：在磁盘上写一条结束日志TxE，标明一个事务成功完成 Checkpoint：Commit之后，把该事务中的修改全部写到磁盘上 清除日志：Checkpoint写完后，清除相应的日志 宕机恢复：replay 如果磁盘上没有结束日志TxE，什么也不做 如果有，按日志重做，然后清除日志 前提假设： 写到磁盘上的日志和数据都是正确的（错误发现和纠错机制） 宕机后磁盘仍然是好的 日志中记录的所有修改必须是幂等的 每个事务有唯一的编号TID 必须有办法确认写磁盘完成 12.将事务用于FS 日志文件系统（Logging File System） 用事务来实现一致性的修改 每个文件操作都作为一个事务：创建/删除文件/目录，重命名，硬链接，软连接，写文件… 宕机恢复： 按日志重做一遍 简单、高效：恢复时间与日志大小成正比 日志必须是幂等的 日志文件系统：data journaling 记录所有修改的日志 例：在一个文件末尾追加一个数据块 流程： 写日志：TxB，i-node日志，bitmap日志，数据块日志 提交日志Commit：写TxE Checkpoint：修改磁盘上的i-node、bitmap、数据块 清除日志 日志开销：所有数据块写两次磁盘 日志文件系统：metadata journaling 只记录元数据修改的日志 例：在一个文件末尾追加一个数据块 流程： 写数据块 写日志：TxB，i-node日志，bitmap日志 提交日志Commit：写TxE Checkpoint：修改磁盘上的i-node，bitmap 清除日志 日志开销：所有数据块只写一次磁盘 13.日志的性能问题 性能问题 频繁写磁盘：每个操作都要同步写磁盘 写放大：只修改一个块中少量内容 改进办法 批量提交：以牺牲可靠性换取性能 先修改内存中的数据结构（bitmap，i-node，数据块） 日志记录它们的内存地址 定期提交所有操作的日志 用NVRAM来保存日志 MVRAM速度快，写日志快，可以大幅度提高写的IOPS 不丢数据 可靠性 （批量提交）宕机仍然可能丢数据，但不会破坏文件系统结构 无法应对硬件故障，比如磁盘扇区坏 14.日志管理 需要多大的日志？ 日志只在宕机恢复时需要 方法： 定期做checkpoint：把缓存里的内容刷回磁盘 checkpoint之后，可以截断日志，从头开始写 固定大小，循环使用 日志要足够大以足以容纳所有内存中的修改 实际系统： 日志大小可配置，通常为百MB 位于FS内部，一个特殊文件，文件名&amp;i-node 位于FS外部，专门的日志盘/分区 LFS（Log-Structured File System） 1.LFS 目标：提高写性能 思想：试图消除对磁盘的小粒度随机写和同步写，像写日志那样大粒度顺序写磁盘 具体： 每次写文件写到新位置（日志末尾）：out-of-place update（COW） 不需要bitmap来管理空闲空间 文件块采用多级索引：文件块位置记录在i-node中 每次写文件采用一致性修改：先写文件块，再写i-node 大粒度顺序写 Segment：大粒度的内存buffer 缓存多个写，一次把整个segment写到磁盘 i-node 每次写文件块，都要写i-node 每次写到新位置 一个文件的i-node在磁盘上没有固定位置 imap imap块随文件块和i-node一起写到日志中 CR（Checkpoint Region）记录每个imap块的最新磁盘位置 CP位于磁盘上的固定位置，有两个CR，分别在磁盘头和尾 目录 目录采用与文件一样的方式来写 读文件 假设LFS刚挂载，内存里什么都没有 先读CR，把CR缓存在内存，以后就不用读了 根据ino，知道它所在的imap块 查CR，得到imap块所在的磁盘地址 读imap块，得到ino对应的i-node的磁盘地址 读i-node，查文件块索引，得到文件块的磁盘地址 读文件块 重写（修改）会产生垃圾 修改文件 例：修改/home/test/foo的第一块 原来的数据块变为无效 -&gt; 垃圾 例：在/home/test/foo末尾追加写一块 原来的i-node变为无效 -&gt; 垃圾 垃圾回收 原理： 后台进程cleaner周期性的检查一定数量的segment 把每个segment中的活块拷贝到新的segment中 何时回收： 周期性回收 空闲时：无访问或访问少 磁盘满时 回收什么样的segment： 热segment：块频繁被重写 冷segment：部分死块，部分稳定块 优先回收冷segment，推迟回收热segment 宕机恢复 两个CR交替写 CR的完整性：CR的第一块和最后一块都有一个时间戳 恢复： 最后一次完成的Checkpoint：时间戳最新的&amp;完整的CR 重构最新的修改：根据CR找到日志末尾，检查后续写的segment 恢复快：无需fsck，无需扫描磁盘 分布式文件系统和数据保护 NFS 1.NFS（Network File System） 多个客户端（计算机）共享一台文件服务器 2.NFS架构 多Client，单Server NFS客户端：实现FS功能和接口 接口：syscall，与本地FS相同接口（透明性） 把文件访问syscall转换成请求 把请求发给服务器 接收服务器发回的请求，并返回给调用者 NFS服务器： 接收客户请求 读写本地FS 把结果发回给客户端 缓存： 客户端缓存 服务器端缓存 3.NFS设计 设计目标： 简单 快速恢复 核心思想：无状态服务器 服务器不记录客户端打开的文件 服务器不记录每个打开文件的当前偏移 服务器不记录被客户端缓存的数据块 核心数据结构：File Handle（FH） 唯一标识客户端要访问的文件或目录 Volume ID ino Generation Number 4.NFS挂载 NFS服务器“export”一个目录给客户端 输出目录表：/etc/exports 输出目录命名：exportfs NFS客户端挂载： NFS服务器（机器名或网络地址） NFS服务器输出目录的路径名 服务器返回输出目录的File Handle 自动挂载 例：两个客户端挂载同一个服务器输出的目录，挂载之后，三个机器可以共享文件 5.NFS Protocol 6.文件访问的实现 客户端open一个文件 open() syscall：路径解析 向服务器发LOOKUP请求 接收服务器应答的FH 将本地fd与FH关联 fd的偏移置为0 客户端read文件 read() syscall：fd, buf, count 根据fd得打FH和偏移 向服务器发READ请求 参数为FH，偏移，count 接收服务器的应答数据 把应答数据拷贝到buf fd的偏移 += count 客户端close文件 释放fd和打开文件结构 无需与服务器交互 服务器接收LOOKUP请求 从目录FH中得到VID和目录ino 读目录i-node 读目录块，查找与name匹配的目录项 构造FH：VID，name的ino，gno 发应答：name的FH 服务器接收READ请求 从FH中得到VID和文件ino 打开本地文件ino得到sfd 设置本地文件的偏移（lseek） 读本地文件数据到sbuf中：read(sfd, sbuf, count) 关闭本地文件：close(sfd) 发应答：sbuf的数据 7.NFS的失效处理 三种失效 客户端请求丢失 服务器宕机 服务器应答丢失 NFS的策略：retry，客户端会超时重发请求 前提：协议请求是幂等的 8.客户端缓存 客户端用一部分kernel内存来缓存元数据和数据 好处：提高文件读写性能，减少和服务器的交互 缓存一致性问题： 当多个客户端同时读写同一个文件：多读单写、多写 当某个客户端写，导致： 修改不可见：客户端打开文件读到旧版本（服务器不是最新版本） 陈旧数据：客户端缓存中的数据变旧 NFS解决办法： Close-to-open consistency flush-on-close open时用GETATTR来检查缓存中数据块的有效性 数据块60s过期，属性缓存3s过期 脏数据：30之内写回NFS服务器 附加手段 网络锁管理：顺序一致性 不共享缓存：只能被一个客户端缓存 9.服务器端缓存 服务器用一部分kernel内存来缓存数据和元数据 好处：提高文件读写性能，服务器端减少磁盘I/O 问题：服务器宕机可能丢数据 解决办法：COMMIT 服务器把之前WRITE写在缓存中的数据写到持久化存储 参数：FH，偏移，count 如果COMMIT超时未收到应答：之前的WRITE和COMMIT本身都要重发 10.NFS的影响力：企业级存储 企业数据中心：SAN架构 企业数据中心：NAS架构（快照） WAFL 1.NetApp的NFS文件服务器 WAFL：Write Anywhere File Layout NetApp为其NFS产品设计的文件系统 设计目标： 请求服务速度快：吞吐率更多，I/O带宽更高 支持大文件系统，且文件系统不断增长 高性能软件RAID 宕机后快速恢复 独特之处： 引入快照 使用NVRAM记录日志（写前日志） 磁盘布局受LFS启发 2.快照（snapshot） 快照是文件系统的一个只读版本 1993年提出 成为文件服务器必备特性 快照用法： 系统管理员配置快照的个数和频率 最初系统能支持20个快照 用快照恢复其中任何一个文件 3.i-node、间址块和数据块 WAFL使用4KB i-node：借鉴UNIX FS 16个指针（64B）用于文件索引 文件大小$\\le 64B$：文件直接存储在i-node中 文件大小$\\le 64KB$：i-node存储16个指向数据块的指针 文件大小$\\le 64MB$： i-node存储16个指向间址块的指针 每个间址块存储1024个指向数据块的指针 文件大小$&gt; 64MB$：i-node存储16个指向二级间址块的指针 4.WAFL的磁盘布局 主要数据结构 一个根i-node：整个FS的根 一个i-node file：包含所有i-node 一个block map file：指示所有空闲块 一个i-node map file：指示所有空闲i-node 为什么将元数据存储于文件中 元数据块可以写在磁盘上任何位置：这是WAFL名字的由来 使得动态增加文件系统的大小变得容易 增加一个磁盘引发i-node个数的增加 将卷管理集成到WAFL中 能够通过Copy-On-Write（COW）来创建快照 新的数据和元数据都可以COW写到磁盘上的新位置 固定元数据位置无法COW 5.快照的实现 WAFL将整个FL组织成一棵树 创建快照： 复制根i-node 新的根i-node指向活跃FS 旧的根i-node指向快照 创建快照之后： 第一次写一个块：把从它到根的数据块都复制（COW） 活跃FS的根i-node指向新数据块 写数据块 以后对这些数据块的写不再触发COW 每个快照都是一个一致状态的只读FS 6.文件系统一致性 定期创建一致点：特殊的快照，用户不可见 宕机恢复： 将文件系统恢复到最后一个一致点 最后一个一致点之后到宕机前的操作：靠日志进行恢复 7.非易失RAM（Non-Volatile RAM） NVRAM：带电池的DRAM，快，但是电池只能维持几小时~几天 日志写入NVRAM 记录自上一个一致点以来的所有写请求 正常关机：先停用NFS服务，再创建一个快照，然后关闭NVRAM 宕机恢复：用NVRAM中的日志来恢复从最后一个一致点之后的修改 NVRAM划分为两个日志：一个日志写满后，转向写另一个日志，满的日志写回磁盘 8.快照数据结构 Block map file 每个4KB磁盘块，对应一个32位的表项 表项值为0：该块为空闲块 第0位等于1：该块属于活动文件系统 第1位等于1：该块属于第一个快照 第2位等于1：该块属于第二个快照 … 9.快照创建 问题： 正在创建快照时，可能有很多NFS请求到来 文件缓存可能需要写回 不系统NFS长时间被挂起不处理请求 WAFL的解决方案： 在创建快照前，将块缓存中的脏块标记为“in-snapshot” 所有对”in-snapshot“缓存块的修改请求被挂起 没有标记为”in-snapshot”的缓存数据可以修改，但不能刷回磁盘 步骤： 为所有“in-snapshot”的文件分配磁盘空间 将i-node缓存中的脏i-node写回至块缓存 更新block map file：对每个表项，将活动FS位的值拷贝到新快照位 刷回： 把所有“in-snapshot”缓存块写到它们新的磁盘位置 每写回一个块，重启它上面被挂起的NFS请求 复制根i-node 10.快照删除 删除快照的根i-node 清除block map file中的位 GFS（Google File System） 1.GFS：应用需求 大规模集群 故障常态化 GB级大文件的持续高带宽 大粒度顺序写和小粒度随机写 追加写Append-only：从头写到尾，没有rewrite 2.GFS：概述 逻辑上，三类组件 客户端提供库函数接口：应用通过专门的库函数访问GFS（用户态） 大量Chunk Server：存储服务器，存储GFS文件 单一Master：存储元数据和维护名字空间 物理上，两类机器 Master是集群中专门一台机器 集群中其他所有机器，既为客户端，又为Chunk Server GFS文件 文件划分为固定长度的Chunk：64MB 以Chunk为粒度存储在多个Chunk Server上 大块的好处： 减少读写时与Master交互 减少元数据量 更好的利用网络和磁盘带宽 文件缓存 客户端不缓存文件：数据量太大 服务器端利用OS提供的文件缓存 文件Chunk：每个Chunk保存多个副本 容错：可用性，可靠性 写文件：同时写多分，强一致性 读文件：选择任意一份，比单复本有更高的带宽 Chunk多个副本的放置： 本地性：本地放一份 网络距离：同一机架放一份 可用性：不同机架放一份 GFS Master：集中式管理 维护三类元数据信息：名字空间，文件 -&gt; Chunk映射，Chunk -&gt; CS映射 监测CS的HB，负责故障恢复 所有元数据信息都维护在Master的内存中 元数据定期持久化 3.GFS：副本一致性 Primary Chunk Server 每个chunk有一个主服务器，其他为从服务器 由主服务器确定对chunk的并发写的顺序 三阶段写 与Master交互，获得主服务器位置 数据传输到主服务器，保存在服务器的内存 主从服务器把数据写入本地文件 4.GFS的影像：开源实现HDFS Hadoop上的分布式文件系统 比Hadoop的MapReduce计算平台还要更广泛地使用 5.GFS的发展 局限性： 集中控制，单一元数据服务器：性能瓶颈、FS规模瓶颈 文件数量越来越多 应用场景越来越多 小文件的应用场景越来越多 解决办法：基于分布式大表的元数据管理 6.分布式文件系统总结 7.数据保护 FS是共享的资源 很多用户 文件或目录：共享或私有 访问了不该访问的文件 失误所至 蓄意攻击 8.安全与保护 不让数据被未经许可的使用 数据机密性：未经许可，不能看到数据 数据完整性：未经许可，不能修改或删除数据 系统可用性：任何人干扰系统使得它不可用 90年代之前：PC和网络尚未普及 单位的计算机：多用户共享 任何用户不能读写其他用户的文件 互联网时代 数据在网络传输过程中被拦截：数据加密 给一个Internet Server 发送大量的请求 9.保护：策略与机制 安全策略：定义目标，即要达到的效果，通常是一组规则，定义可接受的行为和不可接受的行为 机制：用什么样的方法来达到目标 10.保护机制 Authentication（身份认证） Authorization（授权/批准） 决定“A是不是准许做某件事” 需要一个简单的数据库 访问控制： 做出“访问是否准许”的规定 确保没有漏洞 11.身份认证 通常是用密码来验证：一串字符，用户必须记住密码 密码以加密形式存储：使用一种单向的安全hash算法 缺点： 每个用户都要记很多密码 比较弱：“dictionary attack” 12.保护域 规则：每个身份准许做哪些事 保护矩阵：保护域 VS 保护源 13.按列：访问控制表（ACL） 每个对象有一个ACL表 定义每个用户的权限 每个表项为 简单，大多数系统都采用，如UNIX的owner, group, other 实现 ACL实现在内核中 在登录系统时进行身份验证 ACL存储在每个文件中或文件元数据中 打开文件时检查ACL 访问控制 需要一个可信权威：进行访问控制，ACL都需要保护 内核是一个可信权威 内核什么事都可以做 如果有bug，整个系统都可能被破坏 它越小、越简单越好 安全的强度由保护系统链上最薄弱的环节决定 14.一些简单的攻击 滥用合法权利 UNIX：root能做任何事情 拒绝服务（DoS) 耗尽系统所有资源 偷听：侦听网络上传输的包 没有完美保护的系统，每个系统都有漏洞"},{"title":"LLVM Pass 与 APA 简介","date":"2018-07-08T05:54:01.000Z","path":"2018/07/08/LLVM-Pass-and-APA-Introduction/","text":"前段时间学习了一些关于 LLVM Pass 和 APA 方面的知识，趁今天有空，做一些总结。 LLVM Pass Pass 是 LLVM 中一个非常重要的框架，在 LLVM 后端的分析、转化、优化等过程中，通常是多个 Pass 一起作用来共同完成的。 每一个 LLVM Pass 都是 Pass 类的一个派生类，通过重写 Pass 类的虚方法来实现自身的功能。根据你想要实现的功能，你可以选择继承ModulePass或FunctionPass 等等一系列Pass. 下面实现一个简单的Pass: 该 Pass 的功能就是在 main 函数的入口处添加一个打印 hello, world.\\n 的语句。在这儿，我们选择继承 ModulePass 来实现： 123456789101112131415161718192021222324252627282930313233343536 #include &lt;cstdio&gt;#include \"llvm/ADT/Statistic.h\"#include \"llvm/IR/Function.h\"#include \"llvm/IR/Module.h\"#include \"llvm/IR/IRBuilder.h\"#include \"llvm/IR/TypeBuilder.h\"#include \"llvm/Pass.h\"#include \"llvm/Support/raw_ostream.h\"using namespace llvm;namespace &#123; struct PrintfAfterMain : public ModulePass &#123; static char ID; // Pass identification, replacement for typeid PrintfAfterMain() : ModulePass(ID) &#123;&#125; virtual bool runOnModule(Module &amp;M) &#123; Function *F = M.getFunction(\"main\"); if (!F)&#123; errs() &lt;&lt; \"Not exist main function.\\n\"; return false; &#125; Instruction *inst = &amp;(*F-&gt;begin()-&gt;begin()); IRBuilder&lt;&gt; Builder(inst); FunctionType *printf_type = TypeBuilder&lt;int(char *, ...), false&gt;::get(getGlobalContext()); Function *func = cast&lt;Function&gt;(M.getOrInsertFunction( \"printf\", printf_type, AttributeSet().addAttribute(M.getContext(), 1U, Attribute::NoAlias))); Value *helloWorld = Builder.CreateGlobalStringPtr(\"hello world!\\n\"); Builder.CreateCall(func, helloWorld); return true; &#125; &#125;;&#125;char PrintfAfterMain::ID = 0;static RegisterPass&lt;PrintfAfterMain&gt; X(\"PrintfAfterMain\", \"PrintfAfterMain World Pass\", false, false); 我们可以看出，通过重写 ModulePass 的虚函数 runOnModule，只需要几行的代码，便可以实现该功能。简单说一些它的逻辑：在 LLVM 中，每一个 Module 可以看做就代表一个程序，ModulePass 就是对一个 Module 进行操作，一个 Module 维护着一个函数列表，一个 Function 维护有一个 BB 块列表，而一个 BB 块维护有一个指令列表，首先通过 Module 的 getFunction 方法找到 main ，如果没找到，说明模块中不存在 main 函数，这时候不需要对模块进行任何更改，直接返回 false 即可，如果存在 main 函数，那么便可以找到它的第一条指令：&amp;(*F-&gt;begin()-&gt;begin())，然后，通过 IRBuilder.CreateCall 创建一个调用 printf 函数打印 hello, world!\\n. 通过继承 FunctionPass 也可以实现该功能，FunctionPass 作用在每一个函数上，此时，重写 runOnFunction 方法，判断函数为 main 函数，如果不是，则返回，否则，同上进行指令插桩。 APA APA 的全称是 automatic pool allocation，它是 LLVM 后端的一个优化框架，通过将分离的数据结构分配到不同的内存池中，从而控制数据结构在内存中布局。 编译原理研讨课上本人做了一个关于 APA 的调研，发现网上关于 APA 的资源很少，并且 APA 项目本身不稳定，甚至代码存在一些未修复的 bug，因此将编译安装/使用 APA 的一些步骤记录如下： 本次实验中使用的是 LLVM 3.3 和 poolalloc r192788 下载 LLVM 3.3 1 svn co http://llvm.org/svn/llvm-project/llvm/branches/release_33/ llvm3.3 下载 clang 3.3 到 llvm3.3/tools 12 cd llvm3.3/tools/svn co http://llvm.org/svn/llvm-project/cfe/branches/release_33/ clang 由于我在编译 Compiler RT 的时候发生错误，因此这儿不安装 Compiler RT 下载 poolalloc 到 llvm3.3/projects 1 svn co http://llvm.org/svn/llvm-project/poolalloc/trunk/ poolalloc 将 poolalloc 还原到版本 192788 1 svn update -r 192788 修复 poolalloc 192788 中的一些bug, 调用 -poolalloc pass 时发生段错误： 12 cd /path/to/poolallocvi include/poolalloc/Heuristic.h 为 class Heuristic 添加成员方法 setGraphs: 123 void setGraphs(DataStructures ds)&#123; Graph = ds;&#125; PoolAllocate.cpp 1 vi lib/PoolAllocate/PoolAllocate.cpp 在 line 1252: CurHeuristic-&gt;getLocalPoolNodes (F, LocalNodes); 前插入CurHeuristic-&gt;setGraphs(Graphs); 使用 ninja 进行编译安装 在 llvm3.3 同目录下： 1234 mkdir build;cd build;cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_INSTALL_PREFIX=/opt/llvm3.3 ../llvm3.3ln -s ../build/compile_commands.json .. 编译： 1 ninja 安装： 1 sudo ninja install 查看 poolalloc 是否安装成功： 12 cd /opt/llvm3.3/libfind .|grep poolmalloc 如果能看到poolmalloc的库poolalloc.a、poolalloc.so, 则证明安装成功. ninja 安装方法 1234 git clone git://github.com/martine/ninja.gitcd ninja./bootstrap.pysudo cp ninja /usr/local/bin/ 使用 DSA 1)查看与dsa相关的选项 1 opt -load /opt/llvm3.3/lib/LLVMDataStructure.so -load /opt/llvm3.3/lib/poolalloc.so --help|grep dsa 2)使用dsa(以dsa-local分析为例) 1 opt -load /opt/llvm3.3/lib/LLVMDataStructure.so -load /opt/llvm3.3/lib/poolalloc.so -analyze --dsa-local test.ll 使用poolalloc 1234567 clang -emit-llvm -c test.c;/opt/llvm3.3/bin/opt -load /opt/llvm3.3/lib/LLVMDataStructure.so -load /opt/llvm3.3/lib/poolalloc.so -poolalloc test.o &gt; test.o1;/opt/llvm3.3/bin/llvm-dis test.o/test.o1;//查看前后不同：diff test.o.ll test.o1.ll//生成可执行文件：llc test.o1.ll;gcc /opt/llvm3.3/lib/libpoolalloc_rt.a test.o1.s; Slide 下面，附上做报告时用的slide: Automatic Pool Allocation"},{"title":"记一次意外的移位错误","date":"2018-06-05T04:37:40.000Z","path":"2018/06/05/An-unexpected-shifting-error/","text":"移位错误 前天晚上，刷51Nod上面的一个题：通过矩阵快速幂计算斐波那契数列，结果发生了一个意想不到的错误，这件事也告诉了我一个道理： 当代码出错的时候，不要轻易去怀疑工具的问题，而要去想 99% 的可能性是自己的代码有问题. 下面是最开始的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142 #include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll MAXV = 1e9 + 9;ll base[2][2] = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;ll Reult[2][2] = &#123;&#123;1,0&#125;, &#123;0,1&#125;&#125;;void multi(ll A[][2], ll B[][2])&#123; ll tmp[2][2] = &#123;&#123;0, 0&#125;, &#123;0, 0&#125;&#125;; for(int i = 0; i != 2; ++i)&#123; for(int j = 0; j != 2; ++j)&#123; for(int k = 0; k != 2; ++k)&#123; tmp[i][j] += (A[i][k] * B[k][j]) % MAXV; tmp[i][j] %= MAXV; &#125; &#125; &#125; for(int i = 0; i != 2; ++i)&#123; for(int j = 0; j != 2; ++j)&#123; A[i][j] = tmp[i][j]; &#125; &#125;&#125;void QuickPow(int N)&#123; while (N)&#123; if (N&amp;1)&#123; multi(Reult, base); &#125; multi(base, base); N &gt;&gt;= 1; &#125;&#125;int main()&#123; ll n; cin &gt;&gt; n; QuickPow(n-1); cout &lt;&lt; Reult[0][0] &lt;&lt;endl; return 0;&#125; 提交之后，有一部分 test cases 发生错误，而且居然还出现超时.之后查看了一下题目，发现是因为函数 QuickPow 的参数是 int 型，而需要计算的数列的项最大是 10^18，因此，导致发生了溢出，之后，将参数由 int 改为 long long 就好了： 123456789101112131415161718192021222324252627282930313233343536373839404142 #include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll MAXV = 1e9 + 9;ll base[2][2] = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;ll Reult[2][2] = &#123;&#123;1,0&#125;, &#123;0,1&#125;&#125;;void multi(ll A[][2], ll B[][2])&#123; ll tmp[2][2] = &#123;&#123;0, 0&#125;, &#123;0, 0&#125;&#125;; for(int i = 0; i != 2; ++i)&#123; for(int j = 0; j != 2; ++j)&#123; for(int k = 0; k != 2; ++k)&#123; tmp[i][j] += (A[i][k] * B[k][j]) % MAXV; tmp[i][j] %= MAXV; &#125; &#125; &#125; for(int i = 0; i != 2; ++i)&#123; for(int j = 0; j != 2; ++j)&#123; A[i][j] = tmp[i][j]; &#125; &#125;&#125;void QuickPow(ll N)&#123; while (N)&#123; if (N&amp;1)&#123; multi(Reult, base); &#125; multi(base, base); N &gt;&gt;= 1; &#125;&#125;int main()&#123; ll n; cin &gt;&gt; n; QuickPow(n-1); cout &lt;&lt; Reult[0][0] &lt;&lt;endl; return 0;&#125; 当输入的数过大时，前一个程序由于发生溢出导致计算结果不对我能理解，但是有时候会卡我就无法理解了，讲道理不应该啊，由于两个程序除了一个参数类型之外其他地方完全相同，所以我也就没有怀疑是程序的逻辑出了问题，反而去怀疑是编译器的问题.对目标程序进行反汇编，也没发现什么不对劲的地方，唯一的区别就是前者用的是一个 32 位寄存器传参，后者用的是一个 64 位寄存器传参. 昨天，我去向编译原理老师请教，还在想自己会不会发现了一个天大的编译器错误.当老师给我指出错误的时候，突然觉得无比尴尬，自己宛如一个智障. 错误原因如下： 在C/C++中，无符号数移位是逻辑移位，而有符号数移位是算术移位.我在函数中使用了移位运算，因此，当溢出变为负数之后，我们知道，计算机中数的表示都是补码，负数的符号位是 1 ，因此，算术移位右移时高位补符号位就是补 1，所以导致 N 永远不会变为 0，while 循环永远不会结束，程序自然就卡住了. 看下面一个例子： 从上面例子可以看出，有符号移位是算术移位，右移时高位补符号位. 逻辑移位与算术移位 顺便复习一下逻辑移位和算术移位： 逻辑移位 无论左移还是右移，都是补 0. 算术移位 左移：低位补 0右移：高位补符号位"},{"title":"如何通过命令行调节音量","date":"2018-03-11T14:31:20.000Z","path":"2018/03/11/How-to-adjust-volume-in-command-line/","text":"直接使用命令： 1 amixer set Master 100% : 调到最大，参数范围是 0% ~ 100 % 或输入： 1 alsamixer 运行该命令后将会进入命令行图形界面，从而可调节音量。"},{"title":"C++中的关联容器","date":"2018-03-11T06:47:30.000Z","path":"2018/03/11/Summary-of-Associative-Container-in-C-plus-plus/","text":"关联容器(Associative containers)支持通过键来高效地查找和读取元素。两个基本的关联容器类型是 map, set。 本文主要是对 C++ 中基本的关联容器 map, set 中的类型和支持的操作进行总结。 关联容器支持很多顺序容器也提供的相同操作,此外,还提供管理或使用键的特殊操作。 关联容器类型 pair 类型 在头文件 utility 中定义。 pair 类型提供的操作, T1, T2, 为类型，如 pair&lt;string, vector&lt;int&gt; &gt; line; pair 类型的使用相当繁琐,因此,如果需要定义多个相同的 pair 类型对象,可考虑利用 typedef 简化其声明。 与其他标准库类型不同,对于 pair 类,可以直接访问其数据成员:其成员都是仅有的,分别命名为 first 和 second。只需使用普通的点操作符——成员访问标志即可访问其成员。 关联容器 关联容器共享大部分——但并非全部——的顺序容器操作。关联容器不提供front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 map 容器 map 类型通常可理解为关联数组。同样，要使用 map 类型，也需要包含相应的头文件。 map 的构造函数： 对于键类型,唯一的约束就是必须支持 &lt; 操作符,至于是否支持其他的关系或相等运算,则不作要求。 map 类定义的类型 对 map 类型迭代器解引用，会得到一个 pair 类型。 给 map 添加元素 通过下标：下标为键，如果没找到，则添加键值对。使用下标访问 map 与使用下标访问数组或 vector 的行为截然不同:用下标访问不存在的元素将导致在 map 容器中添加一个新元素,它的键即为该下标值。 在 map 中，迭代器返回 value_type 类型的值——包含 const key_type 和mapped_type 类型成员的 pair 对象;下标操作符则返回一个 mapped_type 类型的值。 对于 map 容器,如果下标所表示的键在容器中不存在,则添加新元素，而值进行默认初始化。 例如，利用 map 来统计输入单词数的简单方法： 12345678910111213141516 #include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; map&lt;string, int&gt; words; string word; while (cin &gt;&gt; word)&#123; ++words[word]; &#125; for (map&lt;string, int&gt;::iterator iter = words.begin(); iter != words.end(); ++iter)&#123; cout &lt;&lt; iter-&gt;first &lt;&lt;\"\\t\" &lt;&lt; iter-&gt;second &lt;&lt;endl; &#125; return 0;&#125; map 的 insert 操作 不修改map对象的查询操作 m.count(k) : 返回 m 中 k 出现的次数 m.find(k) : 如果 m 中存在按 k 索引的元素，则返回指向该元素的迭代器，否则，返回超出末端迭代器。 map 的删除操作 map对象的遍历 同样提供 begin, end 运算，以生成用于遍历整个容器的迭代器。 set 容器 set 是键的集合，支持大部分前面的操作，但不支持下标操作。set 支持的操作基本与 map 相同。set 中的键和 map 中的一样，只能做读操作，不能做写操作。 multimap 和 multiset 类型 multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同,只有一个例外:multimap 不支持下标运算。 返回迭代器的关联容器操作"},{"title":"C++中三种顺序容器的总结","date":"2018-03-11T03:51:30.000Z","path":"2018/03/11/Summary-of-Sequential-Container-in-C-plus-plus/","text":"在 C++ 中，标准库提供了三种顺序容器：vector, list, deque，还有三种顺序容器适配器：stack, queue, priority_queue，要使用这些容器，需要在源程序中包含对应的头文件，如 include&lt;vector&gt;。本文主要总结容器的操作。 容器类型： vector: 支持快速随机访问（顺序存储） list : 支持快速插入、删除（非顺序存储） deque : 双端队列 stack : 后进先出堆栈 queue : 先进先出队列 priority_queue : 有优先级管理的队列 容器构造函数 迭代器 每种容器类型都提供若干共同工作的迭代器类型。与容器类型一样,所有迭代器具有相同的接口:如果某种迭代器支持某种操作,那么支持这种操作的其他迭代器也会以相同的方式支持这种操作。 1 container&lt;elemtype&gt;::iterator iter; //声明一个迭代器 所有容器均支持的迭代器操作： 12345 *iter 返回迭代器 iter 所指向的元素的引用iter-&gt;mem 对 iter 进行解引用,获取指定元素中名为 mem 的成员。等效于(*iter).mem++iter/iter++ : 给 iter 加 1,使其指向容器里的下一个元素--iter/iter-- : 给 iter 减 1,使其指向容器里的前一个元素iter1 == iter2/iter1 != iter2 : 比较两个迭代器是否相等(或不等)。当两个迭代器指向同一个容器中的同一个元素,或者当它们都指向同一个容器的超出末端的下一位置时,两个迭代器相等 另外，vector 和 deque 的迭代器还提供额外的运算： 123 iter + n / iter - n : 在迭代器上加(减)整数值 n,将产生指向容器中前面(后面)第 n个元素的迭代器。新计算出来的迭代器必须指向容器中的元素或超出容器末端的下一位置iter1 += iter2 / iter1 -= iter2&gt;, &gt;=, &lt;, &lt;= 操作符 以上运算符仅适用于 vector 和 deque 的迭代器，因为这两种容器是顺序存储的，能够为元素提供快速，随机的访问它们确保可根据元素位置直接有效地访问指定的容器元素。这两种容器都支持通过元素位置实现的随机访问,因此它们的迭代器可以有效地实现算术和关系运算。 迭代器范围 左闭右开：[first, last) 编程意义： 当 first 与 last 相等时,迭代器范围为空; 当 first 与不相等时,迭代器范围内至少有一个元素,而且 first 指向该区间中的第一元素。此外,通过若干次自增运算可以使 first 的值不断增大,直到 first == last 为止。 容器定义的类型别名 容器的begin和end操作 另外，每个操作都有两个版本：const 和 非const，取决于容器的类型是 const 还是 非const 添加元素 正如上图所示，push_front 仅适用于 list 和 deque 。 另外，需要注意的是，插入元素之后可能会使之前的迭代器失效，需要谨慎考虑。 容器大小操作 访问元素 vector, deque 是顺序存储的，因此可通过下标访问。 删除元素 赋值与交换 swap 相当于先删除，然后再赋值，使用swap可以节省删除的成本。 容器自增长 对于大部分应用,使用 vector 容器是最好的。原因在于,标准库的实现者使用这样内存分配策略:以最小的代价连续存储元素。由此而带来的访问元素的便利弥补了其存储代价。 为了使 vector 容器实现快速的内存分配,其实际分配的容量要比当前所需的空间多一些。vector 容器预留了这些额外的存储区,用于存放新添加的元素。于是,不必为每个新元素重新分配容器。所分配的额外内存容量的确切数目因库的实现不同而不同。比起每添加一个新元素就必须重新分配一次容器,这个分配策略带来显著的效率。 capacity 和 reserve 成员 12 c.capacity() : 返回容器容量, capacity &gt;= sizec.reserve(n) : 将容器的预留量设为 n string 类型 在某些方面，可以将 string 看成是字符的容器，因此，大多数的容器操作也适合于 string 。 string 特有的插入和删除操作 子串操作 append/replace append/replace 的参数 args string 查找operator args string compare operator 容器适配器 除了顺序容器,标准库还提供了三种顺序容器适配器:queue、priority_queue 和 stack。 通用操作和类型： stack queue/priority queue"},{"title":"如何在 Linux 命令行中更改屏幕亮度","date":"2018-03-08T15:28:59.000Z","path":"2018/03/08/How-to-Change-Brightness-in-Linux-Command-Line/","text":"寒假的时候，笔记本又坏了，这次比前面两次还要更严重，直接开不了机。于是好了，一个寒假在家什么也没干。到学校的第一天就把电脑送去维修，今天才拿回来。好吧，这已经是第三次维修了。取电脑的时候，我问维修的工程师，这次是哪儿坏了。他回答，主板坏了。我说，主板不是刚刚才换了没多久的吗……他说，又坏了。我竟无言以对。 电脑确实修好了。不过拿回来以后，发现屏幕怎么这么暗，然后我通过桌面设置调节，竟然无法调节，即使调到最大也没变化。我心里一凉，是不是硬件上哪儿又坏了。我切回 Windows 系统，惊喜的发现，亮度是可以调节的，那就好办了，既然是软件的问题，咱就可以自己解决。桌面无法调节，那就直接在命令行手动设置亮度值。 首先，查看屏幕亮度的最大值： 12 fenglv@segmentfault:~$ cat /sys/class/backlight/intel_backlight/max_brightness 7500 输出结果表明，亮度最大值为 7500 ，因此，可以在 0 ~ 7500 之间。 然后，再查看一下当前的亮度值： 12 fenglv@segmentfault:~$ cat /sys/class/backlight/intel_backlight/brightness 957 当前亮度为 957，这 TM 屏幕能不暗吗？ 如果要更改屏幕亮度，那么只需手动更改 /sys/class/backlight/intel_backlight/brightness 文件内容即可。至此，你就应该知道怎么办了。 设置启动时的默认亮度 如果要设置电脑启动时候的默认亮度，那么，只需要在文件 /etc/rc.local exit 0 前面加上如下一行内容： 1 echo 5500 &gt; /sys/class/backlight/intel_backlight/brightness 如上，我把启动时候的亮度值设置为 5500。 自定义亮度 另外，为了每次方便的设置亮度，我写了一个小脚本，并命名为 chbgn ，然后增加执行权限，并放在 $HOME/bin 目录下，这样，每次要设置亮度的时候就可以很方便的进行交互式设置了，体验不比图形界面差。脚本内容如下： 1234567891011121314151617181920212223 #!/usr/bin/env bash# 一个用于调节屏幕亮度的脚本if [[ \"$USER\" != \"root\" ]]; then echo \"The program must be executed under the root user.\"; exit 0;fiecho -n \"Please input the brightness value(0 ~ 7500): \";read int;value=`expr $int + 0`;expr $value &amp;&gt;/dev/null;if [ $? -ne 0 ]; then echo \"Input must be an integer. Change brightness failed!!!\" exit 0;fiif [ $value -ge 0 ] &amp;&amp; [ $value -le 7500 ]; then echo $value &gt; /sys/class/backlight/intel_backlight/brightness echo \"The brightness of the Computer has successfully changed ^_^\" exit 0;fiecho \"Input must be an integer betwwen 0 and 7500. Change brightness failed!!!\";exit 0;"},{"title":"解决 /Usr/lib/x86_64-Linux-gnu/libstdc++.so.6 Version GLIBCXX_3.4.22' Not Found 的问题","date":"2017-12-21T12:48:42.000Z","path":"2017/12/21/fix-the-problem-of-that-usr-lib-x86-64-linux-gnu-libstdc-so-6-version-GLIBCXX-3-4-22-not-found/","text":"今天升级了一下 OpenCv，升级完之后，却出问题了，执行import cv2 报下面的错误： 123 Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ImportError: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.22' not found (required by /home/fenglv/FILE/anaconda3/lib/python3.6/site-packages/../../libopencv_objdetect.so.3.3) 意思是导入库所需要的 libstdc++.so.6 没有找到，然后，我执行 locate libstdc++.so.6 命令，发现这个库是存在的啊。上网查了一下发现原本是因为升级了 OpenCv 之后需要更高版本的库，而当前的版本过低，所以才出错。 执行命令 strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX ，果然，显示的版本低于3.4.22 。 之后找到解决办法： 下载最新版的libstdc++，点击下载，然后解压缩： 1 ar -x libstdc++6_8-20171213-1_amd64.deb &amp;&amp; tar xvf data.tar.xz 之后，直接将解压出来的/usr/x86_64-linux-gnu/libstdc++.so.6.25 复制到/usr/lib/x86_64-linux-gnu/ 下，当然，为了保险起见，你也可以先备份一下原文件。然后 123 cd /usr/bin/lib/x86_64-linux-gnu/sudo rm lidstdc++.so.6sudo ln libstdc++.so.6.25 libstdc++.so.6 现在，你再次执行命令strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX ，显示的版本号就如下： 123456789101112131415161718192021222324252627 GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_3.4.14GLIBCXX_3.4.15GLIBCXX_3.4.16GLIBCXX_3.4.17GLIBCXX_3.4.18GLIBCXX_3.4.19GLIBCXX_3.4.20GLIBCXX_3.4.21GLIBCXX_3.4.22GLIBCXX_3.4.23GLIBCXX_3.4.24GLIBCXX_3.4.25GLIBCXX_DEBUG_MESSAGE_LENGTH 至此，问题解决～"},{"title":"在 Ubuntu 中如何阻止一个包升级","date":"2017-12-17T07:27:06.000Z","path":"2017/12/17/How-to-hold-a-package-in-Ubuntu/","text":"阻止升级： 1 sudo echo \"package hold\" | sudo dpkg --set-selections package 为包的名字。 如果要取消，则执行命令： 1 sudo echo \"package install\" | sudo dpkg --set-selections"},{"title":"Xrandr 命令 的一些使用","date":"2017-12-09T16:53:10.000Z","path":"2017/12/10/Linux-commands-of-xrandr/","text":"设置屏幕分辨率： 123 xrandr : 显示系统支持的所有分辨率xrandr -s 0 : 设置为系统默认分辨率xrandr -s arg : 设置具体分辨率,如 xrandr -s 1024x768 双屏设置： 123456 xrandr : 显示所有显示屏设备名称xrandr --output DEV2 --same-as DEV1 --auto : 设置双屏显示相同的内容, --auto 为最高分辨率，可通过 --mode arg 设置分辨率xrandr --output DEV2 --right-of DEV1 --auto : 右侧扩展xrandr --output DEV2 --left-of DEV1 --auto : 左侧扩展xrandr --output DEV --off : 关闭显示器xrandr --output DEV --mode arg : 双屏分别设置分辨率"},{"title":"使用 Tensorflow 实现神经网络","date":"2017-11-12T04:09:50.000Z","path":"2017/11/12/an-introduction-to-implementing-neural-networks-using-tensorflow/","text":"简介 如果你一直关注数据科学/机器学习，那么你肯定知道目前深度学习和神经网络非常流行。许多组织/公司都想要雇佣精通深度学习技能的人。从商业竞争到开源项目和支付高额薪水，人们在尝试一切可能的方法来挖掘这一有限的人才。自我驱动的工程师正被汽车工业中的利器所追逐，因为汽车工业正处于近几十年来最大的破坏边缘！ 如果你对深度学习的前景感到兴奋，但还没有开始你的旅途，那么我将会开启你的旅程。从这篇文章开始，我将会写一系列关于深度学习的文章，包括最受欢迎的深度学习库和它们的实现。 在这篇文章中，我将会向你介绍 Tensorflow。读完这篇文章以后，你将会了解神经网络的应用，并且能够使用 TensorFlow 来解决实际生活中的问题。阅读本文前，你需要了解神经网络的基本知识并且对编程比较熟悉。虽然本文中使用的语言是 Python，但我关注得更多的是概念，并且尽可能保持语言的不可知性。 让我们开始吧！ 何时使用神经网络？ 神经网络成为人们的关注点已经有很长的一段时间了。如果你想了解关于神经网络和深度学习的更详细的解释，请阅读这篇文章。它的 “depper” 版本在图像识别、语音和自然语言处理等许多领域都取得了巨大的突破。 最主要的问题是什么时候使用神经网络，什么时候不用？这个领域就像现在的金矿一样，每天都会有许多新的发现。为了成为一个“淘金热”分子，你需要记住下面这些事情： 首先，神经网络需要清晰而详实的数据（主要是大数据）来进行训练。如果把神经网络想象成一个孩子，他首先需要观察他的父母如何走路，然后尝试独立行走，用他的每一步，学会如何来完成一个特定的任务。他可能会跌倒几次，但经过几次失败的尝试，他便学会了如何走路。如果你不让他自己尝试，那么他可能永远也不能学会走路。你给他接触的越多，那么他就会学得越好。 使用神经网络来处理一些复杂的问题，比如图像处理是明智的。神经网络属于一类称为表示学习算法的算法类。这些算法将复杂的问题分解成简单的形式，从而使它们能够理解（或“表示“）。就像你在吃东西的时候，需要先把食物嚼碎，然后才咽下。这比传统（非表示学习）算法更加困难。 什么时候你能够拥有合适的神经网络来解决问题？每个问题都有它的困难之处。所以，数据决定了解决问题的方式。比如，如果问题是序列生成，那么递归神经网络更加合适。然而，如果是图像相关的问题，那么改用卷积神经网络会更好。 最后，但不是不重要，硬件需求对于运行一个深度神经网络模型是至关重要的。神经网络模型在很早之前就有了，但是在近些年才开始活跃起来，主要原因就是计算资源更好，更强大了。如果你想用神经网络来解决现实生活中的问题，请准备购买一些高端的硬件设备。 使用神经网络来解决问题的通常手段 神经网络是一种特殊的机器学习（ML）算法。就像每一个机器学习算法一样，你需要按照通常的机器学习工作流程来进行数据预处理，模型建立和模型评估。为了简单起见，我在下面列出了一个处理神经网络问题的清单： 思考一下，使用神经网络算法来处理该问题是否比用传统算法更好（参考上面章节的清单） 调查一下，待解决的问题使用哪种神经网络更适合 使用你选择的语言/库来定义神经网络结构 将数据转化为正确的格式并进行数据划分 根据你的需要对数据进行预处理 添加数据来增大数据量从而更好的训练模型 将数据”喂给”神经网络进行训练 训练并监测训练过程中的变化和验证数据集的变化 测试你的模型，并将它保存下来以便将来使用 在这篇文章中，我将重点放在图像数据上。所以在开始探讨 TensorFlow 之前，让我们先理解一下图像数据。 图像数据以及常用于解决图像问题的库 图像数据通常以三维数据的形式排序，每一维分别代表高、宽和颜色通道。比如，此时你在你的电脑上截一张图，它将会先转化为一个三维数组，然后再压缩成 .jpeg 或 .png 文件格式。 虽然这些图像对于人类来说很容易理解，但是计算机却很难理解它们。这种现象被称为“语义鸿沟”。我们的大脑能够在几秒钟的时间内看到图像并理解完整的图像，然而，计算机却只是把图像看成一组数字。所以问题是如何向计算机解释图片？ 在早期时候，人们试图将图像分解成机器“可理解”的形式，就像一个模板一样。比如，人脸总是有一种特定的结构，这种结构在每个人中都有一定的保留，例如眼睛、鼻子或脸的形状。但是这种方法很乏味，因为当要识别的对象数量增加时，“模板”就不能保存了。 快速前进到 2012 年，一个深度神经网络赢得了 ImageNet 挑战，这是一个根据自然场景来识别对象的著名挑战。在所有随即到来的 ImageNet 挑战中，它持续占领统治地位，从而证明了用它来解决图像问题的有用性。 所以，人们通常使用哪种语言（库）来解决图像识别问题呢？在一个最近的调查中，我发现绝大多数受欢迎的深度学习库都有 Python 接口，紧跟着的是 Lua、Java 和 Matlab 。下面是一些最受欢迎的库： Caffe DeepLearning4j TensorFlow Theano Torch 现在，你已经知道了一张图像是如何存储的，并且知道了常用的库。下面，让我们来看一下 TensorFlow 能够为我们提供什么。 TensorFlow 是什么？ 我们先看一下官方的定义： “TensorFlow 是一个使用数据流图来进行数值计算的开源软件库。图中的节点表示数学运算，而图中的边表示在节点之间进行传递的多维数据数组（又叫做张量）。灵活的架构允许你在桌面、服务器或移动设备上通过一个单一的 API 使用一个或多个 CPU 或 GPU 部署进行计算。” 如果这听起来很让人迷糊，别担心，下面是我的简单定义：你可以简单的把 TensorFlow 看成一个扭曲的 numpy。如果你过去接触过 numpy，那么理解 TensorFlow 就非常简单了。numpy 和 TensorFlow 之间最主要的区别就是 TensorFLow 使用一种惰性的编程范式。它首先搭建一个把所有操作都定义好了的图，然后，当一个“会话“被调用时，它就会开始”运行“这个图。这个图是可扩展的，只需要改变内部张量（又叫做多维数组）的数据表示即可。构建计算图可以看作是使用 TensorFlow 的主要工作。如果想了解更多关于计算图的数学组成，请阅读这篇文章。 我们很容易把 TensorFlow 归为一个神经网络库，但它不仅仅是这样。的确，它是一个非常强大的神经网络库。但是，它还能够做更多的事情。你可以使用它来构建其他机器学习算法，比如决策树或 K-近邻算法。你可以用它来完成任何你通常用 numpy 来完成的事情。因此它又被形象地称为 “NumPy 类固醇”。 使用 TensorFlow 的优点有： 它具有一个直观的结构。顾名思义它具有”张量流“。你可以轻松的可视化图的每一个部分。 对于分布式计算，很容易在 CPU/GPU 上面进行训练。 平台灵活性。你可以在任何地方运行你的模型，移动设备、服务器或 PC 。 一个典型的 TensorFlow ”流“ 每个库都有自己的”实现细节“，即一种遵循其编码范式的编写方式。例如，在实现 scikit-learn 时，你首先创建一个需要的算法对象，然后构建一个训练模型，进而对测试集进行预测，看起来就像下面这样： 123456 # 定义机器学习算法的 hyperparamtersclf = svm.SVC(gamma=0.001, C=100.)# 训练clf.fit(X, y)# 测试clf.predict(X_test) 正如前面说过的，TensorFlow 遵循一种惰性的编程范式。在 TensorFlow 中运行一个程序的通常工作流如下： 构建一个计算图，它可以是 TensorFlow 支持的任意一种数学操作。 初始化变量，编译之前定义的变量 创建会话，这是魔法开始的地方 在会话中运行图，编译后的图传到会话中，然后会话开始执行 关闭会话 TensorFlow 中使用的几个术语： 1 占位符：一种将数据输入图表的方法 1 feed_dict: 一个将数组传递给计算图的字典 让我们写一个小程序并添加两个数字！ 12345678910111213141516171819 # 导入 TensorFlowimport tensorflow as tf# 搭建计算图a = tf.placeholder(tf.int16)b = tf.placeholder(tf.int16)addition = tf.add(a, b)# 初始化变量init = tf.initialize_all_variables()# 创建会话并运行图with tf.Session() as sess: sess.run(init) print \"Addition: %i\" % sess.run(addition, feed_dict=&#123;a: 2, b: 3&#125;)# 关闭会话sess.close() 在 TensorFlow 中实现神经网络 注意：我们可以使用不同的神经网络结构来解决问题，但为了简单起见，在这儿，我们致力于一个前馈多层感知机的深层实现。 让我们首先记住我们学到的关于神经网络的知识。 一个典型的神经网络实现如下： 定义需要编译的神经网络结构 将数据传输到模型 在后台，数据首先被分成批，以便进行摄取，首先对批数据进行预处理，扩充，然后送入神经网络进行训练 神经网络模型进行增量训练 在特定时间显示准确率 训练过后，保存模型，以便日后再次使用 用新数据测试模型并检查它是如何执行的 在这儿，我们解决深度学习实践问题 - 识别数字。让我们先看一下问题陈述。 这是一个图像识别问题，从一个给定的 28x28 的图像中识别数字。我们将所有图像的一个子集用于训练，剩余部分用于测试模型。首先，下载训练和测试文件。数据集包含一个所有图像的压缩文件，以及名字和训练/测试图像相对应的 train.csv 和 test.csv 文件。在数据集中没有提供任何额外的特征，只提供了 .png 格式的原始图像。 正如你所知道的，我们将使用 TensorFlow 来搭建一个神经网络模型。所以你首先需要在你的系统上安装 TensorFlow。请参考官方安装指南，根据你的系统进行安装。 我们将按照上面描述的步骤来搭建神经网络。首先，使用 Python 2.7 核来创建一个 Jupyter notebook，后续步骤如下： 首先导入所有需要的模块： 1234567 # pylab inlineimport osimport numpy as npimport pandas as pdfrom scipy.misc import imreadfrom sklearn.metrics import accuracy_scoreimport tensorflow as tf 让我们设置一个种子值，从而我们能够控制模型的随机性 123 # To stop potential randomnessseed = 128rng = np.random.RandomState(seed) 第一步是设置目录路径，以便安全保存！ 12345678 root_dir = os.path.abspath('../..')data_dir = os.path.join(root_dir, 'data')sub_dir = os.path.join(root_dir, 'sub')# check for existenceos.path.exists(root_dir)os.path.exists(data_dir)os.path.exists(sub_dir) 现在，让我们读入数据集。数据集是 .csv 文件格式的，并且有一个伴有合适标签的名字。 123456 train = pd.read_csv(os.path.join(data_dir, 'Train', 'train.csv'))test = pd.read_csv(os.path.join(data_dir, 'Test.csv'))sample_submission = pd.read_csv(os.path.join(data_dir, 'Sample_Submission.csv'))train.head() 文件名 标签 0 0.png 4 1 1.png 9 2 2.png 1 3 3.png 7 4 4.png 3 让我们看一下我们的数据长什么样！读取图片并显示： 12345678 img_name = rng.choice(train.filename)filepath = os.path.join(data_dir, 'Train', 'Images', 'train', img_name)img = imread(filepath, flatten=True)pylab.imshow(img, cmap='gray')pylab.axis('off')pylab.show() 上面的图片表示为 numpy 数组，就是下面这样： 为了使数据操作更简单，我们把所有图像存为 numpy 数组： 1234567891011121314151617 temp = []for img_name in train.filename: image_path = os.path.join(data_dir, 'Train', 'Images', 'train', img_name) img = imread(image_path, flatten=True) img = img.astype('float32') temp.append(img) train_x = np.stack(temp)temp = []for img_name in test.filename: image_path = os.path.join(data_dir, 'Train', 'Images', 'test', img_name) img = imread(image_path, flatten=True) img = img.astype('float32') temp.append(img) test_x = np.stack(temp) 因为这是一个典型的机器学习问题，为了测试模型的正常功能，我们需要创建一个验证集。我们将数据按 7:3 分为训练集和验证集。 1234 split_size = int(train_x.shape[0]*0.7)train_x, val_x = train_x[:split_size], train_x[split_size:]train_y, val_y = train.label.values[:split_size], train.label.values[split_size:] 现在，在程序中定义一些我们在后面将会用到的有用函数： 123456789101112131415161718192021222324252627 def dense_to_one_hot(labels_dense, num_classes=10): \"\"\"Convert class labels from scalars to one-hot vectors\"\"\" num_labels = labels_dense.shape[0] index_offset = np.arange(num_labels) * num_classes labels_one_hot = np.zeros((num_labels, num_classes)) labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1 return labels_one_hotdef preproc(unclean_batch_x): \"\"\"Convert values to range 0-1\"\"\" temp_batch = unclean_batch_x / unclean_batch_x.max() return temp_batchdef batch_creator(batch_size, dataset_length, dataset_name): \"\"\"Create batch with random samples and return appropriate format\"\"\" batch_mask = rng.choice(dataset_length, batch_size) batch_x = eval(dataset_name + '_x')[[batch_mask]].reshape(-1, input_num_units) batch_x = preproc(batch_x) if dataset_name == 'train': batch_y = eval(dataset_name).ix[batch_mask, 'label'].values batch_y = dense_to_one_hot(batch_y) return batch_x, batch_y 现在，到了主要部分。让我们首先来定义神经网络的结构。我们定义一个三层神经网络：输入层、隐含层和输出层。输入层和输出层的神经元数目是固定的，因为输入就是一个 28x28 的图像，输出就是一个 10x1 的表示类别的向量。在隐含层中，我们设置 500 个神经元，这个数目可以根据你的需要来设置。同时，我们也需要对其余变量赋值。阅读神经网络基础这篇文章来深入了解它是如何工作的。 123456789101112131415161718192021222324252627 ### set all variables# number of neurons in each layerinput_num_units = 28*28hidden_num_units = 500output_num_units = 10# define placeholdersx = tf.placeholder(tf.float32, [None, input_num_units])y = tf.placeholder(tf.float32, [None, output_num_units])# set remaining variablesepochs = 5batch_size = 128learning_rate = 0.01### define weights and biases of the neural network (refer this article if you don't understand the terminologies)weights = &#123; 'hidden': tf.Variable(tf.random_normal([input_num_units, hidden_num_units], seed=seed)), 'output': tf.Variable(tf.random_normal([hidden_num_units, output_num_units], seed=seed))&#125;biases = &#123; 'hidden': tf.Variable(tf.random_normal([hidden_num_units], seed=seed)), 'output': tf.Variable(tf.random_normal([output_num_units], seed=seed))&#125; 现在，开始创建神经网络计算图： 1234 hidden_layer = tf.add(tf.matmul(x, weights['hidden']), biases['hidden'])hidden_layer = tf.nn.relu(hidden_layer)output_layer = tf.matmul(hidden_layer, weights['output']) + biases['output'] 我们也需要定义神经网络的损失（cost）： 1 cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output_layer, y)) 设置优化算法，比如后向传播算法（BP 算法）。在这儿，我们使用 Adam，这是一个高效的梯度下降算法的变种。在 TensorFlow 中还有许多可用的优化算法（参考这儿） 1 optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost) 定义好神经网络结构之后，初始化所有变量： 1 init = tf.initialize_all_variables() 现在，创建一个会话，在会话中运行我们的神经网络。同时，使用我们已经创建好的验证集来验证我们的模型： 12345678910111213141516171819202122232425262728293031 with tf.Session() as sess: # create initialized variables sess.run(init) ### for each epoch, do: ### for each batch, do: ### create pre-processed batch ### run optimizer by feeding batch ### find cost and reiterate to minimize for epoch in range(epochs): avg_cost = 0 total_batch = int(train.shape[0]/batch_size) for i in range(total_batch): batch_x, batch_y = batch_creator(batch_size, train_x.shape[0], 'train') _, c = sess.run([optimizer, cost], feed_dict = &#123;x: batch_x, y: batch_y&#125;) avg_cost += c / total_batch print \"Epoch:\", (epoch+1), \"cost =\", \"&#123;:.5f&#125;\".format(avg_cost) print \"\\nTraining complete!\" # find predictions on val set pred_temp = tf.equal(tf.argmax(output_layer, 1), tf.argmax(y, 1)) accuracy = tf.reduce_mean(tf.cast(pred_temp, \"float\")) print \"Validation Accuracy:\", accuracy.eval(&#123;x: val_x.reshape(-1, input_num_units), y: dense_to_one_hot(val_y)&#125;) predict = tf.argmax(output_layer, 1) pred = predict.eval(&#123;x: test_x.reshape(-1, input_num_units)&#125;) 上面代码的输出如下： 12345678 Epoch: 1 cost = 8.93566Epoch: 2 cost = 1.82103Epoch: 3 cost = 0.98648Epoch: 4 cost = 0.57141Epoch: 5 cost = 0.44550Training complete!Validation Accuracy: 0.952823 为了使用我们的眼睛来测试模型，让我们来看一些它的预测结果： 123456789101112 img_name = rng.choice(test.filename)filepath = os.path.join(data_dir, 'Train', 'Images', 'test', img_name)img = imread(filepath, flatten=True)test_index = int(img_name.split('.')[0]) - 49000print \"Prediction is: \", pred[test_index]pylab.imshow(img, cmap='gray')pylab.axis('off')pylab.show() Prediction is: 8 我们看到模型的性能非常好。现在我们来创建一个子会话： 12345 sample_submission.filename = test.filename sample_submission.label = predsample_submission.to_csv(os.path.join(sub_dir, 'sub01.csv'), index=False) 到现在，我们就把已经训练好的神经网络保存下来了。 TensorFlow 的局限性 尽管 TensorFlow 很强大，但它依旧是一个低级库，打个比方，你可以把它看出一个机器级语言。但是大多数情况下，你需要模块化和高层次的接口，比如 keras 这样的库便能够提供。 TensorFlow 目前仍然在开发中，因此未来还会有很多令人激动的东西到来。 TensorFlow 依赖于你的硬件配置，硬件配置越高越好。 对于许多语言，TensorFlow 还没有 API. TensorFlow 中还有许多东西需要实现，比如 OpenCL 的支持。 上面提到的内容大多数是站在 TensorFlow 开发者的角度的。他们已经制定了一个路线图来说明将来这个库应该如何发展。 TensorFlow vs. 其他库 TensorFlow 是以和 Theano 和 Torch 相似的原则构建的，都是使用数学计算图。但是由于具有分布式计算的支持，TensorFlow 对于解决复杂的问题表现得更好。同时，由于已经支持 TensorFlow 模型的部署（即开源免费），这使得在工业上使用更加容易，对 Deeplearning4j、H2O 和 Turi 这些商业库造成了竞争威胁。TensorFlow 有 Python、C++ 和 Matlab 的 API，接下来可能将要有对其他语言的支持，比如 Ruby 和 R。所以，TensorFlow 正在试图成为具有普遍语言的机器学习库。 接下来往哪走 你已经看到了如何使用 TensorFlow 来建立一个简单的神经网路。这个代码对于来理解如何开始实现 TensorFlow 是有意义的，所以不要小瞧它。但是请记住现实生活需要解决的问题将会更加复杂，你需要稍微修改一下代码。 上面的许多函数能够被抽象出来，以提供无缝的端到端工作流。如果你使用过 scikit-learn，那么你可能知道一个高级库是如何抽象出底层实现，然后给终端用户提供一个更加简单的接口的。虽然 TensorFlow 已经抽象出了大多数的实现，但高级库正在出现，比如 TF-slim 和 TFlearn 。 有用的资源 TensorFlow 官方仓库 Rajat Monga (TensorFlow 技术引导) “TensorFlow for everyone” 视频 一个专用资源列表](https://github.com/jtoy/awesome-tensorflow/#github-projects) 结束语 我希望你觉得这篇文章很有帮助，现在，是时候来进行更多的练习和阅读了。Good luck！如果你使用一个不同的方法/包/库来实现神经网络，那么我很愿意在评论中跟你互动。如果你有什么建议，也请在评论中告知。为了让自己对神经网络的使用更加熟练，请不要忘记尝试解决我们的深度学习练习问题 - 数字识别。 你可以测试你的技能和知识。查看 Live Competitions，来和世界上最优秀的数据科学家进行比赛。 原文链接：https://www.analyticsvidhya.com/blog/2016/10/an-introduction-to-implementing-neural-networks-using-tensorflow/ 翻译：Flynn"},{"title":"在 Linux 中如何通过命令行开启或禁用触摸板","date":"2017-11-02T15:45:10.000Z","path":"2017/11/02/How-to-enable-or-disable-touchpad-in-Linux-with-command-line/","text":"本文将介绍如何在 Linux 中如何使用命令行命令来打开和关闭触摸板。 xinput 首先，需要了解一个工具：xinput 12 xinput is a utility to list available input devices, query informationabout a device and change input device settings. 上面是 man 手册对它的描述。 要通过触摸板开启或关闭触摸板，首先要要获取触摸板的设备 ID 和属性。 我们可以可以先通过 xinput --list 命令查看有哪些输入设备。下面的结果是在我的笔记本上的输出： 123456789101112131415 ⎡ Virtual core pointer id=2 [master pointer (3)]⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)]⎜ ↳ PixArt USB Optical Mouse id=10 [slave pointer (2)]⎜ ↳ DELL0767:00 06CB:7E92 Touchpad id=12 [slave pointer (2)]⎜ ↳ SynPS/2 Synaptics TouchPad id=14 [slave pointer (2)]⎣ Virtual core keyboard id=3 [master keyboard (2)] ↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)] ↳ Power Button id=6 [slave keyboard (3)] ↳ Video Bus id=7 [slave keyboard (3)] ↳ Power Button id=8 [slave keyboard (3)] ↳ Sleep Button id=9 [slave keyboard (3)] ↳ Integrated Webcam id=11 [slave keyboard (3)] ↳ AT Translated Set 2 keyboard id=13 [slave keyboard (3)] ↳ Dell WMI hotkeys id=15 [slave keyboard (3)] ↳ DELL Wireless hotkeys id=16 [slave keyboard (3)] 可以看到，第 4 行输出即为触摸板，后面的 id 即为设备号。 下面，查看触摸板的属性： 123 xinput --list-props 12 ＃或xinput --list-props ‘DELL0767:00 06CB:7E92 Touchpad’ 即使用设备 id 或设备名作为后面的参数均可以。 下面是在我的笔记本上的输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 Device 'DELL0767:00 06CB:7E92 Touchpad': Device Enabled (140): 0 Coordinate Transformation Matrix (142): 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000 Device Accel Profile (263): 1 Device Accel Constant Deceleration (264): 2.500000 Device Accel Adaptive Deceleration (265): 1.000000 Device Accel Velocity Scaling (266): 12.500000 Synaptics Edges (288): 49, 1180, 50, 879 Synaptics Finger (289): 25, 30, 0 Synaptics Tap Time (290): 180 Synaptics Tap Move (291): 67 Synaptics Tap Durations (292): 180, 180, 100 Synaptics ClickPad (293): 1 Synaptics Middle Button Timeout (294): 0 Synaptics Two-Finger Pressure (295): 282 Synaptics Two-Finger Width (296): 7 Synaptics Scrolling Distance (297): 30, 30 Synaptics Edge Scrolling (298): 0, 0, 0 Synaptics Two-Finger Scrolling (299): 1, 1 Synaptics Move Speed (300): 1.000000, 1.750000, 0.129870, 0.000000 Synaptics Off (301): 0 Synaptics Locked Drags (302): 0 Synaptics Locked Drags Timeout (303): 5000 Synaptics Tap Action (304): 2, 3, 0, 0, 1, 3, 2 Synaptics Click Action (305): 1, 3, 0 Synaptics Circular Scrolling (306): 0 Synaptics Circular Scrolling Distance (307): 0.100000 Synaptics Circular Scrolling Trigger (308): 0 Synaptics Circular Pad (309): 0 Synaptics Palm Detection (310): 0 Synaptics Palm Dimensions (311): 10, 200 Synaptics Coasting Speed (312): 20.000000, 50.000000 Synaptics Pressure Motion (313): 30, 160 Synaptics Pressure Motion Factor (314): 1.000000, 1.000000 Synaptics Resolution Detect (315): 1 Synaptics Grab Event Device (316): 0 Synaptics Gestures (317): 1 Synaptics Capabilities (318): 1, 0, 0, 1, 1, 0, 0 Synaptics Pad Resolution (319): 12, 12 Synaptics Area (320): 0, 0, 0, 0 Synaptics Soft Button Areas (321): 614, 0, 761, 0, 0, 0, 0, 0 Synaptics Noise Cancellation (322): 7, 7 Device Product ID (258): 1739, 32402 Device Node (259): \"/dev/input/event15\" 可以看到，第一个属性即为触摸板状态：1 表示开启，0 表示关闭，属性编号为 140。 之后，我们可以使用下面的命令来开启或关闭触摸板： 1234 # 开启触摸板xinput set-prop 12 140 1# 关闭触摸板xinput set-prop 12 140 0 其中，设备 ID 和属性编号也可替换为名字。 但是，每次都使用这个命令会比较麻烦，因此，可以通过一个简单的脚本来实现： 123456789101112 #!/bin/bashif [ \"$1\" == \"on\" ]; then xinput set-prop 12 140 1; echo \"Touchpad successfully enabled!\";elif [ \"$1\" == \"off\" ]; then xinput set-prop 12 140 0; echo \"Touchpad successfully disabled!\"else echo \"Please use the program with one of the following arguments:\" echo \" (1) on : enable the touchpad!\" echo \" (2) off : disable the touchpad!\"fi 将该脚本命名为 touchpad ，然后放到 /home/user/bin 目录下。然后，开启或关闭触摸板就很方便了： 1234 # 开启触摸板touchpad on# 关闭触摸板touchpad off 注意，脚本中的设备 ID 和属性编号应和你的笔记本一致，user 为你的用户名。 gsettings 另外，如果上面的命令不起用了，那么可以试试(Gnome)： 12345678 开启触摸板:sudo gsettings set org.gnome.desktop.peripherals.touchpad send-events true输入时禁用：sudo gsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing true双指滚动sudo gsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing truetap to click:sudo gsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true"},{"title":"记一下那些年使用 Linux 踩过的坑","date":"2017-10-30T11:54:31.000Z","path":"2017/10/30/What-the-fuck-problem-with-Linux/","text":"笔记本上装了双系统：Windows 10 + Ubuntu，刚装好 Ubuntu 不久就重新从 Windows 下分了一个盘挂载到 Ubuntu 下。如今，由于基本不再使用 Windows 系统，准确的说就只在虚拟机上使用一下 QQ、微信。于是，我又从 Windows 下分出一个盘，准备挂载到 Ubuntu 下。然而，却突然启动不进去了，直接进入了 emergency mode，尝试重新启动到默认模式，然后出现下面的错误信息： 1 [ 84.260812] EXT4-fs (sda7): VFS: can&apos;t find ext4 filesystem. 错误信息很直接，说sda7不是ext4文件系统格式。 然后查看分区：fdisk -l，输出如下： 1234567891011121314151617181920212223 Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: gptDisk identifier: A3FE2E3C-3EBC-401D-8BB3-987D9B33F0ECDevice Start End Sectors Size Type/dev/sda1 2048 1026047 1024000 500M EFI System/dev/sda2 1026048 1288191 262144 128M Microsoft reserved/dev/sda3 1288192 284209819 282921628 134.9G Microsoft basic data/dev/sda4 284211200 508033023 223821824 106.7G Microsoft basic data/dev/sda5 508035072 949225471 441190400 210.4G Linux filesystem/dev/sda6 949225472 965793791 16568320 7.9G Linux swap/dev/sda7 965793792 1298845695 333051904 158.8G Microsoft basic data/dev/sda8 1298845696 1718274047 419428352 200G Linux filesystem/dev/sda9 1718276096 1927991295 209715200 100G Microsoft basic datamount -o remount,rw /mount --allchown root:root /usr/bin/sudochmod 4755 /usr/bin/sudo/dev/sda10 1927993344 1928998911 1005568 491M Windows recovery environment/dev/sda11 1928998912 1951117311 22118400 10.6G Windows recovery environment/dev/sda12 1951119360 1953523711 2404352 1.2G Windows recovery environment What ? /dev/sd7 是 Windows 系统的 C 盘，怎么它会在启动的时候挂载呢，而且还是以 ext4 的文件系统格式挂载。想了半天，没发现问题。还好，机智的我赶紧看了一下 /etc/fstab 文件内容： 1234567891011121314 # /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# / was on /dev/sda9 during installationUUID=e3a38d48-680a-49e5-a98f-ae8bb6a37293 / ext4 errors=remount-ro 0 1# /boot/efi was on /dev/sda1 during installationUUID=FE51-6D32 /boot/efi vfat umask=0077 0 1# swap was on /dev/sda10 during installationUUID=c6a51fbb-d72a-4d93-9305-b75aaf6ab1fa none swap sw 0 0dev/sda7 home/fenglv/FILE ext4 defaults 0 1 ？？？原来之前挂载到 Ubuntu 上的盘设备名就是 /dev/sda7 ，添加一个新的分区后设备名变为了 /dev/sda8，现在的 /dev/sda7 对应的就是 Windows 系统的 C 盘。而我没有修改 /etc/fstab ，所以才导致 Linux 系统启动的时候无法将该设备挂载上。 修改之后终于正常启动了。 然而事情并没有结束。之后，sudo 不能使用了，错误信息如下： 123 sudo: error in /etc/sudo.conf, line 0 while loading plugin `sudoers_policy&apos;sudo: /usr/lib/sudo/sudoers.so must be only be writable by ownersudo: fatal error, unable to load plugins 好吧，直接上网查。最后在 askubunntu 上找到了解决办法：启动到 recovery mode ，然后执行下面的命令： 123 mount -o remount,rw /chmod 644 /usr/lib/sudo/sudoers.sochown -R root /usr/lib/sudo 至此，全部问题解决。 问题并没有真的结束（文章更新），之后，virtualbox 不能启动了： 12 VBoxHeadless: Effective UID is not root (euid=1000 egid=1000 uid=1000 gid=1000)VBoxHeadless: Tip! It may help to reinstall VirtualBox. 正确的做法就是按照它的提示把 virtualbox 卸了重新安装。然而，我却去修改/usr/bin的所有者：chown -R root /usr/bin 。这样以后，不但 virtual box 无法启动，sudo 又不能用了，这次的错误信息如下： 1 sudo: /usr/bin/sudo must be owned by uid 0 and have the setuid bit set 最后找到解决办法：再次进入 recovery mode，执行下面命令： 1234 mount -o remount,rw /mount --allchown root:root /usr/bin/sudochmod 4755 /usr/bin/sudo 问题解决。 Linux 的权限问题真让人头疼。"},{"title":"Linux 主机和 Vbox 下的 Windows 虚拟机创建共享文件夹","date":"2017-10-28T06:42:12.000Z","path":"2017/10/28/Linux-host-create-share-folder-with-windows-vbox/","text":"在 Linux 下，难免会使用一些 Windows 的软件，此时其中一个选择就是安装虚拟机。下面将阐述如何在 Linux 主机下创建一个和 VirtualBox 下的 Windows 虚拟机的共享文件夹。 首先确保安装好虚拟机。 第一步，启动虚拟机，点击左上方工具栏 -&gt; 安装增加功能 -&gt; 按照提示安装成功即可。 第一步，打开虚拟机设置 -&gt; 共享文件夹 -&gt; 添加路径 -&gt; 设置共享文件夹名字（假设名字为 Win7，后面会用到。） 第三步，重启虚拟机 -&gt; 打开 cmd -&gt; 输入命令 net use x: \\\\vboxsvr\\Win7 即可。其中 x 为盘符，任意一个未使用的字母均可以，Win7 即为上面设置的共享文件夹名字。 这样，在主机和虚拟机之间就创建了一个共享文件夹。"},{"title":"Python 编程风格","date":"2017-10-26T04:10:08.000Z","path":"2017/10/26/Pythonic-programming-tricks/","text":"本文将记录在学习过程掌握/学习到的一些 Python 编程的奇技淫巧，即如何写 Pythonic 的 Python 代码。因此，文章将会持续更新，更新时间不限。由于本人知识有限，文中难免会出现不足或错误的地方。文中提到的方法适用于 Python 3，对于 Python 2 不一定完全适用。 2018 年 6 月 13 日更新。 多变量赋值 变量赋值是编程语言里面最简单的语句之一，通常情况下，我们会这样做： 123 a = 1b = 2c = 3 这样便完成了对三个变量的赋值，但你可以用更简单的方式： 1 a, b, c = 1, 2, 3 元素值交换 在编程过程中，交换两个变量的值是非常常见的。一般情况下，我们会用下面这种方式来交换两个变量的值（尤其是对于第一门语言是C/C++的人来说）： 123 t = aa = bb = t 这种方式是正确的，没有人敢说它不对，但事实上，在 Python 里，你可以有更简单的方式来完成这件事： 1 a, b = b, a 没错，一行语句就够了。 对上面两个技巧的解释：在 Python 中，任何以逗号分隔的对象均被当作元组处理，因此1, 2, 3 实际上就是一个元组(1, 2, 3)，赋值过程可以看成是元组的解包 。交换值也是同样的，它相当于把等号右边的元组解包后赋值给了左边的变量。为了提高代码的可读性，上面的例子可以加上括号： 12 a, b, c = (1, 2, 3)a, b = (b, a) 循环遍历区间元素 你可以这样： 12 for i in [0, 1, 2, 3, 4, 5] : print(i) 但更好的方法是： 12 for i in range(6) : print(i) 值得一提的是, range 返回的是生成器对象，生成器比列表更加节省内存。 带有索引位置的集合遍历 遍历集合时，如果需要索引信息，直接迭代是没有的，普通的方式是： 123 peoples = ['Tim', 'Bob', 'Ada']for i in range(len(peoples)) : print(i, '---&gt;', peoples[i]) 但你还可以这样： 12 for i, people in enumerate(peoples) : print(i, '---&gt;', people) 字符串连接 普通方式可以用 + 操作： 12345 strs = ['I', 'Love', 'You']s = strs[0]for i in strs[1: ]: s += ' ' + iprint(s) 但你还可以使用 join 方法： 1 print(' '.join(strs)) 与 join 相对应的就是 split 方法，split 方法通过指定分隔符参数来分割字符串，默认为空白符： 12 s = 'I love you'l = s.split() # l = ['I', 'love', 'you'] 此外，split 方法还有一个用法。我们知道，在 Python 中，从键盘输入时，input() 方法会读取一整行输入，然后返回一个字符串，如果想要在同一行输入多个整数并赋值给多个对象，那么 split() 方法就派上用场了： 1234 a, b, c = input().split()a = int(a)b = int(b)c = int(c) 这样，就可以在同一行输入三个整数，然后分别赋值给 a, b, c，当然，此时，仍然是字符串，如果要作为整数使用，那么，使用 int() 转化一下即可。 列表解析 假设 list1 是一个字符串组成的列表，现在，需要把 list1 中的每一个字符串的每一个小写字母找出来，形成一个新的元组。一般情况下，我们可以这样做： 123456 list1 = ['adg', 'Adf', '124']list2 = []for i in list1: for j in i: if j &gt;= 'a' and j &lt;= 'z': list2.append(j) 但实际上，你只需要用一个语句就可以完成这件事： 1 list2 = [j for i in list1 for j in i if j &gt;= 'a' and j &lt;= 'z'] 没错，Python 就是这么简洁。如果把上面的方括号换成圆括号，那么结果返回的就是一个迭代器，可以使用 next() 方法获取元素： 123 list2 = (j for i in list1 for j in i if j &gt;= 'a' and j &lt;= 'z')list2.next() # 返回'a'list2.next() # 返回'd' 收集参数 函数的多个参数可通过一个元组传递，假设有如下函数： 12 def add2(x, y): return x + y 可重新定义为： 1234567 def add2(*params): return params[0] + params[1]#传递参数add2(1, 2)#或tuple1 = (1, 2)add2(*tuple1) 使用双星号则可以传递一个字典： 1234 def with_star(**kwds): print(kwds['name'], ' is ', kwds['age'] ,' years old.')args = &#123;'name' : 'Mrs. GUmby', 'age' : 42&#125;with_star(**args) 使用两个列表创建字典 12345 list1 = [1, 2, 3]list2 = ['a', 'b', 'c']d = dict(zip(list1, list2))list1 == list(d.keys())list2 == list(d.values()) 多态 多态意味着就算不知道变量所引用的对象类型是什么，也可以对它进行操作，看下面的函数： 1234 def add (a, b): return a + badd(1, 2) # 返回３add('ab', 'cd') # 返回'abcd' 很多函数和运算符都是多态的，因此写程序时也应该尽量避免破坏多态，尽量不使用 type, isinstance, issubclass 之类会破坏多态的函数。 多态是 Python 式编程的核心，也被称为 “duck typing”。 打开/关闭文件 执行文件操作时，一定不能忘记 close()，即使代码出错，普遍的方法是在 finally 块中显示的调用 close 方法： 12345 f = open('data.txt')try : data = f.read()finally : f.close() 但更简介的方法是： 12 with open('data.txt') as f : data = f.read() 使用 with 语句，系统会在执行完文件操作之后自动关闭文件对象。 合理使用列表 列表对象是一个查询效率高但更新效率低的数据结构。比如删除元素和插入元素的时候执行效率非常低，需要对剩下的元素进行移动。 123 people = ['xiaoming', 'xiaohong', 'zhangsan', 'lisi']people.pop(0)people.insert(0, 'lihua') 更好的方法是使用 deque: 1234 from collections import dequename = deque(['xiaoming', 'xiaohong', 'zhangsan', 'lisi'])name.popleft()name.appendleft('lihua') deque 是一个双向队列的数据结构，删除元素和插入元素会很快。 遍历字典中的 key 和 value 普通方法： 123 d = &#123;'a':1, 'b':2, 'c':3&#125;for k in d : print(k, '---&gt;', d[k]) 该方法效率较低，因为每次都需要重新进行 hash 查找 key 对应的 value 。 高效的方法是： 12 for k, v in d.items(): print(k, '---&gt;', d[k]) items 返回迭代器对象，效率高，且节省内存。 链式比较 学了那么久 Python，最近才知道 Python 居然支持大多数编程语言都不支持的链式比较： 常规方法： 123 age = 18if age &gt; 18 and age &lt; 60 : print('young man') 事实上，在 Python 中，你可以这样写： 12 if 18 &lt; age &lt; 60 : print('young man') 理解了链式比较操作，那么你也就明白了下面这行代码为什么会返回 False : 1 True == True == False if/else 三目运算 常规： 1234 if gender == 'male' : text = 'man'else : text = 'women' pythonic: 1 text = 'man' if gender == 'male' else 'women' for/else, while/else 语句 for/else, while/else 语句是 Python 中最迷惑人的语法：如果以正常方式退出循环(非 break&#39;, 非return, 程序异常)，那么else` 分支将执行： 12345 for i in range(10) : if i == 5 : breakelse : print(\"hello, world.\") # 无输出 1234 for i in range(10) : print(i)else : print(\"hello, world.\") # 有输出 当然，上面说到的例子没什么用，看下面一个： 1234567 found = falsefor i in mylist : if i == theflag : found = True breakif not found : print(\"Not found.\") 使用 for/else : 12345 for i in mylist : if i == theflag : breakelse : print(\"Not found.\")"},{"title":"Python 速查表","date":"2017-10-07T11:20:55.000Z","path":"2017/10/07/Python-cheat-sheet/","text":"本手册是 Python cheat sheet 的中文翻译版。原作者：Arianne Colton and Sean Chen(data.scientist.info@gmail.com)。 该手册同时位于 GitHub 上，可下载 PDF 版。 惯例 Python 对大小写敏感； Python 的索引从 0 开始（所有编程语言均如此）； Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号。 获取帮助 获取主页帮助： help() 获取函数帮助： help(str.replace) 获取模块帮助： help(re) 模块（亦称库） 模块只是一个简单地以 .py 为后缀的文件。 列出模块内容：dir(module1) 导入模块：import module 调用模块中的函数：module1.func1() 注：import 语句会创建一个新的名字空间，并且在该名字空间内执行 .py 文件中的所有语句。如果你想把模块内容导入到当前名字空间，请使用 from module1 import * 语句。 数值类类型 查看变量的数据类型：type(variable) 六种经常使用的数据类型 int/long：过大的 int 类型会被自动转化为 long 类型。 float：64 位，Python 中没有 double 类型。 bool：真或假。 str：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以 Unicode 编码； 字符串可置于单/双/三引号中； 字符串是字符的序列，因此可以像处理其他序列一样处理字符串； 特殊字符可通过 \\ 或者前缀 r 实现： 1 str1 = r'this\\f?ff' 字符串可通过多种方式格式化： 12 template = '%.2f %s haha $%d';str1 = template % (4.88, 'hola', 2) NoneType(None)：Python null 值（只有 None 对象的一个实例中存在）。 None 不是一个保留关键字，而是 NoneType 的一个唯一实例。 None 通常是可选函数参数的默认值： 1 def func1(a, b, c = None) None 的常见用法： 1 if variable is None : datatime：Python 内建的 datetime 模块提供了 datetime、data 以及 time 类型。 datetime 组合了存储于 date 和 time 中的信息。 123456789101112 #从字符串中创建 datetimedt1 = datetime.strptime('20091031', '%Y%m%d')#获取 date 对象dt1.date()#获取 time 对象dt1.time()#将 datetime 格式化为字符串dt1.strftime('%m/%d/%Y%H:%M')#更改字段值dt2 = dt1.replace(minute = 0, second = 30)#做差, diff 是一个 datetime.timedelta 对象diff = dt1 - dt2 注：Python 中的绝大多数对象都是可变的，只有字符串和元组例外。 数据结构 注：所有的 non-Get 函数调用，比如下面例子中的 list1.sort() 都是原地操作，即不会创建新的对象，除非特别声明。 元组 元组是 Python 中任何类型的对象的一个一维、固定长度、不可变的序列。 123456789101112 #创建元组tup1 = 4, 5, 6 # ortup1 = (6, 7, 8)#创建嵌套元组tup1 = (4, 5, 6), (7, 8)#将序列或迭代器转化为元组tuple([1, 0, 2])#连接元组tup1 + tup2#解包元组a, b, c = tup1 元组应用： 12 #交换两个变量的值a, b = b, a 列表 列表是 Python 中任何类型的对象的一个一维、非固定长度、可变（比如内容可以被修改）的序列。 12345678910111213141516171819202122 #创建列表list1 = [1, 'a', 3]#orlist1 = list(tup1)#连接列表list1 + list2 #orlist1.extend(list2)#追加到列表的末尾list1.append('b')#插入指定位置list1.insert(PosIndex, 'a')#反向插入，即弹出给定位置的值/删除ValueAtIdx = list1.pop(PosIndex)#移除列表中的第一个值, a 必须是列表中第一个值list1.remove('a')#检查成员资格3 in list1 =&gt; True or False#对列表进行排序list1.sort()#按特定方式排序list1.sort(key = len) # 按长度排序 使用 + 连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用 extend() 是更明智的选择； insert 和 append 相比会有更大的开支（时间/空间）； 在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。 内建的 bisect 模块 对一个排序好的列表进行二分查找或插入； bisect.bisect找到元素在列表中的位置，bisect.insort将元素插入到相应位置。用法： 123456 import bisectlist1 = list(range(10))#找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1bisect.bisect(list1, 5)#将 3.5 插入 list1 中合适位置bisect.insort(list1, 3.5) 注：bisect 模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。 针对序列类型的切片 序列类型包括 str、array、tuple、list 等。 用法： 123 list1[start:stop]#如果使用 steplist1(start:stop:step) 注：切片结果包含 start 索引，但不包含 stop 索引；start/stop 索引可以省略，如果省略，则默认为序列从开始到结束，如 list1 == list1[:] 。 step 的应用： 1234 #取出奇数位置的元素list1[::2]#反转字符串str1[::-1] 字典（哈希映射） 1234567891011121314151617 #创建字典dict1 = &#123;'key1': 'value1', 2: [3,2]&#125;#从序列创建字典dict(zip(KeyList, ValueList))#获取/设置/插入元素dict1['key1']dict1['key1'] = 'NewValue'#get 提供默认值dict1.get('key1', DefaultValue)#检查键是否存在'key1' in dict1#获取键列表dict1.keys()#获取值列表dict1.values()#更新值dict1.update(dict2)#dict1 的值被 dict2 替换 如果键不存在，则会出现 KeyError Exception 。 当键不存在时，如果 get()不提供默认值则会返回 None 。 以相同的顺序返回键列表和值列表，但顺序不是特定的，又称极大可能非排序。 有效字典键类型 键必须是不可变的，比如标量类型(int、float、string)或者元组（元组中的所有对象也必须是不可变的）。 这儿涉及的技术术语是 hashability。可以用函数 hash()来检查一个对象是否是可哈希的，比如 hash(&#39;This is a string&#39;) 会返回一个哈希值，而 hash([1,2]) 则会报错（不可哈希）。 集合 一个集合是一些无序且唯一的元素的聚集； 你可以把它看成只有键的字典； 12345678910 #创建集合set([3, 6, 3])#or&#123;3, 6, 3&#125;#子集测试set1.issubset(set2)#超集测试set1.issuperset(set2)#测试两个集合中的元素是否完全相同set1 == set2 集合操作 并（又称或）：set1 | set2 交（又称与）：set1 &amp; set2 差：set1 - set2 对称差（又称异或）：set1 ^ set2 函数 Python 的函数参数传递是通过引用传递。 基本形式 1 def func1(posArg1, keywordArg1 = 1, ..) 注 关键字参数必须跟在位置参数的后面； 默认情况下，Python 不会“延迟求值”，表达式的值会立刻求出来。 函数调用机制 所有函数均位于模块内部作用域。见“模块”部分。 在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组 args 和一个字典 kwargs，然后在函数内部解包。 “函数是对象”的常见用法： 123 def func1(ops = [str.strip, user_define_func, ..], ..): for function in ops: value = function(value) 返回值 如果函数末尾没有 return 语句，则不会返回任何东西。 如果有多个返回值则通过一个元组来实现。 12 return (value1, value2)value1, value2 = func1(..) 匿名函数（又称 LAMBDA 函数） 什么是匿名函数？ 匿名函数是一个只包含一条语句的简单函数。 12 lambda x : x * 2#def func1(x) : return x * 2 匿名函数的应用：’curring’，又称利用已存在函数的部分参数来派生新的函数。 1 ma60 = lambda x : pd.rolling_mean(x, 60) 一些有用的函数（针对数据结构） enumerate() 返回一个序列(i, value)元组，i 是当前 item 的索引。 1 for i, value in enumerate(collection): 应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。 sort()可以从任意序列中返回一个排序好的序列。 1 sorted([2, 1, 3]) =&gt; [1, 2, 3] 应用： 123 sorted(set('abc bcd')) =&gt; [' ','a', 'b', 'c', 'd']# 返回一个字符串排序后无重复的字母序列 zip()函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。 1 zip(seq1, seq2) =&gt; [('seq1_1', 'seq2_1'), (..), ..] zip()可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。 应用：多个序列同时迭代： 1 for i, (a, b) in enumerate(zip(seq1, seq2)): unzip：另一种思考方式是把一些行转化为一些列： 1 seq1, seq2 = zip(zipOutput) reversed() 将一个序列的元素以逆序迭代。 1 list(reversed(range(10))) reversed() 会返回一个迭代器，list() 使之成为一个列表。 控制流 用于 if-else 条件中的操作符： 123456 #检查两个变量是否是相同的对象var1 is var2#检查两个变量是否是不同的对象var1 is not var2#检查两个变量的值是否相等var1 == var2 注：Python 中使用 and、or、not 来组合条件，而不是使用 &amp;&amp;、||、! 。 for循环的常见用法： 1234 #可迭代对象（list、tuple）或迭代器for element in iterator:#如果元素是可以解包的序列for a, b, c in iterator: pass：无操作语句，在不需要进行任何操作的块中使用。 三元表达式，又称简洁的 if-else，基本形式： 1 value = true-expr if condition else false-expr Python 中没有 switch/case 语句，请使用 if/elif。 面向对象编程 对象（object）是 Python 中所有类型的根。 万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个类型（type）。对象变量是一个指向变量在内存中位置的指针。 所有对象均为引用计数。 123456 sys.getrefcount(5) =&gt; xa = 5, b = a#上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5sys.getrefcount(5)=&gt; x + 2del(a); sys.getrefcount(5) =&gt; x + 1 类的基本形式： 123456789101112 class MyObject(object): # 'self' 等价于 Java/C++ 中的 'this' def __init__(self, name): self.name = name def memberFunc1(self, arg1): .. @staticmethod def classFunc2(arg1): ..obj1 = MyObject('name1')obj1.memberFunc1('a')MyObject.classFunc2('b') 有用的交互式工具： 1 dir(variable1) #列出对象的所有可用方法 常见字符串操作 123456789101112131415161718192021 #通过分隔符连接列表/元组', '.join([ 'v1', 'v2', 'v3']) =&gt; 'v1, v2, v3'#格式化字符串string1 = 'My name is &#123;0&#125; &#123;name&#125;'newString1 = string1.format('Sean', name = 'Chen')#分裂字符串sep = '-';stringList1 = string1.split(sep)#获取子串start = 1;string1[start:8]#补 '0' 向右对齐字符串month = '5';month.zfill(2) =&gt; '05'month = '12';month.zfill(2) =&gt; '12'month.zfill(3) =&gt; '012' 异常处理 基本形式： 12345678910 try: ..except ValueError as e: print eexcept (TypeError, AnotherError): ..except: ..finally: .. # 清理，比如 close db; 手动引发异常： 1234 raise AssertionError # 断言失败raise SystemExit# 请求程序退出raise RuntimeError('错误信息 :..') 对列表、字典和元组的深入理解 语法糖（syntactic sugar）会使代码变得更加易读易写。 对列表的理解 将一些元素通过一个简短的语句传入一个过滤器进行过滤和转化，然后可以组成一个新的列表。 1234567 #基本形式[expr for val in collection if condition]#ShortCutresult = []for val in collection: if condition: result.append(expr) 可以省略过滤条件，只留下表达式。 对字典的理解 基本形式： 1 &#123;key-expr : value-expr for value in collection if condition&#125; 对集合的理解 基本形式：和列表一样，只是应该使用 () 而不是 [] 。 嵌套列表 基本形式： 1 [expr for val in collection for innerVal in val if condition]"},{"title":"关于 Linux 你可能不是非常了解的七件事","date":"2017-10-06T04:51:31.000Z","path":"2017/10/06/Seven-things-you-may-not-know-so-far-about-Linux/","text":"使用 Linux 最酷的事情之一就是随着时间的推移，你可以不断获得新的知识。每天，你都可能会遇到一个新的实用工具，或者只是一个不太熟悉的奇技淫巧，但是却非常有用。这些零碎的东西并不总是能够改变生活，但是却是专业知识的基础。 即使是专家，也不可能事事皆知。无论你有多少经验，可能总会有更多的东西需要你去学习。所以，在这儿我列出了七件关于 Linux 你可能不知道的事情。 一个查找命令历史的交互模式 你可能对 history 命令非常熟悉，它会读取 bash 历史，然后以编号列表的方式输出到标准输出（stdout）。然而，如果你在 curl 命令的海洋里寻找一个特定的链接（URL），那么这个列表并不总是那么容易阅读的。 你还可以有另一个选择，Linux 有一个交互式的反向搜索可以帮助你解决这个问题。你可以通过快捷键 ctrl+r启动交互模式，然后进入一个交互提示中，它将会根据你提供的字符串来向后搜索 bash 历史，你可以通过再次按下 ctrl+r 向后搜索更老的命令，或者按下 ctrl+s 向前搜索。 注意，ctrl+s 有时会与 XON/XOFF 流控制冲突，即 XON/XOFF 流控制也会使用该快捷键。你可以通过运行 stty -ixon 命令来禁用该快捷键。在你的个人电脑上，这通常是有用的，但是在禁用前，确保你不需要 XON/XOFF 。 Cron 不是安排任务的唯一方式 Cron 任务对于任何水平的系统管理员，无论是毫无经验的初学者，还是经验丰富的专家来说，都是非常有用的。但是，如果你需要安排一个一次性的任务，那么 at 命令为你提供了一个快捷的方式来创建任务，从而你不需要接触 crontab 。 at 命令的运行方式是在后面紧跟着你想要运行任务的运行时间。时间是灵活的，因为它支持许多时间格式。包括下面这些例子： 123 at 12:00 PM September 30 2017at now + 1 hourat 9:00 AM tomorrow 当你以带参数的方式输入 at 命令以后，将会提示你该命令将在你的 Linux 系统上运行。这可能是一个备份脚本，一套维护任务，或者甚至是一个普通的 bash 命令。如果要结束任务，可以按 ctrl+d 。 另外，你可以使用 atq 命令查看当前用户的所有任务，或者使用 sudo atq 查看所有用户的任务。它将会展示出所有排定好的任务，并且每个任务都伴有一个 ID 。如果你想取消一个排定好的任务，可以使用 atrm 命令，并且以任务 ID 作为参数。 你可以按照功能搜索命令，而不仅仅是通过名字 记住命令的名字非常困难，特别是对于初学者来说。幸运的是，Linux 附带了一个通过名字和描述来搜索 man 页面的工具。 下次，如果你没有记住你想要使用的工具的名称，你可以尝试使用 apropos 命令加上你想要干的事情的描述。比如，apropos build filesystem 将会返回一系列名字和描述包括了 “build” 和 “filesystem” 单词的工具。 apropos 命令接受一个或多个字符串作为参数，但同时它也有其他参数，比如你可以使用 -r 参数，从而通过正则表达式来搜索。 一个允许你来管理系统版本的替代系统 如果你曾进行过软件开发，你就会明白跨项目管理不同版本的语言的支持的重要性。许多 Linux 发行版都有工具可以来处理不同的内建版本。 可执行文件比如 java 往往符号链接到目录 /etc/alternatives 下。反过来，该目录会将符号链接存储为二进制文件并提供一个管理这些链接的接口。Java 可能是替代系统最常管理的语言，但是，经过一些配置，它也可以作为其他应用程序替代品，比如 NVM 和 RVM （NVM 和 RVM 分别是 NodeJS 和 Ruby 的版本管理器）。 在基于 Debian 的系统中，你可以使用 update-alternatives 命令创建和管理这些链接。在 CentOS 中，这个工具就叫做 alternatives 。通过更改你的 alternatives 文件中的链接，你便可以安装一个语言的多个版本，并且在不同的情况下使用不同的二进制。这个替代系统也提供了对任何你可能在命令行运行的程序的支持。 shred 命令是更加安全的删除文件方式 我们大多数时候总是使用 rm 命令来删除文件。但是文件去哪儿了呢？真相是 rm 命令所做的事情并不是像你所想像的那样，它仅仅删除了文件系统和硬盘上的数据的硬链接。硬盘上的数据依旧存在，直到被另一个应用重写覆盖。对于非常敏感的数据来说，这会带来一个很大的安全隐患。 shred 命令是 rm 命令的升级版。当你使用 shred 命令删除一个文件之后，文件中的数据会被多次随机覆写。甚至有一个选项可以在随机覆写之后对所有的数据进行清零。 如果你想安全的删除一个文件并且以零覆盖，那么可以使用下面的命令： shred -u -z [file name] 同时，你也可以使用 -n 选项和一个数字作为参数，从而指定在随机覆盖数据的时候迭代多少次。 通过自动更正来避免输入很长的无效文件路径 有多少次，你输入一个文件的绝对路径，然而却看到“没有该文件或目录”的消息。任何人都会明白输入一个很长的字符串的痛苦。幸运的是，有一个很简单的解决办法。 内建的 shopt 命令允许你设置不同的选项来改变 shell 的行为。设置 cdspell 选项是避免输入文件路径时一个字母出错的头痛的一个简单方式。你可以通过运行 shopt -s cdspell 命令来启用该选项。启用该选项后，当你想要切换目录时，会自动更正为最匹配的目录。 Shell 选项是节省时间的一个好方法（更不用说减少麻烦），此外还有许许多多的其他选项。如果想查看你的系统中所有选项的完整列表，可以运行不带参数的 shopt 命令。需要注意的是，这是 bash 的特性，如果你运行 zsh 或者其他可供选择的 shell，可能无法使用。 通过子 shell 返回到当前目录 如果你曾经配置过一个比较复杂的系统，那么你可能会发现你需要频繁的更换目录，从而很难跟踪你所在的位置。如果在运行完一个命令后自动返回到当前位置，不是很好吗？ Linux 系统实际上提供了一个解决该问题的方法，并且非常简单。如果你想通过 cd 命令进入另一个目录完成一些任务，然后再返回当前工作目录，那么你可以将命令置于括号中。你可以在你的 Linux 系统上尝试下面这个命令。记住你当前的工作目录，然后运行： 1 (cd /etc &amp;&amp; ls -a) 该命令会输出 /etc 目录的内容。现在，检查你的当前工作目录。它和执行该命令前的目录一样，而不是 /etc 目录。 它是如何工作的呢？运行一个括号中的命令会创建一个子 shell 或一个当前 shell 进程的复刻副本。该子 shell 可以访问所有的父变量，反之则不行。所以请记住，你是在运行一个非常复杂的单行命令。 在并行处理中经常使用子 shell ，但是在命令行中，它也能为你带来同样的力量，从而使你在浏览文件系统时更加容易。 via: http://opensourceforu.com/2017/09/top-7-things-linux-may-not-known-far/ 作者：PHIL ZONA译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"Linux 文件系统概览","date":"2017-09-23T04:48:42.000Z","path":"2017/09/23/Introduction-to-Linux-FileSystem/","text":"本文旨在高屋建瓴地来讨论 Linux 文件系统概念，而不是对某种特定的文件系统，比如 EXT4 是如何工作的进行具体的描述。另外，本文也不是一个文件系统命令的教程。 每台通用计算机都需要将各种数据存储在硬盘驱动器（HDD）或其他类似设备上，比如 USB 存储器。这样做有两个原因。首先，当计算机关闭以后，内存（RAM）会失去存于它里面的内容。尽管存在非易失类型的 RAM，在计算机断电以后还能把数据存储下来（比如采用 USB 闪存和固态硬盘的闪存），但是，闪存和标准的、易失性的 RAM，比如 DDR3 以及其他相似类型的 RAM 相比，要贵很多。 数据需要存储在硬盘驱动上的另一个原因是，即使是标准的 RAM 也要比普通硬盘贵得多。尽管 RAM 和硬盘的价格都在迅速下降，但是 RAM 的价格依旧在以字节为单位来计算。让我们进行一个以字节为单位的快速计算：基于 16 GB 大的 RAM 的价格和 2 TB 大的硬盘驱动的价格。计算显示 RAM 的价格大约比硬盘驱动贵 71 倍。今天，一个典型的 RAM 的价格大约是 0.000000004373750 美元/每字节。 直观的展示一下在很久以前 RAM 的价格，在计算机发展的非常早的时期，其中一种类型的 RAM 是基于在 CRT 屏幕上的点。这种 RAM 非常昂贵，大约 1 美元/每字节。 定义 你可能听过其他人以各种不同和令人迷惑的方式谈论过文件系统。文件系统这个单词本身有多重含义，你需要从一个讨论或文件的上下文中理解它的正确含义。 我将根据我所观察到的在不同情况下使用“文件系统”这个词来定义它的不同含义。注意，尽管我试图遵循标准的“官方”含义，但是我打算基于它的不同用法来定义这个术语（如下）。这就是说我将在本文的后续章节中进行更详细的探讨。 始于顶层 root（/）目录的整个 Linux 目录结构。 特定类型的数据存储格式，比如 EXT3、EXT4、BTRFS 以及 XFS 等等。Linux 支持近百种类型的文件系统，包括一些非常老的以及一些最新的。每一种文件系统类型都使用它自己独特的元数据结构来定义数据是如何存储和访问的。 用特定类型的文件系统格式化后的分区或逻辑卷，可以挂载到 Linux 文件系统的指定挂载点上。 文件系统的基本功能 磁盘存储是文件系统必须的功能，它与之伴生的有一些有趣而且不可或缺的细节。很明显，文件系统是用来为非易失数据的存储提供空间，这是它的基本功能。然而，它还有许多从需求出发的重要功能。 所有文件系统都需要提供一个名字空间，这是一种命名和组织方法。它定义了文件应该如何命名、文件名的最大长度，以及所有可用字符集中可用于文件名中字符集子集。它也定义了一个磁盘上数据的逻辑结构，比如使用目录来组织文件而不是把所有文件聚集成一个单一的、巨大的文件混合体。 定义名字空间以后，元数据结构是为该名字空间提供逻辑基础所必须的。这包括所需数据结构要能够支持分层目录结构，同时能够通过结构来确定硬盘空间中的块是已用的或可用的，支持修改文件或目录的名字，提供关于文件大小、创建时间、最后访问或修改时间等信息，以及位置或数据所属的文件在磁盘空间中的位置。其他的元数据用来存储关于磁盘细分的高级信息，比如逻辑卷和分区。这种更高层次的元数据以及它所代表的结构包含描述文件系统存储在驱动器或分区中的信息，但与文件系统元数据无关，与之独立。 文件系统也需要一个应用程序接口（API），从而提供了对文件系统对象，比如文件和目录进行操作的系统功能调用的访问。API 也提供了诸如创建、移动和删除文件的功能。它也提供了算法来确定某些信息，比如文件存于文件系统中的位置。这样的算法可以用来解释诸如磁盘速度和最小化磁盘碎片等术语。 现代文件系统还提供一个安全模型，这是一个定义文件和目录的访问权限的方案。Linux 文件系统安全模型确保用户只能访问自己的文件，而不能访问其他用户的文件或操作系统本身。 最后一块组成部分是实现这些所有功能所需要的软件。Linux 使用两层软件实现的方式来提高系统和程序员的效率。 图片 1：Linux 两层文件系统软件实现。 这两层中的第一层是 Linux 虚拟文件系统。虚拟文件系统提供了内核和开发者访问所有类型文件系统的的单一命令集。虚拟文件系统软件通过调用特殊设备驱动来和不同类型的文件系统进行交互。特定文件系统的设备驱动是第二层实现。设备驱动程序将文件系统命令的标准集解释为在分区或逻辑卷上的特定类型文件系统命令。 目录结构 作为一个通常来说非常有条理的处女座，我喜欢将东西存储在更小的、有组织的小容器中，而不是存于同一个大容器中。目录的使用使我能够存储文件并在我想要查看这些文件的时候也能够找到它们。目录也被称为文件夹，之所以被称为文件夹，是因为其中的文件被类比存放于物理桌面上。 在 Linux 和其他许多操作系统中，目录可以被组织成树状的分层结构。在 Linux 文件系统层次标准中定义了 Linux 的目录结构（LCTT 译注：可参阅这篇）。当通过目录引用来访问目录时，更深层目录名字是通过正斜杠（/）来连接，从而形成一个序列，比如 /var/log 和 /var/spool/mail 。这些被称为路径。 下表提供了标准的、众所周知的、预定义的顶层 Linux 目录及其用途的简要清单。 目录 描述 / (root 文件系统) root 文件系统是文件系统的顶级目录。它必须包含在挂载其它文件系统前需要用来启动 Linux 系统的全部文件。它必须包含需要用来启动剩余文件系统的全部可执行文件和库。文件系统启动以后，所有其他文件系统作为 root 文件系统的子目录挂载到标准的、预定义好的挂载点上。 /bin /bin 目录包含用户的可执行文件。 /boot 包含启动 Linux 系统所需要的静态引导程序和内核可执行文件以及配置文件。 /dev 该目录包含每一个连接到系统的硬件设备的设备文件。这些文件不是设备驱动，而是代表计算机上的每一个计算机能够访问的设备。 /etc 包含主机计算机的本地系统配置文件。 /home 主目录存储用户文件，每一个用户都有一个位于 /home 目录中的子目录（作为其主目录）。 /lib 包含启动系统所需要的共享库文件。 /media 一个挂载外部可移动设备的地方，比如主机可能连接了一个 USB 驱动器。 /mnt 一个普通文件系统的临时挂载点（如不可移动的介质），当管理员对一个文件系统进行修复或在其上工作时可以使用。 /opt 可选文件，比如供应商提供的应用程序应该安装在这儿。 /root 这不是 root（/）文件系统。它是 root 用户的主目录。 /sbin 系统二进制文件。这些是用于系统管理的可执行文件。 /tmp 临时目录。被操作系统和许多程序用来存储临时文件。用户也可能临时在这儿存储文件。注意，存储在这儿的文件可能在任何时候在没有通知的情况下被删除。 /usr 该目录里面包含可共享的、只读的文件，包括可执行二进制文件和库、man 文件以及其他类型的文档。 /var 可变数据文件存储在这儿。这些文件包括日志文件、MySQL 和其他数据库的文件、Web 服务器的数据文件、邮件以及更多。 表 1：Linux 文件系统层次结构的顶层 这些目录以及它们的子目录如表 1 所示，在所有子目录中，粗体的目录组成了 root 文件系统的必需部分。也就是说，它们不能创建为一个分离的文件系统并且在开机时进行挂载。这是因为它们（特别是它们包含的内容）必须在系统启动的时候出现，从而系统才能正确启动。 /media 目录和 /mnt 目录是 root 文件系统的一部分，但是它们从来不包含任何数据，因为它们只是一个临时挂载点。 表 1 中剩下的非粗体的目录不需要在系统启动过程中出现，但会在之后挂载到 root 文件系统上，在开机阶段，它们为主机进行准备，从而执行有用的工作。 请参考官方 Linux 文件系统层次标准（FHS）网页来了解这些每一个目录以及它们的子目录的更多细节。维基百科上也有关于 FHS 的一个很好的介绍。应该尽可能的遵循这些标准，从而确保操作和功能的一致性。无论在主机上使用什么类型的文件系统，该层次目录结构都是相同的。 Linux 统一目录结构 在一些非 Linux 操作系统的个人电脑上，如果有多个物理硬盘驱动器或多个分区，每一个硬盘或分区都会分配一个驱动器号。知道文件或程序位于哪一个硬盘驱动器上是很有必要的，比如 C: 或 D: 。然后，你可以在命令中使用驱动器号，以 D: 为例，为了进入 D: 驱动器，你可以使用 cd 命令来更改工作目录为正确的目录，从而定位需要的文件。每一个硬盘驱动器都有自己单独的、完整的目录树。 Linux 文件系统将所有物理硬盘驱动器和分区统一为一个目录结构。它们均从顶层 root 目录（/）开始。所有其它目录以及它们的子目录均位于单一的 Linux 根目录下。这意味着只有一棵目录树来搜索文件和程序。 因为只有一个文件系统，所以 /home、/tmp、/var、/opt 或 /usr 能够创建在和 root（/）文件系统不同的物理硬盘驱动器、分区或逻辑分区上，然后挂载到一个挂载点（目录）上，从而作为 root 文件系统树的一部分。甚至可移动驱动器，比如 USB 驱动器或一个外接的 USB 或 ESATA 硬盘驱动器均可以挂载到 root 文件系统上，成为目录树不可或缺的部分。 当从 Linux 发行版的一个版本升级到另一个版本或从一个发行版更改到另一个发行版的时候，就会很清楚地看到这样创建到不同分区的好处。通常情况下，除了任何像 Fedora 中的 dnf-upgrade 之类的升级工具，会明智地在升级过程中偶尔重新格式化包含操作系统的硬盘驱动来删除那些长期积累的垃圾。如果 /home 目录是 root 文件系统的一部分（位于同一个硬盘驱动器），那么它也会被格式化，然后需要通过之前的备份恢复。如果 /home 目录作为一个分离的文件系统，那么安装程序将会识别到，并跳过它的格式化。对于存储数据库、邮箱、网页和其它可变的用户以及系统数据的 /var 目录也是这样的。 将 Linux 系统目录树的某些部分作为一个分离的文件系统还有一些其他原因。比如，在很久以前，我还不知道将所有需要的 Linux 目录均作为 root（/）文件系统的一部分可能存在的问题，于是，一些非常大的文件填满了 /home 目录。因为 /home 目录和 /tmp 目录均不是分离的文件系统，而是 root 文件系统的简单子目录，整个 root 文件系统就被填满了。于是就不再有剩余空间可以让操作系统用来存储临时文件或扩展已存在数据文件。首先，应用程序开始抱怨没有空间来保存文件，然后，操作系统也开始异常行动。启动到单用户模式，并清除了 /home 目录中的多余文件之后，终于又能够重新工作了。然后，我使用非常标准的多重文件系统设置来重新安装 Linux 系统，从而避免了系统崩溃的再次发生。 我曾经遇到一个情况，Linux 主机还在运行，但是却不允许用户通过 GUI 桌面登录。我可以通过使用虚拟控制台之一，通过命令行界面（CLI）本地登录，然后远程使用 SSH 。问题的原因是因为 /tmp 文件系统满了，因此 GUI 桌面登录时所需要的一些临时文件不能被创建。因为命令行界面登录不需要在 /tmp 目录中创建文件，所以无可用空间并不会阻止我使用命令行界面来登录。在这种情况下，/tmp 目录是一个分离的文件系统，在 /tmp 所位于的逻辑卷上还有大量的可用空间。我简单地扩展了 /tmp 逻辑卷的容量到能够容纳主机所需要的临时文件，于是问题便解决了。注意，这个解决方法不需要重启，当 /tmp 文件系统扩大以后，用户就可以登录到桌面了。 当我在一家很大的科技公司当实验室管理员的时候，遇到过另外一个故障。开发者将一个应用程序安装到了一个错误的位置（/var）。结果该应用程序崩溃了，因为 /var 文件系统满了，由于缺乏空间，存储于 /var/log 中的日志文件无法附加新的日志消息。然而，系统仍然在运行，因为 root 文件系统和 /tmp 文件系统还没有被填满。删除了该应用程序并重新安装在 /opt 文件系统后，问题便解决了。 文件系统类型 Linux 系统支持大约 100 种分区类型的读取，但是只能对很少的一些进行创建和写操作。但是，可以挂载不同类型的文件系统在同一个 root 文件系统上，并且是很常见的。在这样的背景下，我们所说的文件系统一词是指在硬盘驱动器或逻辑卷上的一个分区中存储和管理用户数据所需要的结构和元数据。能够被 Linux 系统的 fdisk 命令识别的文件系统类型的完整列表在此，你可以感受一下 Linux 系统对许多类型的系统的高度兼容性。David Both 居住在美国北卡罗纳州的首府罗利，是一个 Linux 开源贡献者。他已经从事 IT 行业 40 余年，在 IBM 教授 OS/2 20 余年。1981 年，他在 IBM 开发了第一个关于最初的 IBM 个人电脑的培训课程。他也曾在 Red Hat 教授 RHCE 课程，也曾供职于 MCI worldcom，Cico 以及北卡罗纳州等。他已经为 Linux 开源社区工作近 20 年。 Linux 支持读取这么多类型的分区系统的主要目的是为了提高兼容性，从而至少能够与一些其他计算机系统的文件系统进行交互。下面列出了在 Fedora 中创建一个新的文件系统时的所有可选类型： btrfs cramfs ext2 ext3 ext4 fat gfs2 hfsplus minix msdos ntfs reiserfs vfat xfs 其他发行版支持创建的文件系统类型不同。比如，CentOS 6 只支持创建上表中标为黑体的文件系统类型。 挂载 在 Linux 系统上“挂载mount”文件系统的术语是指在计算机发展的早期，磁带或可移动的磁盘组需要需要物理地挂载到一个合适的驱动器设备上。当通过物理的方式放置到驱动器上以后，操作系统会逻辑地挂载位于磁盘上的文件系统，从而操作系统、应用程序和用户才能够访问文件系统中的内容。 一个挂载点简单的来说就是一个目录，就像任何其它目录一样，是作为 root 文件系统的一部分创建的。所以，比如，home 文件系统是挂载在目录 /home 下。文件系统可以被挂载到其他非 root 文件系统的挂载点上，但是这并不常见。 在 Linux 系统启动阶段的最初阶段，root 文件系统就会被挂载到 root 目录下（/）。其它文件系统在之后通过 SystemV 下的 rc 或更新一些的 Linux 发行版中的 systemd 等 Linux 启动程序挂载。在启动进程中文件系统的挂载是由 /etc/fstab 配置文件管理的。一个简单的记忆方法是，fstab 代表“文件系统表file system table”，它包含了需要挂载的文件系统的列表，这些文件系统均指定了挂载点，以及针对特定文件系统可能需要的选项。 使用 mount 命令可以把文件系统挂载到一个已有的目录/挂载点上。通常情况下，任何作为挂载点的目录都应该是空的且不包含任何其他文件。Linux 系统不会阻止用户挂载一个已被挂载了文件系统的目录或将文件系统挂载到一个包含文件的目录上。如果你将文件系统挂载到一个已有的目录或文件系统上，那么其原始内容将会被隐藏，只有新挂载的文件系统的内容是可见的。 结论 我希望通过这篇文章，阐明了围绕文件系统这个术语的一些可能的模糊之处。我花费了很长的时间，以及在一个良师的帮助下才真正理解和欣赏到 Linux 文件系统的复杂性、优雅性和功能以及它的全部含义。 如果你有任何问题，请写到下面的评论中，我会尽力来回答它们。 下个月 Linux 的另一个重要概念是：万物皆为文件。这个概念对用户和系统管理员来说有一些有趣和重要的实际应用。当我说完这个理由之后，你可能会想阅读我的文章：万物皆为文件，这篇文章会在我下个月计划写的关于 /dev 目录的文章之前写完。（LCTT 译注，也可参阅这篇） （题图 : 原始图片来自 Rikki Endsley. CC BY-SA 4.0） via: https://opensource.com/life/16/10/introduction-linux-filesystems 作者：David Both译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"C 语言中变量的段","date":"2017-09-12T02:16:42.000Z","path":"2017/09/12/the-Section-of-Variables/","text":"前言 在 C 语言中，不同的变量位于不同的段，下面进行简单分析。 看下面一个简单的 C 程序： 123456789101112131415161718 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *myname=\"Bao Yungang\";char gdata[128];char bdata[16] = &#123;1,2,3,4&#125;;main() &#123; char * ldata[16]; char * ddata; ddata = malloc(16); printf(\"myname:%llX\\n\", myname); printf(\"main: %llX\\n\", main); printf(\"gdata: %llX\\nbdata:%llX\\nldata:%llx\\n&amp;ddata:%llx\\nddata: %llx\\n\", gdata,bdata,ldata,&amp;ddata,ddata); free(ddata); return 1;&#125; 我们分析一下程序中出现的变量所位于的段。 分析 首先，根据所学知识进行分析： myname 变量是一个全局变量，并且进行了初始化，指向一个字符串常量。因此，myname 变量本身位于数据段：.data myname所指向的字符串是一个字符串常量，根据 C 语言知识，是只读的，所以应位于只读数据段：.rodata gdata是一个为进行初始化的全局变量，因此位于BSS段（Block Started by Symbol）。 bdata和myname一样是初始化了的全局变量，因此位于数据段。 ldata是一个main函数中的局部变量，因此位于栈中。 ddata变量自身也是main函数中的一个局部变量，因此也位于栈中。 ddata所指向的内存空间是通过malloc函数动态分配的，因此位于堆中。 验证 下面，通过objdump来进行验证： 首先，使用gcc来编译源程序(Ubuntu 16.04.4 + gcc 5.4.0)： 1 gcc -save-temps addr_space.c 通过添加 -save-temps选项来生成中间文件。 下面，使用 objdump 来查看段信息： 1 objdump -D ./a.out 通过-D选项显示出所有段的内容。 首先看bdata 和myname ，我们可以直接在 .data 段看到： 12345678910111213141516 Disassembly of section .data:0000000000601040 &lt;__data_start&gt;: ...0000000000601048 &lt;__dso_handle&gt;: ...0000000000601050 &lt;myname&gt;: 601050: 68 07 40 00 00 pushq $0x4007 ...0000000000601060 &lt;bdata&gt;: 601060: 01 02 add %eax,(%rdx) 601062: 03 04 00 add (%rax,%rax,1),%eax ... 对于 gdata ，也可以直接在 .bss 段看到： 1234567 Disassembly of section .bss:0000000000601080 &lt;completed.7585&gt;: ...00000000006010a0 &lt;gdata&gt;: ... 下面看myname 所指向的字符串常量。 首先，运行程序，输出如下： 123456 myname:400768main: 400626gdata: 6010A0bdata:601060ldata:7ffc84068960ddata:1490010 由运行结果知，myname的值为 400768，它即为 myname所指向的字符串常量的地址。然后我们在 objdump的输出内容中搜索该地址，得到它位于 .rodata中： 12345678910111213141516171819202122232425262728293031323334353637383940 Disassembly of section .rodata:0000000000400760 &lt;_IO_stdin_used&gt;: 400760: 01 00 add %eax,(%rax) 400762: 02 00 add (%rax),%al 400764: 00 00 add %al,(%rax) 400766: 00 00 add %al,(%rax) 400768: 42 61 rex.X (bad) 40076a: 6f outsl %ds:(%rsi),(%dx) 40076b: 20 59 75 and %bl,0x75(%rcx) 40076e: 6e outsb %ds:(%rsi),(%dx) 40076f: 67 61 addr32 (bad) 400771: 6e outsb %ds:(%rsi),(%dx) 400772: 67 00 6d 79 add %ch,0x79(%ebp) 400776: 6e outsb %ds:(%rsi),(%dx) 400777: 61 (bad) 400778: 6d insl (%dx),%es:(%rdi) 400779: 65 3a 25 6c 6c 58 0a cmp %gs:0xa586c6c(%rip),%ah # a9873ec &lt;_end+0xa3862cc&gt; 400780: 00 6d 61 add %ch,0x61(%rbp) 400783: 69 6e 3a 20 25 6c 6c imul $0x6c6c2520,0x3a(%rsi),%ebp 40078a: 58 pop %rax 40078b: 0a 00 or (%rax),%al 40078d: 00 00 add %al,(%rax) 40078f: 00 67 64 add %ah,0x64(%rdi) 400792: 61 (bad) 400793: 74 61 je 4007f6 &lt;__GNU_EH_FRAME_HDR+0x36&gt; 400795: 3a 20 cmp (%rax),%ah 400797: 25 6c 6c 58 0a and $0xa586c6c,%eax 40079c: 62 (bad) 40079d: 64 61 fs (bad) 40079f: 74 61 je 400802 &lt;__GNU_EH_FRAME_HDR+0x42&gt; 4007a1: 3a 25 6c 6c 58 0a cmp 0xa586c6c(%rip),%ah # a987413 &lt;_end+0xa3862f3&gt; 4007a7: 6c insb (%dx),%es:(%rdi) 4007a8: 64 61 fs (bad) 4007aa: 74 61 je 40080d &lt;__GNU_EH_FRAME_HDR+0x4d&gt; 4007ac: 3a 25 6c 6c 78 0a cmp 0xa786c6c(%rip),%ah # ab8741e &lt;_end+0xa5862fe&gt; 4007b2: 64 64 61 fs fs (bad) 4007b5: 74 61 je 400818 &lt;__GNU_EH_FRAME_HDR+0x58&gt; 4007b7: 3a 25 6c 6c 78 0a cmp 0xa786c6c(%rip),%ah # ab87429 &lt;_end+0xa586309&gt; ... 因此，说明 myname指向的字符串常量位于 .rodata 中。事实上，看中间一栏，从 400768 开始，到 400772 的第一个数结束，其中的内容 42 61 6f 20 59 75 6e 67 61 6e 67对应的 ASCII 码就是字符串 “Bao Yungang” 。 对于 ldata 和 ddata 以及 ddata 所指向的分配空间，很难直接从 objdump 的输出中看出来。我们再把 ddata变量本身的地址也打印出来： 1234567 myname:400768main: 400626gdata: 6010A0bdata:601060ldata:7ffe92607930&amp;ddata:7ffe92607928ddata: 221a010 我们看到，ldata和ddata的地址非常大，而 ddata所指向的分配空间的地址相对来说要小很多，这其实也一定程度上验证了我们的结论，根据我们已知的结论，在程序执行过程中，函数中的局部变量是在函数压栈以后，在栈中分配的，而 malloc 函数分配的空间则是在堆中进行分配的，而栈是从上往下长（高地址到低地址），堆则相反，是从下往上长（低地址到高地址），因此，栈中的变量地址较大，而堆中的则较小，所以，程序运行结果与之相符。"},{"title":"编译器简介： 在 Siri 前时代如何与计算机对话","date":"2017-09-12T02:16:15.000Z","path":"2017/09/12/Introduction-to-Compiler/","text":"简单说来，一个编译器compiler不过是一个可以翻译其他程序的程序。传统的编译器可以把源代码翻译成你的计算机能够理解的可执行机器代码。（一些编译器将源代码翻译成别的程序语言，这样的编译器称为源到源翻译器或转化器transpilers。）LLVM 是一个广泛使用的编译器项目，包含许多模块化的编译工具。 传统的编译器设计包含三个部分： 前端Frontend将源代码翻译为中间表示intermediate representation (IR)* 。clang 是 LLVM 中用于 C 家族语言的前端工具。 优化器Optimizer分析 IR 然后将其转化为更高效的形式。opt 是 LLVM 的优化工具。 后端Backend通过将 IR 映射到目标硬件指令集从而生成机器代码。llc 是 LLVM 的后端工具。 注：LLVM 的 IR 是一种和汇编类似的低级语言。然而，它抽离了特定硬件信息。 Hello, Compiler 下面是一个打印 “Hello, Compiler!” 到标准输出的简单 C 程序。C 语法是人类可读的，但是计算机却不能理解，不知道该程序要干什么。我将通过三个编译阶段使该程序变成机器可执行的程序。 123456789 // compile_me.c// Wave to the compiler. The world can wait.#include &lt;stdio.h&gt;int main() &#123; printf(\"Hello, Compiler!\\n\"); return 0;&#125; 前端 正如我在上面所提到的，clang 是 LLVM 中用于 C 家族语言的前端工具。Clang 包含 C 预处理器C preprocessor、词法分析器lexer、语法解析器parser、语义分析器semantic analyzer和 IR 生成器IR generator。 C 预处理器在将源程序翻译成 IR 前修改源程序。预处理器处理外部包含文件，比如上面的 #include &lt;stdio.h&gt;。 它将会把这一行替换为 stdio.h C 标准库文件的完整内容，其中包含 printf 函数的声明。 通过运行下面的命令来查看预处理步骤的输出： 1 clang -E compile_me.c -o preprocessed.i 词法分析器（或扫描器scanner或分词器tokenizer）将一串字符转化为一串单词。每一个单词或记号token，被归并到五种语法类别之一：标点符号、关键字、标识符、文字或注释。 compile_me.c 的分词过程： 语法分析器确定源程序中的单词流是否组成了合法的句子。在分析记号流的语法后，它会输出一个抽象语法树abstract syntax tree（AST）。Clang 的 AST 中的节点表示声明、语句和类型。 compile_me.c 的语法树： 语义分析器会遍历抽象语法树，从而确定代码语句是否有正确意义。这个阶段会检查类型错误。如果 compile_me.c 的 main 函数返回 &quot;zero&quot;而不是 0， 那么语义分析器将会抛出一个错误，因为 &quot;zero&quot; 不是 int 类型。 IR 生成器将抽象语法树翻译为 IR。 对 compile_me.c 运行 clang 来生成 LLVM IR： 1 clang -S -emit-llvm -o llvm_ir.ll compile_me.c 在 llvm_ir.ll 中的 main 函数： 1234567891011 ; llvm_ir.ll@.str = private unnamed_addr constant [18 x i8] c\"Hello, Compiler!\\0A\\00\", align 1define i32 @main() &#123; %1 = alloca i32, align 4 ; &lt;- memory allocated on the stack store i32 0, i32* %1, align 4 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0)) ret i32 0&#125;declare i32 @printf(i8*, ...) 优化程序 优化程序的工作是基于其对程序的运行时行为的理解来提高代码效率。优化程序将 IR 作为输入，然后生成改进后的 IR 作为输出。LLVM 的优化工具 opt 将会通过标记 -O2（大写字母 o，数字 2）来优化处理器速度，通过标记 Os（大写字母 o，小写字母 s）来减少指令数目。 看一看上面的前端工具生成的 LLVM IR 代码和运行下面的命令生成的结果之间的区别： 1 opt -O2 -S llvm_ir.ll -o optimized.ll 在 optimized.ll 中的 main 函数： 12345678910 optimized.ll@str = private unnamed_addr constant [17 x i8] c\"Hello, Compiler!\\00\"define i32 @main() &#123; %puts = tail call i32 @puts(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str, i64 0, i64 0)) ret i32 0&#125;declare i32 @puts(i8* nocapture readonly) 优化后的版本中， main 函数没有在栈中分配内存，因为它不使用任何内存。优化后的代码中调用 puts 函数而不是 printf 函数，因为程序中并没有使用 printf 函数的格式化功能。 当然，优化程序不仅仅知道何时可以把 printf 函数用 puts 函数代替。优化程序也能展开循环并内联简单计算的结果。考虑下面的程序，它将两个整数相加并打印出结果。 1234567 // add.c#include &lt;stdio.h&gt;int main() &#123; int a = 5, b = 10, c = a + b; printf(\"%i + %i = %i\\n\", a, b, c);&#125; 下面是未优化的 LLVM IR： 1234567891011121314151617181920 @.str = private unnamed_addr constant [14 x i8] c\"%i + %i = %i\\0A\\00\", align 1define i32 @main() &#123; %1 = alloca i32, align 4 ; &lt;- allocate stack space for var a %2 = alloca i32, align 4 ; &lt;- allocate stack space for var b %3 = alloca i32, align 4 ; &lt;- allocate stack space for var c store i32 5, i32* %1, align 4 ; &lt;- store 5 at memory location %1 store i32 10, i32* %2, align 4 ; &lt;- store 10 at memory location %2 %4 = load i32, i32* %1, align 4 ; &lt;- load the value at memory address %1 into register %4 %5 = load i32, i32* %2, align 4 ; &lt;- load the value at memory address %2 into register %5 %6 = add nsw i32 %4, %5 ; &lt;- add the values in registers %4 and %5\\. put the result in register %6 store i32 %6, i32* %3, align 4 ; &lt;- put the value of register %6 into memory address %3 %7 = load i32, i32* %1, align 4 ; &lt;- load the value at memory address %1 into register %7 %8 = load i32, i32* %2, align 4 ; &lt;- load the value at memory address %2 into register %8 %9 = load i32, i32* %3, align 4 ; &lt;- load the value at memory address %3 into register %9 %10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i32 0, i32 0), i32 %7, i32 %8, i32 %9) ret i32 0&#125;declare i32 @printf(i8*, ...) 下面是优化后的 LLVM IR： 12345678 @.str = private unnamed_addr constant [14 x i8] c\"%i + %i = %i\\0A\\00\", align 1define i32 @main() &#123; %1 = tail call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i64 0, i64 0), i32 5, i32 10, i32 15) ret i32 0&#125;declare i32 @printf(i8* nocapture readonly, ...) 优化后的 main 函数本质上是未优化版本的第 17 行和 18 行，伴有变量值内联。opt 计算加法，因为所有的变量都是常数。很酷吧，对不对？ 后端 LLVM 的后端工具是 llc。它分三个阶段将 LLVM IR 作为输入生成机器代码。 指令选择是将 IR 指令映射到目标机器的指令集。这个步骤使用虚拟寄存器的无限名字空间。 寄存器分配是将虚拟寄存器映射到目标体系结构的实际寄存器。我的 CPU 是 x86 结构，它只有 16 个寄存器。然而，编译器将会尽可能少的使用寄存器。 指令安排是重排操作，从而反映出目标机器的性能约束。 运行下面这个命令将会产生一些机器代码： 1 llc -o compiled-assembly.s optimized.ll 12345678910 _main: pushq %rbp movq %rsp, %rbp leaq L_str(%rip), %rdi callq _puts xorl %eax, %eax popq %rbp retqL_str: .asciz \"Hello, Compiler!\" 这个程序是 x86 汇编语言，它是计算机所说的语言，并具有人类可读语法。某些人最后也许能理解我。 相关资源： 设计一个编译器 开始探索 LLVM 核心库 via: https://nicoleorchard.com/blog/compilers 作者：Nicole Orchard译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"Npm 安装 Hexo 失败的解决办法","date":"2017-09-02T05:12:32.000Z","path":"2017/09/02/Fix-Error-With-Install-Hexo/","text":"用 npm 安装 Hexo 时候出现错误，使用 sudo 安装依旧不行。 错误如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /usr/local/bin/hexo -&gt; /usr/local/lib/node_modules/hexo-cli/bin/hexo&gt; dtrace-provider@0.8.5 install /usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider&gt; node scripts/install.js&gt; hexo-util@0.6.1 postinstall /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util&gt; npm run build:highlight&gt; hexo-util@0.6.1 build:highlight /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.jsonsh: 1: cannot create highlight_alias.json: Permission deniednpm ERR! code ELIFECYCLEnpm ERR! errno 2npm ERR! hexo-util@0.6.1 build:highlight: `node scripts/build_highlight_alias.js &gt; highlight_alias.json`npm ERR! Exit status 2npm ERR! npm ERR! Failed at the hexo-util@0.6.1 build:highlight script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.┌──────────────────────────────────────────────────────────┐│ npm update check failed ││ Try running with sudo or get access ││ to the local update config store via ││ sudo chown -R $USER:$(id -gn $USER) /home/fenglv/.config │└──────────────────────────────────────────────────────────┘npm ERR! A complete log of this run can be found in:npm ERR! /home/fenglv/.npm/_logs/2017-09-02T05_00_49_566Z-debug.lognpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.2 (node_modules/hexo-cli/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.2: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"linux\",\"arch\":\"x64\"&#125;)npm ERR! code ELIFECYCLEnpm ERR! errno 2npm ERR! hexo-util@0.6.1 postinstall: `npm run build:highlight`npm ERR! Exit status 2npm ERR! npm ERR! Failed at the hexo-util@0.6.1 postinstall script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! /home/fenglv/.npm/_logs/2017-09-02T05_00_53_335Z-debug.log 解决办法：参见npm 官网 1 sudo chown -R $USER $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125; 问题解决。"},{"title":"听说过时间表，但是你是否知道“哈希表”","date":"2017-09-02T04:44:26.000Z","path":"2017/09/02/Hash-Tables/","text":"探索哈希表hash table的世界并理解其底层的机制是非常有趣的，并且将会受益匪浅。所以，让我们了解它，并从头开始探索吧。 哈希表是许多现代软件应用程序中一种常见的数据结构。它提供了类似字典的功能，使你能够在其中执行插入、删除和删除等操作。这么说吧，比如我想找出“苹果”的定义是什么，并且我知道该定义被存储在了我定义的哈希表中。我将查询我的哈希表来得到定义。它在哈希表内的记录看起来可能像：&quot;苹果&quot; =&gt; &quot;一种拥有水果之王之称的绿色水果&quot;。这里，“苹果”是我的关键字，而“一种拥有水果之王之称的水果”是与之关联的值。 还有一个例子可以让我们更清楚，哈希表的内容如下： 1234 \"面包\" =&gt; \"固体\"\"水\" =&gt; \"液体\"\"汤\" =&gt; \"液体\"\"玉米片\" =&gt; \"固体\" 我想知道面包是固体还是液体，所以我将查询哈希表来获取与之相关的值，该哈希表将返回“固体”给我。现在，我们大致了解了哈希表是如何工作的。使用哈希表需要注意的另一个重要概念是每一个关键字都是唯一的。如果到了明天，我拥有一个面包奶昔（它是液体），那么我们需要更新哈希表，把“固体”改为“液体”来反映哈希表的改变。所以，我们需要添加一条记录到字典中：关键字为“面包”，对应的值为“液体”。你能发现下面的表发生了什么变化吗？（LCTT 译注：不知道这个“面包奶昔”是一种什么食物，大约是一种面包做的奶昔，总之你就理解成作者把液体的“面包奶昔”当成一种面包吧。） 1234 \"面包\" =&gt; \"液体\"\"水\" =&gt; \"液体\"\"汤\" =&gt; \"液体\"\"玉米片\" =&gt; \"固体\" 没错，“面包”对应的值被更新为了“液体”。 关键字是唯一的，我的面包不能既是液体又是固体。但是，是什么使得该数据结构与其他数据结构相比如此特殊呢？为什么不使用一个数组来代替呢？它取决于问题的本质。对于某一个特定的问题，使用数组来描述可能会更好，因此，我们需要注意的关键点就是，我们应该选择最适合问题的数据结构。例如，如果你需要做的只是存储一个简单的杂货列表，那么使用数组会很适合。考虑下面的两个问题，两个问题的本质完全不同。 我需要一个水果的列表 我需要一个水果的列表以及各种水果的价格（每千克） 正如你在下面所看到的，用数组来存储水果的列表可能是更好的选择。但是，用哈希表来存储每一种水果的价格看起来是更好的选择。 12345678 //示例数组[\"苹果\", \"桔子\", \"梨子\", \"葡萄\"] //示例哈希表 &#123; \"苹果\" : 3.05, \"桔子\" : 5.5, \"梨子\" : 8.4, \"葡萄\" : 12.4 &#125; 实际上，有许多的机会需要使用哈希表。 时间以及它对你的意义 这是对时间复杂度和空间复杂度的一个复习。 平均情况下，在哈希表中进行搜索、插入和删除记录的时间复杂度均为 O(1) 。实际上，O(1) 读作“大 O 1”，表示常数时间。这意味着执行每一种操作的运行时间不依赖于数据集中数据的数量。我可以保证，查找、插入和删除项目均只花费常数时间，“当且仅当”哈希表的实现方式正确时。如果实现不正确，可能需要花费很慢的 O(n) 时间，尤其是当所有的数据都映射到了哈希表中的同一位置/点。 构建一个好的哈希表 到目前为止，我们已经知道如何使用哈希表了，但是如果我们想构建一个哈希表呢？本质上我们需要做的就是把一个字符串（比如 “狗”）映射到一个哈希代码（一个生成的数），即映射到一个数组的索引。你可能会问，为什么不直接使用索引呢？为什么要这么麻烦呢？因为通过这种方式我们可以直接查询 “狗” 并立即得到 “狗” 所在的位置，String name = Array[&quot;狗&quot;] // 名字叫拉斯。而使用索引查询名称时，可能出现的情况是我们不知道名称所在的索引。比如，String name = Array[10] // 该名字现在叫鲍勃 - 那不是我的狗的名字。这就是把一个字符串映射到一个哈希代码的益处（对应于一个数组的索引而言）。我们可以通过使用模运算符和哈希表的大小来计算出数组的索引：index = hash_code % table_size。 我们需要避免的另一种情况是两个关键字映射到同一个索引，这叫做哈希碰撞，如果哈希函数实现的不好，这很容易发生。实际上，每一个输入比输出多的哈希函数都有可能发生碰撞。通过下面的同一个函数的两个输出来展示一个简单的碰撞： 12 int cat_idx = hashCode(\"猫\") % table_size; //cat_idx 现在等于 1int dog_idx = hashCode(\"狗\") % table_size; //dog_idx 也等于 1 我们可以看到，现在两个数组的索引均是 1 。这样将会出现两个值相互覆盖，因为它们被写到了相同的索引中。如果我们查找 “猫” 的值，将会返回 “拉斯” ，但是这并不是我们想要的。有许多可以解决哈希碰撞的方法，但是更受欢迎的一种方法叫做链接。链接的想法就是对于数组的每一个索引位置都有一个链表，如果碰撞发生，值就被存到链表中。因此，在前面的例子中，我们将会得到我们需要的值，但是我们需要搜索数组中索引为 1 的位置上的链表。伴有链接的哈希实现需要 O(1 + α) 时间，其中 α 是装载因子，它可以表示为 n/k，其中 n 是哈希表中的记录数目，k 是哈希表中可用位置的数目。但是请记住，只有当你给出的关键字非常随机时，这一结论才正确（依赖于 SUHA）。 这是做了一个很大的假设，因为总是有可能任何不相等的关键字都散列到同一点。这一问题的一个解决方法是去除哈希表中关键字对随机性的依赖，转而把随机性集中于关键字是如何被散列的，从而减少矛盾发生的可能性。这被称为…… 通用散列 这个观念很简单，从通用散列universal hash家族集合随机选择一个哈希函数 h 来计算哈希代码。换句话来说，就是选择任何一个随机的哈希函数来散列关键字。通过这种方法，两个不同的关键字的散列结果相同的可能性将非常低（LCTT 译注：原文是“not be the same”，应是笔误）。我只是简单的提一下，如果不相信我那么请相信数学。实现这一方法时需要注意的另一件事是如果选择了一个不好的通用散列家族，它会把时间和空间复杂度拖到 O(U)，其中 U 是散列家族的大小。而其中的挑战就是找到一个不需要太多时间来计算，也不需要太多空间来存储的哈希家族。 上帝哈希函数 追求完美是人的天性。我们是否能够构建一个完美的哈希函数，从而能够把关键字映射到整数集中，并且几乎没有碰撞。好消息是我们能够在一定程度上做到，但是我们的数据必须是静态的（这意味着在一定时间内没有插入/删除/更新）。一个实现完美哈希函数的方法就是使用 2 级哈希2-Level Hashing，它基本上是我们前面讨论过的两种方法的组合。它使用通用散列来选择使用哪个哈希函数，然后通过链接组合起来，但是这次不是使用链表数据结构，而是使用另一个哈希表。让我们看一看下面它是怎么实现的： 但是这是如何工作的以及我们如何能够确保无需关心碰撞？ 它的工作方式与生日悖论相反。它指出，在随机选择的一堆人中，会有一些人生日相同。但是如果一年中的天数远远大于人数（平方以上），那么有极大的可能性所有人的生日都不相同。所以这二者是如何相关的？对于每一个链接哈希表，其大小均为第一级哈希表大小的平方。那就是说，如果有两个元素被散列到同一个点，那么链接哈希表的大小将为 4 。大多数时候，链接哈希表将会非常稀疏/空。 重复下面两步来确保无需担心碰撞： 从通用散列家族中选择一个哈希函数来计算 如果发生碰撞，那么继续从通用散列家族中选择另一个哈希函数来计算 字面上看就是这样（这是一个 O(n^2) 空间的解）。如果需要考虑空间问题，那么显然需要另一个不同的方法。但是值得庆幸的是，该过程平均只需要进行两次。 总结 只有具有一个好的哈希函数才能算得上是一个好的哈希表。在同时保证功能实现、时间和空间的提前下构建一个完美的哈希函数是一件很困难的事。我推荐你在解决问题的时候首先考虑哈希表，因为它能够为你提供巨大的性能优势，而且它能够对应用程序的可用性产生显著差异。哈希表和完美哈希函数常被用于实时编程应用中，并且在各种算法中都得到了广泛应用。你见或者不见，哈希表就在这儿。 via: http://www.zeroequalsfalse.press/2017/02/20/hashtables/ 作者：Marty Jacobs译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"通过开源书籍学习 Ruby 编程","date":"2017-09-02T04:44:13.000Z","path":"2017/09/02/Open-Source-Ruby-Books/","text":"开源的 Ruby 书籍 Ruby 是由 Yukihiro “Matz” Matsumoto 开发的一门通用目的、脚本化、结构化、灵活且完全面向对象的编程语言。它具有一个完全动态类型系统，这意味着它的大多数类型检查是在运行的时候进行，而非编译的时候。因此程序员不必过分担心是整数类型还是字符串类型。Ruby 会自动进行内存管理，它具有许多和 Python、Perl、Lisp、Ada、Eiffel 和 Smalltalk 相同的特性。 Ruby on Rails 框架对于 Ruby 的流行起到了重要作用，它是一个全栈 Web 框架，目前已被用来创建许多受欢迎的应用，包括 Basecamp、GitHub、Shopify、Airbnb、Twitch、SoundCloud、Hulu、Zendesk、Square 和 Highise 。 Ruby 具有很高的可移植性性，在 Linux、Windows、Mac OS X、Cygwin、FreeBSD、NetBSD、OpenBSD、BSD/OS、Solaris、Tru64 UNIX、HP-UX 以及其他许多系统上均可运行。目前，Ruby 在 TIOBE 编程社区排名 12 。 这篇文章有 9 本很优秀的推荐书籍，有针对包括初学者、中级程序员和高级程序员的书籍。当然，所有的书籍都是在开源许可下发布的。 这篇文章是 OSSBlog 的系列文章开源编程书籍的一部分。 《Ruby Best Practices》 作者： Gregory Brown (328 页) 《Ruby Best Practices》适合那些希望像有经验的 Ruby 专家一样使用 Ruby 的程序员。本书是由 Ruby 项目 Prawn 的开发者所撰写的，它阐述了如何使用 Ruby 设计美丽的 API 和特定领域语言，以及如何利用函数式编程想法和技术，从而简化代码，提高效率。 《Ruby Best Practices》 更多的内容是关于如何使用 Ruby 来解决问题，它阐述的是你应该使用的最佳解决方案。这本书不是针对 Ruby 初学者的，所以对于编程新手也不会有太多帮助。这本书的假想读者应该对 Ruby 的相应技术有一定理解，并且拥有一些使用 Ruby 来开发软件的经验。 这本书分为两部分，前八章组成本书的核心部分，后三章附录作为补充材料。 这本书提供了大量的信息： 通过测试驱动代码 - 涉及了大量的测试哲学和技术。使用 mocks 和 stubs 通过利用 Ruby 神秘的力量来设计漂亮的 API：灵活的参数处理和代码块 利用动态工具包向开发者展示如何构建灵活的界面，实现单对象行为，扩展和修改已有代码，以及程序化地构建类和模块 文本处理和文件管理集中于正则表达式，文件、临时文件标准库以及文本处理策略实战 函数式编程技术优化了模块代码组织、存储、无穷目录以及更高顺序程序。 理解代码如何出错以及为什么会出错，阐述如何处理日志记录 通过利用 Ruby 的多语言能力削弱文化屏障 熟练的项目维护 本书为开源书籍，在 CC NC-SA 许可证下发布。 在此下载《Ruby Best Practices》。 《I Love Ruby》 作者： Karthikeyan A K (246 页) 《I Love Ruby》以比传统的介绍更高的深度阐述了基本概念和技术。该方法为编写有用、正确、易维护和高效的 Ruby 代码提供了一个坚实的基础。 章节内容涵盖： 变量 字符串 比较和逻辑 循环 数组 哈希和符号 Ranges 函数 变量作用域 类 &amp; 对象 Rdoc 模块和 Mixins 日期和时间 文件 Proc、匿名 和 块 多线程 异常处理 正则表达式 Gems 元编程 在 GNU 自由文档许可证之下，你可以复制、发布和修改本书，1.3 或任何之后版本由自由软件基金会发布。 点此下载《I Love Ruby》。 Programming Ruby – The Pragmatic Programmer’s Guide 作者： David Thomas, Andrew Hunt (HTML) 《Programming Ruby – The Pragmatic Programmer’s Guide》是一本 Ruby 编程语言的教程和参考书。使用 Ruby，你将能够写出更好的代码，更加有效率，并且使编程变成更加享受的体验。 内容涵盖以下部分： 类、对象和变量 容器、块和迭代器 标准类型 更多方法 表达式 异常、捕获和抛出 模块 基本输入和输出 线程和进程 何时抓取问题 Ruby 和它的世界、Web、Tk 和 微软 Windows 扩展 Ruby 映像、对象空间和分布式 Ruby 标准库 面向对象设计库 网络和 Web 库 嵌入式文件 交互式 Ruby shell 这本书的第一版在开放发布许可证 1.0 版或更新版的许可下发布。本书更新后的第二版涉及 Ruby 1.8 ，并且包括所有可用新库的描述，但是它不是在免费发行许可证下发布的。 点此下载《Programming Ruby – The Pragmatic Programmer’s Guide》。 《Why’s (Poignant) Guide to Ruby》 作者：why the lucky stiff (176 页) 《Why’s (poignant) Guide to Ruby》是一本 Ruby 编程语言的介绍书籍。该书包含一些冷幽默，偶尔也会出现一些和主题无关的内容。本书包含的笑话在 Ruby 社区和卡通角色中都很出名。 本书的内容包括： 关于本书 Kon’nichi wa, Ruby 一个快速（希望是无痛苦的）的 Ruby 浏览（伴随卡通角色）：Ruby 核心概念的基本介绍 代码浮动小叶：评估和值，哈希和列表 组成规则的核心部分：case/when、while/until、变量作用域、块、方法、类定义、类属性、对象、模块、IRB 中的内省、dup、self 和 rbconfig 模块 中心：元编程、正则表达式 当你打算靠近胡须时：在已存在类中发送一个新方法 天堂演奏 本书在 CC-SA 许可证许可下可用。 点此下载《Why’s (poignant) Guide to Ruby》。 《Ruby Hacking Guide》 作者： Minero Aoki ，翻译自 Vincent Isambart 和 Clifford Escobar Caoille (HTML) 通过阅读本书可以达成下面的目标： 拥有关于 Ruby 结构的知识 掌握一般语言处理的知识 收获阅读源代码的技能 本书分为四个部分： 对象 动态分析 评估 外部评估 要想从本书中收获最多的东西，需要具备一定 C 语言的知识和基本的面向对象编程知识。本书在 CC-NC-SA 许可证许可下发布。 原书的官方支持网站为 i.loveruby.net/ja/rhg/ 点此下载《Ruby Hacking Guide》 《The Book Of Ruby》 作者： How Collingbourne (425 页) 《The Book Of Ruby》是一本免费的 Ruby 编程高级教程。 《The Book Of Ruby》以 PDF 文件格式提供，并且每一个章节的所有例子都伴有可运行的源代码。同时，也有一个介绍来阐述如何在 Steel 或其他任何你喜欢的编辑器/IDE 中运行这些 Ruby 代码。它主要集中于 Ruby 语言的 1.8.x 版本。 本书被分成很小的块。每一个章节介绍一个主题，并且分成几个不同的子话题。每一个编程主题由一个或多个小的自包含、可运行的 Ruby 程序构成。 字符串、数字、类和对象 - 获取输入和输出、字符串和外部评估、数字和条件测试：if … then、局部变量和全局变量、类和对象、实例变量、消息、方法、多态性、构造器和检属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量 类等级、属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量 字符串和 Ranges - 用户自定义字符串定界符、引号等更多 数组和哈希 - 展示如何创建一系列对象 循环和迭代器 - for 循环、代码块、while 循环、while 修改器以及 until 循环 条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修改器、以及 case 语句 方法 - 类方法、类变量、类方法是用来干什么的、Ruby 构造器、单例方法、单例类、重载方法以及更多 传递参数和返回值 - 实例方法、类方法、单例方法、返回值、返回多重值、默认参数和多重参数、赋值和常量传递以及更多 异常处理 - 涉及 rescue、ensure、else、错误数量、retry 和 raise 块、Procs 和 匿名 - 阐述为什么它们对 Ruby 来说很特殊 符号 - 符号和字符串、符号和变量以及为什么应该使用符号 模块和 Mixins 文件和 IO - 打开和关闭文件、文件和目录、复制文件、目录询问、一个关于递归的讨论以及按大小排序 YAML - 包括嵌套序列，保存 YAML 数据以及更多 Marshal - 提供一个保存和加载数据的可选择方式 正则表达式 - 进行匹配、匹配群组以及更多 线程 - 向你展示如何同时运行多个任务 调试和测试 - 涉及交互式 Ruby shell（IRB.exe）、debugging 和 单元测试 Ruby on Rails - 浏览一个创建博客的实践指南 动态编程 - 自修改程序、重运算魔法、特殊类型的运算、添加变量和方法以及更多 本书由 SapphireSteel Software 发布，SapphireSteel Software 是用于 Visual Studio 的 Ruby In Steel 集成开发环境的开发者。读者可以复制和发布本书的文本和代码（免费版） 点此下载《The Book Of Ruby》 《The Little Book Of Ruby》 作者： Huw Collingbourne (87 页) 《The Little Book of Ruby》是一本一步接一步的 Ruby 编程教程。它指导读者浏览 Ruby 的基础。另外，它分享了《The Book of Ruby》一书的内容，但是它旨在作为一个简化的教程来阐述 Ruby 的主要特性。 章节内容涵盖： 字符串和方法 - 包括外部评估。详细描述了 Ruby 方法的语法 类和对象 - 阐述如何创建一个新类型的对象 类等级 - 一个特殊类型的类，其为一些其他类的简化并且继承了其他一些类的特性 访问器、属性、类变量 - 访问器方法，属性读写器，属性创建变量，调用超类方法以及类变量探索 数组 - 学习如何创建一系列对象：数组包括多维数组 哈希 - 涉及创建哈希表，为哈希表建立索引以及哈希操作等 循环和迭代器 - for 循环、块、while 循环、while 修饰器以及 until 循环 条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修饰器以及 case 语句 模块和 Mixins - 包括模块方法、模块作为名字空间模块实例方法、模块或 ‘mixins’、来自文件的模块和预定义模块 保存文件以及更多内容 本书可免费复制和发布，只需保留原始文本且注明版权信息。 点此下载《The Little Book of Ruby》 《Kestrels, Quirky Birds, and Hopeless Egocentricity》 作者： Reg “raganwald” Braithwaite (123 页) 《Kestrels, Quirky Birds, and Hopeless Egocentricity》是通过收集 “Raganwald” Braithwaite 的关于组合逻辑、Method Combinators 以及 Ruby 元编程的系列文章而形成的一本方便的电子书。 本书提供了通过使用 Ruby 编程语言来应用组合逻辑的一个基本介绍。组合逻辑是一种数学表示方法，它足够强大，从而用于解决集合论问题以及计算中的问题。 在这本书中，读者会会探讨到一些标准的 Combinators，并且对于每一个 Combinators，书中都用 Ruby 编程语言写程序探讨了它的一些结果。在组合逻辑上，Combinators 之间组合并相互改变，书中的 Ruby 例子注重组合和修改 Ruby 代码。通过像 K Combinator 和 .tap 方法这样的简单例子，本书阐述了元编程的理念和递归 Combinators 。 本书在 MIT 许可证许可下发布。 点此下载《Kestrels, Quirky Birds, and Hopeless Egocentricity》 《Ruby Programming》 作者： Wikibooks.org (261 页) Ruby 是一种解释性、面向对象的编程语言。 本书被分为几个部分，从而方便按顺序阅读。 开始 - 向读者展示如何在其中一个操作系统环境中安装并开始使用 Ruby Ruby 基础 - 阐述 Ruby 语法的主要特性。它涵盖了字符串、编码、写方法、类和对象以及异常等内容 Ruby 语义参考 内建类 可用模块，涵盖一些标准库 中级 Ruby 涉及一些稍微高级的话题 本书在 CC-SA 3.0 本地化许可证许可下发布。 点此下载《Ruby Programming》 无特定顺序，我将在结束前推荐一些没有在开源许可证下发布但可以免费下载的 Ruby 编程书籍。 Mr. Neighborly 的 Humble Little Ruby Book – 一个易读易学的 Ruby 完全指南。 Introduction to Programming with Ruby – 学习编程的基础知识，一切从零开始。 Object Oriented Programming with Ruby – 学习编程的基础知识，一切从零开始。 Core Ruby Tools – 对 Ruby 的四个核心工具 Gems、Ruby Version Managers、Bundler 和 Rake 进行了简短的概述。 Learn Ruby the Hard Way, 3rd Edition – 一本适合初学者的入门书籍。 Learn to Program – 来自 Chris Pine。 Ruby Essentials – 一个准确且简单易学的 Ruby 学习指南。 via: https://www.ossblog.org/study-ruby-programming-with-open-source-books/ 作者：Steve Emms译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"外部排序","date":"2017-08-08T04:53:19.000Z","path":"2017/08/08/External-Sort/","text":"主存储器与外部存储器 外存储器与内存储器相比,优点是: 价格较低 永久的存储能力 缺点: 访问外存储器上的数据比访问内存要慢5 ~ 6 个数量级 因此，要求我们在开发系统时必须考虑如何使外存访问次数达到最少。 磁盘 磁盘存储器通常称为直接存取设备,或随机存取设备,它访问外存上文件的任一记录的时间几乎相同。 磁盘存储器可以顺序存取,也可以随机存取。 每个记录盘面上有很多磁道,数据就存放在这些磁道上。它们在记录盘面上形成一个个同心圆。 每个记录盘面都有一个读写磁头。所有记录盘面的读写磁头都安装在同一个动臂上,随动臂向内或向外做径向移动,从一个磁道移到另一个磁道。 任一时刻,所有记录盘面的读写磁头停留在各个记录盘面的半径相同的磁道上。 各个记录盘面上半径相同的磁道合在一起称为柱面。一个磁道可以划分为若干段,称为扇区,一个扇区就是一次读写的最小数据量。这样,对磁盘存储器来说,从大到小的存储单位是:柱面号、盘片号、磁道号和扇区。 在磁盘组上一次读写的时间主要花在寻找时间上。因此,在磁盘上存放信息时应将相关信息放在同一柱面或邻近柱面上,以求在读写信息时尽量减少磁头来回移动的次数,以避免不必要的寻找时间。 外排序 当待排序的记录数目特别多时,在内存中不能一次处理,必须把它们以文件的形式存放于外存,排序时再把它们一部分一部分调入内存进行处理。这样,在排序过程中必须不断地在内存与外存之间传送数据。这种基于外部存储设备(或文件)的排序技术就是外排序。 外排序的基本过程 基于磁盘进行的排序多使用归并排序方法。其排序过程主要分为两个阶段: 按可用内存大小,将外存上含 n 个记录的文件划分为若干长度为 l 的段 , 用某种内排序方法对各段进行排序。经过排序的段叫做归并段 (Run) 。当它们生成后就被写到外存中去。 把1生成的初始归并段加以归并 , 一趟趟扩大归并段和减少归并段数 , 直至得到整个有序文件为止。 K-路平衡归并 做K-路平衡归并时，如果有m个初始归并段，相应的归并树有logkm+1(logkm上取整)层，需要归并logkm(上取整)趟。 败者树 败者树是一棵正则的完全二叉树。其中 每个叶结点存放各归并段在归并过程中当前参加比较的记录; 每个非叶结点记忆它两个子女结点中记录排序码大的结点 ( 即败者 ) ; 因此,根结点中记忆树中当前记录排序码最小的结点 ( 最小记录 ) 。 败者树与胜者树的区别在于一个选择了败者 ( 排序码大者)，一个选择了胜者(排序码小者) K-路平衡归并排序算法 12345678910111213141516171819202122232425262728293031323334353637 const int MaxValue = ; //当作无穷大值使用void kwaymerge(Element *r, int k) &#123; int i, q; r = new Element[k]; //败者树中的k个记录 int *key = new int[k+1]; //记录的排序码 int *loser = new int[k]; //存放败者树 for (i = 0; i &lt; k; i++) &#123; //叶结点的值 InputRecord(r[i]); key[i] = r[i].key; &#125;; for (i = 0; i &lt; k; i++) loser[i] = k; key[k] = -Maxvalue; //初始化 for (i = k-1; i &gt; 0; i--) adjust (key, loser, k, i); //从key[k-1]到key[0]调整形成败者树 while (key[loser[0]] != MaxValue) &#123; //选冠军 q = loser[0]; //取当前最小记录 OutputRecord(r[q]); //写到输出归并段 InputRecord(r[q]); //读入下一个记录 key[q] = r[q].key; adjust (key, loser, k, q); //从key[q]起调整 &#125; Output end of run marker; //输出段结束标志 delete []r; delete []key; delete []loser;&#125;; //败者树的调整算法void adjust (int key[]; int loser[]; int k; int q) &#123;// 从败者树某叶结点 key[q] 起到根进行比较 , 将最小// key 记录所在归并段的段号记入 loser[0] 。 for (int t = (k+q)/2; t &gt; 0; t /= 2)//t 是 q 的双亲 if (key[loser[t]] &lt; key[q]) &#123;// 败者记入 loser[t] ,胜者记入 q int temp = q; q = loser[t]; loser[t] = temp; &#125;//q 与 loser[t] 交换 loser[0] = q;&#125;; 每选出一个当前排序码最小的记录 , 就需要在将它送入输出缓冲区之后 , 从相应归并段的输入缓冲区中取出下一个参加归并的记录 , 替换已经取走的最小记录 , 再从叶结点到根结点 , 沿某一特定路径进行调整 , 将下一个排序码最小记录的归并段号调整到 loser[0]中。 段结束标志 MaxNum升入 loser[0], 排序完成。 归并路数 k 不是越大越好。归并路数 k 增大 , 相应需增加输入缓冲区个数。如果可供使用的内存空间不变 , 势必要减少每个输入缓冲区的容量 , 使内外存交换数据的次数增大。 初始归并段的生成 为减少读写磁盘次数 , 除增加归并路数 k 外 ,还可减少初始归并段个数 m 。在总记录数 n一定时 , 要减少 m , 必须增大初始归并段长度。 如果规定每个初始归并段等长 , 则此长度应根据生成它的内存工作区空间大小而定 , 因而 m的减少也就受到了限制。 为了突破这个限制 , 可采用败者树来生成初始归并段。在使用同样大内存工作区的情况下 ,可以生成平均比原来等长情况下大一倍的初始归并段 , 从而减少初始归并段个数。 最佳归并树 归并树是描述归并过程的 m 叉树。因为每一次做 m路归并都需要有 m个归并段参加 , 因此 , 归并树是只有度为 0和度为 m 的结点的正则 m 叉树。 在归并树中： 各叶结点代表参加归并的各初始归并段 叶结点上的权值即为该初始归并段中的记录个数 根结点代表最终生成的归并段 叶结点到根结点的路径长度表示在归并过程中的读记录次数 各非叶结点代表归并出来的新归并段 归并树的带权路径长度 WPL 即为归并过程中的总读记录数。因而,在归并过程中总的读写记录次数为 2*WPL 。 不同的归并方案所对应的归并树的带权路径长度各不相同。为了使得总的读写次数达到最少 , 需要改变归并方案 , 重新组织归并树。可将 Huffman 树的思想扩充到 m 叉树的情形。在归并树中 , 让记录个数少的初始归并段最先归并 , 记录个数多的初始归并段最晚归并 , 就可建立总读写次数达到最少的最佳归并树。"},{"title":"内部排序","date":"2017-08-08T04:51:50.000Z","path":"2017/08/08/Inner-Sort/","text":"排序 排序:将一组杂乱无章的数据按一定的规律顺次排列起来。 假设含 n 个记录的序列为 { R1, R2, … , Rn }其相应的关键字序列为 { K1, K2, … , Kn }这些关键字相互之间可以进行比较,即在它们之间存在着这样一个关系 : Kp1 &lt;= Kp2 &lt;= …&lt;= Kpn按此固有关系将上式记录序列重新排列,即使序列成为一个按关键字排序的 序列:{ Rp1, Rp2, … , Rpn }的操作称作排序。 排序算法的稳定性 : 当输入含重复关键字时,重复元素在输入、输出序列中的相对次序是否保持不变。 内排序与外排序 : 内排序是指在 整个排序过程 数据元素全部存放在内存、 不需要访问外存便能完成 的排序, 称此类排序为内部排序 ; 反之,若参加排序的记录数量很大 ,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序, 称为外部排序。 排序算法的分类 :内部排序算法很多。但就其全面性能而言,很难认为哪种方法是最好的。没一种方法都有各自的优缺点,适合在不同环境下使用。插入排序、交换排序、选择排序、归并排序、计数排序等等 &lt; 按排序过程中依据的不同原则 &gt; 待排记录数据类型定义 1234567891011 //待排记录的数据类型定义如下 :#define MAXSIZE 1000 // 待排顺序表最大长度typedef int KeyType; // 关键字类型为整数类型typedef struct &#123; KeyType key;// 关键字项 InfoType otherinfo; // 其它数据项&#125; RcdType;// 记录类型typedef struct &#123; RcdType r[MAXSIZE+1]; // r[0] 闲置 int length;// 顺序表长度&#125; SqList;// 顺序表类型 冒泡排序 基于交换的排序方法。 观察：有序/无序序列中，任意/总有一对相邻元素顺序/逆序 扫描交换：依次比较每一对相邻元素，如有必要，交换之 经一轮扫描交换后，最大元素必然就位；经一轮扫描交换后，问题的规模缩减至n-1。 若整趟扫描都没有进行交换，则排序完成。 1234567891011121314151617181920212223242526 void BubbleSort(Elem R[ ], int n) &#123; i = n;//首先从n位置排序 bool sorted = false; while (!sorted) &#123;//第[i..n]大元素已排序，寻找 第i-1大元素 sorted = true; for (j = 1; j &lt; i; j++) //从[1..i-1]寻找第i-1大元素 if (R[j+1].key &lt; R[j].key) &#123; //将大的记录向后移 Swap(R[j], R[j+1]); sorted = false; //记下进行交换的记录位置 &#125; //if i -= 1; &#125; // while&#125; // BubbleSortvoid BubbleSort(Elem R[ ], int n) &#123; int i = n;//首先从n位置排序 while (i &gt;1) &#123;//第[i..n]大元素已排序，寻找 第i-1大元素 int lastExchangeIndex = 1; for (j = 1; j &lt; i; j++) //从[1..i-1]寻找第i-1大元素 if (R[j+1].key &lt; R[j].key) &#123; //将大的记录向后移 Swap(R[j], R[j+1]); lastExchangeIndex = j; //记下进行交换的记录位置 &#125; //if i = lastExchangeIndex; //本趟进行过交换的最后一个记录的位置 &#125; // while&#125; // BubbleSort 时间复杂度 最好情况：O(n)；最坏情况：O(n^2) 稳定性 稳定 归并排序 基本方法:分而治之，序列一分为二 //O(1)；子序列递归排序 //2×T(n/2)；合并有序子序列 //O(n) 归并排序算法的复杂度为 O(nlogn) 关键在于 merge 的实现 123456789101112131415161718192021222324252627 void mergesort (int low, int hi ) &#123; if (hi-lo&lt;2) return; // 单个元素区间自然有序 else &#123; mi = (low+hi)/2; // 以中点为界 mergesort (low, mi); // 将前半段排序 mergesort (mi+1, hi); // 对后半段排序 Merge (low, mi, hi); // 归并 &#125;&#125; // Msort//二路归并算法void Merge (int low, int mi, int hi) &#123; RcdType *A = elements+low; int lb = mi-low; RcdType *B = new RcdType[1b]; for (i=0; i&lt;lb; B[i] = A[i++]); int lc = hi-mi; RcdType *C = elements+mi; for (i=0, j=0, k=0; j&lt;lb || k&lt;lc; ) &#123; if ( (j&lt;lb) &amp;&amp; (lc&lt;=k || B[j].key&lt;=C[k].key) ) A[i++] = B[j++]; if ( (k&lt;lc) &amp;&amp; (lb&lt;=j || C[k].key&lt;B[j].key) ) A[i++] =C[k++]; &#125; delete(B);&#125;//Merge 算法分析 优点： 最坏情况下最优 O(nlogn) 性能的第一个排序算法 不需要随机读写,完全顺序访问 - 尤其适用于列表之类的序列，磁带之类的设备 只要实现恰当,可保证稳定 可扩展性极佳,十分适宜于外部排序 - 海量网页搜索结果的归并易于并行化 稳定的排序算法。 缺点： 需要对等规模的辅助空间 即便输入完全(或者接近)有序,仍需 O(nlogn) 时 插入排序 基本方法: 始终将序列看作两部分sorted + unsorted，L[0, r]+L[r, n} 初始条件：r=0; 迭代: 处理 e=L[r]，在 sorted 中确定当前元素 e 的适当位置,插入 e ,得到有序的 L[0, r] 不变性:随着 r 的递增, L[0, r) 始终有序,直到 r =n, L 即为整体有序 12345678 void InsertionSort ( SqList &amp;L ) &#123;// 对顺序表 L 作插入排序 for ( i=2; i&lt;=L.length; ++i ) // 逐个将 i 插入已排好 [1..i-1] 中 if (L.r[i].key &lt; L.r[i-1].key) &#123; // 只有小于时需要改变位置 p = search(L.r[i], i, L); L.r[p] = L.r[i]; &#125;&#125; // InsertSort 算法分析 最坏情况：O(n)； 最好情况：O(n^2)； 稳定的排序算法。 选择排序 起泡排序之所以需要O(n2)时间，是因为为挑选每个当前最大的元素M，需做O(n)次比较和O(n)次交换 实际上经过O(n)次比较确定M后，一次交换足矣 123456789101112 void SelectSort (Elem R[], int n ) &#123; // 对记录序列R[1..n]作简单选择排序。 for (i=1; i&lt;n; ++i) &#123; // 选择第 i 小的记录，并交换到位 j = SelectMinKey(R, i); // 与第 i 个记录交换 if (i!=j) int t = R[i]; R[i] = R[j]; R[j] = t; &#125;&#125; // SelectSort 算法分析 共迭代n次，在第k次迭代中SelectMinKey的复杂度O(n-k) SelectMinKey的复杂度可以降至O(logn) 树形选择排序/锦标赛排序 一种按照锦标赛思想进行选择排序的方法。这个过程可以用一棵有 n 个叶子结点的完全二叉树表示：叶节点:待排序元素(选手)；内部节点:孩子中的胜者； 这种比赛树又称为胜者树。 锦标赛选择 更新:唯上一优胜者的祖先,才有必要重新参加比赛，只需从其所在叶节点出发,逐层上溯直到树根。 堆排序 堆是满足下列性质的数列：{r1, r2, ..., rn} 大顶堆 r_i &gt;= r_2i, r_i &gt;= r_2i+1 小顶堆 r_i &lt;= r_2i, r_i &lt;= r_2i+1 堆的结构性 : 逻辑上:等同于完全二叉树 物理上:直接借助顺序存储实现 堆的堆序性：堆是符合这样定义的一棵有局部顺序的线性化完全二叉树：K[i]\\le K[parent(i)]或$K[i]\\ge K[parent(i)]` 优先级队列(PQ priority queue) 队列的一种，不过它可以按照自定义的一种方式（数据的优先级）来对队列中的数据进行态的访问，以方便快速求取最大优先级的数据。 栈和队列，都是PQ的特例——优先级完全取决于元素的插入次序 应用：操作系统中的任务调度、中断处理、离散事件模拟等等 作为底层数据结构所支持的高效操作，是很多高效算法的基础 完全二叉堆：插入 为插入一个新的元素 e ,只需将 e 作为末元素放入原顺序结构。 唯一可能违反堆序性的只有该新节点和它的父亲。 只需从其所在叶节点出发,逐层上溯直到满足堆序性【上滤】。 效率： e 与父亲的交换,每次只需 o(1) 时间,且每经过一次交换, e 都会上升一层; 在插入新节点 e 的整个过程中,只有 e 的祖先们才有可能需要参与交换; 堆是一棵完全树,必平衡,故 e 的祖先至多 o(logn) 所以，通过上滤,可在 O(logn) 时间内插入一个新节点,并整体的重新调整为堆。 1234567891011121314 //插入和上滤Insert(Sqlist &amp;heap, RedType e)&#123; heap.r[heap.length] = e; heap.length += 1; percolateUp(heap, heap.length);&#125; percolateUp(Sqlist &amp;heap, int i)&#123; while ( ParentValid(i) )&#123; j = Parent（i）； if ( heap.r[i].key &gt; heap.r[j].key ) break; swap(heap.r[i], heap.r[j]); i = j; &#125;&#125; 完全二叉堆：删除 最大元素始终在堆顶,故删除只需摘除首元素,代之以末元素 e；// 结构性自然保持,那堆序性如何保持? 唯一可能违反堆序性的只有该节点e 和它的孩子们。 只需从根节点出发,与孩子中的大者换位,逐层下滤直到满足堆 效率:通过下滤,可在 O(logn) 时间内删除堆顶节点,并整体地重新调整为堆。 建堆 自上而下的上滤 建堆可以是一个从空堆开始,依次插入各元素。 1234 Heapify(Sqlist &amp;L)&#123; for (i =1; i&lt;L.length; i++) percolateUp(L, i) ; // 经上滤插入各节点&#125; 效率: 在最坏情况下,每个元素都需上滤到根节点,所以时间复杂度是O(nlogn) 。 自下而上的下滤 给定堆 H0 、 H1 和节点 P,为了得到堆 H0 UPU H1 ,只需将 ra(H0的堆顶) 和 rb(H1的堆顶) 当作 P 的孩子,对 p 下滤 从下向上,子堆逐层合并 1234 Heapify(Sqlist &amp;L)&#123; for (int i = L.length/2; i&gt;0; i--) percolateDown(L, i) ; // 下滤各内部节点&#125; 效率：时间复杂度为O(n) 堆排序即是利用堆的特性,不断输出当前最小( 大 ) 值,从而实现对序列进行排序的一种排序方法。 堆排序是不稳定的排序算法。 1234567891011 //堆排序算法void HeapSort (Sqlist &amp;L ) &#123;// 对顺序表 L 进行堆排序 Heapify ( L ); // 建大顶堆 for ( i=H.length; i&gt;1; --i ) &#123; int t = H.r[0]; H.r[0] = H.r[i]; H.r[i] = t; // 将堆顶记录和当前未经排序子序列H.r[1..i] 中最后一个记录相互交换堆 &#125; percolateDown(L, 0) ; // 对 H.r[0..i-1] 调整,成为新堆&#125; // HeapSort 算法分析： 堆排序的时间复杂度为 O(nlogn) 。 堆排序方法对 n 较大的文件是很有效的。 左式堆 左式堆是一棵单侧倾斜的树: 节点分布偏向左侧 合并操作只涉及右侧 12345678910111213141516171819202122232425262728293031 //左式堆的合并BiNode *Merge(BiNode *a, *b)&#123; if ( !a) return b; if (!b) return a; if ( a-&gt;data&lt;=b-&gt;data ) swap( b, a);//一般确保b不大，确保堆序性 a-&gt;rchild = merge(a-rchild, b); //将a的右子堆与b合并 a-&gt;rchild-&gt;parent = a;//更新父子关系 if ( !a-&gt;lchild || a-&gt;lchild-&gt;NPL &lt; a-&gt;rchild-&gt;NPL ) swap( a-&gt;lchild, a-&gt;rchild ); a-&gt;NLP = a-&gt;rc ? A-&gt;rchild-&gt;NPL+1: 1;//更新父节点的NPL return a;&#125;//左式堆的插入 insert( )BiNode *insert(BiNode *a, e)&#123; BiNode *v = new BiNode(e); root= merge(a, v); root-&gt;parent = NULL;&#125;//左式堆的最大元素的删除DelMaxBiNode *insert(BiNode *root)&#123; BiNode *lHeap = root-&gt;lChild ;BiNode *rHeap = root-&gt;rChild; e = root-&gt;data; delete root; root = merge( lHeap,rHeap); if ( root ) root-&gt;parent = NULL; return e;&#125; 快速排序 分治策略的再一次体现 将序列分为两个子序列: S = SL +SR；规模缩小: max{|SL|,|SR|}&lt;n；彼此独立: max(SL ) &lt;= min(SR ) 在子序列分别递归地排序后,原序列自然有序 平凡解:当只剩单个元素时,本身就是解 QuickSort 的难点在于“分” [ 归并排序 ] 123456789101112131415161718192021222324252627282930313233 void QSort (RedType &amp; R[], int s, int t ) &#123; // 对记录序列R[s..t]进行快速排序 if (s &lt; t-1) &#123; // 长度大于1 pivotloc = Partition(R, s, t); // 对 R[s..t] 进行一次划分 QSort(R, s, pivotloc-1); // 对低子序列递归排序 QSort(R, pivotloc+1, t); // 对高子序列递归排序 &#125;&#125; // QSortvoid QuickSort( SqList &amp; L) &#123; // 对顺序表进行快速排序 QSort(L.r, 1, L.length);&#125; // QuickSortint Partition (RedType&amp; R[], int low, int high) &#123; pivotkey = R[low].key; // 枢轴 while (low&lt;high) &#123; while (low&lt;high &amp;&amp; R[high].key&gt;=pivotkey) --high; R[low]=R[high]; while (low&lt;high &amp;&amp; R[low].key&lt;=pivotkey) ++low; R[high]=R[low]; &#125; return low;// 返回枢轴所在位置&#125; // Partitionint Partition2 (RedType&amp; R[], int low, int high) &#123; pivotkey = R[low].key; // 枢轴 mid = low; for (int k = low+1; k&lt;=high; k++) if (R[k].key&lt;pivotkey) swap(R[++mid], R[k]); swap(R[low], R[mid]);return mid;// 返回枢轴所在位置&#125; // Partition例: 希尔排序 又称“缩小增量排序”，将记录序列分成若干子序列，分别对每个子序列进行插入排序。 1234567891011121314 void ShellSort (SqList &amp;L, int dlta[], int t)&#123;// 增量序列为 dlta[] 的希尔排序,序列长为 t for (k=0; k&lt;t; ++t) ShellInsert(L, dlta[k]);&#125; // ShellSortvoid ShellInsert ( SqList &amp;L, int dk ) &#123; for ( i=dk+1; i&lt;=n; ++i )// 对每个元素在当前增量子序列中排序 if ( L.r[i].key&lt; L.r[i-dk].key) &#123;// 在子序列中用直接插入法排序当前元素 L.r[0] = L.r[i]; for (j=i-dk; j&gt;0&amp;&amp;(L.r[0].key&lt;L.r[j].key); j-=dk) L.r[j+dk] = L.r[j]; // 记录后移,查找插入位置 L.r[j+dk] = L.r[0]; // 插入 &#125; // if&#125; // ShellInsert 算法分析 希尔排序是一种不稳定的插入排序方法。 希尔排序的时间复杂性与各列内部排序的算法 ( 插入 ) 由关。内部排序不一定是高效的,但需要是 input-sensitive 但其实际运行的时间更多地取决于所取“增量”序列的有关,涉及数学上尚未解决的难题。 基数排序 基数排序是一种借助“多关键字排序”的思想来实现“单关键字排序”的内部排序算法。 实现多关键字排序通常有两种作法 : 关键字{K^0&gt;K^1&gt;...&gt;K^{d-1}} 最高位优先 MSD 法 (Most Significant Digit first ) 先对 K^0 进行排序,按 K^0$的不同值将记录序列分成若干子序列之后,分别对 $K^1进行排,…,最后对最次位关键字排序。 最低位优先 LSD 法 (Least Significant Digit first) 先对K^{d-1} 进行排序,然后对K^{d-2} 进行排序, …, 最后对最主位关键字 K^0排序。 对比 最高位优先法 必须将序列逐层分割为若干子序列,然后对各子序列分别进行排序 。 最低位优先法 使用这种排序方法对每一个关键字进行排序时,不必分成子序列,对每个关键字都是整个序列参加排序。 按 LSD 排序时,可以通过若干次“分配”和“收集”来实现排序。其好处是不需要进行关键字间的比较。 实现 在计算机上实现基数排序时,为减少所需辅助存储空间,应采用链表作存储结构,即链式基数排序,具体作法为: 待排序记录以指针相链,构成一个链表; “分配” 时,按当前“关键字位”所取值,将记录分配到不同的 “链队列” 中,每个队列中记录的 “关键字位” 相同; “收集”时,按当前关键字位取值从小到大将各队列首尾相链成一个链表 ； 对每个关键字位均重复 2) 和 3) 两步。 链表基数排序算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #define MAX_NUM_OF_KEY 8#define RADIX 10#define MAX_SPACE 10000typedef struct&#123; KeysType keys[MAX_NUM_OF_KEY]; InfoType otheritems; int next;&#125;SLCell;typedef struct&#123; SLCell r[MAX_SPACE]; int keynum; int recnum;&#125;SLList;typedef int ArrType[RADIX];void Distribute(SLCell &amp;r, int I, ArrType &amp;f, ArrType &amp;e)&#123; for (j=0; j&lt;RADIX; ++j) f[j] = 0; for (p=r[0].next; p; p= r[p].next)&#123; j = r[p].keys[i]; if (!f[j]) f[j] = p; else r[e[j]].next = p; e[j] = p; &#125;&#125;Void Collect(SLCell &amp;r, int I, ArrType f, ArrType e)&#123; for (j=0; !f[j]; j = succ(j)); r[0].next = f[j]; t = e[j]; while (j&lt;RADIX)&#123; for (j=succ(j); j&lt;RADIX-1&amp;&amp;!f[j]; j = succ(j)); if (f[j]) &#123; r[t].next = f[j]; t = e[j];&#125; &#125; r[t].next = 0;&#125;Void Radixsort(SLList &amp;L)&#123; //L是静态链表表示的顺序表 //对L作基数排序，使得L成为自小到大的有序静态链表 for (i=0；i&lt;L.recnum;；++i）L.r[i].next = i+1； L.r[L.recnum].next = 0; for (i=0; i&lt;L.recnum; ++i)&#123; Distribute(L.r, i, f, e); Collect(L.r, I, f, e); &#125;&#125; 算法分析 若每个排序码有 d 位 , 需要重复执行 d 趟“分配”与“收集”。每趟对 n 个元素进行“分配”,对 radix 个队列进行“收集”。总时间复杂度为O(d(n+radix)) 若基数 radix 相同 , 对于元素个数较多而排序码位数较少的情况 , 使用链式基数排序较好。 基数排序需要增加 n+2radix 个附加链接指针。 基数排序是稳定的排序方法。 2-路插入排序 2- 路插入排序是在折半插入排序的基础上进行的改进,目的是减少排序过程中记录移动的次数。 算法的思想为:另设一个和原始待排序列 L 相同的数组D ,该数组是一个循环向量。首先将 L[1] 复制给 D[1] ,并把 D[1]看成是已排好序的序列中处于中间位置的元素,之后将 L 中的从第二个元素开始依次插入到数组 D 中。 表插入排序 为了减少在排序过程中进行的“移动”记录的操作，静态链表结构可以避免元素移动。 123456789101112131415161718192021 #define SIZE 100 typedef struct &#123; RcdType rc; int next; &#125;SLNode; typedef struct &#123; SLNode numbers[SIZE]; int length; &#125;SLinkList; void LInsertionSort (Elem SL[ ] , int n)&#123;// 对记录序列 SL[1..n] 作表插入排序 SL[0].key = MAXINT ; SL[0].next = 1; SL[1].next = 0; for ( i=2; i&lt;=n; ++i )&#123; // 逐个将 i 插入已排好 [1..i-1] 中 for ( j=0, k = SL[0].next; SL[k].key&gt;=SL[i].key ;j=k, k=SL[k].next ); // 从表头开始寻找插入位置 SL[j].next = i; SL[i].next = k; &#125;&#125;// LinsertionSort 表插入排序的结果只是求得一个有序链表。为了方便查找，需要对结果进行重新排列求得一个有序数组。 比较 各种排序方法之间的比较： 排序方法 比较次数(最好) 比较次数(最差) 移动次数(最好) 移动次数(最差) 稳定性 附加存储 直接插入排序 n n^2 0 n^2 稳定 1 冒泡排序 n n^2 0 n^2 稳定 1 快速排序 nlog2n n^2 log2n n 不稳定 log2n 堆排序 nlog2n nlog2n 不稳定 1 归并排序 nlog2n nlog2n 稳定 n"},{"title":"查找和搜索-Part3","date":"2017-08-07T04:51:28.000Z","path":"2017/08/07/Find-and-Search-Part3/","text":"键树 / 数字查找树 Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征: ( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。 键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数 ( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关 ( 排序 ) 键树被约定为是一棵有序树,即同一层中兄弟结点之间依所含符号自左至右有序,并约定结束符‘ $’ 小于任何其它符号。 键树的存储结构:双链树 12345678910 typedef struct DLTNode &#123; char symbol; struct DLTNode *next; // 指向兄弟结点的指针 NodeKind kind; union &#123; Record *infoptr; // 叶子结点内的记录指针 struct DLTNode *first;// 分支结点内的孩子链指针 &#125;&#125; DLTNode, *DLTree; // 双链树的类型 在双链树中查找记录 假设: T 为指向双链树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $) 查找过程: 从树根出发,沿 first 指针到结点 p ,进行比较K.ch[i] =? p-&gt;symbol ,其中, 0 ≤ i ≤ K.num-1， 若相等,沿 first 指针比较下一个字符， 若不等,沿 next 指针顺序查找 12345678910111213141516171819202122 #define MAXKEYLEN 20typedef struct &#123; char ch[MAXKEYLEN]; // 关键字 int num;// 关键字长度&#125; KeysType;// 关键字类型RECORD *SearchDLTree(DLTree T, KeysType K) &#123; DLTree p; int i; p = T-&gt;first; i=0; // 初始化 while (p &amp;&amp; i&lt;K.num) &#123; while (p &amp;&amp; p-&gt;symbol != K.ch[i]) // 查找关键字的第 i 位 p = p-&gt;next; if (p &amp;&amp; i&lt;K.num-1) p = p-&gt;first; // 准备查找下一位 ++i; &#125; // 查找结束 if (!p) return NULL; // 查找不成功 else return p-&gt;infoptr; // 查找成功&#125; //Search DLTree 键树的存储结构: Trie 树 123456789101112131415 typedef struct TrieNode &#123; NodeKind kind; // 结点类型 union &#123; struct &#123; KeyType K; Record *infoptr &#125; lf;// 叶子结点 ( 关键字和指向记录的指针 ) struct &#123; TrieNode *ptr[27]; int num &#125; bh;// 分支结点 (27 个指向下一层结点的指针 ) &#125;&#125; TrieNode, *TrieTree; // 键树类型T 在Trie树中查找记录 假设 : – T 为指向 Trie 树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $) 查找过程: – 从树根出发,搜索和对应字母相应的指针 p:– 若 p 不空,且 p 所指为分支结点,则– p= p-&gt;bh.ptr[ord(K.ch[i])] ( 其中, ord 给出字符在字母表中的序号, 0 ≤ i ≤ K.num-1 )– 沿 p 指针比较下一个字符,直到叶子结点– 若未找到 p ,则查找不成功 1234567891011121314 //在键树 T 中查找关键字等于 K 的记录//ord 求字符在字母表中序号int ord(char c) &#123; return c-'@'; &#125;RECORD *SearchTrie(TrieTree T, KeysType K) &#123; TrieTree p; int i;// 对 K 的每个字符逐个查找, *p 为分支结点 for (p=T, i=0; p &amp;&amp; p-&gt;kind==BRANCH &amp;&amp; i&lt;K.num;p=p-&gt;bh.ptr[ord(K.ch[i])], i++) ; if (p &amp;&amp; p-&gt;kind==LEAF &amp;&amp;strcmp(p-&gt;lf.K.ch, K.ch)==0) return p-&gt;lf.infoptr; // 查找成功 else return NULL; // 查找不成功&#125; //SearchTrie 哈希表 基本思想 Motivation :已有的查找方法需要进行一系列的指定值与数据元素的关键字的比较 – 不同的查找其差别在于关键字和给定值进行比较的顺序不同– 原因:数据元素的关键字和数据元素的存储位置之间没有确定的关系– 结果:查找的效率取决于和给定值进行比较的关键字的个数 Solution : ( 通过哈希函数和冲突处理方法 ) 由记录的关键字确定记录在表中的地址,并将记录放入此地址,这样构成的表叫哈希表 – 哈希查找 ( 又叫散列查找 ) :通过哈希表中的对应关系进行一次存取,就能得到所查的元素– 特别适用于,只知道关键字的所属范围,但不知道确切的关键字 基本概念 哈希函数:在记录的关键字与记录的存储地址之间建立了一种确定的对应关系 – 哈希函数是一种映象,是从关键字空间到存储地址空间的一种映象。– 对于记录 ai , addr(ai) =H(ki) ,其中, addr(ai)是ai的地址, ki 是记录 ai 的关键字– 哈希函数通常是一种压缩映象,所以冲突不可避免– 冲突:对于关键字 ki、 kj ,若 ki!=kj ,但 H(ki)=H(kj)的现象叫冲突 (collision)– 同义词:具有相同哈希函数值的两个不同的关键字,称为该哈希函数的同义词 哈希表设计要素 确定哈希函数的定义域 ( 所有关键字 ) 和值域(0... m-1) 构造合适的哈希函数 – 使得同一关键字总被映射到同一地址– 使得对于所有可能的元素 ( 记录的关键字 ) ,其函数值能尽可能覆盖整个地址空间且均匀地映射到地址空间 所谓均匀 (uniform) 是指从一个关键字映射到地址集合中任何一个地址的概率是相等的,即使得发生冲突的可能性尽可能最少 – 哈希函数的构造简单,能在较短的时间内计算出来。 冲突元给出处理冲突的方法,即当冲突出现时如何为冲突元素找到另一个存储位置。 哈希函数的构造 直接定址法 直接定址法:取关键字或关键字的某个线性函数作哈希地址,即:H(key)=key 或 H(key)=a·key+b(a,b 为常数 ) 特点:直接定址法所得地址集合与关键字集合大小相等,不会发生冲突,但实际中很少使用 举例:根据年份查找该年份的人口数量 数字分析法 数字分析法:若关键字为以 r 为基的数,取关键字的若干位或组合作为哈希地址 特点:适用于关键字位数比哈希地址位数大,且事先知道可能出现的关键字的情况 ( 如频度 ) 平方取中法 平方取中法:将关键字平方后取中间几位作为哈希地址 哈希函数所取的位数由哈希表的长度决定 特点:一个数平方后中间几位和数的每一位都有关,则由随机分布的关键字得到的哈希地址也是随机的 – 适用于:不知道全部关键字情况– 适用于:关键字中的每一位都有某些数字重复出现 折叠法 折叠法 (folding) :将关键字分割成位数相同的几部分 ( 最后一部分可以不同 ) ,然后取这几部分的叠加和作为哈希地址 数位叠加有移位叠加和间界叠加 – 移位叠加:将分割后的几部分低位对齐相加– 间界叠加:从一端到另一端沿分割界来回折迭,然后对齐相加 特点:适于关键字位数很多,且每一位上数字分布大致均匀 除留余数法 除留余数法:取关键字被某个不大于哈希表表长 m 、但最接近于或等于 m 的质数 p 除后所得余数作哈希地址,即:H(key) = key MOD p (p &lt;= m)– 从 p 到 (m-1) 的地址可以在处理冲突的时候用 特点:简单、常用的哈希函数构造方法 一般,哈希函数可以设成: H(key) =(a*key+b) MOD p (a&gt;0, b&gt;0, a MOD p!=0, p 为素数 ) p的选取： 选取p=2^i(p&lt;= m) :便于用移位来实现运算,但等于将关键字的高位忽略而仅留下低位二进制数,因此,高位不同而低位相同的关键字都成为了同义词 选取p=qf (q 、 f 都是 p 的质因数, p&lt;=m) :则所有含有 q 或 f因子的关键字的哈希地址均是 q或 f 的倍数 随机数法 随机数法:取关键字的随机函数值作哈希地址,即H(key)=random(key) 当哈希表中关键字长度不等时,该方法比较合适 选取哈希函数时应考虑的因素 计算哈希函数所需时间 关键字的长度 哈希表长度 ( 即哈希地址范围 ) 关键字分布情况 记录的查找频率 冲突处理方法 开放定址法 当冲突发生时,形成某个探测序列;按此序列逐个探测哈希表中的其他地址,直到为给定的关键字找到一个空地址 ( 开放的地址 ) 为止,将发生冲突的记录放到该地址中 哈希地址的计算公式是: H0 =H(key)Hi (key)=(H(key)+di ) MOD m , i=1, 2, ..., m-1– 其中: H(key) 为哈希函数; m 是哈希表长度; Hi (key) 为经第 i 次探测后得到的哈希地址; di 是第 i 次探测时的增量序列 根据 di 的形成方法,有: – 线性探测法 (Linear Probing)– 二次探测法 (Quadratic Probing)– 伪随机探测法: 用伪随机函数获得伪随机数列 线性探测法 将哈希表 T[0 ...m-1] 看成循环向量。当发生冲突时,从初次发生冲突的位置依次向后探测其他的地址,即: 增量序列为: di=1, 2, 3, ..., m-1 设初次发生冲突的地址是 h ,则依次探测 T[h+1] , T[h+2]... ,直到 T[m-1] 时又循环到表头,再次探测 T[0] , T[1]... ,直到 T[h-1] 探测过程终止的情况: – 探测到的地址为空:表中没有记录。若是查找操作则失败;若是插入操作，则将记录写入到该地址– 探测到的地址有给定的关键字:若是查操作找则成功;若是插入操作则失败– 直到 T[h] :仍未探测到空地址或给定的关键字,则表示哈希表满 线性探测法的特点: – 优点:只要哈希表未满,总能找到一个不冲突的哈希地址– 缺点:二次聚集 ( 两个第一次哈希地址不同的记录争夺同一个后继哈希地址 ) 二次探测法 增量序列为: d_i=1^2,-1^2,2^2,-2^2,3^2,......+k^2,- k^2 (k &lt;= ⌊ m/2 ⌋ ) – 当 M是质数,且装填因子小于等于0.5 ,可以找出空闲地址– 表长 m 形如 4j+3 的质数 ( 如 7, 11, 19, 23, 31, 43, ... 等 ) 时,可以保证查找链的前 m 项均互异:基于 费马双平方定理 除了 2 这个特殊的素数,所有的素数都可以分两类:被 4 除余 1 的素数,如 5 , 13 , 17 , 29 , 37 , 41 ,这类素数都能表示为两个整数的平方和;第二类则是被 4 除余 3 的素数如 3, 7 , 11 , 19 , 23 , 31 。这类不能表示为两个整数的平方和。 优点:探测序列跳跃式地哈希到整个表中,不易产生冲突的聚集现象 缺点:不能保证探测到哈希表的所有地址 再哈希法 构造若干个哈希函数,当发生冲突时,利用不同的哈希函数再计算下一个新哈希地址,直到不发生冲突为止, – 即: Hi =RHi (key) i=1, 2, ..., k– 其中, RHi 为一组不同的哈希函数。第一次发生冲突时,用 RH1 计算,第二次发生冲突时,用 RH2 计算,依此类推直到到某个 Hi不发生冲突为止 优点:不易产生冲突的聚集现象 缺点:计算时间增加 链地址法 将所有关键字为同义词 ( 哈希地址相同 ) 的记录存储在一个单链表中,并用一维数组存放链表的头指针 设哈希表长为 m ,定义一个一维指针数组: RecNode *linkhash[m] ,其中 RecNode 是结点类型,每个分量的初值为空。凡哈希地址为 k 的记录都插入到以linkhash[k]为头指针的链表中,插入位置可以在表头或表尾或按关键字排序插入 优点:不易产生冲突的聚集;删除记录也很简单 建立公共溢出区 在基本哈希表之外,另外设立一个溢出表保存与基本表中记录冲突的所有记录 设哈希表长为 m ,设立基本哈希表 Hashtable[m],每个分量保存一个记录;溢出表 Overtable[m],一旦某个记录的哈希地址发生冲突,都填入溢出表中 哈希查找过程 哈希表的主要目的是用于快速查找,且插入和删除操作都要用到查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //开放定址哈希表的结构int hashsize[] = &#123; 997, ... &#125;;typedef struct &#123; ElemType *elem; //ElemType 中含 key int count; // 当前数据元素个数 int sizeindex;// hashsize[sizeindex] 为当前容量&#125; HashTable;#define SUCCESS 1#define UNSUCCESS 0#define DUPLICATE -1//在哈希表 H 中查找关键码为 K 的元素Status SearchHash(HashTable H, HKeyType K, int &amp;p, int &amp;c) &#123;// 若查找成功,以 p 指示待查数据元素在表中位置,并返回//SUCCESS ,否则,以 p 指示插入位置,并返回 UNSUCCESS,//c 用以记录冲突次数,其初值置零,供建表插入时参考 p = Hash(K); // 求得哈希地址 while ((H.elem[p].key != NULLKEY) &amp;&amp; !equal(K, (H.elem[p].key))) // 该位置中填有记录，并且关键字不相等 collision(p, ++c); // 求得下一探查地址 p if (equal(K, (H.elem[p].key))) return SUCCESS;// 查找成功, p 返回待查数据元素位置 else return UNSUCCESS;// 查找不成功, p 返回的是插入位置&#125; // SearchHash//哈希表插入算法Status InsertHash(HashTable &amp;H, HElemType e) &#123;// 查找不成功时插入数据元素 e 到开放定址哈希表 H 中,// 并返回 OK ;若冲突次数过大,则重建哈希表 int c = 0; int p = 0; if (SearchHash(H, e.key, p, c) == SUCCESS ) return DUPLICATE;// 表中已有与 e 有相同关键字的元素 else if (c &lt; H.cursize) &#123;// 冲突次数 c 未达到上限 ( 阈值 c 可调 ) H.elem[p] = e; ++H.count; return SUCCESS; // 插入 e &#125; else &#123; RecreateHashTable(H); // 重建哈希表 return UNSUCCESS; &#125;&#125; // InsertHash 哈希查找的性能分析 从哈希查找过程可见,尽管哈希表在关键字与记录的存储地址之间建立了直接映象,但由于存在冲突,查找过程仍是一个给定值与关键字进行比较的过程,仍要用 ASL 评价哈希查找效率 哈希查找时,关键字与给定值比较的次数取决于: – 哈希函数– 处理冲突的方法– 哈希表的填满因子：alpha = 填入表中的记录/表的大小 一般情况下,可以认为选用的哈希函数是均匀的,则在讨论 ASL 时,可以不考虑它的因素 哈希表的ASL是填满因子$\\alpha$的函数，而不是$n$的函数。 用哈希表构造查找表时，可以选择一个合适的填满因子，使得ASL限定在某个范围内。"},{"title":"查找和搜索-Part2","date":"2017-08-07T04:51:24.000Z","path":"2017/08/07/Find-and-Search-Part2/","text":"AVL 树 Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率 Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和 Landis于 1962 年提出的,故称 AVL 树 变种:红黑树,树堆,伸展树 基本概念 平衡二叉树 (Balanced Binary Tree 或 Height-Balanced Tree) 或者是空树,或者是满足下列性质的二叉树 左子树和右子树深度之差的绝对值不大于 1 左子树和右子树也都是平衡二叉树 结点的平衡因子 (Balance Factor) :该结点的右子树的深度减去其左子树深度 平衡二叉树上每个结点的平衡因子只可能是 1 、 0和 -1 平衡二叉排序树 (Balanced Binary Sort Tree) :一棵二叉树既是二叉排序树又是平衡二叉树 结构定义 12345 typedef struct BSTNode &#123; ElemType data; int bf; // 平衡因子 struct BSTNode *lchild , *rchild;&#125; BSTNode, *BSTree; 平衡化旋转 如果在一棵平衡的二叉排序树中插入一个新结点,造成了不平衡。此时必须调整树的结构,使之平衡化 每插入一个新结点时, AVL 树中相关结点的平衡状态会发生改变。因此,在插入一个新结点后,需要从插入位置沿通向根的路径回溯,检查各结点的平衡因子 如果在某一结点发现不平衡,停止回溯。从发生不平衡的结点起,沿刚才回溯的路径取直接下两层的结点 如果这三个结点处于一条直线上,则采用单旋转进行平衡化。单旋转可按其方向分为左单旋转和右单旋转 , 其中一个是另一个的镜像,其方向与不平衡的形状相关 如果这三个结点处于一条折线上,则采用双旋转进行平衡化。 右单旋转(RotateRight) : LL 型 在结点 A 的左子女的左子树 D 上插入新结点使其高度增 1 导致结点 A 的平衡因子增到 -2 ,造成不平衡 为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 B 和 D ,以结点 B 为旋转轴,将结点 A 顺时针旋转 1234567891011 void R_Rotate(BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树作右旋处理// 处理之后 p 指向新的树根结点,// 即旋转处理之前的左子树的根结点 BSTree lc; lc = p-&gt;lchild; //lc 指向 *p 的左子树根结点 p-&gt;lchild = lc-&gt;rchild;// lc 的右子树挂接为 *p 的左子树 lc-&gt;rchild = p; p = lc; //p 指向新的根结点&#125; // R_Rotate 左单旋转 (RotateLeft) : RR 型 在结点 A 的右子女的右子树 E 中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变成 2 ,出现不平衡 为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 C 和 E ,以结点 C 为旋转轴,让结点 A 反时针旋转 p 123456789101112 void L_Rotate(BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树作左旋处理// 处理之后 p 指向新的树根结点// 即旋转处理之前的右子树的根结点 BSTree rc; rc = p-&gt;rchild; //rc 指向 *p 的右子树根结点//rc 的左子树挂接为 *p 的右子树 p-&gt;rchild = rc-&gt;lchild; rc-&gt;lchild = p;//p 指向新的根结点 p = rc;&#125; //L_Rotate 先左后右双旋转 (RotationLeftRight)-LR 型 在结点 A 的左子女的右子树中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变为 -2 ,造成不平衡 以结点 E 为旋转轴,将结点 B 反时针旋转,以 E 代替原来 B 的位置 1234567891011 void LR_Rotate (BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树做先左后右旋转 BSTree lc,rc;// 初始化 rc =p; lc =rc-&gt;lchild; p=lc-&gt;rchild; // 重新确定根 lc-&gt;rchild=p-&gt;lchild; // 为 BF 拉链 p-&gt;lchild=lc; // 设置新根的左孩子,为 EB 拉链 rc-&gt;lchild=p-&gt;rchild; // 为 AG 拉链 p-&gt;rchild=rc; // 为 EA 拉链&#125; // LR_Rotate 先右后左双旋转 (RotationRightLeft)-RL 型 在结点 A 的右子女的左子树中插入新结点,该子树高度增 1 。结点 A 的平衡因子变为 2 ,发生了不平衡 首先以结点 D 为旋转轴,将结点 C 顺时针旋转,以 D 代替原来 C 的位置 1234567891011 void RL_Rotate (BSTree &amp;p) &#123;// 对以 *p 为根的二叉排序树做先右后左旋转 BSTree lc,rc;// 初始化 lc =p; rc =lc-&gt;rchild; p=rc-&gt;lchild; rc-&gt;lchild=p-&gt;rchild; p-&gt;rchild=rc; lc-&gt;rchild=p-&gt;lchild; p-&gt;lchild=lc;&#125; // RL_Rotate AVL 树的插入 AVL 树的插入算法是从一棵空树开始,通过输入一系列关键字,逐步建立 AVL 树 在向一棵本来是平衡的 AVL 树中插入一个新结点时,需从插入结点沿通向根的路径向上回溯,如果某个结点的平衡因子的绝对值 |bf| &gt; 1 ,那么需从这个结点出发,使用平衡旋转方法进行平衡化处理 算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 #define LH -1 // 左高#define EH 0 // 等高#define RH 1 // 右高Status InsertAVL(BSTree &amp;T, ElemType e, Boolean &amp;taller) &#123;// 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点,// 则插入一个数据元素为 e 的新结点,并返回 1 ,否则返回0 。// 若因插入而使二叉排序树失去平衡,则作平衡旋转处理,// 布尔变量 taller 反映 T 长高与否 if (!T) &#123; // 插入新结点,树 \" 长高 \" ,置 taller 为 TRUE T = (BSTree) malloc (sizeof(BSTNode)); T-&gt;data = e; T-&gt;lchild = T-&gt;rchild = NULL; T-&gt;bf = EH; taller = TRUE; &#125; else &#123; if (EQ(e.key, T-&gt;data.key))&#123; taller = false; return 0;//已经存在记录，不再插入 &#125; if (LT(e.key, T-&gt;data.key)) &#123;// 应继续在 *T 的左子树中进行搜索 if (InsertAVL(T-&gt;lchild, e, taller)==0) return 0; // 未插入 if (taller) // 插入到 *T 的左子树中且左子树 \" 长高“ switch (T-&gt;bf) &#123; // 检查 *T 的平衡度 case LH: // 原本左子树比右子树高,需作左平衡处理 LeftBalance(T); taller = FALSE; break; case EH: // 原本左、右子树等高// 现因左子树增高而使树增高 T-&gt;bf = LH; taller = TRUE; break; case RH: // 原本右子树比左子树高 S// 现左、右子树等高 T-&gt;bf = EH; taller = FALSE; break; &#125; // switch (T-&gt;bf) &#125; // if else &#123; // 应继续在 T↑ 的右子树中进行搜索 if (InsertAVL(T-&gt;rchild, e, taller)==0) return 0; if (taller) // 已插入到 *T 的右子树且右子树长高 switch (T-&gt;bf) &#123; // 检查 *T 的平衡度 case LH: // 原本左子树比右子树高// 现左、右子树等高 T-&gt;bf = EH; taller = FALSE; break; case EH: // 原本左、右子树等高// 现因右子树增高而使树增高 T-&gt;bf = RH; taller = TRUE; break; case RH: // 原本右子树比左子树高// 需要作右平衡处理 RightBalance(T); taller = FALSE; break; &#125; //switch (T-&gt;bf) &#125; //else &#125; // else return 1; &#125; //InsertAVL//对以指针 T 所指结点为根的二叉树作左平衡旋转处理void LeftBalance(BSTree &amp;T) &#123;// 本算法结束时,指针 T 指向新的根结点 BSTree lc,rd; lc = T-&gt;lchild; // lc 指向 *T 的左子树根结点 switch (lc-&gt;bf) &#123; // 检查 *T 的左子树的平衡度// 并作相应平衡处理 case LH:// 新结点插入在 *T 的左孩子的左子树上,// 要作单右旋处理 T-&gt;bf = lc-&gt;bf = EH; R_Rotate(T); break; case RH: // 新结点插入在 *T 的左孩子的右子树上// 要作双旋处理 rd = lc-&gt;rchild; // rd 指向 *T 的左孩子的右子树根 switch (rd-&gt;bf) &#123; // 修改 *T 及其左孩子的平衡因子 case LH: T-&gt;bf = RH; lc-&gt;bf = EH; break; case EH: T-&gt;bf = lc-&gt;bf = EH; break; case RH: T-&gt;bf = EH; lc-&gt;bf = LH; break; &#125; //switch (rd-&gt;bf) rd-&gt;bf = EH;// 对 *T 的左子树作左旋平衡处理 L_Rotate(T-&gt;lchild); R_Rotate(T); // 对 *T 作右旋平衡处理 &#125; // switch (lc-&gt;bf)&#125; // LeftBalancevoid RightBalance(BSTree *T)&#123; BSTree lc,ld; lc=(*T)-&gt;rchild; switch(lc-&gt;bf)&#123; case RH: (*T)-&gt;bf=lc-&gt;bf=EH; L_Rotate(T); break; case LH: ld=lc-&gt;lchild; switch(ld-&gt;bf)&#123; case LH: (*T)-&gt;bf=EH; lc-&gt;bf=RH; break; case EH: (*T)-&gt;bf=lc-&gt;bf=EH; break; case RH: lc-&gt;bf=EH; (*T)-&gt;bf=LH; &#125; ld-&gt;bf=EH; R_Rotate(&amp;((*T)-&gt;rchild)); L_Rotate(T); break; case EH: (*T)-&gt;bf=RH; lc-&gt;bf=LH; L_Rotate(T); break; &#125;&#125;//RightBalance AVL树的删除 如果被删结点 x 最多只有一个子女,可做简单删除 – 将结点 x 从树中删去– 因为结点 x 最多有一个子女,可以简单地把 x 的双亲中原来指向 x 的指针改指到这个子女结点– 如果结点 x 没有子女, x 双亲原来指向 x的指针置为 NULL– 将原来以结点 x 为根的子树的高度减 1 如果被删结点 x 有两个子女 – 搜索 x 在中序次序下的直接前驱 y ( 同样可以找直接后继 )– 把结点 y 的内容传送给结点 x ,现在问题转移到删除结点 y 。把结点 y 当作被删结点 x– 因为结点 y 最多有一个子女,可以简单地用 前一页给出的方法进行删除 必须沿结点 x 通向根的路径反向追踪高度的变化对路径上各个结点的影响 用一个布尔变量 shorter 来指明子树高度是否被缩短 – 布尔变量 shorter 的值初始化为 True 对于从 x 的双亲到根的路径上的各个结点p,在 shorter 保持为 True 时执行下面操作;如果 shorter 变成 False ,算法终止 – 在每个结点上要做的操作取决于 shorter 的值和结点的 bf ,有时还要依赖子女的 bf 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 int deleteAVL(BSTree *t, ElemType key, bool&amp; shorter)&#123; if((*t)== NULL)&#123; shorter=false; return false; &#125; else if(EQ(key, (*t)-&gt;data))&#123; BSTNode* q = NULL; if((*t)-&gt;lchild == NULL)&#123; q = *t; (*t) = (*t)-&gt;rchild; delete q; shorter = true; &#125; else if((*t)-&gt;rchild == NULL)&#123; q = (*t); (*t) = (*t)-&gt;lchild; delete q; shorter = true; &#125; else&#123; q = (*t)-&gt;lchild; while(q-&gt;rchild) q = q-&gt;rchild; (*t)-&gt;data = q-&gt;data; deleteAVL(&amp;((*t)-&gt;lchild), q-&gt;data, shorter); &#125; &#125; else if(LT(key, (*t)-&gt;data))&#123; if(!deleteAVL(&amp;((*t)-&gt;lchild), key, shorter)) return false; if(shorter)&#123; switch((*t)-&gt;bf)&#123; case LH: (*t)-&gt;bf = EH; shorter = true; break; case EH: (*t)-&gt;bf = RH; shorter = false; break; case RH: RightBalance(t); if((*t)-&gt;rchild-&gt;bf == EH) shorter = false; else shorter = true; break; &#125; &#125; &#125; else&#123; if(!deleteAVL(&amp;((*t)-&gt;rchild), key, shorter)) return false; if(shorter)&#123; switch((*t)-&gt;bf)&#123; case LH: LeftBalance(t); if((*t)-&gt;lchild-&gt;bf == EH) shorter = false; else shorter = true; break; case EH: (*t)-&gt;bf = LH; shorter = false; break; case RH: (*t)-&gt;bf = EH; shorter = true; break; &#125; &#125; &#125; return true;&#125; AVL 上的查找 AVL上进行查找的时间复杂度为O(logn) . B树 一棵m阶B树，或者是空树，或者是满足下面性质的一棵树： 每个节点至多有m棵子树 节点要么是根节点，或者是叶子节点，或者至少有两棵子树 除根节点外，所有非终节点至少有m/2(上取整)棵子树 所有非终端节点应包含如下信息： (n, A_0, K_1, A_1, K_2, A_2, ..., K_n, A_n) 其中，K_i$是关键字，且$K_i &lt; K_{i+1}, A_i$为指向孩子节点的指针，且$A_{i-1}$所指向的子树中的所有节点的关键字均小于$K_i,A_i$所指向子树中的所有节点的关键字均大于$K_i，n$是节点中关键字的个数，$n+1为子树的棵树。 所有叶子节点都在树的同一层上，且不带信息。 叶子节点为外部节点，查找失败时候的节点，实际上不存在。 m阶B树定义 123456789 #define m 3typedef struct BTNode &#123; int keynum; // 结点中关键字个数,即结点大小 struct BTNode *parent; // 指向父结点的指针 KeyType key[m+1]; // 关键字, 0 号单元不用 Record *recptr[m+1]; // 记录指针向量,0 号单元不用 struct BTNode *ptr[m+1]; // 子树指针向量&#125; BTNode, *BTree; //B 树结点和 B 树的类型 B 树的查找:类似二叉排序树 (1) 从树的根结点 T 开始,在 T所指向的结点的关键字向量 key[1...keynum] 中查找给定值 K( 用 s 顺序查找或折半查找 ) : 若 key[i]=K(1≤i≤keynum) ,则查找成功,返回结点及关键字位置;否则,转 (2) ; (2) 将 K 与向量 key[1...keynum]中的各个分量的值进行比较,以选定查找的子树: ​ – 若 K &lt; key[1] : T=T-&gt;ptr[0]​ – 若 key[i] &lt; K&lt; key [i+1] (i=1, 2, ...keynum-1) : T=T-&gt;ptr[i]​ – 若 K&gt;key[keynum] : T=T-&gt;ptr[keynum] 转 (1) ,直到 T 是叶子结点且未找到相等的关键字,则查找失败。在 B+树上插入、删除的过程基本上和 B 树类似 1234567891011121314151617181920212223242526272829 typedef struct &#123; BTNode *pt; // 指向找到的结点 int i; // 在结点中的关键字序号 int tag;//1 :查找成功, 0 :查找失败&#125; Result;int Search(BTree p, KeyType K)&#123; for(int i=0; i &lt; p-&gt;keynum &amp;&amp; p-&gt;key[i+1] &lt;= K; i++); return i; // p-&gt;key[i] &lt;= K &lt; p-&gt;key[i+1]&#125;//在 m 阶 B 树 T 上查找关键字 K ,返回结果 (pt,i,tag)Result SearchBTree(BTree T, KeyType K) &#123; BTree p, q; int found, i, j=0; Result R;// 初始化, p 指向待查结点, q 指向 p 的双亲 p = T; q = NULL; found = FALSE; i = 0; while (p &amp;&amp; !found) &#123; i = Search(p, K); // 在 p-&gt;key[1..keynum] 中查找 i ,// 使得 p-&gt;key[i]&lt;=K&lt;p-&gt;key[i+1] if (i&gt;0 &amp;&amp; p-&gt;key[i]==K) found = TRUE; // 找到待查关键字 else &#123; q = p; p = p-&gt;ptr[i]; &#125; &#125; if (found) &#123; // 查找成功: pt 所指结点中第 i 个关键字等于 K R.pt = p; R.i = i; R.tag = 1; &#125; else &#123; // 关键字 k 应插入在 pt 所指结点中的第 i 和第 i+1 个关键字之间 R.pt = q; R.i = i; R.tag = 0; &#125; return R; // 返回结果信息 : K 的位置 ( 或插入位置 )&#125; // SearchBTree 在 B 树上的查找有两种基本操作: ​ – 在 B 树上查找结点:在磁盘上进行​ – 在结点中查找关键字:将结点信息读入内存后再查找 因此,磁盘上的查找次数 ( 即:待查找的记录关键字在 B 树上的层次数 ) 是决定 B 树查找效率的首要因素. B树的插入 B 树的生成是从空树起,逐个插入关键字 插入时不是每插入一个关键字就添加一个叶子结点,而是首先在最低层的某个叶子结点中添加一个关键字,然后 若关键字的数目达到 m ,则分裂成两个结点,并将中间关键字插入到 p 的父结点,这时,父结点也可能不满足 m 阶 B 树的要求( 分枝数大于 m) ,则必须对父结点进行分裂,一直进行下去,直到没有父结点或分裂后的父结点满足 m 阶 B 树的要求 当根结点分裂时,因没有父结点,则建立一个新的根, B 树增高一层 1234567891011121314 BTNode *split(BTNode *p)// 结点 p 中包含 m 个关键字,从中分裂出一个新的结点&#123; BTNode *q ; int k, mid, j ; q=(BTNode *)malloc(sizeof( BTNode)); mid=(m+1)/2; q-&gt;ptr[0]=p-&gt;ptr[mid]; for (j=1,k=mid+1; k&lt;=m; k++) &#123; q-&gt;key[j]=p-&gt;key[k] ; q-&gt;ptr[j++]=p-&gt;ptr[k] ; &#125; // 将 p 的后半部分移到新结点 q 中 q-&gt;keynum=m-mid ; p-&gt;keynum=mid-1 ; return(q) ;&#125; B树的删除 在 B 树上删除一个关键字 K ,首先找到关键字所在的结点 N ,然后在 N 中进行关键字 K 的删除操作。 B+树 m 阶 B+ 树, B 树的一种变体 一棵 m 阶 B+ 树与 m 阶 B 树的主要差异是: 若一个结点有 n 棵子树,则必含有 n 个关键字 所有叶子结点中包含了全部记录的关键字信息以及这些关键字记录的指针,而且叶子结点按关键字的大小从小到大顺序链接,构成一个有序链表 在 B+ 树中,所有的非叶子结点可以看成是索引,结点中只含有其子树的根结点中的最大 ( 或最小 ) 关键字 B+树定义 12345678910111213 #define M 3typedef enum&#123;branch, left&#125; NodeType;typedef struct BPNode &#123; NodeTag tag; // 结点标志 int keynum; // 结点中关键字的个数 struct BTNode *parent; // 指向父结点的指针 KeyType key[M+1]; // 关键字向量 ,key[0] 未用 union pointer &#123; struct BTNode *ptr[M+1]; // 子树指针向量 RecType *recptr[M+1]; //recptr[0] 未用 &#125;ptrType ; // 用联合体定义子树指针和记录指针&#125;BPNode; B+树的查找 与 B 树相比,对 B+ 树不仅可以从根结点开始按关键字随机查找,而且可以从最小关键字起,按叶子结点的链接顺序进行顺序查找。 在 B+ 树上进行随机查找的过程基本上和 B树类似。 在 B+ 树上进行随机查找时,若非叶子结点的关键字等于给定的 K 值,并不终止,而是继续向下直到叶子结点 ( 只有叶子结点才存储记录 ) , 即无论查找成功与否,都走了一条从根结点到叶子结点的路径。 B+ 树的插入、删除 在 B+ 树上插入、删除的过程基本上和 B 树类似。"},{"title":"查找和搜索-Part1","date":"2017-08-05T04:51:20.000Z","path":"2017/08/05/Find-and-Search-Part1/","text":"基本概念 查找表 (Search Table) :相同类型的数据元素 ( 或记录 ) 组成的集合,每个数据元素通常由若干数据项构成 关键字 (Key ,码 ) :数据元素中某个 ( 或几个 ) 数据项的值,它可以标识一个数据元素 – 主关键字 (Primary Key) :能唯一标识一个数据元素的关键字– 次关键字 (Secondary Key) :能标识若干个数据元素的关键字 关键字类型 数据元素的关键字:其类型通常是可以进行比较运算的类型 典型的关键字类型 123456789 typedef float KeyType ;// 实型typedef int KeyType ; // 整型typedef char KeyType ; // 字符串型• 数据元素类型typedef struct RecType &#123;KeyType key ; // 关键字域... ... // 其他域&#125; ElemType; 对两个关键字的比较 123456789 //C 的宏定义// 对数值型关键字#define EQ(a, b) ((a)==(b))#define LT(a, b) ((a)&lt;(b))#define LQ(a, b) ((a)&lt;=(b))// 对字符串型关键字#define EQ(a, b) (!strcmp((a), (b)) )#define LT(a, b) (strcmp((a), (b))&lt;0 )#define LQ(a, b) (strcmp((a), (b))&lt;=0 ) 查找 根据给定的 Key 值,在查找表中确定一个关键字等于给定值的数据元素或记录 查找表中存在满足条件的数据元素 / 记录,则查找成功,返回所查到的数据元素或其在查找表中的位置 查找表中不存在满足条件的记录,则查找失败 “ 关键字等于给定值 ” 只是一种最为常用的查找条件,实际应用中可能会有其他的查找件,例如查找 “ 关键字在某个范围内的数据元素 ” 等等 采用何种查找方法,首先取决于查找表的组织,即按何种关系组织 / 存储数据元素 查找表是记录的集合,而集合中的元素之间是一种完全松散的关系,因此,查找表是一种非常灵活的数据结构,可以用多种方式来存储 查找及其方法分类 静态查找 / 静态查找表 (Static Search Table):只对该表的数据元素进行查询 动态查找 / 动态查找表 (Dynamic Search Table) :在对该表实施查找的同时,可插入查找表中不存在的记录,或从查找表中删除已存在的某个记录;表的结构本身是在查找过程中动态生成的 分类1：按存储结构的不同 线性表查找: 数据元素保存在顺序表或链表中 哈希查找:数据元素保存在哈希表中,根据给定的 Key 值直接访问 查找表, 从而找到要查找的记录 树表查找:数据元素保存在树中 分类2： 内查找:整个查找过程全部在内存进行 外查找:在查找过程中还需要访问外存，例如:查找表太大,无法全部放入内存中 查找方法的评价指标 查找过程中的主要操作是关键字的比较,查找过程中关键字的平均比较次数是衡量一个查找算法效率高低的标准 ASL (Average Search Length , 平均查找长度 ) 定义为需要和给定值进行比较的关键字的个数的期望值 静态查找表 静态查找表:可以用线性表 ( 顺序表或线性链表 ) 实现 静态查找表 StaticSearchTable 的基本操作: 123456 void CreateSSTable(SSTable *t);// 构造一个查找表void Destroy(SSTable *t);void ListSSTable(SSTable *t); // 输出查找表int SearchSSTable(SSTable *t,KeyType key); // 查找成功,返回元素值在表中位置void Traverser(SSTable *t, void Visit(ElemType *e)); // 按某种次序对 t 的每个元素调用函数 Visit()一次且一次 静态查找表的查找方法 基于顺序表的查找: 顺序查找 (SequentialSearch) ,逐一比较 基于有序表的查找 – 折半查找 / 二分查找 (Binary Search) :每次对查找表进行折半缩小– Fibonacci 查找 :根据 Fibonacci 数列的特点对查找表进行分割– 静态树表查找 基于索引顺序表的查找:索引顺序查找 /分块查找 (Blocking Search) ,基于顺序表和其索引的查找 顺序查找 顺序表的定义如下： 123456 typedef struct SSTable&#123;// 数据元素存储空间的基地址// 建表时按实际长度分配, 0 号单元留空ElemType *elem;int length ; // 实际元素个数&#125; SSTable; 顺序查找算法： 从表的一端 ( 例如:最后一个记录 ) 开始,逐个将记录的关键字和给定 Key 值进行比较– 若某个记录的关键字和给定 Key 值相等,查找成功– 否则,若扫描完整个表,仍然没有找到相应的记录,则查找失败 简单实现： 1234567 int SearchSSTable(SSTable *t, KeyType key) &#123; for(int i=1; i&lt;=t-&gt;length &amp;&amp; (t-&gt;elem[i].key != key); i++ ); if( i&lt;=t-&gt;length ) return i; else return 0;&#125; //Search_Seq 标准算法： 12345678 int SearchSSTable(SSTable *t,KeyType key) &#123;// 设置哨兵,查找失败时返回 0 t-&gt;elem[0].key=key;// 从后往前找 for (int i=t-&gt;length; !EQ(t-&gt;elem[i].key, key); i--) ; return i ; // 找不到时, i 为 0&#125;//设立哨兵后可以使循环中省掉了一次比较 算法分析： 查找成功时候的比较次数：ASL = (n+1)/2 查找失败时候的比较次数：ASL=n+1 若查找成功与不成功的概率相等，则 ASL = 3(n+1)/4 缺点： 查找效率低,当 n 较大时,不宜采用顺序查找。 改进： 根据数据元素被查找的概率组织顺序表，在不等概率的情况下，按被查找概率的升序排序。 在数据元素中增加一数据项,用于记录对该数据元素的访问次数– 在每次查找后,维护查找表使得其按照数据元素的访问次数升序排序 在每次查找后,将刚查找到的元素移动至表尾:已发生的事会重复发生 为顺序表加索引 折半查找 基于有序顺序表的查找算法。 – 查找表中的所有记录是按关键字有序 ( 升序或降序 ) 排列的 查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次将待查记录所在区间缩小一半 ) ,直到找到或找不到记录为止 算法思想： 初始:用 Low、 High 和 Mid 表示待查找区间的下界、上界和中间位置指针,初值设置为 Low=1 , High=n (1) 取中间位置 Mid : Mid=(Low+High)/2 (2) 比较中间位置记录的关键字与给定的 Ke值: – 相等:查找成功;– 大于:待查记录在区间的前半段,修改上界指针: High=Mid-1 ,转 (1) ;– 小于:待查记录在区间的后半段,修改下界指针: Low=Mid+1 ,转 (1) ; 直到越界 (Low&gt;High) ,查找失败 算法实现： 1234567891011121314151617 // 在有序表 t 中折半查找其关键字等于 key 的数据元素int SearchSSTable(SSTable *t, KeyType key) &#123; int low, high, mid; low = 1; high = t-&gt;length; // 置区间初值 while (low &lt;= high) &#123; mid = (low + high) / 2; if (EQ(key , t-&gt;elem[mid].key))// 找到,返回该待查元素在表中的位置 return mid; else if (LT(key, t-&gt;elem[mid].key))// 继续在前半区间进行查找 high = mid - 1; else // 继续在后半区间进行查找 low = mid + 1; &#125; return 0; // 顺序表中不存在待查元素&#125; 算法分析： 查找时,每经过一次比较,查找范围就缩小一半,该过程可用一棵二叉树表示: – 把当前查找区间的中点作为根结点– 左子区间和右子区间分别作为根的左子树和右子树– 排在中间位置前面的作为左子树的结点– 排在中间位置后面的作为右子树的结点 上述描述查找过程的二叉树被称为折半查找的判定树(Decision Tree) – 内结点代表顺序表中已有的元素,外结点代表失败结点,它表示在两个相邻已有元素值之间的值 找到有序表中任一记录的过程是走了一条从根结点到与该记录相应的结点的路径,与给定值进行比较的关键字个数为该结点在判定树上的层次数 查找成功时候的ASL = (n+1)/nlog2(n+1) - 1 当n很大时(n&gt;50)，ASL = log2(n+1) - 1 算法优缺点分析： Strength :折半查找速度很快 – 1000 个元素的有序表,至多需要比较 10 次– 1000,000个元素的有序表,需要不超过 20 次的比较 Limitation :查找对象是有序表,即在查找之前需要对顺序表进行排序操作 Weaknesses : – 折半查找无法应用于链表– 在不等概率查找的情况下,折半查找不一定是有序表最好的查找方法– 当查找表的长度不大时,也许折半查找的效率不如顺序查找 Conclusion :适合于大量的静态数据 – 有序表的插入和删除都比较麻烦,平均要移动表中一半的元素 Fibonacci 查找 基于有序顺序表的查找 – 查找表中的所有记录是按关键字有序 ( 升序或降序 )排列的 查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次根据 Fibonacci 数列的特点对查找表进行分割 ) ,直到找到或找不到记录为止 算法思想 设查找表中的记录数 n比某个 Fibonacci 数小 1,即设 n=F(j)-1 用 Low 、 High 和 Mid 表示待查找区间的下界、上界和分割位置,初值为 Low=1 , High=n (1) 取分割位置 Mid : Mid=F(j-1) (2) 比较 key 值与分割位置记录的关键字: – 相等: 查找成功– 小于:待查记录在区间的前半段,修改上界指针:High=Mid-1 ,这时,区间长度为 F(j-1)-1 ,转(1) ;– 大于:待查记录在区间的后半段,修改下界指针:Low=Mid+1 , 这时,区间长度为 F(j-2)-1 ,转(1) ; 直到越界 (Low&gt;High) ,查找失败 算法实现 1234567891011121314151617181920212223242526272829 //Fibonacci 数的计算int fib(int n) &#123; int i, f, f0=0, f1=1; if (n==0) return 0 ; if (n==1) return 1 ; for (i=2 ; i&lt;=n ; i++ ) &#123; f=f0+f1 ; f0=f1 ; f1=f ; &#125;chazhao return f ;&#125;// 在有序表 t 中用 Fibonacci 方法查找关键字为 key 的记录int SearchSSTableFibonacci(SSTable *t, KeyType key , int n)&#123; int Low=1, High, Mid, f1, f2 ; High=fib(n); f1=fib(n-1); f2=fib(n-2);chazhao while (Low&lt;=High) &#123; Mid=Low+f1-1; if ( EQ(key, t-&gt;elem[Mid].key) ) return Mid ; else if ( LT(key, t-&gt;elem[Mid].key) )&#123; High=Mid-1; f2=f1-f2; f1=f1-f2; &#125; else&#123; Low=Mid+1; f1=f1-f2; f2=f2-f1; &#125; &#125; return 0;&#125; 算法分析 Fibonacci 查找的平均性能比折半查找好，但最坏情况下比折半查找差。 插值查找：根据key值来决定与哪个记录比较并分区。 插值查找适用于关键字均匀分布。 索引顺序查找 / 分块查找 查找表的组织:将查找表分成几块 – 块间有序,即第 i+1 块的所有记录关键字均大于 ( 或小于 ) 第 i 块记录关键字– 块内无序– 在查找表的基础上附加一个索引表,索引表是按关键字有序的,索引表中记录的构成是:– 可以建立多级索引– 可以建立多种索引 先 ( 用顺序查找或折半查找 ) 确定待查记录所在块,再在块内查找 ( 顺序查找 ) 算法实现 123456789101112131415161718192021222324 //数据结构typedef struct IndexType &#123; KeyType maxkey; // 块中最大的关键字 int startpos;// 块的起始位置指针//int length;// 块的长度&#125; Index;//算法实现int SearchSSTableBlock (SSTable *t, Index ind[], KeyType key , int n , int b) &#123; // 表长为 n ,块数为 b int i=0, j , k ;// 在块间顺序查找 while ((i&lt;b)&amp;&amp; LT(ind[i].maxkey, key) ) i++ ; if (i&gt;b) return(0); // 没有找到 j=ind[i].startpos; while ((j&lt;n) &amp;&amp; LQ(t-&gt;elem[j].key, ind[i].maxkey) ) &#123;// 在块内顺序查找 if ( EQ(t-&gt;elem[j].key, key) ) break ; j++ ; &#125; if (j&gt;n||!EQ(t-&gt;elem[j].key, key) ) j=0; return(j)；&#125; 算法分析 索引顺序查找的平均查找长度ASL等于 = 查找索引表确定所在块的平均查找长度Lb + 在块内查找元素的平均查找长度Lw. 查找方法比较 顺序查找 分块查找 折半查找 Fibonacci查找 表结构 有序表/无序表 分块有序表 有序表 有序表 存储结构 顺序存储结构/线性链表 顺序存储结构/线性链表 顺序存储结构 顺序存储结构 ASL 最大 介于两者之间 最小 平均比折半查找好 静态树表/次优查找树的查找 若有序表中的各个元素的查找概率不等,那么,用折半查找,性能未必最优 如何改进,以提高性能 ? – 需要找到查找性能最佳的判定树,即,静态最优查找树 (Static Optimal Tree)– 该判定树的带权内路径长度之和最小 算法思路 构造静态最优查找树的时间开销太大 为有序表构造次优查找树 (Nearly Optimal Search Tree) 基于次优查找树的查找 – 给定 Key ,– 从根结点开始,将 Key 值与根结点比较,若 key大于根结点值,在右子树中查找,若 key 小于根结点值,在左子树中查找– 平均查找长度与 logn 成正比 递归构造次优查找树t 123456789101112131415161718192021222324252627 // 根据有序表 R[low..high] 及其累计权值表 sw( 其中 sw[0]==0)构造次优查找树 tBiTree SecondOptimal(ElemType R[], float sw[], int low, int high) &#123; int i,j; float min,dw; BiTree *t; i = low; min = (float) fabs(sw[high]-sw[low]); dw = sw[high]+sw[low-1]; for (j=low+1; j&lt;=high; ++j) // 选择最小的 ΔPi 值 if (fabs(dw-sw[j]-sw[j-1]) &lt; min) &#123; i = j; min = (float)fabs(dw-sw[j]-sw[j-1]); &#125; if (!(t = (BiTree *)malloc(sizeof(BiTreeTNode)))) return ERROR; t-&gt;data = R[i];// 生成结点 if (i==low) t-&gt;lchild = NULL;// 左子树空 else t-&gt;lchild=SecondOptimal(R, sw, low, i-1); // 构造左子树 if (i==high) t-&gt;rchild = NULL; // 右子树空 else t-&gt;rchild=SecondOptimal(R, sw, i+1, high); // 构造右子树 return t; &#125; // SecondOptimal 动态查找表 表的组织方式 若以线性表的形式组织查找表,那么如需要对查找表进行插入、删除或排序操作,就必须移动大量的记录 – 当记录数很多时,这种移动的代价很大 以树的形式组织查找表,可以对查找表进行动态、高效的查找 – 二叉排序树– 平衡二叉树– B 树– B+ 树– 键树 二叉排序树 二叉排序树或者是空树,或者是满足下列性质的二叉树: 若左子树不为空,则左子树上所有结点的值( 关键字 ) 都小于根结点的值; 若右子树不为空,则右子树上所有结点的值( 关键字 ) 都大于根结点的值; 左、右子树都分别是二叉排序树 每个结点的 Key互不相同 数据结构 12345678910 //BST 可以用二叉链表来存储typedef int KeyType;typedef struct RecType&#123; KeyType key;//Others&#125; ElemType;typedef struct BiTreeNode &#123; ElemType data; struct BiTreeNode *lchild,*rchild;&#125; *BiTree; BST的查找算法1 123456789101112 // 在根指针 T 所指二叉排序树中,// 递归地查找其关键字等于 key 的数据元素,// 若查找成功,则返回指向该数据元素结点的指针// 若查找不成功,则返回空指针BiTree SearchBST (BiTree T, KeyType key) &#123; if (!T || EQ(key, T-&gt;data.key)) return T; // 查找结束 else if (LT(key, T-&gt;data.key)) return SearchBST(T-&gt;lchild, key); // 在左子树中查找 else return SearchBST(T-&gt;rchild, key); // 在右子树中查找&#125; // SearchBST 注：若按中序遍历一棵二叉排序树,所得到的结点序列是一个递增序列 BST的构造 BST 是在查找过程中,当树中不存在关键字等于给定值的结点时进行插入 – 新插入的结点一定是 BST 的一个新的叶子结点,并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子 因此: – 需要一个 BST 的查找算法,它在没有找到指定值时,返回:查找路径上访问的最后一个结点– 基于上述查找算法,形成 BST 的构造算法： 123456789101112131415 // 若查找成功,则指针 p 指向该数据元素结点,并返回 TRUE// 否则指针 p 指向查找路径上访问的最后一个结点,并返回// FALSE 。指针 f 指向 T 的双亲,其初始调用值为 NULLStatus SearchBST(BiTree T, KeyType key, BiTree f, BiTree &amp;p)&#123; if (!T) &#123; p = f; return FALSE; &#125; // 查找不成功 else if (EQ(key, T-&gt;data.key)) &#123; p = T; return TRUE; &#125; // 查找成功 else if (LT(key, T-&gt;data.key)) return SearchBST(T-&gt;lchild, key, T, p); // 在左子树中查找 else return SearchBST(T-&gt;rchild, key, T, p); // 在右子树中查找&#125; // SearchBST BST的插入算法 123456789101112131415161718 // 当二叉排序树 T 中没有关键字等于 e.key 的数据元素时,// 插入 e 并返回 TRUE ,否则返回 FALSEStatus InsertBST(BiTree &amp;T, ElemType e)&#123; BiTree p,s; if (!SearchBST(T, e.key, NULL, p)) &#123; // 查找不成功 s = (BiTree)malloc(sizeof( BiTreeNode )); s-&gt;data = e; s-&gt;lchild = s-&gt;rchild = NULL; if (!p) T = s; // 插入 s 为新的根结点 else if (LT(e.key, p-&gt;data.key)) p-&gt;lchild=s; // 插入 s 为左孩子 时,不必移动其它 else p-&gt;rchild=s;// 插入 s 为右孩子 return TRUE; &#125; else return FALSE; // 树中已有关键字相同的结点,不再插入&#125; // Insert BST BST上节点的删除 从 BST 上删除一个结点,需要保证删除结点后的树仍满足 BST 的性质 设被删除结点为 p ,其父结点为 f ,分如下情况: 若 p 是叶子结点: 直接删除 p 若 p 只有一棵子树 ( 左子树或右子树 ) :直接用 p 的左子树 ( 或右子树 ) 取代 p 的位置而成为 f的一棵子树 若 p 既有左子树又有右子树 方法一：用 p 的直接前驱 ( 或直接后继 ) 结点 s 代替 p ,即从 p 的左子树中选择值最大的结点 s 放在 p 的位置 ( 用结点 s 的内容替换结点 p 内容 ) ,然后删除结点 s ,并将 s的左子树作为 s 的父结点的右子树 方法二：找到 s , s 是 p 的左子树中的最右边的结点且没有右子树,将 p 的右子树作为 s 的右子树,然后用 p的左子树顶替被删结点 ( 也就是将 p 的左子树为 f 的左子树 ) 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 Status DeleteBST(BiTree *T, KeyType key)// 若二叉排序树 T 中存在关键字等于 key 的数据元素时,// 则删除该数据元素结点 p ,返回 TRUE ;否则返回 FALSE&#123; if (!T) return FALSE;// 不存在关键字等于 key 的数据元素 else &#123; if (EQ(key, T-&gt;data.key))// 找到关键字等于 key 的数据元素 return Delete(T); else if (LT(key, T-&gt;data.key)) return DeleteBST(T-&gt;lchild, key); else return DeleteBST(T-&gt;rchild, key); &#125;&#125;//DeleteBST// 从二叉排序树中删除结点 p ,并重接它的左或右子树，伪代码Status Delete(BiTree &amp;p) &#123; BiTree q, s; if (!p-&gt;rchild) &#123;// 右子树空则只需重接它的左子树 q = p; p = p-&gt;lchild; //将 p 原来的父结点 ( 设为 f) 与 p 相连 f-&gt;lchild/rchild=p free(q); &#125; else if (!p-&gt;lchild) &#123;// 只需重接它的右子树 q = p; p = p-&gt;rchild; //将 p 原来的父结点 ( 设为 f) 与 p 相连 f-&gt;lchild/rchild=p free(q); &#125; else &#123; // 左右子树均不空,按方法一// 左右子树均不空 q = p; s = p-&gt;lchild; while (s-&gt;rchild)// 转左,然后向右到尽头 q &#123; q = s; s = s-&gt;rchild; &#125;//s 指向被删结点的前驱 p-&gt;data = s-&gt;data; if (q != p) q-&gt;rchild = s-&gt;lchild;// 重接 *q 的右子树 else q-&gt;lchild = s-&gt;lchild;// 重接 *q 的左子树 free(s); &#125; return TRUE;&#125; BST的查找性能分析 二叉排序树上成功的查找次数不会超过二叉树的深度,而具有 n 个结点的二叉排序树的深度,最好为 log2n ,最坏为 n 。因此二叉排序树查找的最好时间复杂度为 O(log2n) ,最坏的时间复杂度为 O(n)。 在随机情况下, n 个结点的二叉排序树的平均查找长度 (ASL) 和log2n( 树的深度 ) 是等数量级的。 随机:各个元素的查找概率相同,元素组成的序列是随机的"},{"title":"动态存储管理","date":"2017-07-30T11:57:40.000Z","path":"2017/07/30/Dynamic-Memory-Management/","text":"存储空间的分配和管理 问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序 问题的解决策略:采用动态存储管理思想 存储空间的分配和管理策略的选择与用户的需求有关: 用户存储请求的分配量的大小分布 用户存储分配请求和释放请求的频率 分配效率 对系统的重要性 动态存储管理 - 堆的管理 堆(heap)：操作系统在内存中划出一块地址连续的大区域 占用块:已分配给用户使用的一块地址连续的内存区域; 空闲块:未曾分配的地址连续的内存区域 堆的管理要解决的问题:如何根据用户的存储 / 内存分配请求分配内存空间?如何回收被释放的或不再使用的 ) 内存空间? 堆的使用:利用程序设计语言提供的内存动态分配函数– C : malloc() , calloc() , realloc , free() 函数– C++ : new , delete 函数等 内存分配方式 方式1： 从高地址空闲块中进行分配,直到分配无法进行时,才回收所有用户不再使用的空闲块,重新组织一个大的空闲块来再分配。 方式2：用户程序一旦运行结束,便将它所占的内存区释放成为空闲块,同时,每当新用户请求分配内存时,需查找整个内存区中所有空闲块,并从中找出一个合适的空闲块分配之。 可利用空间表 可利用空间表 / 存储池:包含所有可分配的空闲块 – 当用户请求分配时,系统从可利用空间表中删除一个结点分配之 – 当用户释放其所占内存时,系统即回收并将它插入到可利用空间表中 可利用空间表的组织方式 – 目录表 – 链表方式 链式可利用空间表的分配方式 当可利用空间表以链表方式组织时,每个空闲块就是链表中的一个结点– 分配时:从链表中找到一个合适的结点加以分配,然后将该结点删除之;– 回收时:将空闲块插入到链表中。 具体的分配和释放的策略取决于结点 ( 空闲块 ) 的结构– 空闲块的大小相同– 空闲块的大小只有几种规格– 空闲块的大小不固定 分配方式1：空闲块的大小相同 – 将进行动态存储分配的整个内存区域( 堆 ) 按所需大小分割成若干大小相同的块,然后用指针链接成一个可利用空间表。– 分配时:从表的首结点分配,然后删除该结点– 回收时:将释放的空闲块插入表头– 存在的问题:空间利用率不高当请求分配的块空间大小比最大规格的结点还大时,分配不能进行。而实际上内存空间却可能存在比所需大小还要大的的连续空间。 分配方式2：空闲块大小只有几种规格 – 根据统计分析得到的概率分布,事先对动态分配的堆建立若干个可利用空间链表,同一链表中的结点 ( 块 ) 大小都相同。– 分配时:根据请求的大小,将最接近该大小的某个链表的首结点分配给用户。若剩余部分正好是另一种规格大小,则将剩余部分插入到另一种规格的链表中,然后删除该结点– 回收时:只要将所释放的空闲块插入到相应大小的表头– 存在的问题:同前 分配方式3：请求分配的块大小不确定 – 整个堆空间开始是一个空闲块,链表中只有一个大小为整个堆的结点,随着分配和回收的进行,链表中的结点大小和个数动态变化– 链表结点中,增加一个表示结点大小的域 (size),以保存空闲块的大小– 分配策略:若用户请求分配大小为 n(kB) 的内存,而链表中有若干大小不小于 n 的空闲块时,如何分配 ? 首次拟合法 (First fit) 最佳拟合法 (Best fit) 最差拟合法 (Worst fit) 首次拟合法 (First fit) 分配时:从表头指针开始查找可利用空间表,将找到的第一个不小于 n 的空闲块的部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点 回收时:将释放的空闲块插在链表的表头 特点:分配时随机的;回收时仅需插入到表头 最佳拟合法 (Best fit) 分配时:扫描整个可利用空间链表,找到一个大小满足要求且最接近 n 的空闲块,将其中的一部分 ( 即所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点 回收时:只要将释放的空闲块插入到可利用空间链表的合适位置 为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 包括块回收时 ) 成按从小到大排序 ( 升序 ) 优点:适用于请求分配的内存块大小范围较广的系统 缺点:系统容易产生无法分配的内存碎片;无论分配与回收,都需要查找空闲链表,最费时 最差拟合法 (Worst fit) 分配时:扫描整个可利用空间链表,找到一个大小最大的空闲块,将其中的一部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点 回收时:只要将释放的空闲块插入到链表的合适位置 为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 块回收时 ) 成按从大到小排序 (降序 ) 特点:适用于请求分配的内存块的大小范围较窄的系统;分配无需查找,回收需要查找适当的位置 边界标识法 (Boundary Tag Method) 操作系统中常用的动态存储管理方法 将所有的空闲块链接成一个双重循环链表 每个内存区域的头部和底部两个边界上分别设置标识,以标识该区域为占用块或空闲块 在回收块时易于判别在物理位置上与其相邻的内存区域是否为空闲块,以便于将所有地址连续的空闲存储区合并成一个尽可能大的空闲块 可利用空间表的节点结构： 123456789101112131415161718192021 typedef struct word &#123;union &#123;// 头部域,指向前驱结点 struct word *llink;// 尾部域,指向本结点的头部 struct word *uplink;&#125;; int tag; //0 :空闲; 1 :占用 int size;// 头部域,指向后继结点 struct word *rlink;//OtherType other;&#125;WORD, head, foot, *Space;// 指向 p 所指结点的底部#define FootLoc(p) (p+p-&gt;size-1)Space FootLoc(Space p) &#123; char *q; Space f; q=(char *)p; f=(Space)(q+sizeof(char)*p-&gt;size-sizeof(foot)); return f;&#125; 分配算法：两个约定 分配约定 选定适当常量 e ,设待分配空闲块、请求分配空间的大小分别为 m 、 n 当 m-n&lt;=e 时:将整个空闲块分配给用户; 当 m-n&gt;e 时:则只分配请求的大小 n 给用户; 尽量减少空闲块链表中出现小碎片 ( 容量 ≤ e) ,提高分配效率;减少对空闲块链表的维护工作量 为了避免修改指针,约定将高地址部分分配给用户 查找约定 每次需要查找空闲块时,从上次刚分配结点的后继结点开始查找空闲块 作用:提高查找空闲块的速度,防止小容量结点聚集 分配算法：首次拟合法 123456789101112131415161718192021222324252627282930 const int e = 16; // 不保留小于等于 e 的剩余量// 若有不小于 n 的空闲块,则分配相应的存储块,并返回其首地址, 否则返回 NULLSpace AllocBoundTag(Space pav, int n) &#123; Space p;// 查找不小于 n 的空闲块 for (p=pav; p &amp;&amp; p-&gt;size&lt;n &amp;&amp; p-&gt;rlink!=pav; p=p-&gt;rlink); if (!p || p-&gt;size&lt;n) return NULL; // 找不到,返回空指针 else &#123; // p 指向找到的空闲块 Space f = FootLoc(p); // f 指向底部 pav = p-&gt;rlink;// pav 指向 *p 结点的后继结点 if (p-&gt;size-n &lt;= e) &#123; // 整块分配,不保留小于等于 e 的剩余量 if (pav==p) pav = NULL; // 可利用空间表变为空表 else &#123; // 在表中删除分配的结点 pav-&gt;llink = p-&gt;llink; p-&gt;llink-&gt;rlink = pav; &#125; p-&gt;tag = f-&gt;tag = 1; // 修改分配结点的头部和底部标志 &#125; else &#123; // 分配该块的后 n 个字 f-&gt;tag = 1; // 修改分配块的底部标志 p-&gt;size -= n; // 置剩余块大小 f = FootLoc(p); // 指向剩余块底部 f-&gt;tag = 0; f-&gt;uplink = p; // 设置剩余块底部 p = f+1; // 指向分配块头部 p-&gt;tag = 1; p-&gt;size = n; // 设置分配块头部 &#125; return p; // 返回分配块首地址 &#125;&#125; // AllocBoundTag 回收算法 情况1 释放块的左、右邻块均为占用块:将被释放块简单地插入到空闲块链表中即可 12345678910 p-&gt;tag=0 ; FootLoc(p)-&gt;uplink=p;FootLoc(p)-&gt;tag=0;if ( !pav )pav=p-&gt;llink=p-&gt;rlink=p; // 第一个空闲块else &#123;// 刚释放的空闲结点是插在 pav 之前,并成为 pavq=pav-&gt;llink; p-&gt;rlink=pav ;p-&gt;llink=q ; q-&gt;rlink=pav-&gt;llink=p ;pav=p ; //pav 指向刚释放的空闲结点// 成为下次分配最先查询的结点&#125; 情况2、3 释放块的左邻块空闲而右邻块为占用:和左邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部 123 n=p-&gt;size;s=(p-1)-&gt;uplink; s-&gt;size+=n; // 设置新空闲块大小f=FootLoc(p); f-&gt;uplink=s; f-&gt;tag=0; // 设置新空闲块底部 释放块的左邻占用而右邻空闲:和右邻块合并成一个大的空闲块结点,改变右邻块的 size 域及重新设置( 合并后 ) 结点的头部 12345 t= FootLoc(p)+1; p-&gt;tag=0; q=t-&gt;llink;p-&gt;llink=q; q-&gt;rlink=p ; // 设置空闲块的前驱q1=t-&gt;rlink ; p-&gt;rlink=q1 ; q1-&gt;llink=p ;p-&gt;size+=t-&gt;size; // 设置新空闲块大小FootLoc(t)-&gt;uplink=p ; // 底部指针指向新结点的头部 情况4 释放块的左、右邻块均为空闲块:和左、右邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部 12345678 n=p-&gt;size;s=(p-1)-&gt;uplink;//s 指向左邻块t= FootLoc(p)+1; //t 指向右邻块 , p+p-&gt;sizes-&gt;size +=n+t-&gt;size; // 设置新空闲结点的大小// 在空闲链表中,删除右邻空闲块q=t-&gt;llink; q1=t-&gt;rlink; // 修改右邻原来的关系q-&gt;rlink=q1; q1-&gt;llink=q ;FootLoc(t)-&gt;uplink=s; // 新结点底部指针指向其头部 伙伴系统 (Buddy System) 操作系统中常用的动态存储管理方法 与边界标识法类似,所不同是:无论占用块或空闲块,其大小均为 2 的 k 次幂 ,不是以顺序片段来分配内存 伙伴系统的可利用空间表: 将所有大小相同的空闲块建于一张子表中,每个子表是一个双重链表,这样的链表可能有 m+1 个 再将这 m+1 个表头指针用向量结构组织成一个表 可利用空间表的结构: 123456789101112 #define M 16typedef struct WORD_b &#123; WORD_b * llink;// 前驱结点 int tag;// 块占用标识 int kval;// 块的大小,是 2 的幂次 WORD_b *rlink;// 后继结点 OtherType other;&#125; WORD_b, head;typedef struct HeadNode &#123; int nodesize; WORD_b * first;&#125; FreeList[M+1];// 子表个数为 M+1 伙伴系统的分配算法 1234567891011121314151617181920212223242526 WORD_b* AllocBuddy (FreeList avail[], int n) &#123;// avail[0..m] 为可利用空间表, n 为申请分配量,若有不小于n 的空闲块,则分配相应的存储块,并返回其首地址;否则返回 NULL WORD_b *pa, *pre, *suc, *pi;// 查找满足分配要求的子表 for (int k=0; k&lt;=m &amp;&amp; (!avail[k].first ||avail[k].nodesize&lt;n+1);k++) ; if (k&gt;m) return NULL; // 分配失败 else &#123; // 进行分配 pa = avail[k].first; // 指向可分配子表的第一个结点// 分别指向前驱和后继 pre = pa-&gt;llink; suc = pa-&gt;rlink; if (pa==suc) avail[k].first = NULL; // 分配后该子表变成空表 else &#123; // 从子表删去 *pa 结点 pre-&gt;rlink = suc; suc-&gt;llink = pre; avail[k].first = suc; &#125;// 将剩余块插入相应子表 for (int i=1; avail[k-i].nodesize&gt;=n+1; ++i) &#123; pi = pa+(int)pow(2, (k-i)); pi-&gt;rlink = pi; pi-&gt;llink = pi; pi-&gt;tag = 0; pi-&gt;kval = k-i; avail[k-i].first = pi; &#125; pa-&gt;tag = 1; pa-&gt;kval = k-(--i); &#125; return pa;&#125; // AllocBuddy 回收算法 释放占用块时,需要将该新的空闲块插入到可利用空闲表中 考虑合并成大块的问题:只有 “ 互为伙伴 ” 的两个子块均空闲时才合并;即使有两个相邻且大小相同的空闲块,如果不是 “ 互为伙伴 ” ( 从同一个大块中分裂出来的 ) 也不合并。 设要回收的空闲块的首地址是 p ,其大小为 2^k : (1) 判断其 “ 互为伙伴 ” 的块是否空闲: 若不空闲,仅将要回收的空闲块直接插入到相应的子表中;否则转 (2) ; (2) 按以下步骤进行空闲块的合并: 在相应子表中找到其伙伴并删除之; 合并两个空闲块; (3) 重复 (2) ,直到合并后的空闲块的伙伴不是空闲块为止 特点:算法简单;速度快;但容易产生碎片 无用单元收集 无用单元:用户不再使用而系统没有回收的变量和结构 产生原因:程序 Bug – p=malloc(size); … … p=NULL; // 未回收的空间– p=malloc(size); … … q=p;free(p);// 悬挂访问"},{"title":"局部变量的栈溢出","date":"2017-07-28T13:47:54.000Z","path":"2017/07/28/Stack-Over-Flow-in-Function/","text":"先上代码： 123456789101112131415161718192021222324252627 #include&lt;iostream&gt;const int MAX_N = 10000000;using namespace std;bool Tree[MAX_N] = &#123;false&#125;;//全局变量int main()&#123; int depth, balls; cin &gt;&gt; depth &gt;&gt; balls; int ind = 0; int last = 0; while( ind ++ &lt; balls )&#123; int curr = 1; for ( int i = 0; i &lt; depth; ++i )&#123; if( false == Tree[curr] )&#123; curr = curr*2; &#125; else&#123; curr = curr*2 + 1; &#125; Tree[curr] = !Tree[curr]; last = curr; &#125; &#125; cout &lt;&lt; last &lt;&lt; endl; return 0;&#125; 代码1 12345678910111213141516171819202122232425262728 #include&lt;iostream&gt;const int MAX_N = 10000000;using namespace std;bool Tree[MAX_N] = &#123;false&#125;;int main()&#123; int depth, balls; cin &gt;&gt; depth &gt;&gt; balls; bool Tree[MAX_N] = &#123;false&#125;;//局部变量 int ind = 0; int last = 0; while( ind ++ &lt; balls )&#123; int curr = 1; for ( int i = 0; i &lt; depth; ++i )&#123; if( false == Tree[curr] )&#123; curr = curr*2; &#125; else&#123; curr = curr*2 + 1; &#125; Tree[curr] = !Tree[curr]; last = curr; &#125; &#125; cout &lt;&lt; last &lt;&lt; endl; return 0;&#125; 代码2 观察代码1和代码2，二者只有一个区别，前者Tree为全局变量，而后者为局部变量。一般来说，我们可能觉得两个函数运行的时候不会有什么不同，然而却出现不同的结果： 代码1能正确运行，代码2： 我们知道，在内存中，全局变量存于全局变量区，而局部变量位于栈中，函数以栈帧的形式存储。相对来说，全局变量区空间较大，而栈空间较小，因此便导致了代码2的栈溢出，而代码1则正常。"},{"title":"《Linux 命令行大全》学习笔记-Part3","date":"2017-06-20T04:54:21.000Z","path":"2017/06/20/Linux-Command-Line-learning-notes-Part3/","text":"Chapter 14 软件包管理 低级软件包： Debian : dpkg/rpm dpkg –install file.deb/rpm -i package_file/rpm -U package_file：安装/升级软件 dpkg –list ：列出所有已安装软件 dpkg –status package_name：判断是否已安装 dpkg –search filename/rpm -qf file_name：查询文件所属命令 高级软件包：apt-get apt-get update ; apt-cache search file_name：搜索软件包 apt-get update ; apt-get install package_name：安装软件包 apt-get remove package_name/yum erase package_name：删除软件包，彻底删除干净，可加上 –purge 参数 apt-get update ; apt-get upgrade ：更新/升级软件包 apt-cache show packagename ：显示软件包相关信息 apt-cache search package_name/yum search package_name：搜索软件包 Chapter 15 存储介质 /etc/fstab 文件：显示系统启动时挂载的设备。 mount ：查看已挂载文件系统（不带参数） mount -t ext4 /dev/sda1 /mnt ：挂载文件系统（root 权限），-t 选项指定文件系统类型 umount /dev/hdc：卸载设备 ls /dev：查看/dev目录下的设备信息 sudo tail -f /var/log/messages ：实时系统监测 sudo fdisk /dev/sdb：磁盘分区 sudo fdformat /dev/sdb1：格式化 sudo mkfs -t ext4 /dev/sdb1：创建新的文件系统(-t vfat:fat32) sudo fsck /dev/sdb1：检查闪存（事先需卸载） dd if=input_file of=output_file：文件复制（数据块） example: dd if=/dev/sdb of=/dev/sdc ​ dd if=ubuntu.iso of=/dev/sdc（创建系统启动盘） 挂载镜像文件：mkdir /mnt/iso_file; mount -t iso9660 -o loop image.iso /mnt/iso_file wodim dev=/dev/cdrw blank=fast ：擦除设备 wodim dev=/dev/cdrw image.iso ：写入镜像文件 md5sum image.iso：计算校验和 Chapter 16 网络 ping ：向网络主机发送特殊数据包，检测网络是否连通，例如：ping linux.com traceroute ：跟踪网络数据包的传输路径，例如：traceroute ucasfl.me netstat ：检查网络设置及相关统计数据 -ie 选项：检查系统中的网络接口信息 -r 选项：显示内核的网络路由表 文件传输 ftp: 123456 ftp fileserver:连接主机cd dir:进入目录ls:列出内容lcd dir ：切换目录get something:下载东西help:显示命令列表 lftp：与 ftp 类似，支持更多的协议和功能 wget ：用于文件下载的命令行程序，既可从网站上下载，也可从 ftp 站点下载 example: wget http://ucasfl.me/scripts/vim_config.sh ssh:安全登录远程计算机：ssh user@hostname/ip ssh user@remote_host command : 远程执行命令 scp user@remote_host:document.txt /user/home/ ：将远程文件复制到当前的 home 目录下 sftp : 命令与 ftp 类似，不过远程主机不需要 ftp 服务器，只需要 ssh 服务器 Chapter 17 文件搜索 locate filename：搜索文件，支持扩展，例如：locate zip :搜索以 zip 开头的文件 find : 较复杂的方式查找文件 find ~ | wc -l : 计算当前系统总目录的文件数。 1234567 find ~ -type x : 指定类型查找，x 为参数x: b:块设备文件 c:字符设备文件 d:目录文件 f:普通文件 l:符号链接 find 命令的 test 项参数： 123456789101112131415161718 -cmin n ：匹配n分钟前改变状态的文件或目录，不到n分钟，用 -n，超过n分钟，用+n-cnewer file :匹配内容或属性的修改时间比file晚的文件或目录-ctime 24:匹配系统中n*24小时前文件状态被改变的文件或目录-empty: 匹配空文件或空目录-group name:匹配属于name组的文件或目录-iname pattern:与-name test项功能类似，只是不区分大小写-inum n:匹配索引节点是n的文件-mmin n:匹配n分钟前内容被修改的文件或目录-mtime n:匹配n*24小时前只有内容被修改的文件或目录-name pattern :匹配有特定通配符的文件或目录-newer file :匹配内容的修改时间比file文件更近的文件或目录-nouser:匹配不属于有效用户的文件或目录-nogroup:匹配不属于有效组的文件或目录-perm mode :寻找访问权限与既定模式匹配的文件或目录-samefile name:与-inum test 选项类似-size n:匹配n大小的文件-type c:匹配c类型的文件-user name:匹配属于name用户的文件或目录 find 命令的逻辑操作符： -and :与 -or : 或 -not : 非 () : 括号 注：在shell中，括号需要加反斜杠进行转义。 action 选项： 12345 预定义操作：-delete: 删除匹配文件-ls: 对匹配的文件执行ls操作-print: 将匹配的文件的全路径以标准形式打印出，默认形式-quit: 匹配成功便退出 自定义操作： -exec/-ok command {}; :command 为预执行命令(-ok会在每一次执行命令前询问用户) touch filename: 设定或更新文件的修改时间，文件不存在时，会创建一个新文件(空文件) stat filename: 显示文件的所有信息及属性 option选项： 12345 -depth: 引导find程序处理目录前先处理目录内的文件-maxdepth levels: 当执行测试条件行为时，设置find程序陷入的目录数的最大级别数-mindepth levels: 设置find程序陷入目录数的最小级别数-noleaf: 指导find程序不要基于“正在搜索类UNIX文件系统”的假设来优化搜索，当扫描DOS/Windows文件系统和CD时，会用到该选项-mount: 引导find程序不要遍历挂载在其他文件系统上的目录 Chapter 18 归档和备份 gzip: 12 gzip filename: 压缩文件gunzip filename.gz: 解压缩文件 gzip 命令的一些选项： 123456789 -c: 将输出内容写到标准输出端口并且保持原有文件-d: 解压缩，gzip -d == gunzip-f: 强制压缩-h: 显示有用信息，可用 --help 代替-l: 列出所有压缩文件的压缩统计，也可以用 --list 代替-r: 存在目录时，递归压缩 ==--recursive-t: 检验压缩文件的完整性 ==--test-v: 在压缩时显示详细信息，==--verbose-number: 设置压缩级别，number是1~9的一个数，默认压缩级别是6 bzip2/bunzip2: 与gzip命令类似，不过使用不同的压缩算法，该算法具有高质量的数据压缩能力，但降低了压缩速度。 tar: 归档文件 用法：tar mode pathname… tar命令的操作模式： 123456 c: 创建文件或目录的归档文件x: 从归档文件中提取文件t: 在归档文件末尾追加指定路径名r: 列出归档文件的内容f: 指定归档文件名v: 获取详细信息 example: tar cf/cvf file.tar file: 归档文件 tar xf/xvf file.tar file: 提取文件 zip: 打包压缩文件 example: zip -r file.zip file 解压缩：unzip file.zip rsync: 远程文件、目录的同步 Chapter 19 正则表达式 grep: 文本搜索，搜索文本文件中与指定正则表达式匹配的行，并送至标准输出 命令用法： grep mode searchfile，例如 grep -h ‘^int$’ test.c grep 选项： 1234567 -i: 忽略大小写-v: 输出不匹配行-c: 输出匹配项数目-l: 输出匹配项文件名而不是直接输出匹配行-L: 与-l类似，但输出不包含匹配项的文件名-n: 在每个匹配行前面加上该行在文件中的行号-h: 进行多文件搜索时，抑制文件名输出 正则表达式： 详细内容可查看计算理论相关书籍。 元字符：^ $ . [ ] - ? * + ( ) | \\ a/A~z/Z 为文字字符 注：在命令行中输入包含元字符的正则表达式时，应把元字符用引号括起来以避免不必要的shell 扩展。 任意字符： . : 匹配任意字符 example: ls /usr/bin/ | grep -h ‘.zip’ 注意，上面输出中并不会包含zip，因为zip只包含三个字符，而这里至少要有四个字符。 开头字符和末尾字符： ^ : 匹配开头字符 $ : 匹配末尾字符 example : ls /usr/bin | grep -h ‘^zip’ : 匹配以zip开头的输出 ls /usr/bin | grep -h ‘zip$’ : 匹配以zip结尾的输出 ls /usr/bin | grep -h ‘^zip$’ : 输出只有zip 中括号表达式和字符类 中括号除了可用于匹配正则表达式中的给定字符外，还可用于匹配字符集中的单个字符。借助中括号，也可指定要匹配的字符集，例如：ls /usr/bin | grep -h ‘[bg]zip’ 会输出以bzip和gzip开头的输出。 注：^在中括号中表示否定；-在中括号中表示字符范围。 否定 在中括号中使用 ^ ,表示剩余字符不应该出现，例如： ls /usr/bin/ | grep -h &#39;[^bg]zip&#39; 会得到包含zip但zip前面既不是b，又不是g的程序。 注：^ 只有在中括号中的第一个字符才会当作否定符，否则当作普通符号处理。 字符范围 使用 - 例： 123 grep -h '^[A-Z]' filename :所有以大写字母开头的行grep -h '^[A-Za-z0-9]' filename :所有以字母和数字开头的行grep -h '[-AZ]' filename :仅表示包含连字符，大写字母A或Z的行 POSIX 字符集 12345678910111213 [:alnum:] 字母字符和数字字母，在ASCII中，与[A-Za-z0-9]等效[:word:] 与上者相比，多了下划线字符_[:alpha:] 字母字符，在ASCII中，等效于[A-Za-z][:blank:] 空字符，包括空格和制表符[:cntrl:] ASCII控制符，包括ASCII字符0~31以及127[:digit:] 数字0~9[:graph:] 可见字符，在ASCII中，包括字符33~126[:lower:] 小写字母[:punct:] 标点符号字符[:print:] 可打印字符，包括[:graph:]中的所有字符加上空格字符[:space:] 空白字符包括空格符，制表符，回车符，换行符垂直制表符以及换页符，在ASCII中，等价于[\\t\\r\\n\\v\\f][:upper:] 大写字母[:xdigit:] 用于表示十六进制的字符 ==[0-9a-fA-F] 例如： ls /usr/sbin/[[:upper:]]* : 列出所有以大写字母开头的文件 或选项：| 例如： 12 echo \"AAA\" | grep -E 'AAA|BBB|CCC'ls /usr/bin | grep -Eh '^(bz|gz|zip)' 匹配以bz或gz或zip开头的程序 匹配某元素0次或1次：? ? 置于字符的后面表示前面的字符（单个）匹配一次或零次 匹配0次或多次： * 用法和上者类似。 匹配一次或多次： + 用法和上者类似。 以指定次数匹配： 1234 &#123;n&#125; 前面的元素恰好出现n次&#123;n,m&#125; 前面的元素出现的次数在n~m之间时匹配&#123;n,&#125; 前面的元素超过n次时匹配&#123;,m&#125; 前面的元素不超过m次时匹配 locate 查找文件： 选项： –regexp 支持基本正则表达式 –regex 支持扩展正则表达式 less 和 Vim 二者皆支持正则表达式搜索，并且搜索方法相同：按下“/”键后，输入正则表达式，便可搜索。 Chapter 20 文本处理 cat : 进行文件间的拼接并输出到标准输出 选项： -A : 输出非打印字符 -n : 对行编号 -s : 禁止输出多个空白行 sort : 对文本进行排序 sort 是一个排序程序，操作对象为标准输入或是命令行中指定的一个或多个文件，然后将结果送至标准输出。 example: 12 sort &gt; foo.txt 可在键盘输入然后sort排序后输入到 foo.txt 中（重定向）sort file1 file2 file3 &gt; file_sorted 将三个文件进行排序后输出到一个文件中 sort 选项： 1234567 -b 忽略行开头的空格，默认情况下，会对整个行进行排序-f 排序时不区分大小写-n 基于字符串的长度进行排序而不是基于字母表顺序进行排序-r 逆序进行排序-m 将输入的多个参数当作已经排序好的。将多个文件合并为一个排序好的文件，而不执行额外的排序操作-o 将排序结果输出到文件而不是标准输出-t 定义字段分隔符，默认情况下是空格或制表符 uniq 给定一个排序好的文件或标准输入，unip会删除重复的行并将结果输出到标准输出中。 注意：uniq仅对排序好的文件有用，因为uniq只能移除相邻的重复行。 123456 -c 输出重复行列表，并且在重复行的前面加上出现的次数-d 只输出重复行，不包括单独行-f n 忽略每行的前n个字段-i 行与行之间比较时忽略大小写-s n 忽略每行的前n个字符-u 仅输出不重复的行，该选项是默认的 cut 从文本行中提取一段文字并输出至标准输出。 1234 -c char_list 从文本行中提取char_list定义的内容，例，cut -c 7-10 提取每行中的7-10个字符-f field_list 从文本行中提取field_list定义的一个或多个字段-d delim_char 使用-f选项后，可使用delim_char作为字段分隔符，默认时以Tab制表符隔开--complemet 从文本中提取整行，除了那些-c和/或-f指定的部分 paste - 合并文本行 example: paste file1.txt file2.txt：将两个文件中的内容按行拼接起来 join - 连接两个文件中具有相同字段的行 example: join file1.txt file2.txt comm - 逐行比较两个已排序好的文件 详见另一篇博客 - Linux Command of comm diff - 逐行比较文件 patch - 对原文件进行 diff 操作 tr - 替换或删除字符 sed - 用于文本过滤和转换的流编辑器 aspell - 交互式拼写检查工具 Chapter 21 格式化输出 nl - 对行进行标号 example : nl file.txt : 默认对非空行进行标号。 fold - 设定文本行长度 example : 12 fold -w 15 file.txt 每行设置为15个字符fold -w 15 -s file.txt 使其断行时考虑单词边界 fmt - 简单的文本格式化工具 pr - 格式化打印文本 printf - 格式化并打印数据，与C语言中的printf类似。 Chapter 22 打印 pr : 转换打印文本，从而进行打印操作 lpr: 打印文件 lp: 打印文件 a2ps: 格式化文件，以在PostScript打印机上打印 lpstat: 显示打印状态信息 lpq: 显示打印机队列状态 lprm: 取消打印任务 cancel: 取消打印任务 Chapter 23 编译程序 123 ./configuremakesudo make install"},{"title":"C 语言中的静态变量","date":"2017-06-19T09:17:44.000Z","path":"2017/06/19/The-Static-Variables-in-C/","text":"静态变量 静态变量的关键字为 static ，采用静态存储方式，一般的声明如： 1 static int a;//a 为一个静态变量 静态变量的一些特点： 静态局部变量在函数内定义，但不像自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。 静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 允许对构造类静态局部量赋初值。若未赋以初值，则由系统自动赋值。数值型变量自动赋初值0，字符型变量赋空字符。 对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。 根据静态局部变量的特点， 可以看出它是一种生存期为整个源文件的量。虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用， 而且保存了前次被调用后留下的值。 因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。 尽管如此，全局静态变量和局部静态变量还有一些区别。 全局静态变量 尽管全局静态变量的生命周期为整个源程序，但是，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。 局部静态变量 在一些函数比如递归函数中，局部静态变量用处较大，比如在递归函数中。但是需要注意，每次在主函数中调用该函数时，局部静态变量都保存之前的值。此时，需要注意一个问题。 如果在一个递归函数中，当递归调用时，需要静态变量保存之前的值，而每次在主函数中调用该递归函数，都需要将该静态变量赋一个固定的初值，那么可以多加一个参数来实现。 下面是一个例子。通过中序遍历一个平衡二叉排序树来获取一个递增序列，将该序列存于一个数组中，并得到数组的最后一个元素下标。 第一种实现： 123456789101112131415 int inorder(BiTree T, int key[], int *last)&#123; static int i = 0; if(!T) return 1; else&#123; if (inorder(T-&gt;lchild, key, last, ++ restore))&#123; key[i++] = T-&gt;data;//get array list if (inorder(T-&gt;rchild, key, last, ++ restore))&#123; *last = i - 1;// get the length-1 of list return 1; &#125; &#125; return 0; &#125;&#125;//inorder 如果在主函数中，该函数仅调用一次，那么像这样写没有任何问题。但是，如果主函数中多次调用了该递归函数，那么之后的调用 i 的初值遍不是 0 ，而这儿我们需要在是 0 ，当每次在主函数中调用时。 我们可以通过添加一个参数来保证每次在主函数中调用该递归函数时，i 的初值均为 0： 1234567891011121314151617 int inorder(BiTree T, int key[], int *last, int restore)&#123; static int i = 0; if (!restore) i = 0;//when everytime call the function in main function, restore i to zero if(!T) return 1; else&#123; if (inorder(T-&gt;lchild, key, last, ++ restore))&#123; key[i++] = T-&gt;data;//get array list if (inorder(T-&gt;rchild, key, last, ++ restore))&#123; *last = i - 1;// get the length-1 of list return 1; &#125; &#125; return 0; &#125;&#125;//inorder 如上面的代码所示，我们增加了一个新的参数 restore，每次在主函数中调用该函数时，restore 传入的值为 0 ，这样便可消除上面的问题。"},{"title":"递归实现平衡二叉树的插入、删除、合并和分裂","date":"2017-06-19T08:39:12.000Z","path":"2017/06/19/Using-Recursive-Method-to-Finish-the-Join-Split-of-AVL-Tree/","text":"平衡二叉树 平衡二叉树是这样一棵树，要么是一棵空树，要么是满足下面条件的树： 左子树和右子树的深度的绝对值只差不超过 1; 左子树和右子树也是平衡二叉树。 既是二茬排序树又是平衡二叉树的树为平衡二茬排序树。下面说到的平衡二叉树表示平衡二茬排序树。 在平衡二叉树的结构定义中，比二叉树多了一个平衡因子。实现平衡二叉树的插入和删除是一件比较头疼的事情。因为每次插入或删除之后都要检查平衡是否被破坏，如果被破坏，则要进行各种左旋、右旋的平衡化。 除了插入和删除，有的时候还会涉及到将两个平衡二叉树或多个合并成一个平衡二叉树。或者将一个平衡二叉树分裂为两个平衡二叉树，其中一个中的值均小于等于 $x$，另一个的值均大于 $x$ 。对于合并，最常规的方法自然是，将其中一个二叉树中的点一个个插入到另一个平衡二叉树中。然而，这样做的时间复杂度很大，而且其中一棵二叉树被破坏。但是，如果通过递归来做，则可以在不破坏两棵树的前提下创建一棵新的平衡二叉树，并且时间复杂度比前者要优越很多。 算法 下面说一下该算法： 分别中序遍历两棵二叉树，得到两个有序序列。 将两个有序序列合并为一个有序序列。 利用该有序序列来创建一棵新的平衡二叉树。 递归部分： 终止条件： 序列中只剩下一个或两个记录，一个时，直接建节点，插入记录；两个时，可建节点，将前者插入，然后再后一个作为前者的右孩子插入。 递归： 当序列数大于二时，首先建立节点，将序列最中间的记录插入，然后递归，将中间节点之前的记录作为左孩子插入，中间节点后面的记录作为右孩子插入。 通过该算法构造出的二叉树一定为平衡二茬排序树： 每次递归保证了左边的点小于根节点，右边的点大于根节点，因此为排序树。 递归过程中保证了左右孩子的数目相等或相差一个，这样保证了左右孩子的深度绝对值只差不会超过 1 。 利用这一个思路，也可进行分裂、插入和删除： 分裂：中序遍历平衡二叉树得到序列，定位出 $x$ 的位置，利用递归算法和 $x$ 以及之前的序列可构造出一棵二叉树，之后的序列同样构造出一棵二叉树。 插入：先中序遍历得到序列，将需插入的值插入序列，然后再建树，只是这样相当于重新创建一棵二叉树。 删除：和插入一样。 C 语言实现： 下面是合并和分裂的 C 语言实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAX 100#define MMAX 200typedef struct BiTreeNode&#123; int number; int data; struct BiTreeNode *lchild; struct BiTreeNode *rchild;&#125;BiTreeNode, *BiTree;void join(BiTree *T, int key[], int first, int last); //use a sorted array key[] to create a balanced treevoid split(BiTree T, BiTree *T1, BiTree *T2, int x); //split a balanced tree into two balanced treeint inorder(BiTree T, int key[], int *last, int restore); //inorder traverse a balanced tree to get the record listint preorder(BiTree T); //preorder traverse a treeint get_index_x(int key[], int last, int x, int *index_x); //get the index of x in array keyvoid merge_array(int key[], int key1[], int key2[], int len1, int len2, int *last); //merge two sorted array into one sorted arrayvoid merge_tree(BiTree *T, BiTree T1, BiTree T2); //merge two balanced tree into one balanced treevoid merge_tree(BiTree *T, BiTree T1, BiTree T2)&#123; int key[MMAX], key1[MAX], key2[MAX]; int len1, len2, last; //get lists inorder(T1, key1, &amp;len1, 0); inorder(T2, key2, &amp;len2, 0); //merge lists merge_array(key, key1, key2, len1, len2, &amp;last); join(T, key, 0, last); //create tree&#125;//merge_treevoid merge_array(int key[], int key1[], int key2[], int len1, int len2, int *last)&#123; int i, j, k ; key[0] = (key1[0] &lt; key2[0])?key1[0]:key2[0];//get the first value for(i = 0, j = 0, k = 1; i &lt;= len1 &amp;&amp; j &lt;= len2; )&#123; //merge lists if (key1[i] &lt; key2[j] )&#123; if (key1[i] != key[k-1]) key[k++] = key1[i++]; else i ++; &#125; else &#123; if (key2[j] != key[k-1]) key[k++] = key2[j++]; else j ++; &#125; &#125; if (i &lt;= len1)&#123; //merge remain record of key1[] while ( i &lt;= len1 ) &#123; key[k++] = key1[i++]; &#125; &#125; else if(j &lt;= len2 )&#123; //merge remain record of key2[] while ( j &lt;= len2 ) &#123; key[k++] = key2[j++]; &#125; &#125; else ; *last = k - 1; //get lenth-1&#125;//merge_arrayvoid join(BiTree *T, int key[], int first, int last)&#123; //create balanced tree using sorted array if(first == last)&#123;//left one record *T = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;data = key[first]; (*T)-&gt;lchild = (*T)-&gt;rchild = NULL; &#125; else if(first == last - 1)&#123;//left two record *T = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;data = key[first]; (*T)-&gt;rchild = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;rchild-&gt;data = key[last]; (*T)-&gt;lchild = (*T)-&gt;rchild-&gt;lchild = (*T)-&gt;rchild-&gt;rchild = NULL; &#125; else&#123; //insert middle record int middle = (first + last) / 2; *T = (BiTree) malloc (sizeof(BiTreeNode)); (*T)-&gt;data = key[middle]; //recursive call the join function join(&amp;((*T)-&gt;lchild), key, first, middle - 1); join(&amp;((*T)-&gt;rchild), key, middle + 1, last); &#125;&#125; //joinvoid split(BiTree T, BiTree *T1, BiTree *T2, int x)&#123; //split one balanced tree T into two balanced tree T1 and T2 int key[MAX]; int last, index_x; inorder(T, key, &amp;last, 0);//get sorted list array int get_x = get_index_x(key, last, x, &amp;index_x);//get the index of x in array key if (get_x)&#123; //call join funcion to create balanced tree join(T1, key, 0, index_x); join(T2, key, index_x + 1, last); &#125; else&#123; //all record &gt; x or &lt;= x, don't need split; *T1 = T; *T2 = NULL; &#125;&#125; //splitint get_index_x(int key[], int last, int x, int *index_x)&#123; int i, j; for ( i = 0; i &lt;= last; i++ ) &#123; j = i + 1; if( key[i] &lt;= x &amp;&amp; key[j] &gt; x &amp;&amp; j &lt;= last )&#123; *index_x = i; return 1; &#125; &#125; return 0;&#125;//get_indexint inorder(BiTree T, int key[], int *last, int restore)&#123; static int i = 0; if (!restore) i = 0;//when everytime call the function in main function, restore i to zero if(!T) return 1; else&#123; if (inorder(T-&gt;lchild, key, last, ++ restore))&#123; key[i++] = T-&gt;data;//get array list if (inorder(T-&gt;rchild, key, last, ++ restore))&#123; *last = i - 1;// get the length-1 of list return 1; &#125; &#125; return 0; &#125;&#125;//inorderint preorder(BiTree T)&#123; if(!T)&#123; return 1; &#125; else&#123; printf( \"%d \", T-&gt;data ); if(preorder(T-&gt;lchild)) if(preorder(T-&gt;rchild)) return 1; return 0; &#125; return 0;&#125;//preorderint main( int argc, char **argv ) &#123; int key[16]; for ( int i = 1; i &lt;= 16; i++ ) &#123; key[i-1] = 4*i - 3; &#125; BiTree T; join(&amp;T, key, 0, 15); preorder(T); printf( \"\\n\\n\" ); int num[40]; for ( int i = 0; i &lt; 40; i++ ) &#123; num[i] = 2*i + 1; &#125; BiTree T0, T1, T2; join(&amp;T0, num, 0, 39); preorder(T0); printf( \"\\n\\n\" ); int x; printf( \"Input x: \" ); scanf(\"%d\", &amp;x); split(T0, &amp;T1, &amp;T2, x); preorder(T1); printf( \"\\n\" ); preorder(T2); printf( \"\\n\\n\" ); int key1[10], key2[20]; for(int i = 0; i &lt; 10; i ++) key1[i] = 3*i; for ( int i = 0; i &lt; 20; i++ ) &#123; key2[i] = 2*i; &#125; BiTree t, t1, t2; join(&amp;t1, key1, 0, 9); preorder(t1); printf( \"\\n\" ); join(&amp;t2, key2, 0, 19); preorder(t2); printf( \"\\n\\n\" ); merge_tree(&amp;t, t1, t2); preorder(t); printf( \"\\n\" ); return 0;&#125;"},{"title":"使用 Python 开始你的机器学习之旅","date":"2017-06-07T14:42:18.000Z","path":"2017/06/07/Start-Machine-Learning-with-Python/","text":"机器学习是你的简历中必需的一门技能。我们简要概括一下使用 Python 来进行机器学习的一些步骤。 你想知道如何开始机器学习吗？在这篇文章中，我将简要概括一下使用 Python 来开始机器学习的一些步骤。Python 是一门流行的开源程序设计语言，也是在人工智能及其它相关科学领域中最常用的语言之一。机器学习简称 ML，是人工智能的一个分支，它是利用算法从数据中进行学习，然后作出预测。机器学习有助于帮助我们预测我们周围的世界。 从无人驾驶汽车到股市预测，再到在线学习，机器学习通过预测来进行自我提高的方法几乎被用在了每一个领域。由于机器学习的实际运用，目前它已经成为就业市场上最有需求的技能之一。另外，使用 Python 来开始机器学习很简单，因为有大量的在线资源，以及许多可用的 Python 机器学习库。 你需要如何开始使用 Python 进行机器学习呢？让我们来总结一下这个过程。 提高你的 Python 技能 由于 Python 在工业界和科学界都非常受欢迎，因此你不难找到 Python 的学习资源。如果你是一个从未接触过 Python 的新手，你可以利用在线资源，比如课程、书籍和视频来学习 Python。比如下面列举的一些资源： Python 学习之路 Google 开发者 Python 课程（视频） Google 的 Python 课堂 安装 Anaconda 下一步是安装 Anacona。有了 Anaconda ，你将可以开始使用 Python 来探索机器学习的世界了。Anaconda 的默认安装库包含了进行机器学习所需要的工具。 基本的机器学习技能 有了一些基本的 Python 编程技能，你就可以开始学习一些基本的机器学习技能了。一个实用的学习方法是学到一定技能便开始进行练习。然而，如果你想深入学习这个领域，那么你需要准备投入更多的学习时间。 一个获取技能的有效方法是在线课程。吴恩达的 Coursera 机器学习课程 是一个不错的选择。其它有用的在线训练包括： Python 机器学习： Scikit-Learn 教程 Python 实用机器学习教程 你也可以在 LiveEdu.tv 上观看机器学习视频，从而进一步了解这个领域。 学习更多的 Python 库 当你对 Python 和机器学习有一个好的感觉之后，可以开始学习一些开源的 Python 库。科学的 Python 库将会使完成一些简单的机器学习任务变得很简单。然而，选择什么库是完全主观的，并且在业界内许多人有很大的争论。 一些实用的 Python 库包括： Scikit-learn ：一个优雅的机器学习算法库，可用于数据挖掘和数据分析任务。 Tensorflow ：一个易于使用的神经网络库。 Theano ： 一个强大的机器学习库，可以帮助你轻松的评估数学表达式。 Pattern ： 可以帮助你进行自然语言处理、数据挖掘以及更多的工作。 Nilearn ：基于 Scikit-learn，它可以帮助你进行简单快速的统计学习。 探索机器学习 对基本的 Python、机器学习技能和 Python 库有了一定理解之后，就可以开始探索机器学习了。接下来，尝试探索一下 Scikit-learn 库。一个不错的教程是 Jake VanderPlas 写的 Scikit-learn 简介。 然后，进入中级主题，比如 K-均值聚类算法简介、线性回归、决策树和逻辑回归。 最后，深入高级机器学习主题，比如向量机和复杂数据转换。 就像学习任何新技能一样，练习得越多，就会学得越好。你可以通过练习不同的算法，使用不同的数据集来更好的理解机器学习，并提高解决问题的整体能力。 使用 Python 进行机器学习是对你的技能的一个很好的补充，并且有大量免费和低成本的在线资源可以帮助你。你已经掌握机器学习技能了吗？可以在下面留下你的评论，或者提交一篇文章来分享你的故事。 作者简介： Michael J. Garbade 博士是旧金山 LiveEdu Inc（Livecoding.tv）的创始人兼首席执行官。Livecoding.tv 是世界上观看工程师直播编代码最先进的直播平台。你可以通过观看工程师们写网站、移动应用和游戏，来将你的技能提升到一个新的水平。MichaelJ. Garbade 博士拥有金融学博士学位，并且是一名自学成才的工程师，他喜欢 Python、Django、Sencha Touch 和视频流。 via: https://opensource.com/article/17/5/python-machine-learning-introduction 作者：Michael J. Garbade译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"使用 Comm 比较两个排序好的文件","date":"2017-06-05T14:39:58.000Z","path":"2017/06/05/Linux-Command-of-comm/","text":"Linux 中的 comm 命令可以让用户按行比较两个已经排序好的文件。在本教程中，我们将使用一些浅显易懂的例子来讨论这个命令行工具。在开始之前，请注意，本教程中提到的所有例子都已经在 Ubuntu 16.04LTS 版本中测试过。 下面的例子将会告诉你 comm 命令是如何工作的。 1、 如何使用 comm 比较两个排序好的文件 要使用 comm 命令比较两个排序好的文件，只需要把它们的名字作为 comm 命令的参数。下面是通常的语法： 1 comm [name-of-first-file] [name-of-second-file] 比如，假设 file1 和 file2 是这种情况下的两个文件。前者包含下面几行内容： 1234 001056127258 而后者包含下面几行内容： 1234 002056167369 此时，comm 命令的输出如下图所示： 1 comm file1 file2 你可以看到，输出包含 3 列。第一列是仅包含在 file1 中的内容，第二列是仅包含在 file2 中的内容，最后，第三列是两个文件中均包含的内容。 2、 如何不输出 comm 命令输出中的某些列 如果你想，你可以不输出 comm 命令输出中的某些列。对于该特性，你有三个命令行选项可用：-1、-2 和 -3 。正如你所猜想的，这些数字表示你不想输出的列。 比如，下面这个命令将会不输出上面例子中的第三列： 1 comm -3 file1 file2 因此，你可以看到，第三列并没有输出。 注意，你可以通过一个单一命令同时不输出多列内容。比如： 1 comm -12 file1 file2 上面这个命令将会不输出第一、二列。 3、 如何使用 comm 命令比较两个未排序好的文件 正如我们所知道的，comm 只可用于排序好的文件。如果发现其中一个文件未排序好，那么便会在输出中产生一条信息来告诉用户。比如，我们交换 file1 的第一行和第二行，然后与 file2 进行比较。下面是该命令的输出： 你可以看到，这个命令产生一个输出告诉我们：file1 还没有排序好。此时，如果你不想让这个工具检查输入是否已经排序好，那么你可以使用 --nocheck-order 选项： 1 comm --nocheck-order file1 file2 你可以看到，前面出现的提示信息已经消失了。 注意，如果你想明确告诉 comm 命令来检查输入文件是否排序好，那么你可以使用 --check-order 选项。 4、 如何用自定义字符串分隔 comm 命令的输出列 默认情况下，comm 命令的输出列之间是以空格分隔的。然而，如何你想使用一个自定义字符串作为分隔符，那么你可以使用 --output-delimiter 选项。使用该选项时需要指定你想用来作为分隔符的字符串。 1 comm --output-delimiter=+ file1 file2 比如，我们使用加号来作为分隔符： 5、 如何使 comm 的输出行以 NUL 字符终止 默认情况下，comm 命令的输出行以新行终止。然而，如果你想，那么你可以改为以 NUL 字符终止，只需要使用 -z 选项即可： 1 comm -z file1 file2 结论 comm 命令并没有特别多的特性性，我们在这儿已经讨论了它的绝大多数命令行选项。只需要理解和练习在这篇教程中讨论的内容，那么你便可以在日常工作中知道如何使用这个工具了。如果你有任何问题或者疑问，请前往该命令的 man 手册，或者在下面评论。 via: https://www.howtoforge.com/linux-comm-command/ 作者：Himanshu Arora译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"8 个优秀的开源 Markdown 编辑器","date":"2017-05-23T09:23:40.000Z","path":"2017/05/23/8-Excellent-Open-Source-Markdown-Editor/","text":"Markdown 首先，对 Markdown 进行一个简单的介绍。Markdown 是由 John Gruber 和 Aaron Swartz 共同创建的一种轻量级纯文本格式语法。Markdown 可以让用户“以易读、易写的纯文本格式来进行写作，然后可以将其转换为有效格式的 XHTML（或 HTML）“。Markdown 语法只包含一些非常容易记住的符号。其学习曲线平缓；你可以在炒蘑菇的同时一点点学习 Markdown 语法（大约 10 分钟）。通过使用尽可能简单的语法，错误率达到了最小化。除了拥有友好的语法，它还具有直接输出干净、有效的（X）HTML 文件的强大功能。如果你看过我的 HTML 文件，你就会知道这个功能是多么的重要。 Markdown 格式语法的主要目标是实现最大的可读性。用户能够以纯文本的形式发布一份 Markdown 格式的文件。用 Markdown 进行文本写作的一个优点是易于在计算机、智能手机和个人之间共享。几乎所有的内容管理系统都支持 Markdown 。它作为一种网络写作格式流行起来，其产生一些被许多服务采用的变种，比如 GitHub 和 Stack Exchange 。 你可以使用任何文本编辑器来写 Markdown 文件。但我建议使用一个专门为这种语法设计的编辑器。这篇文章中所讨论的软件允许你使用 Markdown 语法来写各种格式的专业文档，包括博客文章、演示文稿、报告、电子邮件以及幻灯片等。另外，所有的应用都是在开源许可证下发布的，在 Linux、OS X 和 Windows 操作系统下均可用。 Remarkable 让我们从 Remarkable 开始。Remarkable 是一个 apt 软件包的名字，它是一个相当有特色的 Markdown 编辑器 — 它并不支持 Markdown 的全部功能特性，但该有的功能特性都有。它使用和 GitHub Markdown 类似的语法。 你可以使用 Remarkable 来写 Markdown 文档，并在实时预览窗口查看更改。你可以把你的文件导出为 PDF 格式（带有目录）和 HTML 格式文件。它有强大的配置选项，从而具有许多样式，因此，你可以把它配置成你最满意的 Markdown 编辑器。 其他一些特性： 语法高亮 支持 GitHub 风味的 Markdown 支持 MathJax - 通过高级格式呈现丰富文档 键盘快捷键 在 Debian、Ubuntu、Fedora、SUSE 和 Arch 系统上均有 Remarkable 的可用的简易安装程序。 主页： https://remarkableapp.github.io/许可证： MIT 许可 Atom 毫无疑问， Atom 是一个神话般的文本编辑器。超过 50 个开源包集合在一个微小的内核上，从而构成 Atom 。伴有 Node.js 的支持，以及全套功能特性，Atom 是我最喜欢用来写代码的编辑器。Atom 的特性在杀手级开源应用的文章中有更详细介绍，它是如此的强大。但是作为一个 Markdown 编辑器，Atom 还有许多不足之处，它的默认包不支持 Markdown 的特性。例如，正如上图所展示的，它不支持等价渲染。 但是，开源拥有强大的力量，这是我强烈提倡开源的一个重要原因。Atom 上有许多包以及一些复刻，从而添加了缺失的功能特性。比如，Markdown Preview Plus 提供了 Markdown 文件的实时预览，并伴有数学公式渲染和实时重加载。另外，你也可以尝试一下 Markdown Preview Enhanced。如果你需要自动滚动特性，那么 markdown-scroll-sync 可以满足你的需求。我是 Markdown-Writer和 Markdown-pdf的忠实拥趸，后者支持将 Markdown 快速转换为 PDF、PNG 以及 JPEG 文件。 这个方式体现了开源的理念：允许用户通过添加扩展来提供所需的特性。这让我想起了 Woolworths 的 n 种杂拌糖果的故事。虽然需要多付出一些努力，但能收获最好的回报。 主页： https://atom.io/许可证： MIT 许可 Haroopad Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。 Haroo 在韩语中的意思是“一天”。 它的功能列表非常可观。请看下面： 主题、皮肤和 UI 组件 超过 30 种不同的编辑主题 - tomorrow-night-bright 和 zenburn 是近期刚添加的 编辑器中的代码块的语法高亮 Ruby、Python、PHP、Javascript、C、HTML 和 CSS 的语法高亮支持 基于 CodeMirror，这是一个在浏览器中使用 JavaScript 实现的通用文本编辑器 实时预览主题 基于 markdown-css 的 7 个主题 语法高亮 基于 hightlight.js 的 112 种语言以及 49 种样式 定制主题 基于 CSS （层叠样式表）的样式 演示模式 - 对于现场演示非常有用 绘图 - 流程图和序列图 任务列表 扩展 Markdown 语法，支持 TOC（目录）、 GitHub 风味 Markdown 以及数学表达式、脚注和任务列表等 字体大小 使用首选窗口和快捷键来设置编辑器和预览字体大小 嵌入富媒体内容 视频、音频、3D、文本、开放图形以及 oEmbed 支持大约 100 种主要的网络服务（YouTude、SoundCloud、Flickr 等） 支持拖放 显示模式 默认：编辑器｜预览器，倒置：预览器｜编辑器，仅编辑器，仅预览器（View -&gt; Mode） 插入当前日期和时间 多种格式支持（Insert -&gt; Data &amp; Time） HtML 到 Markdown 拖放你在 Web 浏览器中选择好的文本 Markdown 解析选项 大纲预览 纯粹主义者的 Vim 键位绑定 Markdown 自动补全 导出为 PDF 和 HTML 带有样式的 HTML 复制到剪切板可用于所见即所得编辑器 自动保存和恢复 文件状态信息 换行符或空格缩进 （一、二、三）列布局视图 Markdown 语法帮助对话框 导入和导出设置 通过 MathJax 支持 LaTex 数学表达式 导出文件为 HTML 和 PDF 创建扩展来构建自己的功能 高效地将文件转换进博客系统：WordPress、Evernote 和 Tumblr 等 全屏模式－尽管该模式不能隐藏顶部菜单栏和顶部工具栏 国际化支持：英文、韩文、西班牙文、简体中文、德文、越南文、俄文、希腊文、葡萄牙文、日文、意大利文、印度尼西亚文土耳其文和法文 主页 http://pad.haroopress.com/许可证： GNU GPL v3 许可 StackEdit StackEdit 是一个功能齐全的 Markdown 编辑器，基于 PageDown（该 Markdown 库被 Stack Overflow 和其他一些 Stack 交流网站使用）。不同于在这个列表中的其他编辑器，StackEdit 是一个基于 Web 的编辑器。在 Chrome 浏览器上即可使用 StackEdit 。 特性包括： 实时预览 HTML，并通过绑定滚动连接特性来将编辑器和预览的滚动条相绑定 支持 Markdown Extra 和 GitHub 风味 Markdown，Prettify/Highlight.js 语法高亮 通过 MathJax 支持 LaTex 数学表达式 所见即所得的控制按键 布局配置 不同风格的主题支持 la carte 扩展 离线编辑 可以与 Google 云端硬盘（多帐户）和 Dropbox 在线同步 一键发布到 Blogger、Dropbox、Gist、GitHub、Google Drive、SSH 服务器、Tumblr 和 WordPress 主页： https://stackedit.io/许可证： Apache 许可 MacDown MacDown 是在这个列表中唯一一个只运行在 macOS 上的全特性编辑器。具体来说，它需要在 OX S 10.8 或更高的版本上才能使用。它在内部使用 Hoedown 将 Markdown 渲染成 HTML，这使得它的特性更加强大。Heodown 是 Sundown 的一个复活复刻。它完全符合标准，无依赖，具有良好的扩展支持和 UTF-8 感知。 MacDown 基于 Mou，这是专为 Web 开发人员设计的专用解决方案。 它提供了良好的 Markdown 渲染，通过 Prism 提供的语言识别渲染实现代码块级的语法高亮，MathML 和 LaTex 渲染，GTM 任务列表，Jekyll 前端以及可选的高级自动补全。更重要的是，它占用资源很少。想在 OS X 上写 Markdown？MacDown 是我针对 Web 开发者的开源推荐。 主页： https://macdown.uranusjr.com/许可证： MIT 许可 ghostwriter ghostwriter 是一个跨平台的、具有美感的、无干扰的 Markdown 编辑器。它内建了 Sundown 处理器支持，还可以自动检测 pandoc、MultiMarkdown、Discount 和 cmark 处理器。它试图成为一个朴实的编辑器。 ghostwriter 有许多很好的功能设置，包括语法高亮、全屏模式、聚焦模式、主题、通过 Hunspell 进行拼写检查、实时字数统计、实时 HTML 预览、HTML 预览自定义 CSS 样式表、图片拖放支持以及国际化支持。Hemingway 模式按钮可以禁用退格键和删除键。一个新的 “Markdown cheat sheet” HUD 窗口是一个有用的新增功能。主题支持很基本，但在 GitHub 仓库上也有一些可用的试验性主题。 ghostwriter 的功能有限。我越来越欣赏这个应用的通用性，部分原因是其简洁的界面能够让写作者完全集中在策划内容上。这一应用非常值得推荐。 ghostwirter 在 Linux 和 Windows 系统上均可用。在 Windows 系统上还有一个便携式的版本可用。 主页： https://github.com/wereturtle/ghostwriter许可证： GNU GPL v3 许可 Abricotine Abricotine 是一个为桌面构建的、旨在跨平台且开源的 Markdown 编辑器。它在 Linux、OS X 和 Windows 上均可用。 该应用支持 Markdown 语法以及一些 GitHub 风味的 Markdown 增强（比如表格）。它允许用户直接在文本编辑器中预览文档，而不是在侧窗栏。 该应用有一系列有用的特性，包括拼写检查、以 HTML 格式保存文件或把富文本复制粘贴到邮件客户端。你也可以在侧窗中显示文档目录，展示语法高亮代码、以及助手、锚点和隐藏字符等。它目前正处于早期的开发阶段，因此还有一些很基本的 bug 需要修复，但它值得关注。它有两个主题可用，如果有能力，你也可以添加你自己的主题。 主页： http://abricotine.brrd.fr/许可证： GNU 通用公共许可证 v3 或更高许可 ReText ReText 是一个简单而强大的 Markdown 和 reStructureText 文本编辑器。用户可以控制所有输出的格式。它编辑的文件是纯文本文件，但可以导出为 PDF、HTML 和其他格式的文件。ReText 官方仅支持 Linux 系统。 特性包括： 全屏模式 实时预览 同步滚动（针对 Markdown） 支持数学公式 拼写检查 分页符 导出为 HTML、ODT 和 PDF 格式 使用其他标记语言 主页： https://github.com/retext-project/retext许可证： GNU GPL v2 或更高许可 via: https://www.ossblog.org/markdown-editors/ 作者：Steve Emms译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"如何在 Vim 中使用模式行进行文本特定设置","date":"2017-05-20T09:15:15.000Z","path":"2017/05/20/Text-Specific-Setting-in-Vim/","text":"虽然插件毫无疑问是 Vim 最大的优势，然而，还有其它一些功能，使得它成为当今 Linux 用户中最强大、功能最丰富的文本编辑器/IDE 之一。其中一个功能就是可以根据文件做特定的设置。我们可以使用该编辑器的模式行（Modeline）特性来实现该功能。 在这篇文章中，我将讨论如何使用 Vim 的模式行（Modeline）特性来简单的理解一些例子。 在开始之前，值得提醒一下，这篇教程中提及的所有例子、命令和指令都已经在 Ubuntu 16.04 中使用 Vim 7.4 版本测试过。 VIM 模式行 用法 正如上面已经提到的， Vim 的模式行特性让你能够进行特定于文件的更改。比如，假设你想把项目中的一个特定文件中的所有制表符用空格替换，并且确保这个更改不会影响到其它所有文件。这是模式行帮助你完成你想做的事情的一个理想情况。 因此，你可以考虑将下面这一行加入文件的开头或结尾来完成这件事。 1 # vim: set expandtab: （LCTT 译注：模式行就是一行以注释符，如 #、//、/* 开头，间隔一个空格，以 vim: 关键字触发的设置命令。可参看：http://vim.wikia.com/wiki/Modeline_magic ） 如果你是在 Linux 系统上尝试上面的练习来测试用例，很有可能它将不会像你所期望的那样工作。如果是这样，也不必担心，因为某些情况下，模式行特性需要先激活才能起作用（出于安全原因，在一些系统比如 Debian、Ubuntu、GGentoo 和 OSX 上默认情况下禁用）。 为了启用该特性，打开 .vimrc 文件（位于 home 目录），然后加入下面一行内容： 1 set modeline 现在，无论何时你在该文件输入一个制表符然后保存时（文件中已输入 expandtab 模式行命令的前提下），都会被自动转换为空格。 让我们考虑另一个用例。假设在 Vim 中， 制表符默认设置为 4 个空格，但对于某个特殊的文件，你想把它增加到 8 个。对于这种情况，你需要在文件的开头或末尾加上下面这行内容： 1 // vim: noai:ts=8: 现在，输入一个制表符，你会看到，空格的数量为 8 个。 你可能已经注意到我刚才说的，这些模式行命令需要加在靠近文件的顶部或底部。如果你好奇为什么是这样，那么理由是该特性以这种方式设计的。下面这一行（来自 Vim 官方文件）将会解释清楚： “模式行不能随意放在文件中的任何位置：它需要放在文件中的前几行或最后几行。modelines 变量控制 Vim 检查模式行在文件中的确切位置。请查看 :help modelines 。默认情况下，设置为 5 行。” 下面是 :help modelines 命令（上面提到的）输出的内容： 如果 modeline 已启用并且 modelines 给出了行数，那么便在相应位置查找 set 命令。如果 modeline 禁用或 modelines 设置的行数为 0 则不查找。 尝试把模式行命令置于超出 5 行的范围（距离文件底部和顶部的距离均超过 5 行），你会发现， 制表符将会恢复为 Vim 默认数目的空格 — 在我的情况里是 4 个空格。 然而，你可以按照自己的意愿改变默认行数，只需在你的 .vimrc 文件中加入下面一行命令 1 set modelines=[新值] 比如，我把值从 5 增加到了 10 。 1 set modelines=10 这意味着，现在我可以把模式行命令置于文件前 10 行或最后 10 行的任意位置。 继续，无论何时，当你在编辑一个文件的时候，你可以输入下面的命令（在 Vim 编辑器的命令模式下输入）来查看当前与命令行相关的设置以及它们最新的设置。 1 :verbose set modeline? modelines? 比如，在我的例子中，上面的命令产生了如下所示的输出： 1234 modeline Last set from ~/.vimrcmodelines=10 Last set from ~/.vimrc 关于 Vim 的模式行特性，你还需要知道一些重要的点： 默认情况下，当 Vim 以非兼容（nocompatible）模式运行时该特性是启用的，但需要注意的是，在一些发行版中，出于安全考虑，系统的 vimrc 文件禁用了该选项。 默认情况下，当以 root 权限编辑文件时，该特性被禁用（如果你是使用 sudo 方式打开该文件，那么该特性依旧能够正常工作）。 通过 set 来设置模式行，其结束于第一个冒号，而非反斜杠。不使用 set，则后面的文本都是选项。比如，/* vim: noai:ts=4:sw=4 */ 是一个无效的模式行。 （LCTT译注：关于模式行中的 set，上述描述指的是：如果用 set 来设置，那么当发现第一个 : 时，表明选项结束，后面的 */ 之类的为了闭合注释而出现的文本均无关；而如果不用 set 来设置，那么以 vim: 起头的该行所有内容均视作选项。 ） 安全考虑 令人沮丧的是， Vim 的模式行特性可能会造成安全性问题。事实上，在过去，已经报道过多个和模式行相关的问题，包括 shell 命令注入，任意命令执行和无授权访问等。我知道，这些问题发生在很早的一些时候，现在应该已经修复好了，但是，这提醒了我们，模式行特性有可能会被黑客滥用。 结论 模式行可能是 Vim 编辑器的一个高级命令，但是它并不难理解。毫无疑问，它的学习曲线会有一些复杂，但是不需多问也知道，该特性是多么的有用。当然，出于安全考虑，在启用并使用该选项前，你需要对自己的选择进行权衡。 你有使用过模式行特性吗？你的体验是什么样的？记得在下面的评论中分享给我们。 via: https://www.howtoforge.com/tutorial/vim-modeline-settings/ 作者：Ansh译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"向 Linus Torvalds 学习让编出的代码具有 “Good Taste”","date":"2017-05-14T09:18:20.000Z","path":"2017/05/14/Linus's-Coding-Preference-of-Good-Tastes/","text":"在最近关于 Linus Torvalds 的一个采访中，这位 Linux 的创始人，在采访过程中大约 14:20 的时候，提及了关于代码的 “good taste”。good taste？采访者请他展示更多的细节，于是，Linus Torvalds 展示了一张提前准备好的插图。 他展示的是一个代码片段。但这段代码并没有 “good taste”。这是一个具有 “poor taste” 的代码片段，把它作为例子，以提供一些初步的比较。 这是一个用 C 写的函数，作用是删除链表中的一个对象，它包含有 10 行代码。 他把注意力集中在底部的 if 语句。正是这个 if 语句受到他的批判。 我暂停了这段视频，开始研究幻灯片。我发现我最近有写过和这很像的代码。Linus 不就是在说我的代码品味很差吗？我放下自傲，继续观看视频。 随后， Linus 向观众解释，正如我们所知道的，当从链表中删除一个对象时，需要考虑两种可能的情况。当所需删除的对象位于链表的表头时，删除过程和位于链表中间的情况不同。这就是这个 if 语句具有 “poor taste” 的原因。 但既然他承认考虑这两种不同的情况是必要的，那为什么像上面那样写如此糟糕呢？ 接下来，他又向观众展示了第二张幻灯片。这个幻灯片展示的是实现同样功能的一个函数，但这段代码具有 “goog taste” 。 原先的 10 行代码现在减少为 4 行。 但代码的行数并不重要，关键是 if 语句，它不见了，因为不再需要了。代码已经被重构，所以，不用管对象在列表中的位置，都可以运用同样的操作把它删除。 Linus 解释了一下新的代码，它消除了边缘情况，就是这样。然后采访转入了下一个话题。 我琢磨了一会这段代码。 Linus 是对的，的确，第二个函数更好。如果这是一个确定代码具有 “good taste” 还是 “bad taste” 的测试，那么很遗憾，我失败了。我从未想到过有可能能够去除条件语句。我写过不止一次这样的 if 语句，因为我经常使用链表。 这个例子的意义，不仅仅是教给了我们一个从链表中删除对象的更好方法，而是启发了我们去思考自己写的代码。你通过程序实现的一个简单算法，可能还有改进的空间，只是你从来没有考虑过。 以这种方式，我回去审查最近正在做的项目的代码。也许是一个巧合，刚好也是用 C 写的。 我尽最大的能力去审查代码，“good taste” 的一个基本要求是关于边缘情况的消除方法，通常我们会使用条件语句来消除边缘情况。你的测试使用的条件语句越少，你的代码就会有更好的 “taste” 。 下面，我将分享一个通过审查代码进行了改进的一个特殊例子。 这是一个关于初始化网格边缘的算法。 下面所写的是一个用来初始化网格边缘的算法，网格 grid 以一个二维数组表示：grid[行][列] 。 再次说明，这段代码的目的只是用来初始化位于 grid 边缘的点的值，所以，只需要给最上方一行、最下方一行、最左边一列以及最右边一列赋值即可。 为了完成这件事，我通过循环遍历 grid 中的每一个点，然后使用条件语句来测试该点是否位于边缘。代码看起来就是下面这样： 12345678910111213141516 for (r = 0; r &lt; GRID_SIZE; ++r) &#123; for (c = 0; c &lt; GRID_SIZE; ++c) &#123; // Top Edge if (r == 0) grid[r][c] = 0; // Left Edge if (c == 0) grid[r][c] = 0; // Right Edge if (c == GRID_SIZE - 1) grid[r][c] = 0; // Bottom Edge if (r == GRID_SIZE - 1) grid[r][c] = 0; &#125;&#125; 虽然这样做是对的，但回过头来看，这个结构存在一些问题。 复杂性 — 在双层循环里面使用 4 个条件语句似乎过于复杂。 高效性 — 假设 GRID_SIZE 的值为 64，那么这个循环需要执行 4096 次，但需要进行赋值的只有位于边缘的 256 个点。 用 Linus 的眼光来看，将会认为这段代码没有 “good taste” 。 所以，我对上面的问题进行了一下思考。经过一番思考，我把复杂度减少为包含四个条件语句的单层 for 循环。虽然只是稍微改进了一下复杂性，但在性能上也有了极大的提高，因为它只是沿着边缘的点进行了 256 次循环。 1234567891011121314 for (i = 0; i &lt; GRID_SIZE * 4; ++i) &#123; // Top Edge if (i &lt; GRID_SIZE) grid[0][i] = 0; // Right Edge else if (i &lt; GRID_SIZE * 2) grid[i - GRID_SIZE][GRID_SIZE - 1] = 0; // Left Edge else if (i &lt; GRID_SIZE * 3) grid[i - (GRID_SIZE * 2)][0] = 0; // Bottom Edge else grid[GRID_SIZE - 1][i - (GRID_SIZE * 3)] = 0;&#125; 的确是一个很大的提高。但是它看起来很丑，并不是易于阅读理解的代码。基于这一点，我并不满意。 我继续思考，是否可以进一步改进呢？事实上，答案是 YES！最后，我想出了一个非常简单且优雅的算法，老实说，我不敢相信我会花了那么长时间才发现这个算法。 下面是这段代码的最后版本。它只有一层 for 循环并且没有条件语句。另外。循环只执行了 64 次迭代，极大的改善了复杂性和高效性。 1234567891011 for (i = 0; i &lt; GRID_SIZE; ++i) &#123; // Top Edge grid[0][i] = 0; // Bottom Edge grid[GRID_SIZE - 1][i] = 0; // Left Edge grid[i][0] = 0; // Right Edge grid[i][GRID_SIZE - 1] = 0;&#125; 这段代码通过每次循环迭代来初始化四条边缘上的点。它并不复杂，而且非常高效，易于阅读。和原始的版本，甚至是第二个版本相比，都有天壤之别。 至此，我已经非常满意了。 那么，我是一个有 “good taste” 的开发者么？ 我觉得我是，但是这并不是因为我上面提供的这个例子，也不是因为我在这篇文章中没有提到的其它代码……而是因为具有 “good taste” 的编码工作远非一段代码所能代表。Linus 自己也说他所提供的这段代码不足以表达他的观点。 我明白 Linus 的意思，也明白那些具有 “good taste” 的程序员虽各有不同，但是他们都是会将他们之前开发的代码花费时间重构的人。他们明确界定了所开发的组件的边界，以及是如何与其它组件之间的交互。他们试着确保每一样工作都完美、优雅。 其结果就是类似于 Linus 的 “good taste” 的例子，或者像我的例子一样，不过是千千万万个 “good taste”。 你会让你的下个项目也具有这种 “good taste” 吗？ via: https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a 作者：Brian Barto译者：ucasFL校对：wxy 本文由 LCTT 组织编译，Linux中国 荣誉推出"},{"title":"图-Part3","date":"2017-05-11T08:50:36.000Z","path":"2017/05/11/Graph-Part3/","text":"最小生成树:克鲁斯卡尔 (Kruskal) 算法 先构造一个只含 n 个顶点的子图 SG ,然后从权值最小的边开始,若添加该边不会使得 SG 中产生回路,则在 SG上加上这条边。如此重复,直至加上 n-1条边为止。 贪心原则:根据权值,从小到大依次尝试各边。 具体描述： 设 G=(V, E) 是具有 n 个顶点的连通网,现要构造 G 的最小生成树 T=(U, TE) – 初始时: U=V , TE={}– 对 G 中的边按权值大小从小到大排序– 选取权值最小的边 (vi , vj )– 若边 (vi , vj ) 加入到 TE 后形成回路,则舍弃该边;否则,将该边并入到 TE 中,即 TE=TE ∪ {(vi , vj )}– 重复前一步骤,直到 TE 中包含有 n-1 条边为止 贪心策略 – 局部最优,但不一定能达到全局最优– 但在拟阵上实施贪心策略,就能实现最优解 算法实现的关键：回路的检测。解决办法：定义一个一维数组Vset[n]。 – 初值: vSet[i]=i ,表示每个顶点各自组成一个连通分量,连通分量的编号简单地使用顶点在图中的位置 ( 编号 )– 往 TE 中增加一条边 (vi , vj) 之前,先检查 vSet[i] 和 vSet[j] 值 若 vSet[i]=vSet[j] ,则表明 vi 和 vj 处在同一个连通分量中,加入此边会形成回路 若 vSet[i]≠vSet[j] ,则加入此边不会形成回路,故将此边加入到生成树的边集中 加入一条新边后,将两个不同的连通分量合并:将一个 连通分量的编号换成另一个连通分量的编号 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940 typedef int ElemType;typedef struct Enode&#123; int ivex , jvex; // 边所依附的两个顶点 int weight; // 边的权值&#125; ENode; // 边表元素类型定义typedef struct &#123; int vexnum , edgenum; // 顶点数和边数 ElemType vexlist[MAX_VEX]; // 顶点表 ENode edgelist[MAX_EDGE]; // 边表&#125; EGraph; // 用边表存放图typedef struct MSTEdge&#123; int vex1,vex2,weight; // 边所依附的两个顶点及权重&#125; MSTEdge; // 存放最小生成树MSTEdge *Kruskal (EGraph *g)&#123; int i,j,k,s1,s2; MSTEdge *TE; int *vSet; TE=(MSTEdge *)malloc(g-&gt;vexnum*sizeof(MSTEdge)); vSet=(int *)malloc(g-&gt;vexnum*sizeof(int)); for(i=0;i&lt;g-&gt;vexnum;i++) vSet[i]=i;// 初始化数组 vSet // 对边按权值从小到大排序 BubbleSort(g-&gt;edgelist,g-&gt;edgenum); i=0;j=0; while(i&lt;g-&gt;vexnum &amp;&amp; j&lt;g-&gt;edgenum) &#123; s1=vSet[g-&gt;edgelist[j].ivex]; s2=vSet[g-&gt;edgelist[j].jvex]; // 若边的两个顶点的连通分量编号不同 , // 则将该边加入到 TE 中 if(s1!=s2) &#123; TE[i].vex1=g-&gt;edgelist[j].ivex; TE[i].vex2=g-&gt;edgelist[j].jvex;+ TE[i].weight=g-&gt;edgelist[j].weight; i++; for(k=0;k&lt;g-&gt;vexnum;k++) if(vSet[k]==s2) vSet[k]=s1; &#125; j++; &#125; free(vSet); return TE;&#125; 算法改进： 回路检测 – 边的加入,会形成多颗树– 为每棵树各选出一个 leader– 每个顶点设指针 parent– 沿 parent 可以找到对应的 leader– leader.parent = 该子树的结点个数– 在引入新边 e =(u,v) 时:– 由 u, v 的 parent 找到并比较 leader(u) 和 leader(v)– e 的引入形成回路 iff leader(u) = leader(v) 未形成回路时的子树合并 1234 if(leader(u).parent &gt; leader(v).parent) leader(u).parent=leader(v);else leader(v).parent =leader(u) Kruskal 算法的时间复杂度 设带权连通图有 n 个顶点和 e 条边 则算法的主要执行是: – vSet 数组初始化:时间复杂度是 O(n)– 边表按权值排序:若采用堆排序或快速排序,时间复杂度是O(eloge)– 回路检测和连通分量合并 while 循环:最大执行频度是 O(n) ,其中包含修改 vSet 数组,共执行 n-1 次,时间复杂度是 O(n^2 ) 优化后,时间复杂度是 O(e) 若将生成树 T 的连通分量看成等价类,则构造 T 加入新边的过程类似求等价类 整个算法的时间复杂度是 O(eloge+n^2 ) ,优化后, Kruskal 算法的时间复杂度为 O(eloge) 独立系统和拟阵 有限集 E 的一个子集簇 F ,若具有如下的性质:对于 F 中的任一个元素 E ,当 S 是 Ei 的子集时 S 也是 F 中的元素,即 S ⊆ Ei ∈ F ==&gt; S ∈ F,则 F 称为独立系统,其元素为独立集。 — 在独立系统上定义的组合优化问题,称为最优独立集问题,例如求最小生成树,最优边无关集。 拟阵是指一个独立系统 F 满足下列可扩充条件:对任意两个独立集 I 、 I’ ,若 I’ 中的元素个数大于 I 的元素个数,则 I’ 中必存在一个不属于 I 的元素 e 使得将 e 加入 I 时,它仍是一个独立集。 贪心算法能求得最优独立集的充分必要条件是该独立系统是一个拟阵。 定理:如果 G=(V,E) 是一个无向图,则是个拟阵,其中集合为 E ,即 G 的边集,为无回路的 E 的子集。 用贪心算法求解拟阵的组合优化问题,能获得最优解。 Prim 算法和 Kruskal 算法的简单描述： Prime 算法：选定一个顶点，然后添加与它相连的最小权值边，加上新的顶点，再继续选与这两个顶点相连权值最小的边，一直进行下去，直到有 n-1 条边。 Kruskal 算法：选边，从权值最小的往上选，确保不形成回路（贪心算法）。 图的路径 关键路径 / 最长路径:有向无环带权图 /AOE 网 最短路径: 带权有向图 ( 权非负 ) ,求单源最短路径: Dijkstra 算法 带权图,求所有顶点之间的最短路径: Floyd算法 路径 对无向图 G=(V, E) ,若从顶点 vi 经过若干条边能到达 vj ,称顶点 vi 和 vj 是连通的,又称顶点 vi到 vj 有路径 对有向图 G=(V, E) ,从顶点 vi 到 vj 有有向路径,指的是从顶点 vi 经过若干条有向边 (弧) 能到达 vj 路径上边或有向边 ( 弧 ) 的数目称为该路径的长度 从顶点 vi 到 vj 的路径不唯一 两种路径表示法:边 / 弧的序列,结点序列– Path=ei0, ei1, …eim , eij属于E, j=1,2, …,m– Path=vi0, vi1, …vim , vij属于V 且 (vij-1 , vij 属于 E, j=1,2, …,m 在一条路径中,若没有重复相同的顶点,该路径称为简单路径 (simple path) 第一个顶点和最后一个顶点相同的路径称为回路 (circuit, 环 cycle) 在一个回路中,若除第一个与最后一个顶点之外,其余顶点不重复出现的回路称为简单回路。 欧拉路径 (Euler path) :若图 G 中存在这样一条简单路径,使得它恰好通过 G 中的每条边一次。 欧拉回路 (Euler circuit) :若欧拉路径的第一个顶点和最后一个顶点相同。 哈密顿路径 (Hamilton path) :通过图 G 的每个结点一次,且仅一次的简单路径。 哈密顿回路：第一个顶点和最后一个顶点相同的哈密顿路径 有向无环带权图 /AOE 网的关键路径 AOE(Activity On Edge) 网是一个顶点表示事件 (Event) 、弧表示活动(Activity) 的有向无环图, 弧上的权值表示相应活动所需的时间 (Duration) 或费用。 只有一个入度为 0 的点 ( 称为起点 ) 和一个出度为 0 的点( 称为汇点 ) 每个事件表示在其前的所有活动已经完成,其后的活动可以开始 在 AOE 网上从起点到汇点的长度最长的路径,是关键路径 (Critical Path) — 关键路径的长度表示完成整个工程所需的最短时间— 关键活动:关键路径上的活动— 关键活动若不按期完成,就会影响整个工程的完成— 非关键活动加速并不能使整个工程提前。想使整个工程提前,要考虑关键路径上的关键活动 顶点 ( 事件 ) 的最早发生时间 ve 是从起点到该顶点的最长路径长度 汇点的最早发生时间是最短工期 顶点 ( 事件 ) 的 ( 不影响工程进度的 ) 最迟发生时间 vl 是从汇点最早发生时间减去该顶点到汇点的最长路径长度。 起点的最早发生时间等于其最迟发生时间 汇点的最早发生时间等于其最迟发生时间 对弧 ( 活动 ) ,其弧头的最迟发生时间减去弧尾的最早发生时间是该活动最长可持续时间,再减去弧权,为这个弧 ( 活动 ) 允许的延时 D 。 识别关键活动： 利用拓扑排序计算图 g 的一个拓扑序列 从拓扑排序序列的第一个顶点 ( 起点 ) 开始,按拓扑顺序依次计算每个顶点 ( 事件 ) 的最早发生时间ve(i) 有向网 g 采用邻接表存储结构,若 g 无回路,则用栈 T 返回 g 的一个拓扑序列, ve 中保存各顶点事件的最早发生时间 按拓扑顺序的逆序,从最后一个顶点 ( 汇点 ) 开始,依次计算每个事件的最迟发生时间 vl(i) 找出 vl(i) - ve(i) == 0 的点 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 typedef int Status;#define OK 1#define ERROR 0Status TopologicalOrder(AGraph *g, char orderResult[],int ve[]) &#123; for(i=0;i&lt;MAX_VERTEX_NUM;i++) indegree[i]=0; FindIndegree(g,indegree); for(i=g-&gt;vexnum-1;i&gt;=0;i--) if(indegree[i]==0) &#123; // 入度为 0 者进栈 stack[top]=i; top++; &#125; for(i=0;i&lt;g-&gt;vexnum;i++) ve[i]=0; count=0; // 对输出顶点计数 while(top!=0)&#123; top--;i=stack[top]; orderResult[count]=g-&gt;v[i].vertex; count++; for(p=g-&gt;v[i].first;p;p=p-&gt;next)&#123; // 弧 ij j=p-&gt;vindex;// 对 i 号顶点的每个邻接点的入度减 1 if(--indegree[j]==0)&#123;// 若入度减为 0 ,则入栈 stack[top]=j; top++; &#125; if(ve[j]&lt;ve[i] + p-&gt;info) ve[j]=ve[i]+ p-&gt;info; &#125; &#125; if(count&lt;g-&gt;vexnum) return ERROR;// 该图有回路 else return OK; &#125;Status CriticalPath(AGraph *g) &#123; if (!TopologicalOrder(g, orderedV, ve)) return ERROR;// 初始化顶点事件的最迟发生时间 for(i=0;i&lt;g-&gt;vexnum;i++) vl[i] = ve[g-&gt;vexnum-1]; // 按拓扑逆序求各顶点的 vl 值 top=g-&gt;vexnum; while (top) for(top--,j=orderedV[top]-'A',p=g-&gt;v[j].first;p; p=p-&gt;next) &#123; k=p-&gt;vindex; dut=p-&gt;info; //dut&lt;j,k&gt; if (vl[j]&gt;vl[k]-dut) vl[j]=vl[k]-dut; &#125; for (j=0; j&lt;g-&gt;vexnum; ++j) // 求 ee, el 和关键路径 for (p=g-&gt;v[j].first; p; p=p-&gt;next)&#123; k=p-&gt;vindex; dut=p-&gt;info; ee = ve[j]; el = vl[k]-dut; tag = (ee==el) ? '*' : ' '; if(tag=='*') printf(\"%c %c \\n\",'A'+j, 'A'+k); &#125; return OK;&#125; 算法分析： 设 AOE 网有 n 个事件, e 个活动,则算法的主要执行是:– 进行拓扑排序:时间复杂度是 O(n+e)– 求每个事件的 ve 值和 vl 值:时间复杂度是 O(n+e)– 根据 ve 值和 vl 值找关键活动:时间复杂度是 O(n+e) 整个算法的时间复杂度是 O(n+e) 最短路径 边上权值非负情形的单源最短路径问题 – Dijkstra 算法 边上权值为任意值的所有顶点之间的最短路径 – Floyd 算法 Dijkstra 算法 对于给定的有向图 G=(V , E) 及单个源点 Vs求 Vs 到 G 的其余各顶点的最短路径。Dijkstra 算法按路径长度递增次序产生最短路径。 最短路径：直接从源点到该点 ( 只含一条弧 ) ; 或者是,从源点经过已求得最短路径的顶点,再到达该顶点。 就同一个起点而言,任何最短路径的前缀,也是一条最短路径。 算法思想 -Dijkstra 算法： S 是已求得最短路径的终点的集合 定义一个数组 dist[n] ,其每个 dist[i] 分量保存从源点 V0 出发中间只经过集合 S 中的顶点而到达 Vi 的所有路径中长度最小的路径长度值,换句话说, dist[] 保存了当前已求得的从源点到其余各顶点的最短路径值 – 初始状态:• 若从 V0 到顶点 Vi 有边 , 则 dist[i] 为该边的权值• 若从 V0 到顶点 Vi 无边 , 则 dist[i] 为INFINITY 下一条最短路径的终点 Vj 必定是不在 S 中且是 dist 数组值最小的顶点 算法实现： 有向图用带权的邻接矩阵表示 数组 final[n] 用于标识一个顶点是否已加入S 中。 final[v] 为 1 当且仅当 v ∈ S ,即:已经求得从 v0 到 v 的最短路径 用二维数组 P 保存从 v0 顶点到其余顶点 v 的最短路径 123456789101112131415161718192021222324252627282930313233343536 // 求有向网 G 的 v0 顶点到其余顶点 v 的最短路径 P[v][] 及其带权长度 dist[v]void ShortestPath_DIJ(MGraph *g,int v0,PathMatrix &amp;P, int dist[]) &#123; int i=0,j, v,w,min; int final[MAX_VERTEX_NUM]; for (v=0; v&lt;g-&gt;vexnum; v++) &#123;// 初始化 final[v] = 0; dist[v] = g-&gt;arcs[v0][v]; for (w=0; w&lt;g-&gt;vexnum; w++) P[v][w] = 0; // 设空路径 if (dist[v] &lt; INFINITY) &#123; P[v][v0] = 1; P[v][v] = 1; &#125; &#125; dist[v0] = 0; final[v0] = 1; // 初始化, v0 顶点属于 S 集1// 主循环:每次求得 v0 到某个 v 顶点的最短路径并加 v 到 S 集 for (i=1; i&lt;g-&gt;vexnum; i++) &#123; // 其余 g-&gt;vexnum-1 个顶点 min = INFINITY; // 当前所知离 v0 顶点的最近距离 for (w=0; w&lt; g-&gt;vexnum; w++) if (!final[w]) //w 顶点在 V-S 中 if (dist[w]&lt;min) // w 顶点离 v0 顶点更近 &#123; v = w; min = D[w]; &#125; final[v] = 1; // 离 v0 顶点最近的 v 加入 S 集 // 更新当前最短路径及距离 for (w=0; w&lt;g-&gt;vexnum; w++) if (!final[w]&amp;&amp;(min+g-&gt;arcs[v][w] &lt;dist[w])) &#123; // 修改 dist[w] 和 P[w], w ∈ V-S dist[w] = min + g-&gt;arcs[v][w];+ for(j=0;j&lt;g-&gt;vexnum;j++) P[w][j] = P[v][j]; // 第 v 行赋值于第 w 行 P[w][w] = TRUE; // P[w] = P[v]+[w] &#125;//if &#125;//for&#125; //ShortestPath_DIJ Dijkstra 算法 - 算法分析： Dijkstra 算法的主要执行是: – 数组变量的初始化:时间复杂度是 O(n)– 求最短路径的二重循环:时间复杂度是 O(n^2) 因此,整个算法的时间复杂度是 O(n^2) Floyd 算法 求得有向图 G=(V ,E) 中每一对顶点间的最短路径： 时间复杂度仍是 O(n^3 ) 允许图中有带负权值的边,但不许有包含带负权值的边组成的回路 Floyd 算法 - 算法思想: Vi 和 Vj 之间的最短路径可能是: – 不存在通路– 直接相连– 最短路径 (Vi,Vk) + (Vk,Vj) D^K (Vi,Vj) 为中途只经过前 k 个顶点的最短路径长度 D^K (Vi,Vj)= Wij, k=0=min(D k-1 (Vi,Vj),D k-1 (Vi,Vk)+D k-1 (Vk,Vj)), k&gt;=1 设顶点集 S( 初值为空 ) ,用数组 D 的每个元素D[i][j] 保存从 Vi 只经过 S 中的顶点到达 Vj 的最短路径长度,其思想是:– 初始时令 S={ } , D[i][j] 的赋初值方式是:if i ==j:D[i][j]=0 ,else if exists PATH:D[i][j]=Wij, else:D[i][j]=INFINITY – 将图中一个顶点 V k 加入到 S 中,修改 D[i][j] 的值D[i][j]=Min ({D[i][j] , (D[i][k]+D[k][j]) })– 原因:从 Vi 经过 S 中的顶点 (Vk ) 到达 V-j 的路径长度可能比原来不经过 Vk 的路径更短– 重复上一步,直到 G 的所有顶点都加入到 S 中为止 算法实现： 12345678910111213141516171819202122 // 用 Floyd 算法求有向网 G 中各对顶点 v 和 w 之间的最短路径P[v][w] 及其带权长度 D[v][w] 。若 P[v][w][u] 为 TRUE ,则 u 是从 v 到 w 当前求得最短路径上的顶点void ShortestPath_FLOYD(MGraph G, PathMatrix P[], DistancMatrix &amp;D) &#123; int v,w,u,i; // 各对结点之间初始化已知路径及距离 for (v=0; v&lt;G.vexnum; ++v) for (w=0; w&lt;G.vexnum; ++w) &#123; D[v][w] = G.arcs[v][w]; for (u=0; u&lt;G.vexnum; ++u) P[v][w][u] = FALSE; if (D[v][w] &lt; INFINITY) &#123; // 从 v 到 w 有直接路径 P[v][w][v] = P[v][w][w] = TRUE; &#125;//if &#125;//for for (u=0; u&lt;G.vexnum; ++u) for (v=0; v&lt;G.vexnum; ++v) for (w=0; w&lt;G.vexnum; ++w) if (D[v][u]+D[u][w] &lt; D[v][w]) &#123; // 从 v 经 u 到 w 的一条路径更短 D[v][w] = D[v][u]+D[u][w]; for (i=0; i&lt;G.vexnum; ++i) P[v][w][i] =(P[v][u][i] || P[u][w][i]); &#125;//if&#125; // ShortestPath_FLOYD Floyd 算法 - 算法改进: 定义二维数组 Path[n][n](n 为图的顶点数 ) ,元素Path[i][j]保存从 Vi 到 Vj 的最短路径所经过的顶点 若 Path[i][j]=k :从 Vi 到 Vj 经过 Vk ,最短路径序列是 (Vi , …, Vk , …, Vj ) ,则路径子序列: (Vi ,…, Vk ) 和 (Vk , …, Vj ) 一定是从 Vi 到 Vk 和从 Vk 到 Vj的最短路径,从而可以根据 Path[i][k] 和 Path[k][j] 的值再找到该路径上所经过的其它顶点,… 依此类推: – 初始化为 Path[i][j]=-1 ,表示从 Vi 到 Vj 不经过任何 (S 中的中间 ) 顶点。当某个顶点 Vk 加入到 S 中后使 D[i][j] 变小时,令 Path[i][j]=k"},{"title":"图-Part2","date":"2017-05-11T08:32:48.000Z","path":"2017/05/11/Graph-Part2/","text":"图的结点排序:拓扑排序 拓扑排序 (Topological Sort) :由某个集合上的一个偏序得到该集合上的一个全序的操作。 集合上的关系:集合 A 上的关系是从 A 到 A 的关系(A x A)。 自反性 对称性与非对称性 传递性 偏序是指集合中仅有部分元素之间可以比较,而全序是指集合中任意两个元素之间都可以比较。 可以用有向无环图 (Directed Acycling Graph)表示集合元素以及元素之间的关系。DAG :图中没有回路 ( 环 ) 的有向图 AOV 网 (Activity On Vertex Network) :在有向图中,用顶点表示活动,用有向边表示活动之间的优先关系。 DAG/AOV 网的拓扑排序：DAG/AOV 网的拓扑排序:构造 AOV 网中顶点的一个拓扑线性序列 (v’1 ,v’2 , ⋯ ,v’n ) ,使得该线性序列不仅保持原来有向图中顶点之间的优先关系,而且对原图中没有优先关系的顶点之间也建立一种 ( 人为的 ) 优先关系。 拓扑排序算法 在 AOV 网中选择一个没有前驱的顶点并输出 注：选择不同的顶点,会产生不同的拓扑排序结果 在 AOV 网中删除该顶点以及从该顶点出发的 ( 以该顶点为尾的弧 ) 所有有向弧 ( 边 ) 重复执行前两步,直到图中全部顶点都已输出 ( 图中无环 ) 或图中不存在无前驱的顶点 ( 图中必有环 ). 算法实现： 采用正邻接链表作为 AOV 网的存储结构 设立堆栈,用来暂存入度为 0 的顶点 ( 即无前驱顶点 ) 删除以该顶点为尾的弧:弧头顶点的入度减 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 typedef int Status;#define OK 1#define ERROR 0//结点入度值的计算和保存//方案 1 :typedef struct node &#123; int vindex; // 邻接点在头结点数组中的位置 ( 下标 ) int count; // 记录该结点的入度 struct node *next;// 指向下一个表结点&#125;NodeLink; // 表结点类型定义//方案 2 :int indegree[MAX_VERTEX_NUM]; // 存放顶点的入度void FindIndegree(AGraph *g,int indegree[MAX_VERTEX_NUM])&#123; NodeLink *p; for(int i=0;i&lt;g-&gt;vexnum;i++)&#123; p=g-&gt;v[i].first; while(p) &#123; indegree[p-&gt;vindex]++; p=p-&gt;next; &#125; &#125;&#125;//栈,用于存放零入度顶点char stack[MAX_VERTEX_NUM];int top=0;Status TopologicalSort(AGraph *g) &#123; NodeLink *p; for(i=0;i&lt;MAX_VERTEX_NUM;i++) indegree[i]=0; FindIndegree(g,indegree); for(i=g-&gt;vexnum-1;i&gt;=0;i--) //for(i=0;i&lt;g-&gt;vexnum;i++) if(indegree[i]==0) &#123; // 入度为 0 者进栈 top++; stack[top]=i; &#125; count=0; // 对输出顶点计数 while(top!=0)&#123; i=stack[top]; top--; printf(\"%c\",g-&gt;v[i].vertex); count++;+ for(p=g-&gt;v[i].first;p;p=p-&gt;next)&#123; j=p-&gt;vindex; // 对 i 号顶点的每个邻接点的入度减 1 if(--indegree[j]==0)&#123; // 若入度减为 0 ,则入栈 top++; stack[top]=j; &#125; &#125; &#125; if(count&lt;g-&gt;vexnum) return ERROR; // 该图有回路 else return OK;&#125; 拓扑排序:算法时间复杂度分析 设 AOV 网有 n 个顶点, e 条边,则算法的主要执行是:– 统计各顶点的入度:时间复杂度是 O(n+e) ;– 入度为 0 的顶点入栈:时间复杂度是 O(n) ;– 排序过程:顶点入栈和出栈操作执行 n 次,入度减 1 的操作共执行 e 次,时间复杂度是 O(n+e) ;因此,整个算法的时间复杂度是 O(n+e) 。 拓扑排序应用： 应用 1 :图的回路 ( 环 ) 的检查方法:对有向图的顶点进行拓扑排序,若所有顶点都在其拓扑有序序列中,则无环。 应用 2 :工程执行顺序 / 课程先修顺序:对 AOV 网的顶点进行拓扑排序。 图的连通性 对无向图 G=(V , E) ,若任意vi , vj 属于V , vi和 vj 都是连通的 ( 指从 vi 到 vj 有路径存在 ),则称图 G 是连通图 (connected graph) ,否则称为非连通图。 对有向图 G=(V , E) ,若任意 vi , vj 属于V ,都有以 vi 为起点, vj 为终点以及以 vj 为起点, vi 为终点的有向路径,称图 G 是强连通图(strongly connected graph) ,否则称为非强连通图。 若 G 是非连通图,则极大的连通子图称为G 的连通分量 (connected component)。若 G 是非强连通图,则极大的强连通子图称为 G 的强连通分量 (strongly connected component)“ 极大”的含义:对子图再增加图 G 中的其它顶点,子图就不再连通。极大不等于最大。 生成树：连通图的生成树是一个极小连通子图,它含有图中全部 n 个顶点和只有能构成一棵树的 n-1 条边。 生成森林：有向图的生成森林是这样一个子图,由若干棵有向树组成,含有图中全部顶点,但只有足以构成若干棵不相交有向树的弧。 有向网：带权的有向连通图。 无向网：带权的无向连通图。 重连通图：若从一个连通图中删去任何一个顶点及其相关联的边,它仍为一个连通图的话,则该连通图被称为重 ( 双 ) 连通图 (biconnected graph)。 若连通图中的某个顶点和其相关联的边被删去之后,该连通图被分割成两个或两个以上的连通分量,则称此顶点为关节点 (articulation point)/ 割点(cut point)。 没有关节点的连通图为重连通图。 无向图的连通分量 对于无向图,对其进行遍历时: 若是连通图,仅需从图中任一顶点出发,就能访问图中的所有顶点。 若是非连通图,需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是这个连通分量的顶点集。 无向非连通图的生成森林 若 G=(V,E) 是无向非连通图,那么,对图进行遍历,可得到若干个连通分量的顶点集: V1(G), V2(G),…, Vn(G) 和相应所经过的边集: T1(G), T2(G), …, Tn(G)上述顶点集和对应的边集组成的二元组 Gi=(Vi(G),Ti(G))(1 &lt;= i &lt;= n) 是对应的图的连通分量的生成树,所有这些生成树构成了原来非连通图的生成森林。 求无向非连通图的生成森林 构造无向非连通图的深度优先生成森林算法 – 修改图的深度优先遍历算法– 采用孩子兄弟链表作为生成森林的存储结构 从某个顶点出发构造图的深度优先生成树算法 – 首先从某个顶点 V 出发,建立生成树树根结点,然后再分别以 V 的邻接点为始点,建立相应的子生成树,并将其作为 V 结点的子树链接到 V 结点上。– 算法是一个递归算法。 算法实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 #define MAX_VERTEX_NUM 30typedef char ElemType;typedef struct node &#123; int vindex; // 邻接点在头结点数组中的位置 ( 下标 ) struct node *next;// 指向下一个表结点&#125;node, NodeLink; // 表结点类型定义typedef struct &#123; int vexnum,edgenum,kind; // 图的顶点数、边数、种类标志 struct &#123; ElemType vertex; NodeLink *first;// 指向第一个表结点 &#125;v[MAX_VERTEX_NUM];&#125;AGraph;typedef struct cstree &#123; ElemType data; struct CSNode *firstchild,*nextsibling;&#125;CSNode, *CSTree;CSTree DFSForest(AGraph *g) &#123; int i; CSTree p,q,t; t=NULL; for(i=0;i&lt;g-&gt;vexnum;i++) visited[i]=0; for(i=0;i&lt;g-&gt;vexnum;i++) if(!visited[i]) &#123; // 第 i 个顶点为新的生成树的根结点 p=(CSTree)malloc(sizeof(cstree)); // 分配根结点 p-&gt;data=GetVex(g,i);// 给该结点赋值 p-&gt;firstchild=NULL; p-&gt;nextsibling=NULL; if(!t) t=p; //p 是第一棵生成树的根 (t 的根 ) else // 其它生成树的根 , 成为前一棵的根的兄弟 q-&gt;nextsibling=p; q=p;//q 指示当前生成树的根 DFSTree(g,i,p);// 建立以 p 为根的生成树 &#125;//if return t;&#125; // DFSForest// 从第 x 个顶点出发递归地深度优先遍历图 G// 建立以 t 为根的生成树void DFSTree(AGraph *g,int x,CSTree t) &#123; int first=1; CSTree p,q; NodeLink *u; visited[x]=1; u=g-&gt;v[x].first; while(u)&#123; if(!visited[u-&gt;vindex])&#123; // 为 u 生成 生成树 t 的结点 p p= (CSTree)malloc(sizeof(cstree)); p-&gt;data=GetVex(g,u-&gt;vindex); p-&gt;firstchild=NULL;p-&gt;nextsibling=NULL; if(first) &#123; //u 是 x 的第一个未被访问的邻接顶点 t-&gt;firstchild = p; first=0; &#125; else &#123; //u 是 x 的其它未被访问的邻接顶点 // 那么, p 是上一邻接顶点的右兄弟结点 q-&gt;nextsibling= p; &#125; q=p; DFSTree(g,u-&gt;vindex,q); &#125; u=u-&gt;next; &#125;&#125; 有向图的强连通分量 对于有向图,在其每一个强连通分量中,任何两个顶点都是可达的。 任意V属于G ,与 V 可相互到达的所有顶点就是包含 V 的强连通分量的所有顶点。 设从 V 可到达 ( 以 V 为起点的所有有向路径的终点 ) 的顶点集合为 T1(G) ,而到达 V( 以 V 为终点的所有有向路径的起点 ) 的顶点集合为 T2(G) ,则包含 V 的强连通分量的顶点集合是: T1(G)∩T2(G) 。 求有向图 G 的强连通分量的基本步骤: 对 G 进行深度优先遍历,生成 G 的深度优先生成森林 T 对森林 T 的顶点按退出 DFS 函数的顺序进行编号 改变 G 中每一条弧的方向,构成一个新的有向图 G’ 按 (2) 中标出的顶点编号,从编号最大的顶点开始对 G’ 进行深度优先搜索,得到一棵深度优先生成树。若一次完整的搜索过程没有遍历 G’ 的所有顶点,则访问的顶点中选择一个编号最大的顶点,由它开始再进行深度优先搜索,并得到另一棵深度优先生成树。在该步骤中,每一次深度优先搜索所得到的生成树中的顶点就是 G 的一个强连通分量的所有顶点。 重复步骤 (4) ,直到 G’ 中的所有顶点都被访问。 算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //采用十字链表作为存储结构//用数组finished[n]存放顶点序列#define MAX_VERTEX_NUM 30typedef char ElemType;typedef struct ArcBox &#123; int tailvex, headvex;// 尾结点和头结点在图中的位置 //InfoType info;// 与弧相关的信息 如权值 struct ArcBox *hlink, *tlink;// 分别链接弧头相同和弧尾相同的弧&#125;ArcNode; // 弧结点typedef struct VexNode &#123; ElemType data; // 顶点信息 ArcBox *firstin, *firstout;// 分别指向该顶点第一条入弧和出弧&#125;VexNode;// 顶点结点typedef struct &#123; int vexnum, arcnum; VexNode xlist[MAX_VERTEX_NUM];&#125;OLGraph;int visited[MAX_VERTEX_NUM];int finished[MAX_VERTEX_NUM],count;void ConnectedComponent(OLGraph *g) &#123; int i,j,v,k=1; count=0; for(i=0; i&lt;g-&gt;vexnum; i++) visited[i]=0; for(i=0; i&lt;g-&gt;vexnum; i++) if (!visited[i]) DFS(g,i); // 对图 G 正向遍历 for(i=0; i&lt;g-&gt;vexnum; i++) visited[i]=0; for(j=g-&gt;vexnum-1;j&gt;=0;j--) &#123; v=finished[j]; if (!visited[v]) &#123; printf(\"\\n 第 %d 个连通分量顶点 :\", k++); ReverseDFS(g,v); // 对图 G 逆向遍历 printf(\"\\n\"); &#125; &#125;&#125;void DFS(OLGraph *g,int x) &#123;// 按弧的正向搜索 ArcBox *p; visited[x]=1; for(p=g-&gt;xlist[x].firstout; p!=NULL ; p=p-&gt;tlink) if (!visited[p-&gt;headvex]) DFS(g,p-&gt;headvex); finished[count++]=x;&#125;void ReverseDFS(OLGraph *g,int x) &#123;// 对图 G 按弧的逆向进行搜索 ArcBox *p; visited[x]=1; printf(\"%d\",x);// 输出顶点 for(p=g-&gt;xlist[x].firstin; p!=NULL;p=p-&gt;hlink) if(!visited[p-&gt;tailvex]) ReverseDFS(g,p-&gt;tailvex);&#125; 重连通图和关节点 关节点： 需借助图的深度优先生成树来分析：假设从某个顶点 V0 出发对连通图进行深度优先搜索遍历,则可得到一棵深度优先生成树,树上包含图的所有顶点。 若生成树的根结点有两个或两个以上的分支,则此顶点 ( 生成树的根 ) 必为关节点 对生成树上的任意一个内部结点 v( 非叶子结点 ) ,若其某棵子树的根或子树中的其它结点没有和 v 祖先相通的回边,则该结点 v 必为关节点。 对上述判定准则的算法表达：顶点 v 为关节点: 存在顶点 w 是生成树上顶点 v 的孩子,且 W 及其子孙均无指向 v 的祖先的回边 定义: low(v) = Min{visited[v], low[w], visited[k] } 其中 – 顶点 w 是生成树上顶点 v 的孩子– 顶点 k 是生成树上和顶点 v 由回边相联接的祖先– visited 记录深度优先遍历时的访问次序 若对顶点 v ,在生成树上存在一个子树根 w , 且 low[w] ≥ visited[v] ,则顶点 v 为关节点。 修改深度优先遍历算法: visited[v] 的值改为遍历过程中顶点的访问次序,该次序记录在 count 值中 遍历过程中,求得 low[v]=Min{visited[v],low[w],visited[k]} 从子树遍历返回时,判别 low[w] &gt;= visited[v] 123456789101112131415161718192021222324252627282930313233343536373839404142434445 //查找并输出连通图 G 上的全部关节点void FindArticul(AGraph *g) &#123; // 连通图 g 以邻接表作存储结构 // 全局变量 count 对访问计数 int v; struct ArcNode *p; // 设定邻接表上 0 号顶点为生成树的根 count=1; visited[0] = 1; // 其余顶点尚未访问 for (int i=1; i&lt;g-&gt;vexnum; ++i) visited[i] = 0; p = g-&gt;vertices[0].firstarc; if(p) &#123; v = p-&gt;adjvex;// 从第 v 顶点出发深度优先查找关节点 DFSArticul(g, v); if (count &lt; g-&gt;vexnum) &#123; // 生成树的根有至少两棵子树 // 根是关节点,输出 printf (0, g-&gt;vertices[0].data); while (p-&gt;nextarc) &#123; // 寻找还没有访问到的节点 p = p-&gt;nextarc; v = p-&gt;adjvex; if (visited[v]==0) DFSArticul(g, v); &#125;//while &#125;//if &#125;//if(p)&#125; // FindArticulvoid DFSArticul(AGraph *g, int v0 ) &#123; int min, w; struct ArcNode *p;//v0 是第 count 个访问的顶点 visited[v0] = min = ++count; for (p=g-&gt;vertices[v0].firstarc; p!=NULL;p=p-&gt;nextarc) &#123; // 检查 v0 的每个邻接顶点 w = p-&gt;adjvex; // w 为 v0 的邻接顶点 if (visited[w] == 0) &#123; // w 未曾被访问,是 v0 的孩子 DFSArticul(g, w); // 返回前求得 low[w] if (low[w] &lt; min) min = low[w]; // 从子树返回时判断 v0 是否是关节点 if (low[w] &gt;= visited[v0]) // 输出关节点 printf(v0, g-&gt;vertices[v0].data); &#125; else //w 是回边上的顶点 if (visited[w] &lt; min) //w 已被访问, w 是 v0 在生成树上的祖先 min = visited[w]; &#125;//for low[v0] = min;&#125; // DFSArticul 最小生成树 带权连通图 G 上的最小代价生成树。 覆盖 G 中的所有顶点 连通各个顶点但无环 加边的话,出现单环 删边的话,各个顶点不连通 Spanning tree 不唯一 生成树的代价:如果连通图是一个带权图,则其生成树中的边也带权,生成树中所有边的权值 ( 每条边上的权均为大于零的实数 ) 之和称为生成树的代价。– 生成树各边权重之和最小– Minimum Cost Spanning Tree 不唯一 ayley 公式: 连接 n 个互异顶点的树有 n^(n-2)棵;或等价地说, n 阶完全图 kn 有 n^(n-2) 棵生成树 构造最小生成树的基本原则: 尽可能选取权值最小的边 但不能构成回路 选择 n-1 条边 普里姆 (Prim) 算法 逐步添加结点 w , w 要满足:– 新添加的 w 和已经在生成树上的顶点 v 之间存在一条边,该边的权值在所有连通顶点 w 和 v 之间的边中取值最小; 从连通网 N=(U, E) 中找最小生成树 T=(U, TE)– 若从顶点 v0 出发构造, U={v0 } , TE={} ;– 先找权值最小的边 (u, v) ,其中 u ∈ U 且 v ∈ V-U,并且子图 (U, TE) 不构成环,则 U= U ∪ {v} , TE=TE ∪ {(u, v)} ;– 重复前一步,直到 U=V 为止,这时, TE 中必有 n-1 条边, T=(U, TE) 就是最小生成树;+ 算法实现： 设用数组 ( 邻接矩阵 ) 表示图– 若两个顶点之间不存在边,则对应的权值设为指定的最大值 所构造的最小生成树用一维数组存储其 n-1 条边 12345678910111213141516171819202122232425262728293031323334 typedef struct MSTEdge &#123; // 边所依附的图中两个顶点 int vex1, vex2; WeightType weight; // 边的权值&#125;MSTEdge;struct &#123; int adjvex; // 边所依附于 U 中的顶点 int lowcost ; // 该边的权值&#125; closedge[MAX_VERTEX_NUM];//用 Prim 算法从第 u 个顶点出发构造网 G的最小生成树 T ,输出 T 的各条边void MiniSpanTree_PRIM(MGraph G, VertexType u)&#123; int i,j,k; k= LocateVex(G, u); for (j=0; j&lt;G.vexnum; ++j ) &#123; // 辅助数组初始化 if (j!=k) &#123; closedge[j].adjvex=u; closedge[j].lowcost=G.arcs[k][j].adj; &#125; &#125; closedge[k].lowcost = 0; // 初始, U = &#123;u&#125; for (i=1; i&lt;G.vexnum; ++i) &#123; // 选择其余 G.vexnum-1 个顶点添加到生成树上 // 求出加入 T 的下一个结点:第 k 顶点 k = minimum(closedge); // 输出生成树的边,或者保存到 MSTEdge 数组中 printf(closedge[k].adjvex, G.vexs[k]); closedge[k].lowcost = 0; // 第 k 顶点并入 U 集+ for (j=0; j&lt;G.vexnum; ++j) if (G.arcs[k][j].adj &lt; closedge[j].lowcost) &#123; // 修改其它顶点的最小边 closedge[j].adjvex=G.vexs[k]; closedge[j].lowcost=G.arcs[k][j].adj; &#125; &#125;&#125; // MiniSpanTree Prim 算法的时间复杂度分析: 设带权连通图有 n 个顶点,则算法的主要执行是二重循环:– 求 closedge 中权值最小的边,频度为 n-1– 修改 closedge 数组,频度为 n 因此,整个算法的时间复杂度是 O(n^2 ) ,与边的数目无关。"},{"title":"图-Part1","date":"2017-05-11T08:07:46.000Z","path":"2017/05/11/Graph-Part1/","text":"图 线性结构: 除第一个和最后一个元素外,任何一个元素都有唯一的一个直接前驱和直接后继。 非线性结构： 树结构:每个元素对下 ( 层 ) 可以有 0 个或多个元素相联系,对上 (层) 只有唯一的一个元素相关,数据元素之间有明显的层次关系 图结构:任意两个元素之间可能存在关系,图中任意元素之间都可能相关;结点之间的关系可以是任意的 图的术语 顶点、弧、 子图 (subgraph) 和生成子图 (spanning subgraph) 设有图 G=(V, E) 和 G’=(V’, E’) ,若 V’&lt;=V 且 E’&lt;=E ,则称图 G’ 是 G 的子图;若 V’=V 且 E’&lt;=E ,则称图 G’ 是 G 的一个生成子图。 简单图 (simple graph) :每条边连接两个不同的顶点且没有两条不同的边连接一对相同顶点的图 完全图 (complete graph) :在每对不同顶点之间恰好有一条边的简单图 多重图 (multigraph) :有多重边连接到同一对顶点的图 有向图：顶点之间的弧有序 无向图：顶点之间的弧无序 稀疏图 (sparse graph) :有很少边或弧的图 (e&lt;n log n) 的图,反之称为稠密图 (dense graph) 对于无向图,若图中顶点数为 n ,用 e 表示边的数目,则 e 的范围[0 , n(n-1)/2] 完全图:具有 n(n-1)/2 条边的无向图 对于有向图,若图中顶点数为 n ,用 e 表示弧的数目,则 e的范围[0 , n(n-1)] 完全图:具有 n(n-1) 条边的有向图 权重：与图的边 / 弧相关的数 带权图或网 (network) :图上每个边 ( 或弧 ) 都附加一个权值图的度 对于无向图 G=(V, E) : 若边 (v,w)属于E ,则称顶点 v 和 w 互为邻接点,即 v 和 w 相邻 (adjacent) ,而边 (v,w) 依附于 (incident) 顶点 v 和 w for any vi&lt;V ,依附于 vi 的边的数目称为顶点 vi 的度(degree) ,记为 TD(vi) 握手定理:/Handshaking theorem :所有顶点的度的和是图中边的 2 倍 定理:在任何图中,所有度数之和必为偶数 ,度数为奇数的结点必定是偶数个 推论:若图G有 n 个顶点, n+1 条边,则G中至少有一个结点的度数大于 3 。 对于有向图 G=(V, E) : 若有向弧 属于 E ,则称:顶点 v 邻接到顶点 w ,顶点 w 邻接自顶点 v ,弧 与顶点 v 、 w 相关联 以 vi 作为起点的有向边 ( 弧 ) 的数目称为顶点 vi 的出度 (outdegree) ,记为 OD(vi) 以 vi 作为终点的有向边 ( 弧 ) 的数目称为顶点 vi 的入度 (indegree) ,记为 ID(vi) 顶点 vi 的出度与入度之和称为 vi 的度,记为 TD(vi) , 即, TD(vi)=OD(vi)+ID(vi) 定理:所有顶点的度的和是图中边的 2 倍 定理:在任何有向图中,所有结点的入度之和等于所有结点的出度之和 图的存储结构 数组（邻接矩阵）表示法 对于有 n 个顶点的图: 用一维数组 vexs[n] 存储顶点信息 用二维数组 A[n][n] 存储顶点之间关系的信息 无向图:无权图的数组表示 如果vi, vj 有边，则 A[i][j] = 1; 否则 A[i][j] = 0 无向图:带权图的数组表示: 若 vi, vj 相邻，权值为Wij, 则 A[i][j] = Wij 否则，A[i][j] = infinity 无向图的邻接矩阵是 n 阶对称方阵; 对于顶点 vi ,其度数是第 i 行的非 0 元素的个数 无向图的边数是上 ( 或下 ) 三角形矩阵中非 0 元素个数 有向图:无权图的邻接矩阵表示: 若从 vi 到 vj 有弧，则 A[i][j] = 1;否则, A[i][j] = 0; 有向图:带权图的邻接矩阵表示: 若 vi, vj 之间有弧，权值为 Wij, 则 A[i][j] == Wij否则，A[i][j] = infinity 图的数组表示： 123456789101112131415161718 // 图的种类: UDG 无向图, DG 有向图, UDN 无向网, DN 有向网typedef enum &#123;UDG, DG, UDN, DN&#125; GraphKind;typedef struct ArcCell &#123; VRType adj; // 顶点关系类型: w/1/0 InfoType *info;&#125;ArcCell, AdjMatrix[MaxVertexNum][MaxVertexNum]typedef struct&#123; VertexType vexs[MaxVertexNum]; // 顶点向量 AdjMatrix arcs; // 邻接矩阵 int vernum,arcnum; // 图的顶点数和弧数 GraphKind kind;&#125;MGraph;typedef struct&#123; int vexnum,arcnum; // 顶点数,边数, GraphKind kind; // 图的种类 char vexs[Max]; // 存放顶点信息 int A[Max][Max];// 存放边的信息&#125;MGraph; 采用数组构造无向图： 12345678910111213141516171819 void CreateGraph(MGraph *g) &#123; int i,j,k; printf(\"Input: Vex Num &amp; Arc Num &amp; Arc Kind\\n\"); scanf(\"%d %d %d\",&amp;g-&gt;vexnum,&amp;g-&gt;arcnum,&amp;k); switch (k) &#123; case 0: g-&gt;kind=UDG;break; case 1: g-&gt;kind=DG;break; &#125; for(k=0;k&lt;g-&gt;vexnum;k++) g-&gt;vexs[k]='A'+k; for(i=0;i&lt;g-&gt;vexnum;i++) for(j=0;j&lt;g-&gt;vexnum;j++) g-&gt;A[i][j] = 0; // 初始化邻接矩阵 printf(\"Input: %d edges: \\n\",g-&gt;arcnum); for(k=0;k&lt;g-&gt;arcnum;k++)&#123; scanf(\"%d %d\",&amp;i,&amp;j); g-&gt;A[i][j]=1; if(g-&gt;kind==UDG) g-&gt;A[j][i]=1; // 无向图时,邻接矩阵是对称的 &#125; &#125; 输出无向图： 123456789 void ListGraph(MGraph *g)&#123; int i,j; for(i=0;i&lt;g-&gt;vexnum;i++) &#123; printf(\"%6c---\",g-&gt;vexs[i]); for(j=0;j&lt;g-&gt;vexnum;j++) printf(\"%4d\",g-&gt;A[i][j]); printf(\"\\n\"); &#125;&#125; 邻接表 (Adjacency List) 法 对图的每个顶点建立一个单链表:第 i 个单链表表示依附于顶点 Vi 的边 ( 对有向图是以顶点 Vi 为尾的弧 ). 链表中的结点称为表结点。 邻接点域 (adjvex) 指示与顶点 Vi 邻接的顶点在图中的位置 ( 顶点编号 ) 数据域 (info) 存储和边或弧相关的信息如权值等 链域 (nextarc) 指向下一个与顶点 Vi 邻接的表结点 每一个单链表设一个表头结点 数据域 (data) 存储顶点名或其他信息,链域 (firstarc) 指向链表中的一个结点; 所有表头结点用一个向量以顺序结构形式存储,以便随机访问任意顶点的链表:表头向量的下标指示顶点的序号; 有向图：正临接表（出度直观）；逆临接表（入度直观） 临接表的特点： 表头向量中每个分量就是一个单链表的表头结点,分量个数就是图中的顶点数目 在邻接表上容易找出任一顶点的第一个邻接点和下一个邻接点 在无向图,顶点 Vi 的度是第 i 个链表的结点数 对有向图,可以建立 ( 正 ) 邻接表或逆邻接表 在有向图中,第 i 个链表中的结点数是顶点 Vi的出 ( 或入 ) 度;求入 ( 或出 ) 度,须遍历整个邻接表 在边或弧稀疏的条件下,用邻接表表示比用邻接矩阵表示节省存储空间 临接表的实现： 1234567891011121314 #define MAX_VERTEX_NUM 30typedef char ElemType;typedef struct NodeLink &#123; int vindex; // 邻接点在头结点数组中的位置 ( 下标 ) struct NodeLink *next;//一个表结点&#125; NodeLink; // 表结点类型定义typedef struct &#123; // 图的顶点数、边数、种类标志 int vexnum,edgenum,kind; struct &#123; ElemType vertex; NodeLink *first;// 指向第一个表结点 &#125;v[MAX_VERTEX_NUM];&#125;AGraph; 采用临接表构造无向图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 void CreateGraph(AGraph *g,int n,int m)&#123; int i, e = 0; NodeLink *p, *q, *s; char x, y; g-&gt;vexnum = n; g-&gt;kind = m; for(i=0;i&lt;n;i++) &#123;// 初始化邻接表 g-&gt;v[i].vertex = 'A'+i; g-&gt;v[i].first=NULL; &#125; printf(\"Input edges x--&gt;y:\"); scanf(\"%c%c\",&amp;x,&amp;y); while(x!='X' &amp;&amp; y!='X')&#123; //生成节点并插入临接表 e++; s=(NodeLink *)malloc(sizeof(NodeLink)); s-&gt;vindex= y-'A'; if(g-&gt;v[x-'A'].first == NULL) &#123; g-&gt;v[x-'A'].first =s; s-&gt;next = NULL; &#125; else&#123; p=g-&gt;v[x-'A'].first; q=p-&gt;next; while (q!=NULL)&#123; p=q;q=q-&gt;next; &#125; p-&gt;next=s;s-&gt;next=q; &#125; if(!g-&gt;kind)&#123; // 无向图 s=(NodeLink *)malloc(sizeof(NodeLink)); s-&gt;vindex = x-'A'; if(g-&gt;v[y-'A'].first == NULL) &#123; g-&gt;v[y-'A'].first =s; s-&gt;next = NULL; &#125; else&#123; p=g-&gt;v[y-'A'].first; q=p-&gt;next;+ while(q!=NULL) &#123; p=q;q=q-&gt;next; &#125; p-&gt;next =s;s-&gt;next=q; &#125; &#125; scanf(\" %c%c\",&amp;x,&amp;y); &#125; g-&gt;edgenum =e;&#125; 输出无向图： 12345678910111213 void ListGraph(AGraph *g) &#123; int i; NodeLink *p; for(i=0;i&lt;g-&gt;vexnum;i++)&#123; printf(\"%d:%c---&gt;\",i,g-&gt;v[i].vertex); p=g-&gt;v[i].first; while(p) &#123; printf(\"%3d\",p-&gt;vindex); p=p-&gt;next; &#125; printf(\"\\n\"); &#125;&#125; 图的顶点定位： 1234567 // 确定一个顶点在 v 数组中的位置int LocateVex(AGraph *g,ElemType u)&#123; int k; for(k=0;k&lt;g-&gt;vexnum;k++) if (g-&gt;v[k].vertex == u) return k; return -1; // 图中无此顶点&#125; 十字链表 每个顶点对应一个结点:每条弧的弧头结点和弧尾结点都存放在链表中。 每条弧对应一个结点。 从一个顶点结点的 firstout 出发,沿表结点的 tlink 指针构成了正邻接表的链表结构。+ 从一个顶点结点的 firstin 出发,沿表结点的hlink 指针构成了逆邻接表的链表结构。 十字链表的实现： 1234567891011121314 #define MAX_VERTEX_NUM 30 // 最大顶点数typedef char ElemType;typedef struct ArcBox &#123; int tailvex, headvex;// 尾结点和头结点在图中的位置 //InfoType info; // 与弧相关的信息 如权值 struct ArcBox *hlink, *tlink; // 分别链接弧头相同和弧尾相同的弧&#125;ArcNode; // 弧结点typedef struct VexNode &#123; ElemType data; // 顶点信息+ ArcBox *firstin, *firstout; // 分别指向该顶点第一条入弧和出弧&#125;VexNode;// 顶点结点typedef struct &#123;int vexnum, arcnum; VexNode xlist[MAX_VERTEX_NUM];&#125;OLGraph; 采用十字链表构造有向图： 1234567891011121314151617181920 void CreateGraph(OLGraph *g) &#123; // G.kind = DG int i,j,k; char v1,v2; struct ArcBox *p; scanf(\"%d %d\",&amp;g-&gt;vexnum, &amp;g-&gt;arcnum); for(i=0; i&lt;g-&gt;vexnum; ++i) &#123; // 构造表头向量 g-&gt;xlist[i].data='A'+i; // 设置顶点值 g-&gt;xlist[i].firstin = g-&gt;xlist[i].firstout = NULL; &#125; for(k=0; k&lt;g-&gt;arcnum; ++k) &#123; // 输入各弧并构造十字链表 scanf(\" %c%c\",&amp;v1, &amp;v2); // 输入一条弧的始点和终点 i=LocateVex(g,v1); j=LocateVex(g,v2); // 确定 v1 和 v2 在 g 中位置 p=(ArcBox *) malloc (sizeof (ArcBox)); // 假定有足够空间 p-&gt;tailvex=i; p-&gt;headvex=j; p-&gt;hlink=g-&gt;xlist[j].firstin; p-&gt;tlink=g-&gt;xlist[j].firstout; g-&gt;xlist[j].firstin = g-&gt;xlist[i].firstout = p; // 在入弧和出弧链头插入 &#125; return;&#125; 临接多重表 邻接多重表:用于表示无向图 每个顶点用一个顶点结点表示: data 域:存储和顶点相关的信息;firstedge 域:指向依附于该顶点的第一条边所对应的表结点; 每条边用一个边结点表示; mark 域:用以标识该条边是否被访问过;ivex 和 jvex 域:分别保存该边所依附的两个顶点在图中的位置;info 域:保存该边的相关信息;ilink 域:指向下一条依附于顶点 ivex 的边;jlink 域:指向下一条依附于顶点 jvex 的边; 邻接多重表与邻接表的区别： 邻接表的同一条边用两个结点表示,而邻接多重表只用一个结点表示。 邻接多重表能较方便地完成对边的操作:– 标记已被搜索的边– 删除一条边 除标志域外,邻接多重表与邻接表表达的信息是相同的,因此,操作的实现也基本相似。 临接多重表的定义： 1234567891011121314151617 #define MAX_VERTEX_NUM 30 // 最大顶点数typedef emnu &#123;unvisited , visited&#125; VisitIf;typedef struct Ebox &#123; VisitIf mark; // 访问标记 int ivex, jvex; // 该边依附的两个结点在图中的位置 // 分别指向依附于这两个顶点的下一条边 struct EBox *ilink, *jlink; InfoType info ;// 与边相关的信息 , 如权值&#125;EBox ; // 弧边结点typedef struct VexBox &#123; VertexType data; // 顶点信息 EBox *firsedge ; // 指向依附于该顶点的第一条边&#125;VerBox; // 顶点结点typedef struct &#123; int vexnum,edgenum; // 无向图的顶点数和边数 VerBox adjmulist[MAX_VERTEX_NUM];&#125;AMGraph ; 图的遍历 从图的某一顶点出发,访遍图中的其余顶点,且每个顶点仅被访问一次。 复杂性:图的任意顶点可能和其余的顶点相邻接,可能在访问了某个顶点后,沿某条路径搜索后又回到原顶点。解决办法:在遍历过程中记下已被访问过的顶点,即:设置一个辅助向量 Visited1…n ,其初值为 0 ,一旦访问了顶点 vi 后,设置 Visited[i] 为 1 或为访问的次序号。 算法:– 深度优先搜索算法和广度优先搜索算法– 采用的数据结构是 ( 正 ) 邻接链表 深度优先搜索 (Depth First Search, DFS) 设初始状态时图中的所有顶点均未被访问 从图中某个顶点 V0 出发,访问此顶点,然后依次从 V0 的未被访问的邻接点出发深度优先遍历图,直至图中所有和 V0 有路径相通的顶点都被访问到; 若图中尚有顶点未被访问,则选一个未曾被访问的顶点作为起点,重复上述过程,直到图中所有顶点都被访问到为止。 DFS 递归实现： 1234567891011121314151617181920212223242526 //递归实现１int visited[MAX_VERTEX_NUM]; // 访问标志数组Status (* VisitFunc)(int v); // 函数变量// 从第 x 个顶点出发递归地深度优先遍历图 gvoid DFS(AGraph *g,int x) &#123; NodeLink *p; visited[x]=1; printf(\"%3c\",g-&gt;v[x].vertex);//VisitFunc(v); // 访问第 v 个顶点 p=g-&gt;v[x].first; while(p)&#123; if(!visited[p-&gt;vindex]) // 对 x 的尚未访问的邻接顶点 DFS(g,p-&gt;vindex); p=p-&gt;next; &#125;&#125;//递归实现２// 对图 G 作深度优先遍历，时间复杂度 O(n+e)int visited[MAX_VERTEX_NUM]; // 访问标志数组void DFSGraph(AGraph *g)&#123; int i; for(i=0;i&lt;g-&gt;vexnum;i++) visited[i]=0; // 访问标志数组初始化 for(i=0;i&lt;g-&gt;vexnum;i++) if(!visited[i]) DFS(g,i);&#125; 广度优先搜索 (Breadth First Search, BFS) 设初始状态时图中的所有顶点均未被访问 从图中的某个顶点 V0 出发,并在访问此顶点之后依次访问 V0 的所有未被访问过的邻接点,之后按这些顶点被访问的先后次序依次访问它们的邻接点,直至图中所有和V0 有路径相通的顶点都被访问到 若图中尚有顶点未被访问,则选一个未曾被访问的顶点作为起点,重复上述过程,直到图中所有顶点都被访问到为止 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 //BFS 非递归实现，伪代码void BFSTraverse(Graph G, Status (*Visit)(int v )) &#123; // 使用辅助队列 Q ,保存已访问过的顶点 // 使用访问标志数组 visited ,用于标记图中顶点是否被访问过 QElemType v,w; queue Q; QElemType u; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; InitQueue(Q); // 置空的辅助队列 Q for (v=0; v&lt;G.vexnum; ++v)&#123; if (!visited[v]) &#123;// v 尚未访问 visited[v] = TRUE; Visit(v); // 访问 v EnQueue(Q, v); // v 入队列 while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); // 队头元素出队并置为 u for (w=FirstAdjVex(G, u); w&gt;=0; w=NextAdjVex(G, u, w)) if (!visited[w]) &#123;// u 的尚未访问的邻接顶点 w 入队列 Q visited[w] = TRUE; Visit(w); EnQueue(Q, w); &#125;//if &#125;//while &#125;//if &#125;//&#125; //时间复杂度 O(n+e)//另一种非递归实现void BFS(AGraph *g,int x) &#123; // 用一个数组 q 作辅助队列 , q[0..front) 存放的是访问过的顶点 // q[front..rear) 存放的是已访问顶点的相邻点,是马上要访问的顶点 int q[MAX_VERTEX_NUM],front,rear,i; NodeLink *p; front=rear=0; q[rear++]=x; while(front != rear) &#123;// 顶点出队列,并访问它 x=q[front++]; printf(\"%c-&gt;\",g-&gt;v[x].vertex); visited[x]=1; p=g-&gt;v[x].first; while(p!=NULL)&#123; for(i=0;i&lt;rear;i++) // 判邻接点是否在数组 q 中 if(p-&gt;vindex == q[i]) break; if(i &gt;=rear)// 邻接点未被访问且不在队列中,则入队列 q[rear++]=p-&gt;vindex; p=p-&gt;next; // 找 x 的下一个邻接点 &#125; &#125;&#125;//递归实现void BFSGraph(AGraph *g)&#123; int i; for(i=0;i&lt;g-&gt;vexnum;i++) visited[i]=0; for(i=0;i&lt;g-&gt;vexnum;i++) if(!visited[i]) BFS(g,i);&#125; 图遍历的应用 连通图的生成树: DFS/BFS 非连通图的生成森林: DFS/BFS 重连通图 / 连通图关节点的判定: DFS 图的连通性检测: DFS/BFS 无向图的环路检测: DFS/BFS 有向图的环路检测: DFS 顶点之间的可达性检测: DFS/BFS 顶点之间的路径求解: DFS/BFS 顶点之间的最短距离: BFS 欧拉回路: DFS 拓扑排序: DFS"},{"title":"树-Part2","date":"2017-05-06T07:52:46.000Z","path":"2017/05/06/Tree-Part2/","text":"树与森林 树的三种存储表示方法： 双亲表示法：顺序存储，设置一个指示器指示双亲位置。 123456789 #define MAX_TREE_SIZE 100typedef struct PTNode&#123;//节点结构 TElemType data; int parent;//双亲位置域&#125;PTNode;typedef struct&#123; PTNode nodes[MAX_TREE_SIZE]; int r, n; //根的位置和节点数&#125;PTree; 孩子表示法：把每个节点的孩子节点排列起来，看成一个线性表，且以单链表做存储结构。则 n 个节点有 n 个孩子链表，n 个头指针又组成一个线性表。 123456789101112 typedef struct CTNode&#123; int child; struct CTNode *next;&#125;*ChildPtr, CTNode;typedef struct&#123; TElemType data;+ ChildPtr firstchild; //孩子链表头指针&#125;CTBox;typedef struct&#123; CTBox nodes[MAX_TREE_SIZE]; int n, r;&#125;CTree; 孩子兄弟表示法： firstChild 指向该结点的第一个子女结点。无序树时,可任意指定一个结点为第一个女。 nextSibling 指向该结点的下一个兄弟。任一结点在存储时总是有顺序的。若想找某结点的所有子女,可先找 firstChild, 再反复用 nextSibling 沿链扫描。 1234 typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild, *nextsibling;&#125; CSNode, *CSTree; 由于二叉树和树都可以用二叉链表作为存储结构,则以二叉链表作为媒介可导出树与二叉树之间的一个对应。给定一棵树,可以找到唯一的一棵二叉树与之对应。从物理上看,他们的二叉链表是相同的,只是解释不同。 从树的二叉链表表示的定义可知,任何一棵和树 对应的二叉树,其右子树必空 。 若把森林中第二棵树的根结点看作是第一棵树的根结点的兄弟,则同样可以导出二叉树的对应关系。由此即得森林转化为二叉树的算法。 和树对应的二叉树,其左、右子树的概念已改变为:左是孩子,右是兄弟 。 树和森林的遍历： 深度优先遍历 先根次序遍历：对应二叉树的先序遍历 后根次序遍历：对应二叉树的中序遍历 广度优先遍历 树与等价关系： 等价关系： 自反性 传递性 对称性 划分等价类： 令 S 中每个元素各自形成一个只含单个元素的子集,记为 S1 ,…, Sn。 依次扫描 m 个偶对,对每个扫描的偶对( x , y ),判定 x 和 y 所属的子集。假设 x∈Si , y∈Sj ,若 Si≠Sj ,则将 Si并入 Sj 并置 Si 为空(或将 Sj 并入 Si 并置 Sj 为空)。当 m 个偶对都被处理后,S1 , S2 ,… ,Sn 中所有非空子集即为 S 的 R 等价类。 1234567891011121314151617 //采用树的双亲表示法作为存储结构typedef PTree MFSet; //PTree 的定义见上面定义//查找函数int find_mfset(MFSet S, int i)&#123; if( i &lt; 1 || i &gt; S.n) return -1; for(j = i; S.nodes[j].parent &gt; 0; j = S.node.parent); return j;&#125;//find_mfset//归并函数Status merge_mfset(MFSet *S, int i, int j)&#123; //求并集 Si 并 Sj //S-&gt;node[i]和S-&gt;node[j]为两个不相交的子集 Si, Sj 的根节点 if( i &lt; 1 || i &gt; S-&gt;n || j &lt; 1 || j &gt; S-&gt;n) return ERROR; S-&gt;node[i]-&gt;parent = j;&#125; merge 算法改进：令成员少的指向成员多的，同时，需修改存储结构，令根节点的 parent 域存储子集中所含成员数目的负值。 1234567891011121314 void mix_mfset(MFset *S, int i, int j)&#123; if(i &lt; 1|| i &gt; S-&gt;n || j &lt; 1 || j &gt; S-&gt;n) return ERROR; if(S-&gt;node[i]-&gt;parent &gt; S-&gt;node[j]-&gt;parent)&#123; //Si 的成员比 Sj 少 S-&gt;node[j]-&gt;parent += S-&gt;node[i]-&gt;parent;+ S-&gt;node[i]-&gt;parent = j; &#125; else&#123; S-&gt;node[i]-&gt;parent += S-&gt;node[j]-&gt;parent; S-&gt;node[j]-&gt;parent = i; &#125; return OK;&#125;//mix_mfset 随着子集的依次合并,树的深度不断增大。为改善此种情况,当所需确定的元素 i 不在树的第二层时,可通过 “ 压缩路径 “ 功能缩短元素到达根结点的路径。 123456789 int fix_mfset(MFSet *S, int i)&#123; //确定 i 所在子集,将从 i 至根路径上所有结点变为根的孩子结点 if(i&lt;1 || i&gt;S.n)return-1; //i 不是 S 中的任何子集的元素 for(j=i ; S-&gt;nodes[j]-&gt;parent&gt;0 ; j=S-&gt;nodes[j]-&gt;parent); for(k=i;k !=j;k=t)&#123; t=S-&gt;nodes [ k ]-&gt;parent; S-&gt;nodes [ k ]-&gt;parent=j; &#125; return j;&#125; 哈夫曼树与哈夫曼编码 最优树的定义： 结点的路径长度定义为: 从根结点到该结点的路径上分支的数目。 树的路径长度定义为: 树中每个结点的路径长度之和。 完全 二叉树是 路径长度最短的 二叉树。 结点的带权路径长度定义为:从根结点到该结点的路径长度与该结点的权的乘积。 树的带权路径长度定义为:树中所有叶子结点的带权路径长度之和（WPL） 最优二叉树 (哈夫曼树)定义为: 假设有 n 个权子 {w1 , w2 , ….wn } ,构造一棵有 n 个叶子 结点的 二叉树,每个叶子结点带权 wi , 则其中带权路径长度 WPL 值最小的 二叉树为最优二叉树。在 Huffman 树中,权值大的结点离根最近。 Huffman 树的构造算法(贪心算法) 根据给定的 n 个权值（w1, w2, …, wn）构成 n 棵二叉树的集合 F = {T1, T2, …, Tn}，其中每棵二叉树 Ti 中只有一个带权为 wi 的根节点，其左右子树均为空。 在 F 中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树的根节点的权值之和。 在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。 重复上两个步骤，直到 F 中只含一棵树，该树便为 Huffman 树。 贪心算法： 贪心算法(又称贪婪算法)是指,在对问题求解时,总是做出在当前看来是最好的选择。也就是说,不从整体最优上加以考虑,他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解,但对相当广范围的 许多问题是能产生整体最优解的,或者是整体最优解的近似解。 正则二叉树：哈夫曼树中没有度为 1 的结点,树中任意非叶子结点都有 2 个儿子,这类树又称为正则二叉树。 一棵有 n 个叶子结点的哈夫曼树共有 2n-1 个结点 。 显然：除最下面那棵树以外每一个叶子对应一个根节点，所有 N = n + n - 1 = 2n - 1;Huffman 编码 前缀编码；任意一个字符的编码都不是其他字符编码的前缀。 主要用途是实现数据压缩,实现数据的无损压缩。 利用二叉树可以构造一种不等长的二进制编码,而且得到的必为二进制前缀编码。如下图： A(0), B(10), C(110), D(111) 构造以出现频率为权值的哈夫曼树,就能得到相应的哈夫曼编码,这是一种最优前缀编码,即使所传电文的总长度最短。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 typedef struct &#123; unsigned int weight; unsigned int parent, lchild, rchild;&#125; HTNode, *HuffmanTree;typedef char **HuffmanCode;//求Huffman编码算法void HuffmanCoding(HuffmanTree *HT, HuffmanCode *HC, int *w, int n) &#123; //W 存放 n 个字符的权值，构造 Huffman 树 HT, 并求出 n 个字符的 Huffman 编码 HC m = 2*n-1; HT = (HuffmanTree )malloc((m+1)*sizeof(HTNode)); for (p=HT, i=1; i&lt;=n; ++i, ++p, ++w) *p=&#123;*w, 0, 0, 0); for (; i&lt;=m; ++i, ++p)//建树 *p = &#123;0, 0, 0, 0); for (i=n+1; i&lt;=m; ++i)&#123; Select(HT, i-1, s1, s2); HT[s1]-&gt;parent = I; HT[s2]-&gt;parent = I; HT[i]-&gt;lchild = s1; HT[i]-&gt;rchild = S2; HT[i]-&gt;weight = HT[s1]-&gt;weight+HT[s2]-&gt;weight; &#125; //从叶子到 根逆向求 每个 字符的哈夫曼编码 HC= ( HuffmanCode ) malloc( (n+1)*sizeof(char *));//分配n个字符编码的头指针向量 char *cd = (char *)mallco (n *sizeof(char));//分配求编码工作空间 cd[n-1] = “\\0”; for (i=1; i&lt;=n; ++i)&#123; int start = n-1; for (int c= i, int f=HT[i]-&gt;parent; f!=0; c=f, f=HT[f]-&gt;parent) if (HT[f]-&gt;lchild == c) cd[--start] = “0”; else cd[--start] = “1”; HC[i] = (char *)malloc((n-start)*sizeof(char)); strcpy(HC[i], &amp;cd[stat]); &#125; free(cd);&#125;//HuffmanCoding//-------- 无栈 非递归 遍历哈夫曼树,求哈夫曼编码 -------- HC= ( HuffmanCode ) malloc( (n+1)*sizeof(char *)); int p = m; int cdlen = 0; for ( int i=1 ; i&lt;=m ; ++i ) HT[i]-&gt;weight = 0; while (p) &#123; if (HT[p]-&gt;weight ==0)&#123; HP[p]-&gt;weight = 1; if (HP[p]-&gt;lchild != 0)&#123;p = HT[p]-&gt;lchild; cd[cdlen++] = “0”;&#125; else if (HT[p]-&gt;rchild == 0)&#123; HC[p] = (char *)malloc((cdlen+1)*sizeof(char)); cd[cdlen] = “\\0”; strcpy(HC[p], cd); &#125; &#125; else if (HT[p]-&gt;weight == 1)&#123; HT[p]-&gt;weight = 2; if (HT[p]-&gt;rchild != 0)&#123; p = HT[p]-&gt;rchild; cd[cdlen++] = “1”; &#125; &#125; else &#123; HT[p]-&gt;weight = 0; p = HT[p]-&gt;parent; --cdlen; &#125;//else &#125;//while 回溯法与树的遍历 回溯法是一种“穷举”方法 , 也叫试探法。它是一种系统地搜索问题的解的方法。 用回溯算法解决问题的一般步骤: 针对所所给问题,定义问题的解空间,它至少包含问题的一个(最优)解。 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。 以深度优先的方式搜索解空间,并且在搜索过程中用约束函数剪枝解空间,避免无效搜索。 树的计数 二叉树计数：讨论有 n 个节点，互不相似的二叉树的数目。 卡特兰数： S(n) = 1/(n+1)C(2n,n)(见组合数学)即 n 个节点对应 1/(n+1)C(2n,n) 棵不同的二叉树。C(2n,n)为 2n 个不同数中选 n 个的组合数。"},{"title":"树-Part1","date":"2017-05-06T07:01:22.000Z","path":"2017/05/06/Tree-Part1/","text":"树的定义 树 (tree) 是一个 n(n&gt;=0) 个结点的有限集。 在一棵非空树中：(1) 有且仅有 一个的称为根 (root) 的结点；(2) 当 n&gt;1 时,其余结点可分为 m (m&gt;0)个互不相交的有限集 T_1 , T_2 , …, T_m. 树的基本术语： 结点:数据元素 + 若干指向子树的分支 结点的度:结点拥有的子树个数 树的度:树中所有结点的度的最大值 叶子结点:度为零的结点 分支结点:度大于零的结点 孩子:若结点的子树非空,结点子树的根即为该结点的子女。 双亲:若结点有子女,该结点是子女双亲。 兄弟:同一结点的子女互称为兄弟。 祖先:结点的祖先是从根到该结点所经分支上的所有结点。 子孙: 以某结点为根的子树种任一结点都是该结点的子孙。 结点的层次:规定根结点为第一层,其子女 结点的层次等于它的层次加一。 深度:树中结点的最大 层次称为树的深度。 有序树:树中结点的各棵子树 T0, T1, …是有次序的,即为有序树。 无序树: 森林:森林是 m ( m≥0 )棵树的集合。 二叉树 二叉树的定义：是一种树型结构,它的特点是每个节点至多只有两棵子树,并且,二叉树的子树有左右之分,其次序不能任意颠倒 。 满二叉树 (Full Binary Tree)：一棵 深度为 k 且有 2k−12k−1 个结点的二叉树。特点:每层上的结点数都是最大的结点数。 完全二叉树 (Complete Binary Tree)：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。 特点: 叶子结点只可能出现在层次最大的两层上 对任一结点,若其右分支下的子孙的最大层次为 l ,则其左分支下的子孙的最大层次必定为 l 或者 l+1 。 二叉树的基本性质 性质 1： 若二叉树结点的层次从 1 开始 ,则在二叉树的第 i 层最多有 $2^{i-1}$ 个结点( i≥1)。 性质 2： 深度为 k 的二叉树最少有 k 个结点,最多有 2^k−1个结点(k ≥1` )。（等比数列求和） 性质 3： 对任何一棵二叉树,如果其叶结点有 $n_0$ 个 , 度为 2 的非叶结点有 $n_2$个 ,则有： n_0=n_2+1性质 4： 具有 n (n≥0) 个结点的完全二叉树的深度为 log_2n+1 性质 5: 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号,则对完全二叉树中任意一个编号为 i 的结点: 若 i=1 ,则该结点是二叉树的根,无双亲;否则,编号为 i/2 的结点为其双亲结点 ; 若 2i&gt;n ,则该结点无左孩子,否则,编号为 2i 的结点为其左孩子结点; 若 2i+1&gt;n ,则该结点无右孩子结点,否则,编号为 2i+1 的结点为其右孩子结点。 二叉树的存储结构： 顺序存储：仅适用于完全二叉树，将完全二叉树中编号为 i 的节点存储在一维数组中编号为 i-1 的分量中。 1234567 #define OK 1#define ERROR 0typedef int Status;typedef char TElemType;#define MAX_TREE_SIZE 100 //二叉树最大节点数typedef TElemType SqBiTree[MAX_TREE_SIZE]; //０号单元存储根节点SqBiTree bt; 链式存储结构： 1234 typedef struct BiTNode&#123; TElemType data;+ struct BiTNode *lchild, *rchild;//左右孩子指针&#125;BiTNode, *BiTree; 创建二叉树： 1234567891011121314 Status CreateBiTree(BiTree *T)&#123; //按先序次序输入二叉树的值，空格字符表示空树 char ch; if ((ch = getchar ()) == ' ')&#123; T = NULL; &#125; else&#123; if(!(T = (BiTNode *) malloc (sizeof(BiTNode)))) exit(-1) T-&gt;data = ch;+ CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125; return 1;&#125;//CreateBiTree 遍历二叉树 顺着某一条搜索路径巡访二叉树中的结点,使得每个结点均被访问一次,而且仅被访问一次。 先序遍历：先访问根节点，然后访问左孩子，然后再访问右孩子；（对应前缀表达式） 中序遍历：先访问左孩子，然后访问根节点，最后访问右孩子；（对应中缀表达式） 后序遍历：先访问左孩子，然后访问右孩子，最后访问根节点；（对应后缀表达式） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 //先序遍历二叉树，递归Status PreOrderTraverse(BiTree T, Status(* Visit)(TElemType))&#123; if(T)&#123; if(Visit(T-&gt;data)) if(PreOrderTraverse(T-&gt;lchild, Visit)) if(PreOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125; else return OK;&#125;Status Visit(T-&gt;data)&#123; if (T-&gt;data != ' ')&#123; printf(\"%c\\n\",T-&gt;data); return OK; &#125; return ERROR;&#125;//中序遍历二叉树，递归Status InOrderTraverse(BiTree T, Status(* Visit)(TElemType e))&#123; if(T)&#123; if(InOrderTraverse(T-&gt;lchild, Visit)) if(Visit(T-&gt;data)) if(InOrderTraverse(T-&gt;rchild, Visit)) return OK; return ERROR; &#125; return OK;&#125;//后序遍历二叉树，递归Status PostOrderTraverse(BiTree T, Status(* Visit)(TElemType e))&#123; if(T)&#123; if(PostOrderTraverse(T-&gt;lchild, Visit)) if(PostOrderTraverse(T-&gt;rchild, Visit)) if(Visit(T-&gt;data)) return OK; return ERROR; &#125;&#125;//下面部分为伪代码//先序遍历迭代算法１void PreOrder_iter1( BiTree T, Status ( *Visit)(TElemType e)&#123; IniStack ( S ) if (T) Push (S, T); While (! StackEmpty(S) ) &#123; // 在栈变空前反复循环 Pop (S, p); visit(p); // 弹出并访问当前结点 if (p-&gt;rchild) Push (S, p-&gt;rchild); // 右孩子先入后出 if (p-&gt;lchild) Push (S, p-&gt;lchild); // 左孩子后入先出 &#125;&#125;//先序遍历的迭代算法 2void PreOrder_iter2( BiTree T, Status ( *Visit)(TElemType e)&#123; IniStack(S); if (T) Push(S, T); do&#123; // 在栈变空前反复循环 Pop(S, x); while (x)&#123; // 访问子树 x 的左侧链,右子树入栈缓冲 visit(x); Push(S, x-&gt;rchild); // 右子树入栈 x = x-&gt;lchild; // 沿左侧链下行 &#125; &#125;while (! StackEmpty(S))&#125;中序遍历迭代算法 1void InOrder_iter1( BiTree T , Status ( *Visit)(TElemType e)&#123;// 采用二叉链表存储结构,中序遍历二叉树的非递归算法 IniStack ( S ); BiTree p = T ; while (p || ! StackEmpty(S))&#123; if (p) &#123; Push (S, p); p= p-&gt;lchild; &#125;// 从当前节点出发 , 逐批进栈 else&#123; Pop (S, p); if ( !Visit (p-&gt;data) ) return ERROR; // 退栈 , 访问 p = p-&gt;rightChild; // 遍历指针进到右子女 &#125; &#125; //while return OK;&#125;;中序遍历迭代算法 2void InOrder_iter2( BiTree T , Status ( *Visit)(TElemType e)&#123; // 采用二叉链表存储结构,中序遍历二叉树的非递归算法 IniStack ( S ); push(S, T) ; while ( ! StackEmpty(S) )&#123; while (GetTop(S, p) &amp;&amp; p) Push (S, p-&gt;lchild); Pop(S, p); if (! StackEmpty(S) )&#123; Pop (S, p); if ( !Visit (p-&gt;data)) return ERROR); // 退栈 , 访问 p = p-&gt;rightChild; // 遍历指针进到右子女 &#125; &#125; //while return OK;&#125;; 层次遍历二叉树： 层次序遍历二叉树就是从根结点开始,按层次逐层从左至右逐一遍历。 层次遍历方法按照深度,逐层对二叉树结构进行遍历,所以可以利用和栈对立的数据结构-队列来进行。 123456789101112 void InOrder_iter2( BiTree T , Status ( *Visit)(TElemType e)&#123; InitQueue(Q); EnQueue(Q, T); while ( ! QueueEmpty(Q) ) &#123; DeQueue(Q, x); Visit(x); if ( x-&gt;leftChild ) EnQueue( Q, x-&gt;leftChild ); if ( x-&gt;rightChild ) EnQueue( Q, x-&gt;rightChild); &#125;&#125; 线索化二叉树 二叉树的遍历实际将二叉树的非线性结构线性化,任一数据都有它的前驱和后继。但这种信息只能在遍历过程中才能得到。 预处理,将某种遍历顺序下的前驱、后继关系(线索)记在树的存储结构中,实现二叉树的线索化。而加上线索的二叉树称为线索二叉树。 n 个结点的二叉链表必定存在n+1 个空链域。 以这 n+1 个 leftChild 和 rightChild 的空闲指针用作 pred 指针和succ 指针,并增设两个标志ltag 和 rtag ,指明指针是指示子女还是前驱、后继线索。 当 ltag ( 或 rtag) = 0 ,表示相应指针指示左子女( 或右子女结点 ) ;当 ltag ( 或 rtag) = 1 ,表示相应指针为前驱 ( 或后继 ) 线索。 1234567 //二叉线索存储表示typedef enum &#123; Link, Thread &#125; PointerThr;// Link==0: 指针, Thread==1: 线索typedef struct BiThrNod &#123; TElemType data; struct BiThrNode *lchild, *rchild; // 左右指针 PointerThr LTag, RTag; // 左右标志&#125; BiThrNode, *BiThrTree; 为仿照线性表的存储界偶，在二叉树的线索表上添加新的头节点，并令其 lchild 指向二叉树的根节点， rchild 指向中序遍历时访问的最后一个节点；反之，令中序遍历的第一个节点的 lchild 和最后一个遍历的节点的 rchild 均指向头节点。 1234567891011121314 void InOrderTraverse_Thr(BiThrTree T,void (*Visit)(TElemType e)) &#123; //T 指向头结点。中序遍历二叉树 T 的非递归算法 BiThrTree p = T-&gt;lchild;// p 指向根结点 while ( p != T ) &#123; // 空树或遍历结束时, p==T while (p-&gt;LTag==Link) p = p-&gt;lchild; // 第一个结点 if ( ! Visit(p-&gt;data) ) return ERROR; while (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123; // 无右子树 p = p-&gt;rchild; Visit(p-&gt;data);// 访问后继结点 &#125; p = p-&gt;rchild; // p 进至其右子树根 &#125;&#125; // InOrderTraverse_Thr 线索化二叉树 在中序遍历过程中修改结点的左、右指针域,以保存当前访问结点的“前驱”和“后继”信息。遍历过程中,附设指针 pre, 并始终保持指针 pre 指向当前访问的、指针 p 所指结点的前驱。 1234567891011121314151617181920212223242526272829303132 Status InOrderThreading( BiThrTree *Thrt,BiThrTree T ) &#123; if(!(Thrt = (BiThrTree) malloc (sizeof(BiThrNode)))) exit(-1); Thrt-&gt;LTag= LINK ; Thrt-&gt;Rtag= Thread ; Thrt-&gt;rchild = Thrt; if (!T) Thre-&gt;lchild = Thrt; else &#123; Thrt-&gt;lchild = T; BiThrTree pre = Thrt; InThreading(T, pre); pre-&gt;rchild = Thrt; pre-Rtag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125; // InThreadingvoid InThreading(BiThrTree p, BiThrTree pre)&#123; if(p)&#123; InThreading(p-&gt;lchild, p); if(!p-&gt;lchild)&#123; p-&gt;LTag = Thread; p-&gt;lchild = pre; &#125; if(!pre-&gt;rchild)&#123; pre-&gt;RTag = Thread; pre-&gt;rchild = p; &#125; pre = p; InThreading(p-&gt;rchild ,pre); &#125;&#125;//InThreading"},{"title":"埃拉托色尼筛选法","date":"2017-04-26T12:33:25.000Z","path":"2017/04/26/the Sieve of Eratosthenes/","text":"埃拉托色尼筛选法(the Sieve of Eratosthenes)简称埃氏筛法，是古希腊数学家埃拉托色尼(Eratosthenes 274B.C.～194B.C.)提出的一种筛选法。 是针对自然数列中的自然数而实施的，用于求一定范围内的质数。 步骤： （1）先把1删除（现今数学界1既不是质数也不是合数）； （2）读取队列中当前最小的数2，然后把2的倍数删去； （3）读取队列中当前最小的数3，然后把3的倍数删去； （4）读取队列中当前最小的数5，然后把5的倍数删去； （5）如上所述直到需求的范围内所有的数均删除或读取； 今天，无意中看到这一算法，觉得很好，便用 C 语言来实现了该算法。采用链表作为数据结构，并通过递归筛选。下面是实现的 C 语言代码，已经过调试验证，结果正确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 //埃拉托色尼筛选法#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct LinkNode&#123; int data; struct LinkNode *next;&#125;LinkNode, *LinkList;//创建一个链表存储的从1到n的数组LinkList Create( int n)&#123; LinkList L,p; int i; L = (LinkList) malloc (sizeof(LinkNode)); if(!L) exit(0); L-&gt;next = NULL; for( i = n; i &gt; 0; i-- )&#123; p = (LinkList) malloc (sizeof(LinkNode)); if ( !p ) &#123; exit(0); &#125; p-&gt;data = i; p-&gt;next = L-&gt;next; L-&gt;next = p; &#125; return L;&#125;//求出所有素数(递归加筛选)void Prime(LinkList L, int n)&#123; static int i = 0; int state; LinkList p, q, r, s; state = i; p = L; q = p-&gt;next; while(state--)&#123; p = p-&gt;next; q = q-&gt;next; &#125; if (q == NULL || 2*q-&gt;data &gt; n) //终止 return; else if(q-&gt;data == 1)&#123; //删除1 r = p; p-&gt;next = q-&gt;next; free(r); i++; Prime(L, n); return; &#125; else&#123; //删除第一个的所有倍数 int value = p-&gt;data; LinkList temp; while(q)&#123; if (q-&gt;data % value == 0)&#123; p-&gt;next = q-&gt;next; temp = q; q = q-&gt;next; free(temp); &#125; if( !q ) break; p = p-&gt;next; q = q-&gt;next; &#125; i++; Prime(L, n); return; &#125;&#125;LinkList Create(int n);void Prime(LinkList L, int n);void PrintList(LinkList L);//打印值void PrintList(LinkList L)&#123; int i = 1; while( L-&gt;next )&#123; printf( \"%d\\t\", L-&gt;next-&gt;data ); if(i%7 == 0) printf( \"\\n\" ); i++; L = L-&gt;next; &#125; printf( \"\\n\" );&#125;int main( int argc, char **argv ) &#123; LinkList p; int n; printf( \"Enter number:\" ); scanf(\"%d\", &amp;n); p = Create(n); PrintList(p); Prime(p, n); printf( \"Prime:\\n\" ); PrintList(p); return 0;&#125;"},{"title":"再谈 C 语言中的指针","date":"2017-04-22T06:59:08.000Z","path":"2017/04/22/the-Error-Summary-of-C-Pointer-Part2/","text":"据说，指针是 C 语言中最灵活的地方，但可能也是 C 语言中最容易出错的地方。 指向指针的指针是指针的指针： 前两天，写一个关于十字链表存储稀疏矩阵的数据结构题，结果在初始化的时候就出现语法错误，而且折腾好久都没发现，先上代码： 12345678910111213141516 typedef int Status;typedef int ElemType;#define OK 1#define OVERFLOW 0typedef struct OLNode&#123; int i, j; //该非零元的行和列下标 ElemType e; struct OLNode *down, *right;&#125; OLNode, *OLink;typedef struct&#123; OLink *rhead, *chead;//行和列链表头指针向量 int mu, nu, tu;&#125;CrossList; 上面的代码是十字链表存储的结构定义。 在初始化时： 1234567 CrossList L;CrossList *M = &amp;L;M-&gt;mu = m;M-&gt;nu = n;M-&gt;tu = t;//m,n.t is constantsM-&gt;rhead = (OLink) malloc ((m + 1) * sizeof(OLink));M-&gt;chead = (OLink) malloc ((n + 1) * sizeof(OLink)); 其实仔细点就应该发现，rhead 和 chead 都是指向 OLink 的指针，所以它们是指向指针的指针，而我把它们转换成了指向 OLNode 的指针，自然就出错了，正确的应该是： 1234567 CrossList L;CrossList *M = &amp;L;M-&gt;mu = m;M-&gt;nu = n;M-&gt;tu = t;//m,n.t is constantsM-&gt;rhead = (OLink *) malloc ((m + 1) * sizeof(OLink));M-&gt;chead = (OLink *) malloc ((n + 1) * sizeof(OLink)); 这一点在函数传参过程中也很关键，下面再说。 C 语言中的传参是值传参 关于Ｃ语言中的值传参，最简单的一个典型例子就是交换两个变量的值： 12345 void wrongchange(int a, int b)&#123; int t = a; a = b; b = a;&#125; 我们都知道，上面的这个函数是无法交换 a,b 的值的，因为传入函数的只是a,b的值，所以函数里面发生什么并不会改变a,b的值，正确的做法是传入a,b的地址： 12345 coid correctchange(int *a, int *b)&#123; int t = *a; *a = *b; *b = t&#125; 也就是说，当把一个变量传入一个函数以后，不管你在这个函数里面对该变量做什么，在函数外面，这个变量都不会有任何变化，因为传参时仅仅是把该变量的值传入函数中去了。所以当我们要对变量进行改变时，需要传入变量的地址。 对于一般的变量，我们容易注意到这一点，可对于指针变量，当要改变指针变量的值的时候，就容易忽略了这一点，因为想着已经是地址了。 这次错误是在一个关于广义表的题：题目要求删除广义表中所有值等于 x 的原子节点。 第一个错误发生在创建一个广义表的时候，我把一个指向广义表的指针传入函数，这是没问题的。但是，后面就出现问题了： 12345678910111213141516171819202122232425262728293031323334353637383940 typedef int AtomType;typedef enum&#123;ATOM,LIST&#125;ElemTag;typedef struct GLNode &#123; ElemTag tag;// = ATOM or = LIST union &#123;// 原子结点和表结点的联合部分 AtomType atom; struct &#123;struct GLNode *hp, *tp;&#125; ptr;//ptr.hp,ptr.tp分别指向表头和表尾 &#125;;&#125;GLNode, *GList;void CreatGList(GList L)&#123;//part1 int i; GList p = L; p-&gt;tag = LIST; p-&gt;ptr.hp = (GList) malloc (sizeof (GLNode)); if(!p-&gt;ptr.hp)&#123; printf( \"Error!\" ); exit(0); &#125; p-&gt;ptr.hp-&gt;tag = ATOM; p-&gt;ptr.hp-&gt;atom = rand()%10; p-&gt;ptr.tp = (GList)malloc(sizeof(GLNode));//part2 p = p-&gt;ptr.tp; for( int i = 0; i &lt; 40 ; i ++ )&#123; p-&gt;tag = LIST; p-&gt;ptr.hp = (GList) malloc(sizeof(GLNode)); p-&gt;ptr.hp-&gt;tag = ATOM; p-&gt;ptr.hp-&gt;atom = rand()%10; p-&gt;ptr.tp = (GList) malloc (sizeof(GLNode)); p = q-&gt;ptr.tp; &#125; p-&gt;tag = ATOM; p-&gt;atom = rand()%10;&#125; 如果懂得一些 C 语言知识的话，很容易看出我的算法是什么样的，但是这样的做法是错的。首先，part1 是没有问题的，但part2有问题了： L是一个指向GLNode 的指针，因次，把它传入函数以后，可以改变L-&gt;ptr.hp,L-&gt;ptr.tp的值，这是有效的，但是，再继续给L-&gt;ptr.tp指向的节点进行操作，就有问题了。在这个函数里面是没有问题的，但是，离开这个函数以后后，那些节点都是没有意义的。 要解决这个问题，其实很简单：不要调用新的函数，直接在 main 函数中进行就可以了。 下一个又是传参的问题。 删除节点时，实际上要改变的是地址的值，因此，我们需要传入的参数不能是地址了，而应该是地址的地址，传入的变量也就是指针的指针变量。这话说起来好别扭…… 123456789101112131415161718 int DeleX(GList *L, AtomType x)&#123; if(!*L) return 1;//空表直接返回 else if((*L)-&gt;tag == ATOM)&#123; if((*L)-&gt;atom != x) return 1;//原子值不等于x else&#123; //删除值等于x的原子项 free(*L); *L = NULL; return 1; &#125; &#125; else&#123; DeleX(&amp;((*L)-&gt;ptr.hp), x); DeleX(&amp;((*L)-&gt;ptr.tp), x); return 1; &#125;&#125; 上面的代码是正确的，错误的就是传入的参数为 GList L，因此，传入的就是L的值，所以，无法改变L，也就不能成功删除节点了。"},{"title":"数组和广义表","date":"2017-04-15T07:13:55.000Z","path":"2017/04/15/Array-and-Table/","text":"数组的类型定义 数组是几乎所有程序设计语言都设定为固有类型的一种数据类型。从线性结构看,数组类型可以看作是数据元素本身还是线性结构的一个数据结构。 n 维数组的特点是每一个数据元素受 n 个线性关系的约束,可以有多个直接前驱和多个直接后继 ; 数组元素的下标一般具有固定的下界和上界,因此它比其他复杂的非线性结构简单。 一维数组常被称为向量( Vector )； 二维数组 A[m][n] 可看成是由 m 个行向量组成的向量,也可看成是由 n 个列向量组成的向量； 一个二维数组类型可以定义为其分量类型为一维数组类型的一维数组类型； 数组的顺序表示和实现： 一旦建立了数组 ,结构中的数据元素个数 和元素之间的关系固定 。因此,采用顺序存储结构表示数组是自然;用顺序存储表示多维数组,就必须按某种次序将数组元素排列到一个序列中。 有两种顺序映象的方式: 以行序为主序； 以列序为主序； 数组元素的存储位置是其下标(j1 , j2 , ....,jn) 的线性函数。一旦确定了数组的各维的阶数, ci 就是常数。所以存取数组中任一元素的时间相等。我们称具有这一特点的存储结构为随机存储结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 #include&lt;stdarg.h&gt;#define MAX_ARRAY_DIM 8typedef int Status;typedef int OK;typedef int ERROR;typedef int OVERFLOW;typedef struct &#123; ElemType *base; //数组元素基址 int dim; //数组维数 int *bounds; //数组维界基址 int *constants; //数组映像函数常量基址&#125;Array;//初始化数组Status InitArray(Array *A, int dim, ...)&#123; //若数组维数和各维长度合法，则构造相应数组A并返回OK if( dim &lt; 1 || dim &gt; MAX_ARRAY_DIM ) return ERROR; A-&gt;dim = dim; A-&gt;bounds = (int *) malloc (dim * sizeof(int)); if(!A-&gt;bounds) exit(OVERFLOW); //若各维长度合法，则存入A-&gt;bounds,并求出元素总数 int elemtotal = 1; va_list ap; va_start(ap, dim);//va 初始化 for(int i = 0; i &lt; dim; i++)&#123; A-&gt;bounds[i] = va_arg(ap, int); //依次访问每一个参数 if(A-&gt;bounds[i] &lt; 0)&#123; return ERROR; &#125; elemtotal *= A-&gt;bounds[i]; &#125; va_end(ap); A-&gt;base = (ElemType *) malloc (elemtotal * sizeof(ElemType)); if(!A-&gt;base)&#123; return OVERFLOW; &#125; //求映像常数Ci A-&gt;constants = (int *) malloc (dim * sizeof(int)); if(!A-&gt;constants)&#123; return OVERFLOW; &#125; A-&gt;constants[dim - 1] = 1; for(int i = dim -2; i &gt;= 0; i--)&#123; A-&gt;constants[i] = A-&gt;boun[i+1] * A-&gt;constants[i+1]; &#125; return OK;&#125;//销毁数组Status DestroyArray(Array *A)&#123; if(!A-&gt;base)&#123; return ERROR; &#125; free(A-&gt;base); A-&gt;base = NULL; if(!A-&gt;bounds)&#123; return ERROE; &#125; free(A-&gt;bounds); A-&gt;bounds = NULL; if(!A-&gt;constants)&#123; return ERROR; &#125; free(A-&gt;constants); A-&gt;constants = NULL; return OK;&#125;//定位，相对位置Status Locate(Array *A, va_list ap, int *off)&#123; *off = 0; int ind for(int i = 0; i &lt; A-&gt;dim, i++)&#123; ind = va_arg(ap, int) if(ind &lt; 0|| ind &gt;= A-&gt;bounds[i]) return OVERFLOW; off += A-&gt;constants[i] * ind; &#125; return OK;&#125;Status value(Array *A, ElemType e, ...)&#123; va_list ap; int off, result; va_start(ap,e); if((result = Locate(A, ap, &amp;off)) &lt;= 0) return result; e = *(A-&gt;base + off); return OK;&#125;Status Assign(Array *A, ElemType e, ...)&#123; va_list ap; va_start(ap, e); int result, off; if((result = Locate(A, ap, &amp;off)) &lt;= 0 ) return result; *(A-&gt;base + off) = e; return OK;&#125; 矩阵的压缩存储(特殊矩阵) 特殊矩阵是指非零元素或零元素的分布有一定规律的矩阵。 假若值相同的元素或者零元素在矩阵中的分布有一定规律,则我们称此类矩阵为特殊矩阵;反之,称为稀疏矩阵。 特殊矩阵的压缩存储主要是针对阶数很高的特殊矩阵。为节省存储空间,对可以不存储的元素,如零元素或对称元素,不再存储。 对称矩阵 对称矩阵中的元素关于主对角线对称, aij = aji , 0 &lt;= i,j &lt;= n-1。 为节约存储,只存对角线及对角线以上的元素,或者只存对角线或对角线以下的元素。前者称为上三角矩阵,后者称为下三角矩阵。 对角矩阵 三对角矩阵中除主对角线及在主对角线上 下最临近的两条对角线上的元素外,所有其它元素均为0 。总共有 3n - 2个非零元素。 稀疏矩阵 以常规方法,即以二维数组表示高阶的稀疏矩阵时产生的问题 : 零值元素占了很大空间; 计算中进行了很多和零值的运算。如遇除法,则需判别除数是否为零; 解决问题的原则 : 尽可能少存或不存零值元素 ; 尽可能减少没有实际意义的运算 ; 操作方便;即:能尽可能快地找到与下标值 (i, j) 对应的元素 ;能尽可能快地找到同一行或同一列的非零值元。 在存储稀疏矩阵时,为节省存储空间,应只存储非零元素。但由于非零元素的分布一般没有规律,故在存储非零元素时,必须记下它所在的行和列的位置 ( i, j ) 。 基于三元组表示的稀疏矩阵的压缩存储方法: 三元组顺序表； 行逻辑联接的顺序表； 十字链表； 三元组顺序表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 #define MAXSIZE 12500 //假设非零元素个数的最大值为12500typedef struct &#123; int i, j ;// 该非零元的行下标和列下标 ElemType e ;// 该非零元的值&#125; Triple ; // 三元组类型typedef struct &#123; Triple data[MAXSIZE + 1]; int mu, nu, tu; // 矩阵的行数、列数和非零元素个数&#125; TSMatrix; // 稀疏矩阵类型//转置Status TransposeSMatrix(TSMatrix M, TSMatrix *T)&#123; *T-&gt;mu = M.nu; *T-&gt;nu = M.mu; *T-&gt;tu = M.tu; if(*T-&gt;tu)&#123; int q = 1; for(int col = 1; col &lt;= M.nu; col++)&#123; for(int p = 1; p &lt;= M.tu; p++ )&#123; if(M.data[p].j = col)&#123; *T-&gt;data[q]-&gt;i = M.data[p].j; *T-&gt;data[q]-&gt;j = M.data[p].i; *T-&gt;data[q]-&gt;e = M.data[p].e; q++; &#125; &#125; &#125; &#125; return OK;&#125;//TransposeSMatrix//快速转置算法Status FastTransposeSMatrix(TSMatrix M, TSMatrix *T)&#123; *T-&gt;mu = M.nu; *T-&gt;nu = M.mu; *T-&gt;tu = M.tu; int num[M.nu], cpot[M.nu]; if(*T-&gt;tu)&#123; for(int col = 1; col &lt;＝ M.nu; ++col)&#123; num[col] = 0; &#125; for(int t = 1; t &lt;= M.tu; t++)&#123; ++num[M.data[t].j];//求M中每一列含非零元素的个数 &#125; cpot[1] = 1; for(int col = 2; col &lt;= M.nu; col++)&#123; cpot[col] = cpot[col - 1] + num[col - 1];//求第col列第一个非零元素在b.data中的序号 &#125; for(int p = 1, int col; p &lt; M.tu; p++)&#123; col = M.data[p].j; q = cpot[col]; *T-&gt;data[q]-&gt;i = M.data[p].j; *T-&gt;data[q]-&gt;j = M.data[p].i; *T-&gt;data[q]-&gt;e = M.data[p].e; ++ cpot[col]; &#125;//for &#125;//if&#125;//FastTransposeSMatrix 行逻辑联接的顺序表 三元组顺序表又称有序的双下标法,它的特点是,非零元在表中按行序有序存储,因此便于进行依行顺序处理的矩阵运算。然而,若需随机存取某一行中的非零元,则需从头开始进行查找。 修改前述的稀疏矩阵的结构定义,增加一个数据成员rpos ,指示各行第一个非零元素的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 #define MAXMN 500typedef struct &#123; Triple data[MAXSIZE + 1]; //非零元三元组表 int rpos[MAXMN + 1]; // 各行第一个非零元的位置表 int mu, nu, tu;&#125; RLSMatrix; // 行逻辑链接顺序表类型//两个稀疏矩阵相乘Status MultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix *Q)&#123; if(M.nu != N.mu) return ERROR; //不能相乘，出错 *Q-&gt;mu = M.mu; *Q-&gt;nu = N.nu; *Q-&gt;tu = 0; //Q初始化 if(M.tu * N.tu != 0)&#123; int arow ; int i, j; int tp, p, q; int brow, t; int ctemp[N.nu]; for(arow = 1; arow &lt;= M.nu; arow++)&#123; for(i = 0; i &lt; N.nu; i++) ctemp[i] = 0; *Q-&gt;rpos[arow] = Q.tu + 1; if(arow &lt; M.tu) tp = M.rpos[arow + 1]; else tp = M.tu + 1; for(p = M.rpos[arow]; p &lt; tp; p++)&#123; brow = M.data[p].j;//对当前行非零元，找到在N中的行号 if(brow &lt; N.mu) t = N.rpos[brow + 1]; else t = N.tu + 1; for(q = N.rpos[brow]; q &lt; t; q++)&#123; ccol = N.data[q].j; ctemp[ccol] += M.data[p].e * M.data[q].e; &#125; //for q &#125; //求Q中第arow行的非零元 for(ccol = 1; ccol &lt;= *Q-&gt;nu; ccol++)//压缩存储该行非零元素 if(ctemp[ccol])&#123; if(++*Q-&gt;tu &gt; MAXSIZE) return ERROE; *Q-&gt;data[*Q-&gt;tu]-&gt;i = arow; *Q-&gt;data[*Q-&gt;tu]-&gt;j = ccol; *Q-&gt;data[*A-&gt;tu]-&gt;e = ctemp[ccol]; &#125;//if &#125;//for arow &#125;//if return OK;&#125;//MultSMatrix 十字链表 当矩阵的非零元个数和位置在操作中变化较大时 [ 例如矩阵的加法 ] ,就不宜采用顺序存储结构来表示三元组的线性表,而是采用链式存储结构表示三元组的线性表。 每个非零元由一个含 5个域的节点表示( i , j, e, right, down )： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 typedef struct OLNode&#123; int i, j; //该非零元的行和列下标 ElemType e; struct OLNODE *right, *down; //该非零元所在行表和列表的后继链域&#125; OLNode; *Olink;typedef struct&#123; OLink *rhead, *chead; //行和列链表头指针向量 int mu, nu, tu;&#125;CrossList;//创建采用十字链存储的稀疏矩阵Status CreateSMatrix_OL(CrossList *M)&#123; //if(M) //free(M); int m, n, t; int i, j, e; scanf(\"%d%d%d\",&amp;m, &amp;n, &amp;t); *M-&gt;mu = m; *M-&gt;nu = n; *M-&gt;tu = t; M-&gt;rhead = (OLink *) malloc ((m + 1) * sizeof(OLink)); M-&gt;chead = (OLink *) malloc ((n + 1) * sizeof(OLink)); if(!M-&gt;rhead || !M-&gt;chead) exit(OVERFLOW);//存储分配失败 for(i = 0; i &lt;= m; i++) M-&gt;rhead[i] = NULL; for(i = 0; i &lt;= n; i++) M-&gt;chead[i] = NULL;//初始化行列表头指针向量 for(scanf(\"%d%d%d\",&amp;i,&amp;j,&amp;e);i!=0;scanf(\"%d%d%d\",&amp;i,&amp;j,&amp;e))&#123; OLNode *p, *q; p = (OLNode *) malloc (sizeof(OLnode)); if(!p) exit(OVERFLOW); p-&gt;i = i; p-&gt;j = j; p-&gt;e = e;//生成节点 if(M-&gt;rhead[i] == NULL || M-&gt;rhead[i]-&gt;j &gt; j)&#123;//寻找在行表中的插入位置 p-&gt;right = M-&gt;rhead[i]; M-&gt;rhead[i] = p; &#125; else&#123; for(q = M-&gt;rhead[i]; q-&gt;right &amp;&amp; q-&gt;right-&gt;j &lt; j; q = q-&gt;right) ; p-&gt;right = q-&gt;right ; q-&gt;right = p; &#125;//完成行插入 if(M-&gt;chead[j] == NULL || M-&gt;chead[j]-&gt;i &gt; i)&#123; p-&gt;down = M.chead[j]; M-&gt;chead[j] = p; &#125;//寻找在列表中的插入位置 else&#123; for(q = M-&gt;head[j]; q-&gt;down &amp;&amp; q-&gt;down-&gt;i &lt; i; q = q-&gt;down); p-&gt;down = q-&gt;down; q-&gt;down = p; &#125;//完成列插入 &#125;//for return OK;&#125;//CreateSMatrix_OL 广义表 广义表是递归定义的线性结构。 当 LS 非空时, 表的第一个表元素称为广义表的表头( head ), 而其它表元素组成的表称为广义表的表尾( tail )。 广义表的存储结构 广义表的数据元素具有不同的结构,且是一个带深度的层次结构。因此难以用顺序存储结构来存放,而是采用链式存储结构。 构造存储结构的两种分析方法 : 表头、表尾分析法 子表分析法 表头表尾分析法：若广义表不空,则可分解为表头和表尾;反之,一对确定的表头和表尾可唯一确定广义表 123456789 typedef enum&#123;ATOM, LIST&#125; ElemTag;typedef struct GLNode &#123; ElemTag tag;// = ATOM or = LIST union &#123;// 原子结点和表结点的联合部分 AtomType atom; struct &#123;struct GLNode *hp, *tp;&#125; ptr;//ptr.hp,ptr.tp分别指向表头和表尾&#125;&#125; *GList; 子表分析法： 12345678910 typedef enum&#123;ATOM, LIST&#125; ElemTag;typedef struct GLNode &#123; ElemTag tag;// = ATOM or = LIST union &#123;// 原子结点和表结点的联合部分 AtomType atom; struct GLNode *hp; &#125;; struct GLNode *tp;// 相当于线性链表的 next&#125; *GList; m 元多项式的表示： 123456789 typedef struct MPNode &#123; ElemTag tag; int exp; // 指数域 union &#123;// 原子结点和表结点的联合部分 float coef; // 系数域 struct GLNodex *hp; &#125;; struct MPNode *tp ; // 相当于线性链表的 next&#125; *Mplist; //m 元多项式广义表类型定义 广义表操作得递归函数 利用递归算法分而治之的思想,递归算法设计中的关键问题是,如何将 一个子问题的解组合成原问题的解。 求广义表的深度 将广义表 LS (a1 , a2 , a3 , ..., an ) 分解成 n 个子表,分别 ( 递归 ) 求得每个子表的深度 。 广义表的深度 =Max { 子表的深度 } +1 DEPTH(LS)的递归定义： 基本项 当 LS 为空表时，DEPTH(LS) = 1; 当 LS 为原子时，DEPTH(LS) = 0; 归纳项 DEPTH(LS) = 1 + Max{DEPTH(ai)} i = 1,2,...,n 12345678910111213141516 int GListDepth(GList L)&#123;//采用头尾链表存储结构 int max; int dep; if(!L)&#123; return 1;//空表深度为1 &#125; if(L-&gt;tag == ATOM)&#123; return 0;//原子深度为0 &#125; for(max = 0, GList pp = L; pp; pp = pp-&gt;ptr.tp)&#123; dep = GListDepth(pp-&gt;ptr.hp); if(dep &gt; max) max = dep; &#125; return max + 1;&#125;//GListDepth 复制广义表 将广义表分解成表头和表尾两部分,分别 ( 递归 ) 复制求得新的表头和表尾。 新的广义表由新的表头和表尾构成。 基本项 : InitGList(NEWLS) 当LS 为空表 递归项: COPY(表头) { 复制表头 } COPY(表尾) { 复制表尾 } 1234567891011121314151617 Status CopyGList(GList *T, GList L)&#123;//由L复制得T if(!L)&#123; T = NULL;//复制空表 &#125; else&#123; if(!(T = (GList)malloc(sizeof(GLNode)))) exit(OVERFLOW); *T-&gt;tag = L-&gt;tag; if(L-&gt;tag == ATOM) *T-&gt;atom = L-&gt;atom; else&#123; CopyGList(*T-&gt;ptr.hp, L-&gt;ptr.hp); CopyGList(*T-&gt;ptr.tp, L-&gt;ptr.tp); &#125;//else &#125;//else return OK;&#125;//CopyGList 建立广义表的存储结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //伪代码Status CreateGList(GList &amp;L, SString S)&#123; if(StrCompare(S, emp)) L = NULL; //emp = \"()\" else&#123; if(!(L = (GList)malloc(sizeof(GLNode)))) exit(OVERFLOW);//建立表节点 if(StrLength(S) == 1)&#123; L-&gt;tag = ATOM; L-&gt;atom = S; &#125; else&#123; L-&gt;tag = LIST; p = L; SubString(sub, 2, StrLength(S) - 2); do&#123;//重复建立n个子表 sever(sub, hsub);//从sub中分离出表头串hsub CreateGList(p-&gt;ptr.hp, hsub); q = p; if(!StrEmpty(sub))&#123;//表尾不空 if(!(p = (GLNode *)malloc(sizeof(GLNode)))) exit(OVERFLOW); p-&gt;tag = LIST; q-&gt;ptr.tp = p; &#125;//if &#125; while(!StrEmpty(sub)); q-&gt;ptr.tp = NULL &#125;//else &#125;//else return OK;&#125;//CreateGListStatus sever(SString &amp;str, SString &amp;hstr)&#123; n = StrLength(str); i = 0; k = 0; do&#123; ++i; SubString(ch, str, i, 1); if(ch == '()') ++k; else if(ch == ')') --k; &#125;while(i &lt; n &amp;&amp; (ch != ','|| k != 0)); if(i &lt; n)&#123; SubString(hstr, str, 1, i - 1); SubString(str, str, i + 1, n - i); &#125; else&#123; StrCopy(hstr, str); ClearString(str); &#125;&#125;//sever"},{"title":"此去经年，应是良辰好景虚设","date":"2017-04-05T13:31:46.000Z","path":"2017/04/05/Miss-You/","text":"前言 如果要我用一句话来形容你是我的什么人那么我会说你是此生唯一的、最最珍贵的知心爱人！ 正文 寒蝉凄切，对长亭晚，骤雨初歇都门帐饮无绪，留恋处，兰舟催发 执手相看泪眼，竟无语凝噎念去去，千里烟波，暮霭沉沉楚天阔 多情自古伤离别，更那堪，冷落清秋节今宵酒醒何处？ 杨柳岸，晓风残月 此去经年，应是良辰好景虚设便纵有千种风情，更与何人说？ －《柳永》 高中的时候，第一次读到《雨霖铃》那时候，并无太多感觉 直到有一天，自己开始了一段无比真挚的爱情并且是一段相距两千公里的爱情我才体会到了词中那份不舍之痛 2017 年 2 月 16 日晚在从昆明去往北京的 Z162 火车上我泪流满面 2017 年 4 月 4 日在从昆明飞往北京的 KN5212 航班上我又一次泪流满面 再次读到《雨霖铃》词中情景竟和我无甚区别 那一句“执手相看泪眼，竟无语凝噎”若非亲自体会怎能知其中滋味 无论何时每当想起分别时刻还是会流泪满面 ４日下午到达北京时北京的天空灰得像哭过 没人喜欢异地恋我也一样但我喜欢你 我舍不得放开你舍不得离开你你也一样 我想一辈子和你在一起你也一样 如果要我用一句话来形容你是我的什么人那么我会说你是此生唯一的、最最珍贵的知心爱人！ 回忆 过去，你以为我喜欢拍照后来，我告诉你只有和你在一起时，我才喜欢拍照： 2017-04-02中午，昆明市君莱酒店 2017-04-03中午，呈贡区傣族人家 2017-04-03中午，呈贡区朝云街 2017-04-03下午，云南中医学院食堂 2017-04-04早，昆明地铁一号线 2017-04-04早，从南部客运站去往长水机场的大巴 2017-04-04早，昆明长水国际机场"},{"title":"如何在 Vim 中进行文本选择操作和使用标志","date":"2017-04-05T13:27:50.000Z","path":"2017/04/05/Text-Select-and-Use-Flag-in-Vim/","text":"基于图形界面的文本或源代码编辑器，提供了一些诸如文本选择的功能。我是想说，可能大多数人不觉得这是一个功能。不过像 Vim 这种基于命令行的编辑器就不是这样。当你仅使用键盘操作 Vim 的时候，就需要学习特定的命令来选择你想要的文本。在这个教程中，我们将详细讨论文本选择这一功能以及 Vim 中的标志功能。 在此之前需要说明的是，本教程中所提到的例子、命令和指令都是在 Ubuntu 16.04 的环境下测试的。Vim 的版本是 7.4。 Vim 的文本选择功能 我们假设你已经具备了 Vim 编辑器的基本知识（如果没有，可以先阅读这篇文章）。你应该知道，d 命令能够剪切/删除一行内容。如果你想要剪切 3 行的话，可以重复命令 3 次。不过，如果需要剪切 15 行呢？重复 d 命令 15 次是个实用的解决方法吗？ 显然不是。这种情况下的最佳方法是，选中你想要剪切/删除的行，再运行 d 命令。举个例子： 假如我想要剪切/删除下面截图中 INTRODUCTION 小节的第一段： 那么我的做法是：将光标放在第一行的开始，（确保退出了 Insert 模式）按下 V（即 Shift+v）命令。这时 Vim 会开启视图模式，并选中第一行。 现在，我可以使用方向键“下”，来选中整个段落。 这就是我们想要的，对吧！现在只需按 d 键，就可以剪切/删除选中的段落了。当然，除了剪切/删除，你可以对选中的文本做任何操作。 这给我们带来了另一个重要的问题：当我们不需要删除整行的时候，该怎么做呢？也就是说，我们刚才讨论的解决方法，仅适用于想要对整行做操作的情况。那么如果我们只想删除段落的前三句话呢？ 其实也有相应的命令 - 只需用小写 v 来代替大写 V 即可。在下面的例子中，我使用 v 来选中段落的前三句话： 有时候，你需要处理的数据由单独的列组成，你的需求可能是选择特定的一列。考虑下面的截图： 假设我们只需选择文本的第二列，即国家的名字。这种情况下，你可以将光标放在这一列的第一个字母上，按 Ctrl+v 一次。然后，按方向键“下”，选中每个国家名字的第一个字母： 然后按方向键“右”，选中这一列。 小窍门：如果你之前选中了某个文本块，现在想重新选中那个文本块，只需在命令模式下按 gv 即可。 使用标志 有时候，你在处理一个很大的文件（例如源代码文件或者一个 shell 脚本），可能想要切换到一个特定的位置，然后再回到刚才所在的行。如果这两行的位置不远，或者你并不常做这类操作，那么这不是什么问题。 但是，如果你需要频繁地在当前位置和一些较远的行之间切换，那么最好的方法就是使用标志。你只需标记当前的位置，然后就能够通过标志名，从文件的任意位置回到当前的位置。 在 Vim 中，我们使用 m 命令紧跟一个字母来标记一行（字母表示标志名，可用小写的 a - z）。例如 ma。然后你可以使用命令 &#39;a （包括左侧的单引号）回到标志为 a 的行。 小窍门：你可以使用“单引号” &#39; 来跳转到标志行的第一个字符，或使用“反引号” ` 来跳转到标志行的特定列。 Vim 的标志功能还有很多其他的用法。例如，你可以先标记一行，然后将光标移到其他行，运行下面的命令： 1 d'[标志名] 来删除当前位置和标志行之间的所有内容。 在 Vim 官方文档中，有一个重要的内容： 每个文件有一些由小写字母（a-z）定义的标志。此外，还存在一些由大写字母（A-Z）定义的全局标志，它们定义了一个特定文件的某个位置。例如，你可能在同时编辑十个文件，每个文件都可以有标志 a，但是只有一个文件能够有标志 A。 我们已经讨论了使用小写字母作为 Vim 标志的基本用法，以及它们的便捷之处。下面的这段摘录讲解的足够清晰： 由于种种局限性，大写字母标志可能乍一看不如小写字母标志好用，但它可以用作一种快速的文件书签。例如，打开 .vimrc 文件，按下 mV，然后退出。下次再想要编辑 .vimrc 文件的时候，按下 &#39;V 就能够打开它。 最后，我们使用 delmarks 命令来删除标志。例如： 1 :delmarks a 这一命令将从文件中删除一个标志。当然，你也可以删除标志所在的行，这样标志将被自动删除。你可以在 Vim 文档 中找到关于标志的更多信息。 总结 当你开始使用 Vim 作为首选编辑器的时候，类似于这篇教程中提到的功能将会是非常有用的工具，能够节省大量的时间。你得承认，这里介绍的文本选择和标志功能几乎不怎么需要学习，所需要的只是一点练习。 via: https://www.howtoforge.com/tutorial/how-to-use-markers-and-perform-text-selection-in-vim/ 作者：Himanshu Arora译者：Cathon校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"串 - Part 2","date":"2017-03-27T00:50:38.000Z","path":"2017/03/27/String-Part2/","text":"Brute-force 算法 将主串 S 的第 pos 个字符和模式串 P 的第 1个字符比较 若相等,继续逐个比较后续字符; 若不等,则从主串 S 的 (pos+1) 字符起,重新与 P 第 1 个字符比较。 直到主串 S 的一个连续子串字符序列与模式串 P 相等。这时匹配成功,返回 S 与 P匹配的子序列第一个字符的序号,否则,匹配失败,返回值 0 。 KMP 算法 每当一趟匹配过程中出现字符比较不相等时,不回溯主串指针,而是将模式串向右滑动恰当位置,继续比较。 挖掘了模式串内在的关联信息 消除了每趟失配后为实施下一趟比较时对主串指针的回退,避免了对已被匹配过的字符的再检查 提高了模式匹配效率 令主串的长度是 n ,模式串的长度是 m ,则算法的时间复杂度: O(m+n) 引入 next 数组/next 特征向量 next[j] = k ,表示在模式串 P 的 P[0,j) 中,自匹配的真前缀和真后缀的 ( 最大 ) 长度为 k； 当模式串 P 中第 j 个字符与主串 S 中相应字符失配时,在下一次匹配中,模式串 P 应当由 next[j] 位置的字符与主串中刚失配的字符重新继续进行比较； $next $数组的定义 / 给定模式串 P：设模式串 $P = p_0 p1 … p{m-2} p_{m-1}$• 令 SetX={0&lt;k&lt;j | P[0..k) = P[j-k .. j)}• ext[j] = max (SetX) 令 next[j] = k ,表示在模式串 P 的 P[0,j) 中,自匹配的真前缀和真后缀最大长度为 k：那么, next[j+1]= ?分两种情况: 情况 1 :当 P[j] = P[k] , next[j+1] = next[j]+1，即next[j+1]=k+1； 情况 2 :当 P[j] ≠ P[k] ,next[j+1] 等于 在P[0..next[j])的真前缀与 P[0..j+1) 中真后缀匹配的最大长度，即 next[j+1]=next[...next[j]...] +1； C 语言实现 12345678910111213141516171819202122232425262728293031 //计算next数组void GetNext(HString *pattern,int next[])&#123; int j,k; j=0; //j: 模式子串的位置 k= -1; //k: 模式自匹配指针 next[0]= -1; while(j&lt;pattern-&gt;length)&#123; if(k== -1 || pattern-&gt;ch[j] == pattern-&gt;ch[k])&#123; j++;k++; next[j]=k; &#125; // 失配 else k=next[k]; &#125;&#125;//时间复杂度为 O(m)//StrIndexKMPint StrIndexKMP(HString *s,HString *t,int pos) &#123; int next[INITSTRLEN]; GetNext(t,next); int i,j; i=pos-1;j=0; while(i&lt;s-&gt;length &amp;&amp; j&lt;t-&gt;length)&#123; if(j== -1 || s-&gt;ch[i] == t-&gt;ch[j])&#123; i++;j++; &#125; else j=next[j]; &#125; if(j&gt;=t-&gt;length) return i-t-&gt;length+1; else return 0;&#125; 对 next 数组的优化: nextval 将主串的 S[i] 、模式串的 P[k] 进行匹配。若 P[k]=P[j] ,那么匹配一定不成功,串还要右滑,滑到 next[k] 位置。所以,可以直接将 j 的 next 值改成next[k] 。 将 GetNext 中的 next[j]=k; 改成: 123 If(pattern-&gt;ch[j] == pattern-&gt;ch[k]) next[j]=next[k]; else next[j]=k; C 语言实现： 1234567891011121314 void GetNextVal(HString *pattern,int nextval[])&#123; int j,k; j=0;k= -1; nextval[0]= -1; while(j&lt;pattern-&gt;length)&#123; if(k== -1 || pattern-&gt;ch[j] == pattern-&gt;ch[k])&#123; j++;k++; if(pattern-&gt;ch[j] == pattern-&gt;ch[k]) nextval[j]=nextval[k]; else nextval[j]=k; &#125; else k=nextval[k]; &#125;&#125;"},{"title":"在独立的 Root 和 Home 硬盘驱动器上安装 Ubuntu","date":"2017-03-24T09:54:10.000Z","path":"2017/03/24/Install-Ubuntu-in-Seperate-Root-and-Home-Drive/","text":"安装 Linux 系统时，可以有两种不同的方式。第一种方式是在一个超快的固态硬盘上进行安装，这样可以保证迅速开机和高速访问数据。第二种方式是在一个较慢但很强大的普通硬盘驱动器上安装，这样的硬盘转速快并且存储容量大，从而可以存储大量的应用程序和数据。 然而，一些 Linux 用户都知道，固态硬盘很棒，但是又很贵，而普通硬盘容量很大但速度较慢。如果我告诉你，可以同时利用两种硬盘来安装 Linux 系统，会怎么样？一个超快、现代化的固态硬盘驱动 Linux 内核，一个容量很大的普通硬盘来存储其他数据。 在这篇文章中，我将阐述如何通过分离 Root 目录和 Home 目录安装 Ubuntu 系统 — Root 目录存于 SSD（固态硬盘）中，Home 目录存于普通硬盘中。 没有多余的硬盘驱动器？尝试一下 SD 卡（内存卡）！ 在多个驱动器上安装 Linux 系统是很不错的，并且每一个高级用户都应该学会这样做。然而，还有一种情况使得用户应该这样安装 Linux 系统 － 在低存储容量的笔记本电脑上安装系统。可能你有一台很便宜、没有花费太多的笔记本电脑，上面安装了 Linux 系统，电脑上没有多余的硬盘驱动，但有一个 SD 卡插槽。 这篇教程也是针对这种类型的电脑的。跟随这篇教程，可以为笔记本电脑买一个高速的 SD 卡来存储 Home 目录，而不是使用另一个硬盘驱动。本教程也适用于这种使用情况。 制作 USB 启动盘 首先去这个网站下载最新的 Ubuntu Linux 版本。然后下载 Etcher- USB 镜像制作工具。这是一个使用起来很简单的工具，并且支持所有主流的操作系统。你还需要一个至少有 2GB 大小的 USB 驱动器。 安装好 Etcher 以后，直接打开。点击 选择镜像Select Image 按钮来制作镜像。这将提示用户浏览、寻找 ISO 镜像，找到前面下载的 Ubuntu ISO 文件并选择。然后，插入 USB 驱动器，Etcher 应该会自动选择它。之后，点击 “Flash!” 按钮，Ubuntu 启动盘的制作过程就开始了。 为了能够启动 Ubuntu 系统，需要配置 BIOS。这是必需的，这样计算机才能启动新创建的 Ubuntu 启动盘。为了进入 BIOS，在插入 USB 的情况下重启电脑，然后按正确的键（Del、F2 或者任何和你的电脑相应的键）。找到从 USB 启动的选项，然后启用这个选项。 如果你的个人电脑不支持 USB 启动，那么把 Ubuntu 镜像刻入 DVD 中。 安装 当用启动盘第一次加载 Ubuntu 时，欢迎界面会出现两个选项。请选择 “安装 Ubuntu” 选项。在下一页中，Ubiquity 安装工具会请求用户选择一些选项。这些选项不是强制性的，可以忽略。然而，建议两个选项都勾选，因为这样可以节省安装系统以后的时间，特别是安装 MP3 解码器和更新系统。（LCTT 译注：当然如果你的网速不够快，还是不要勾选的好。） 勾选了“准备安装 Ubuntu”Preparing to install Ubuntu页面中的两个选项以后，需要选择安装类型了。有许多种安装类型。然而，这个教程需要选择自定义安装类型。为了进入自定义安装页面，勾选“其他”something else选项，然后点击“继续”。 现在将显示 Ubuntu 自定义安装分区工具。它将显示任何/所有能够安装 Ubuntu 系统的磁盘。如果两个硬盘均可用，那么它们都会显示。如果插有 SD 卡，那么它也会显示。 选择用于 Root 文件系统的硬盘驱动器。如果上面已经有分区表，编辑器会显示出来，请使用分区工具把它们全部删除。如果驱动没有格式化也没有分区，那么使用鼠标选择驱动器，然后点击“新建分区表”new partition table。对所有驱动器执行这个操作，从而使它们都有分区表。（LCTT 译注：警告，如果驱动器上有你需要的数据，请先备份，否则重新分区后将永远丢失。） 现在所有分区都有了分区表（并已删除分区），可以开始进行配置了。在第一个驱动器下选择空闲空间，然后点击加号按钮来创建新分区。然后将会出现一个“创建分区窗口”。允许工具使用整个硬盘。然后转到“挂载点”Mount Point下拉菜单。选择 / （Root）作为挂载点，之后点击 OK 按钮确认设置。 对第二个驱动器做相同的事，这次选择 /home 作为挂载点。两个驱动都设置好以后，选择要放入引导装载器的驱动器，然后点击 “现在安装”install now，安装进程就开始了。 从这以后的安装进程是标准安装。创建用户名、选择时区等。 注： 你是以 UEFI 模式进行安装吗？如果是，那么需要给 boot 创建一个 512 MB 大小的 FAT32 分区。在创建其他任何分区前做这件事。确保选择 “/boot” 作为这个分区的挂载点。 如果你需要一个交换分区，那么，在创建用于 / 的分区前，在第一个驱动器上进行创建。可以通过点击 ‘+’ 按钮，然后输入所需大小，选择下拉菜单中的“交换区域”swap area来创建交换分区。 结论 Linux 最好的地方就是可以自己按需配置。有多少其他操作系统可以让你把文件系统分割在不同的硬盘驱动上？并不多，这是肯定的。我希望有了这个指南，你将意识到 Ubuntu 能够提供的真正力量。 安装 Ubuntu 系统时你会用多个驱动器吗？请在下面的评论中让我们知道。 via: https://www.maketecheasier.com/install-ubuntu-with-different-root-home-hard-drives/ 作者：Derrik Diener译者：ucasFL校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"串-Part1","date":"2017-03-22T15:08:32.000Z","path":"2017/03/22/String-Part1/","text":"概念 串 ( 即字符串, string) 是由零个或多个字符组成的有限序列。 串是一类特殊的线性表: 其逻辑结构和线性表极为相似,区别仅在于表中每个数据元素是一个字符; 组成串的字符少,字符数量可以很大,对串的操作种类多且复杂; 串的基本操作和线性表有很大差别: 在线性表的基本操作中,大多以“单个元素”作为操作对象; 在串的基本操作中,通常以“串的整体”作为操作对象:在串中查找子串、插入子串删除子串、替换子串; S=&quot;a_1a_2a_3...a_n&quot; 串的名: s 串的值:双引号里的字符序列,但不包括双引号,双引号是定界符, ai 可以是字母、数字和其他字符 串的长度:串中字符的数目 n 字符在串中的位置:字符在串中的位序 空串 (null string) :零个字符的串,长度为 0 S=“” 空格串 (blank string) :由空格组成的串– S=“ ” 子串:串中任意个连续的字符组成的子序列 主串:包含子串的串 子串在主串中的位置是以子串的第一个字符在主串中的位置来表示的 空串是任意串的子串,任意串是其自身的子串 平凡 (trivial) 子串 vs. 真 (proper) 子串:字符串自身之外的所有非空子串 串的前缀:串中最靠前的若干个字符 串的后缀:串中最靠后的若干个字符 空串是任何串的前缀、后缀,任意串是其自身的前缀、后缀,平凡前缀,平凡后缀,真前缀,真后缀 串的相等:两个串相等当且仅当这两个串的值相等,即,两个串的长度相等,且对应位置的字符均相同 字符相等意味着字符所对应的 ascii 值相等 串的模式匹配 检测问题 /Detection :检测模式串是否出现 定位问题 /Location :首次在哪里出现 计数问题 /Counting :模式串在主串中出现了几次 枚举问题 /Enumeration :模式串分别出现在主串中的哪里 串的具体实现 顺序存储: 定长顺序存储表示:用一组地址连续的存储单元存储串值的字符序列,属静态存储方式 堆分配存储表示:用一组地址连续的存储单元存储串值的字符序列,但存储空间是在程序执行过程中动态分配而得到的 堆:自由存储区, C 语言的动态分配函数从中获得可用的存储空间 链式存储: 串的块链存储表示:链式方式存储 C 语言中的串处理 用字符数组存放串。 C 语言 中的串处理函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445 – char *gets(char *str) ; // 从 stdin 中读取串– int puts(char *str) ; // 向 stdout 输出串– int strlen(char *str); // 返回串的长度– char *strcpy(char *dest, char *src); // 复制串– char *strcat(char *dest, char *src); // 联接串– int strcmp(char *str1, char *str2); // 比较串,s1&lt;s2 时返回负数,相等返回 0 , s1&gt;s2 时返回正数– char *strstr(char *str,char *substr); // 返回子串首次出现的位置- strchr :检索并返回字符 c 在字符串 s 中第一次出现的位置- strrchr :检索并返回字符串 s 中最后一次出现给定字符c 的位置- strspn :检索并返回在 s1 和 s2 中均有的字符个数- strpbrk :检索并返回两个字符串中首个相同字符的位置- strupr :将字符串 s 中的小写字母全部转换成大写字母,并返回转换后的字符串- strlwr :将字符串 s 中的大写字母全部转换成小写字母,并返回转换后的字符串- strtol :将字符串 str 转换成长整型数,并返回这个数- strtod :将字符串 str 转换成双精度数,并返回这个数- strdup :将字符串 s 复制到新建的位置- strrev : 将字符串逆置- strtok :将字符串分割成由定界符隔离的一个个片段- strncat :将字符串 src 中最多 maxlen 个字符复制到字符串 dest 中- strncmp :比较字符串 s1 与 s2 中的前 maxlen 个字符- strncpy :复制 src 中的前 maxlen 个字符到 dest 中- stricmp :以不区分大小写的方式比较字符串 s1 和 s2, 并返回 s1-s2- strnicmp :以不区分大小写的方式比较字符串 s1 与s2 中的前 maxlen 个字符 C 语言实现 12345678910111213141516171819202122232425262728293031323334353637 • #define MAXSTRLEN 255• Typedef unsigned char SString[MAXSTRLEN+1];//串拼接 / 将 s1 和 s2 拼接成 tint StrConcat(SString t,SString s1,SString s2)&#123; int uncut; if (s1[0]+s2[0] &lt;= MAXSTRLEN) &#123; strncpy(&amp;t[1],&amp;s1[1],s1[0]); strncpy(&amp;t[s1[0]+1],&amp;s2[1],s2[0]); t[0]=s1[0]+s2[0]; t[t[0]+1]='\\0'; uncut= TRUE; &#125; else if(s1[0]&lt;MAXSTRLEN) &#123;// s2 被截断 strncpy(&amp;t[1],&amp;s1[1],s1[0]); strncpy(&amp;t[s1[0]+1],&amp;s2[1],MAXSTRLEN-s1[0]); t[0]=MAXSTRLEN; t[MAXSTRLEN+1]='\\0'; uncut=FALSE; &#125; else &#123; //s1[0] = MAXSTRLEN ,故 s2 被截断,仅取 s1 strncpy(&amp;t[1],&amp;s1[1],MAXSTRLEN); t[0]=MAXSTRLEN;t[MAXSTRLEN+1]='\\0'; uncut=FALSE; &#125; return uncut;&#125;// 将 s 中从第 pos 个字符开始的连续 len 个字符放到 sub 中Status StrSubStr(SString sub,SString s,int pos,int len) &#123; if(pos&lt;1 || pos&gt;s[0] || len&lt;0 ||len&gt; s[0]-pos+1) return ERROR; strncpy(&amp;sub[1],&amp;s[pos],len); sub[0]= len; sub[sub[0]+1]='\\0'; return OK;&#125; Brute-force 算法思想: 将主串 s 的第 pos 个字符和模式 t 的第 1 个字符比较 若相等,继续逐个比较后续字符; 若不等,则从主串 s 的 (pos+1) 字符起,重新与 t 第 1 个字符比较。 直到主串 s 的一个连续子串字符序列与模式 t 相等。返回值为 s 中与 T 匹配的子序列第一个字符的序号,即匹配成功,否则,匹配失败,返回值 0 。 123456789101112131415 //串匹配 / 模式匹配int StrIndex(SString s,SString t,int pos)&#123; int i,j; i=pos;j=1; while(i&lt;=s[0] &amp;&amp; j&lt;=t[0])&#123; if(s[i] == t[j]) &#123; i++;j++; &#125; // 继续比较后继字符 else &#123; i=i-j+2;j=1; &#125;// 指针 i 后退 ( 至当前匹配起始位置的下一位置 ) 重新开始匹配 &#125; if(j&gt;t[0]) return i-t[0];// 匹配成功,返回子串 t 的位置 else return 0;&#125; 顺序串 / 堆分配存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 //结构类型定义typedef struct &#123; char *ch; // 若是非空串,则按串长度 +1 分配存储区 int length; // 串长 int strsize; // 存储空间大小,包含串的结束符&#125; HString;//初始化Status StrInit(HString *s)&#123; s-&gt;ch = (char *)malloc(INITSTRLEN *sizeof(char)); if(!s-&gt;ch) return ERROR; s-&gt;ch[0]='\\0'; s-&gt;length = 0; s-&gt;strsize= INITSTRLEN; return OK;&#125;//获取串长度int StrLen(HString *s)&#123; return s-&gt;length;&#125;//判断串是否相等Status IsStrEqual(HString *s1,HString *s2)&#123; int i=0; for(i=0;i&lt;s1-&gt;length &amp;&amp; i&lt; s2-&gt;length; i++) if(s1-&gt;ch[i]!= s2-&gt;ch[i]) return ERROR; if (i&lt;s1-&gt;length || i&lt;s2-&gt;length) return ERROR; else return OK;&#125;//串比较int StrComp(HString *s,HString *t)&#123; for(i=0;i&lt;s-&gt;length &amp;&amp; i&lt;t-&gt;length;i++) if(s-&gt;ch[i] !=t-&gt;ch[i]) return (s-&gt;ch[i]-t-&gt;ch[i]); return s-&gt;length-t-&gt;length;&#125;// 将 s1,s2 拼接成 sStatus StrConcat(HString *s,HString *s1, HString *s2) &#123; int i; if(s-&gt;strsize &lt; (s1-&gt;length + s2-&gt;length)) &#123; s-&gt;ch = (char *)realloc(s-&gt;ch,(s1-&gt;length+s2-&gt;length+1)* sizeof(char)); if(!s-&gt;ch) return ERROR; s-&gt;strsize = s1-&gt;length + s2-&gt;length+1;&#125; i=0; while(i&lt;s1-&gt;length) &#123; s-&gt;ch[i]=s1-&gt;ch[i]; i++; &#125; while(i&lt;s1-&gt;length+s2-&gt;length) &#123; s-&gt;ch[i]=s2-&gt;ch[i-s1-&gt;length]; i++; &#125; s-&gt;ch[i]='\\0'; s-&gt;length = s1-&gt;length+s2-&gt;length; return OK;&#125;// 取子串,将 s 中从第 i 个字符开始的连续 j 个字符放到 subsStatus StrSubstr(HString *subs,HString *s,int i,int j)&#123; int k; if(i&lt;=0 || i&gt; s-&gt;length || j&lt;0 || j&gt;s-&gt;length -i +1) return ERROR; if(subs-&gt;strsize &lt; j) &#123; subs-&gt;ch =(char *)realloc(subs-&gt;ch,(j+1)*sizeof(char)); if(!subs-&gt;ch) return ERROR; subs-&gt;strsize =j+1; &#125; for(k=0;k&lt;j;k++) subs-&gt;ch[k] = s-&gt;ch[i-1+k]; subs-&gt;ch[j]='\\0'; subs-&gt;length=j; return OK;&#125;// 在 s 的第 i 个字符之前 (1&lt;=i&lt;=s-&gt;length+1) 插入字符串 tStatus StrInsert(HString *s,int i,HString *t) &#123; int j; if(i&lt;=0 || i&gt;s-&gt;length+1) return ERROR; // 位置不合法出错 if(s-&gt;strsize &lt; s-&gt;length + t-&gt;length)&#123; // 空间不够 s-&gt;ch = (char *)realloc(s-&gt;ch,(s-&gt;length+t-&gt;length)*sizeof(char)); if(!s-&gt;ch) return ERROR; s-&gt;strsize = s-&gt;length + t-&gt;length; &#125; for(j=s-&gt;length-1;j&gt;=i-1;j--) // 字符后移,腾挪空间 s-&gt;ch[j+t-&gt;length] = s-&gt;ch[j]; for(j=0;j&lt;t-&gt;length;j++) // 插入 t s-&gt;ch[i+j-1] = t-&gt;ch[j]; s-&gt;length +=t-&gt;length; return OK;&#125;// 串替换,将 s 从第 i 个字符开始 j 个连续字符用字符串 t 替换Status StrReplace(HString *s,int i,int j,HString *t)&#123; int k; if(i&lt;=0 || i&gt; s-&gt;length || j&lt;=0 || j&gt;s-&gt;length-i+1) return ERROR; if(j&lt;t-&gt;length) &#123; if(s-&gt;length+t-&gt;length-j&gt;s-&gt;strsize)&#123; s-&gt;ch =(char*)realloc(s-&gt;ch,(s-&gt;length+t-&gt;length-j+1)*sizeo(char)); if(!s-&gt;ch) return ERROR; s-&gt;strsize = s-&gt;length + t-&gt;length –j+1; &#125; for(k=s-&gt;length;k&gt;=i+j-1;k--) // 向后移,挪空间 s-&gt;ch[k-j+t-&gt;length] = s-&gt;ch[k]; &#125; else for(k=i-1+j;k&lt;s-&gt;length;k++) s-&gt;ch[k-j+t-&gt;length] = s-&gt;ch[k]; // 向前移 s-&gt;length = s-&gt;length + t-&gt;length -j; s-&gt;ch[s-&gt;length+1]='\\0'; for(k=0;k&lt;t-&gt;length;k++) s-&gt;ch[k+i-1] = t-&gt;ch[k]; return OK;&#125; 模式匹配 模式匹配:利用 HString 的基本操作:在主串 s 的第 pos 个字符之后寻找与t 相等的子串,找到则返回第一个这样的子串在 S 中的位置,否则返回 0 。t为模式串 12345678910111213141516 int StrIndex(HString *s,HString *t,int pos)&#123; int i,m,n; HString sub; StrInit (&amp;sub); if(pos&gt;0) &#123; i=pos;n=StrLen(s);m=StrLen(t); while(i&lt;=n-m+1) &#123; StrSubstr(&amp;sub,s,i,m); if(!IsStrEqual(&amp;sub,t)) i++; else return i; &#125; &#125; return 0;&#125; 字串替换 利用 HString 的基本操作，用 v 替换主串 s 中出现的所有与 t 相等的不叠的子串。 123456789101112131415161718192021 void StrRepSubstr(HString *s,HString *t,HString *v)&#123; int n,m,pos,i; HString newStr,sub; StrInit(&amp;newStr); StrInit(&amp;sub); n=StrLen(s);m=StrLen(t);pos=1; i=1; while(pos&lt;=n-m+1 &amp;&amp; i)&#123; i=StrIndex(s,t,pos); if(i!=0)&#123; StrSubstr(&amp;sub,s,pos,i-pos); //sub 存放 无需置换的子串 StrConcat(&amp;newStr,&amp;newStr,&amp;sub); StrConcat(&amp;newStr,&amp;newStr,v); pos=i+m; &#125; &#125; if(StrSubstr(&amp;sub,s,pos,n-pos+1)) StrConcat(s,&amp;newStr,&amp;sub); else StrCopy(s,&amp;newStr); return ;&#125; 块链存储 12345678910 #define CHUNKSIZE 80 // 每块大小,由用户定义typedef struct Chunk &#123; // 首先定义结点类型 char ch[CHUNKSIZE];// 每个结点中的数据域 struct Chunk * next ;// 每个结点中的指针域&#125; Chunk;typedef struct &#123; // 定义用链式存储的串类型 Chunk *head;// 头指针 Chunk *tail;// 尾指针 int curLen;// 结点个数&#125; LString;"},{"title":"队列","date":"2017-03-18T12:04:54.000Z","path":"2017/03/18/Queue/","text":"定义 队列 (Queue) 也是运算受限的线性表。 只允许在表的一端进行插入,而在另一端进行删除； 队头 (front) :允许进行删除的一端； 队尾 (rear) :允许进行插入的一端； 空队列:队列中没有元素； 特性： 先进先出 (First In First Out , FIFO) ,先进入队列的成员总是先离开队列； 在空队列中依次加入元素 a 1 , a 2 , … , a n 之后, a 1 是队头元素, a n 是队尾元素,而退出队列的序只能是 a 1 , a 2 , … , an； 队列的链式表示和实现 链队列:用链表表示的队列 数据元素结点,头结点； 队列的队头指针和队尾指针； C 语言实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 #define OK 1#define ERROR 0typedef int ElemType ;typedef int Status;typedef struct Node &#123; ElemType data; struct Node *next;&#125;QNode;typedef struct &#123; QNode *front; QNode *rear;&#125;LinkedQueue;//链队列的基本操作// 链队列的初始化,构造一个空队列Status InitQueue(LinkedQueue *lq)&#123; lq-&gt;front=lq-&gt;rear=(QNode *)malloc(sizeof(QNode)); if(!lq-&gt;front) return ERROR; lq-&gt;front-&gt;next=NULL; return OK;&#125;//队列判空int IsQueueEmpty(LinkedQueue *lq)&#123; if(lq-&gt;front == lq-&gt;rear) return 1; else return 0;&#125;//取队头元素Status GetFront(LinkedQueue *lq,ElemType *e)&#123; if(lq-&gt;front == lq-&gt;rear) return ERROR;//队列为空 *e=lq-&gt;front-&gt;next-&gt;data;return OK; &#125;// 入队:插入元素 e 为队列的新的队尾元素Status Enqueue(LinkedQueue *lq,ElemType e)&#123; QNode *p; p=(QNode *)malloc(sizeof(QNode)); if(!p) return ERROR; p-&gt;data =e; p-&gt;next=NULL; lq-&gt;rear-&gt;next=p; // 修改尾指针 lq-&gt;rear=p; return OK;&#125;// 出队:若队列不空,则删除队列的队头元素,// 用 e 返回其值,并返回 OK ;否则返回 ERRORStatus Dequeue(LinkedQueue *lq,ElemType *e)&#123; QNode *p; if (lq-&gt;front == lq-&gt;rear) return ERROR; // 空队列的话,则出错 p = lq-&gt;front-&gt;next; // 修改头指针 *e = p-&gt;data; lq-&gt;front-&gt;next =p-&gt;next; if(lq-&gt;rear==p) lq-&gt;rear=lq-&gt;front; // 修改尾指针 free(p); return OK;&#125; 队列的顺序表示和实现 顺序队列:利用一组连续的存储单元 ( 一维数组 ) 依次存放从队头到队尾的各个元素； C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839 //静态顺序队列的定义:#define MAXQUEUESIZE 100typedef struct queue &#123; ElemType Queue_array[MAXQUEUESIZE] ; int front; // 队头指针 int rear; // 队尾指针 int queueSize;// 队列空间的大小&#125;SqQueue;//初始化Status Init_SqQueue(SqQueue *ql)&#123; ql-&gt;front=ql-&gt;rear=0; ql-&gt;queuesize=MAXQUEUESIZE; return OK; &#125;//插入元素Status Insert_SqQueue(SqQueue *ql,ElemType e)&#123; ql-&gt;Queue_array[ql-&gt;rear]=e; ql-&gt;rear++; return OK;&#125;//取队头元素Status Get_SqQueue(SqQueue *ql, ElemType *e)&#123; if(ql-&gt;front==ql-&gt;rear) return ERROR; //队列为空 *e=ql-&gt;Queue_array[ql-&gt;front]; ql-&gt;front++; return OK;&#125;//队列判空Status IsSqQueueEmpty(SqQueue *ql)&#123; if(ql-&gt;front==ql-&gt;rear) return OK; else return ERROR;&#125; 循环队列 循环队列:将为队列分配的向量空间看成为一个首尾相接的圆环； 在循环队列中进行出队、入队操作时,队头、队尾指针仍要加 1； 但当队头、队尾指针到达 MAXQUEUESIZE-1时,其加 1 操作的结果是指向 0； 判断队满的条件: 队空和队满时,头尾指针均相等； 无法通过 front==rear 来判断队列“空”还是“满”； 少用一个元素空间,约定:以“队列头指针在队尾指针的下一个位置上”为队满的标志； C 语言实现 12345678910111213141516171819202122232425262728293031323334353637 //定义#define MAXQUEUESIZE 100typedef struct queue &#123; ElemType *base; // 动态分配的存储空间 int front; // 队头指针,若队列不空,指向队列头元素 int rear; // 队尾指针,若队列不空,指向队列尾元素 的下一个位置&#125; CircularQueue;// 队列初始化,构造一个空循环队列Status InitQueue(CircularQueue *cq)&#123; cq-&gt;base=(ElemType *)malloc(MAXQUEUESIZE*sizeof(ElemType)); if(!cq-&gt;base) return ERROR; cq-&gt;front=cq-&gt;rear=0; return OK;&#125;// 返回队列的元素个数,即队列的长度int GetLen(CircularQueue *cq) &#123; return ((cq-&gt;rear - cq-&gt;front + MAXQUEUESIZE)%MAXQUEUESIZE);&#125;// 插入元素 e 为 Q 的新的队尾元素Status Enqueue(CircularQueue *cq,ElemType e) &#123; if((cq-&gt;rear+1)%MAXQUEUESIZE == cq-&gt;front) return ERROR; // 队列满 cq-&gt;base[cq-&gt;rear]=e; cq-&gt;rear=(cq-&gt;rear+1)%MAXQUEUESIZE; return OK;&#125;// 若队列不空,则删除 Q 的队头元素,// 用 e 返回其值,并返回 OK; 否则返回 ERRORStatus Dequeue(CircularQueue *cq,ElemType *e) &#123; if(cq-&gt;front == cq-&gt;rear) return ERROR; *e=cq-&gt;base[cq-&gt;front]; cq-&gt;front=(cq-&gt;front +1)%MAXQUEUESIZE; return OK;&#125;"},{"title":"Vim 快捷键速查表","date":"2017-03-18T07:35:23.000Z","path":"2017/03/18/Vim-Shortcut-Sheet/","text":"本文是 Vim 用户指南 系列的其中一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 技巧 3 个针对高级用户的 Vim 编辑器实用技巧 Vim 编辑器是一个基于命令行的工具，是传奇编辑器 vi 的增强版。尽管图形界面的富文本编辑有很多，但是熟悉 Vim 对于每一位 Linux 的使用者都能有所帮助——无论你是经验丰富的系统管理员，还是刚上手树莓派的新手用户。 这个轻量级的编辑器是个非常强大的工具。在有经验的使用者手中，它能完成不可思议的任务。除了常规的文本编辑功能以外，它还支持一些进阶特性。例如，基于正则表达式的搜索和替换、编码转换，以及语法高亮、代码折叠等的编程特性。 使用 Vim 时有一个非常重要的一点需要注意，那就是按键的功能取决于编辑器当前的“模式”。例如，在“普通模式”输入字母j时，光标会向下移动一行。而当你在“插入模式”下输入字符，则只是正常的文字录入。 下面就是速查表，以便于你充分利用 Vim。 基本操作 快捷键 功能 Esc 从当前模式转换到“普通模式”。所有的键对应到命令。 i “插入模式”用于插入文字。回归按键的本职工作。 : “命令行模式” Vim 希望你输入类似于保存该文档命令的地方。 方向键 快捷键 功能 h 光标向左移动一个字符 j 或 Ctrl + J 光标向下移动一行 k 或 Ctrl + P 光标向上移动一行 l 光标向右移动一个字符 0 （数字 0）移动光标至本行开头 $ 移动光标至本行末尾 ^ 移动光标至本行第一个非空字符处 w 向前移动一个词 （上一个字母和数字组成的词之后） W 向前移动一个词 （以空格分隔的词） 5w 向前移动五个词 b 向后移动一个词 （下一个字母和数字组成的词之前） B 向后移动一个词 （以空格分隔的词） 5b 向后移动五个词 G 移动至文件末尾 gg 移动至文件开头 浏览文档 快捷键 功能 ( 跳转到上一句 ) 跳转到下一句 { 跳转到上一段 } 跳转到下一段 [[ 跳转到上一部分 ]] 跳转到下一部分 [] 跳转到上一部分的末尾 ][ 跳转到上一部分的开头 插入文本 快捷键 功能 a 在光标后插入文本 A 在行末插入文本 i 在光标前插入文本 o （小写字母 o）在光标下方新开一行 O （大写字母 O）在光标上方新开一行 特殊插入 快捷键 功能 :r [filename] 在光标下方插入文件 [filename] 的内容 :r ![command] 执行命令 [command] ，并将输出插入至光标下方 删除文本 快捷键 功能 x 删除光标处字符 dw 删除一个词 d0 删至行首 d$ 删至行末 d) 删至句末 dgg 删至文件开头 dG 删至文件末尾 dd 删除该行 3dd 删除三行 简单替换文本 快捷键 功能 r{text} 将光标处的字符替换成 {text} R 进入覆写模式，输入的字符将替换原有的字符 复制/粘贴文本 快捷键 功能 yy 复制当前行至存储缓冲区 [&quot;x]yy 复制当前行至寄存器 x p 在当前行之后粘贴存储缓冲区中的内容 P 在当前行之前粘贴存储缓冲区中的内容 [&quot;x]p 在当前行之后粘贴寄存器 x 中的内容 [&quot;x]P 在当前行之前粘贴寄存器 x 中的内容 撤销/重做操作 快捷键 功能 u 撤销最后的操作 Ctrl+r 重做最后撤销的操作 搜索和替换 快捷键 功能 /search_text 检索文档，在文档后面的部分搜索 search_text ?search_text 检索文档，在文档前面的部分搜索 search_text n 移动到后一个检索结果 N 移动到前一个检索结果 :%s/original/replacement 检索第一个 “original” 字符串并将其替换成 “replacement” :%s/original/replacement/g 检索并将所有的 “original” 替换为 “replacement” :%s/original/replacement/gc 检索出所有的 “original” 字符串，但在替换成 “replacement” 前，先询问是否替换 书签 快捷键 功能 m {a-zA-Z} 在当前光标位置设置书签，书签名可用一个大小写字母（{a-zA-Z}） :marks 列出所有书签 {a-zA-Z} 跳转到书签 {a-zA-Z} 选择文本 快捷键 功能 v 进入逐字可视模式 V 进入逐行可视模式 Esc 退出可视模式 改动选中文本 快捷键 功能 ~ 切换大小写 d 删除一个词 c 变更 y 复制 &gt; 右移 &lt; 左移 ! 通过外部命令进行过滤 保存并退出 快捷键 功能 :q 退出 Vim，如果文件已被修改，将退出失败 :w 保存文件 :w new_name 用 new_name 作为文件名保存文件 :wq 保存文件并退出 Vim :q! 退出 Vim，不保存文件改动 ZZ 退出 Vim，如果文件被改动过，保存改动内容 ZQ 与 :q! 相同，退出 Vim，不保存文件改动 下载 Vim 快捷键速查表 仅仅是这样是否还不足以满足你？别担心，我们已经为你整理好了一份下载版的速查表，以备不时之需。 点此下载（英文） via: https://www.maketecheasier.com/vim-keyboard-shortcuts-cheatsheet/ 作者：Himanshu Arora译者：martin2011qi校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"Vim 初学者入门指南","date":"2017-03-18T07:34:57.000Z","path":"2017/03/18/Vim-Beginner-Tutorial/","text":"这篇文章是 VIM 用户指南 系列文章中的一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 技巧 3 个针对高级用户的 Vim 编辑器有用技巧 对一个程序员来说，选择一个文本编辑器是一件非常重要的事。因为不同编辑器之间有着不少的差异：图形界面或者非图形界面、不同的快捷键、不同的编程语言支持、不同的插件以及自定义设置等等。我建议不是去搜索最棒的编辑器，而是去选择最适合你的习惯且最适应你的任务的那一个。假如你打算在一个团体中工作，那么最好和你的共事者选择一样的编辑器。这样的话，一旦你在使用中遇到问题，你就可以去向他们寻求帮助。 这正是我在几年之前开始使用 Vim 的原因。通常来说，Vim 会被置于传说中的 Emacs 的对立面。我承认我对 Emacs 知之甚少，但是对于它俩，你需要知道的是它们都可以被深度定制，并且在初学时也都非常令人困惑。这个教程并不会介绍有关 Vim 的所有内容，而是将介绍一些基础以使你在最初就能正确使用它，随后还会展示一些小技巧，借此（希望能）让你有能力自己去探索学习。 Vim 一词来源于 “VI iMproved”。Vi 是一个被广泛安装于 Unix 系统的非图形界面文本编辑器，并且它也被默认安装在了 Linux 系统中。Vim 是这个原始编辑器的增强版，但是不同于 Vi，并不是每个发行版都默认安装了它。 安装 在 Ubuntu 中可以使用如下命令来安装 Vim： 1 sudo apt-get install vim 如果你已经对某些插件有了兴趣，使用以下命令： 1 sudo apt-cache search vim 这命令将给你输出一个很长的和 Vim 有关的包列表。在这之中，有针对不同编程语言的工具，有插件管理器，等等。 在这系列教程中，我将会在 Ubuntu 上使用最新版的 Vim（7.3.154，LCTT 译注：现在最新版为 8.0）。当然你也可以使用其它任何版本。 热身 在终端输入 vim 命令，你将会看到一个非常棒的欢迎界面。 （LCTT 译注：看到了欢迎界面中那行“Help poor children in Uganda!” 了吗？） 如果你之前从未使用过 Vi 或者 Vim，那么你很可能甚至不知道该怎么退出它… 是的，这是事实。任何你常用的快捷键在 Vim 中都将失去原有的效果。（LCTT 译注：网上有个流传的笑话——“如何制造乱码”，“让新手退出 vi”） 首先，要使用任何命令式的功能，像保存（save）或者退出（exit），你都先得输入一个冒号（:）。保存是 :w 而退出是 :q。如果你想不保存文件就退出，那么就要使用强制退出命令 :q!。Vim 中非常棒的一点是你不需要分开输入各个命令，换言之，如果你想保存然后退出，你就可以直接使用 :wq。 现在，我们退出 Vim 再打开一个文本文件。为此，你只需把想要编辑的文件名加在命令后面即可： 1 vim [文本文件名] 一般而言，当你打开一个文本文件，你将会处在查看模式。这使得 Vim 与众不同并且最初会让人感到困惑。Vim 主要由两种模式构成：查看模式和编辑模式。查看模式用于查看内容并且使用一些命令。想要进入编辑模式，只需按 i 键进行插入（insert）或者 a 键进行添加（add）。想要返回到查看模式或者进行命令式功能的操作，按 Escape 键即可。插入（insert）和添加（add）的差异仅仅在于你是想在光标位置之前还是在光标之后进入编辑模式并进行文字输入。要想彻底地明白，你应该亲自去尝试一下。我的建议是：仅在行尾使用添加（add），而在其它时候使用插入（insert）。 （LCTT 译注：此段落中“查看模式”原文是 “visual mode”，疑为“view mode”，在此模式下可以查看文本，但是不能进行编辑；而“visual mode” 是编辑模式的一种，可以按 v 键进入，然后就可以用方向键从当前光标位置开始进行选择，并以反白的视觉效果显示，通常选择后可以按 y 进行复制、按 d 进行剪切等操作。） 要想在文本之中移动光标，你通常可以使用键盘上的方向键，它们无论是在查看模式还是在编辑模式都可以生效。不过，一个真正的纯粹主义者将会告诉你使用按键 h 向左，j 向下，k 向上，l 向右来（在查看模式）进行移动。 现在你已经明白了如何和简单地控制 Vim，我们再来更加深入一些。 一些简单命令 现在你已经熟悉了在正常模式和插入模式之间进行切换，下面是一些可以在正常模式中使用的命令： x：删除一个字符 u：撤销一个操作（相当与 Ctrl+z） dd：删除一行内容 dw：删除一个单词 yy：复制一行内容 yw：复制一个单词 p：粘贴一个之前删除或复制的行或者单词 e：跳到下个单词（LCTT 译注：词尾）（比单纯用方向键更快） r：替换一个字母（按 r，松开，然后再按新字母） 当然不止这些，不过这些对现在来说已经足够了。如果你掌握了上面的全部，你将能你很顺溜地使用 Vim 了。 对于那些还想知道更多的人，我再多提一下。你可以在任何这些命令之前加上一个数值，那么这个命令将被重复执行相应的次数。例如，5x 将在当前行连续删除 5 个字母，而 3p 将会粘贴 3 次。 高级命令 最后，作为对你自己继续探索的鼓励和示例，这里给出几个高级且常用的命令： /所搜索的内容：在文中搜索特定内容 :sp 文本文件名：将屏幕水平分割成上下两半，新文件展示在另一半。想要在两侧切换焦点，可以使用 Ctrl+w 快捷键。 :vsp 文本文件名：同上，但是是垂直分割屏幕 Ctrl+Shift+C 和 Ctrl+Shift+V：在终端中复制和粘贴文本 :! 命令名：在 Vim 中运行 Vim 外的终端命令，直接发送给 shell。例如，:! ls 将在不退出编辑器的同时，显示你当前目录内的文件。 结论 我觉得你现在应该已经有了足够的准备来开始使用 Vim。你还可以通过安装各种插件，编辑 ~.vimrc 文件，或者在 shell 中输入 vimtutor 命令来使用交互式教程以学到更多。 如果你有任何你想分享的关于 Vim 的其它命令，请在评论中告知我们。 via: https://www.maketecheasier.com/start-with-vim-linux/ 作者：Himanshu Arora译者：Yinr校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"Free：一个在 Linux 中检查内存使用情况的标准命令","date":"2017-03-18T02:15:31.000Z","path":"2017/03/18/Free-Command-in-Linux/","text":"我们都知道， IT 基础设施方面的大多数服务器（包括世界顶级的超级计算机）都运行在 Linux 平台上，因为和其他操作系统相比， Linux 更加灵活。有的操作系统对于一些微乎其微的改动和补丁更新都需要重启，但是 Linux 不需要，只有对于一些关键补丁的更新， Linux 才会需要重启。 Linux 系统管理员面临的一大挑战是如何在没有任何停机时间的情况下维护系统的良好运行。管理内存使用是 Linux 管理员又一个具有挑战性的任务。free 是 Linux 中一个标准的并且被广泛使用的命令，它被用来分析内存统计（空闲和已用）。今天，我们将要讨论 free 命令以及它的一些有用选项。 推荐文章： smem － Linux 内存报告/统计工具 vmstat － 一个报告虚拟内存统计的标准而又漂亮的工具 Free 命令是什么 free 命令能够显示系统中物理上的空闲（free）和已用（used）内存，还有交换（swap）内存，同时，也能显示被内核使用的缓冲（buffers）和缓存（caches）。这些信息是通过解析文件 /proc/meninfo 而收集到的。 显示系统内存 不带任何选项运行 free 命令会显示系统内存，包括空闲（free）、已用（used）、交换（swap）、缓冲（buffers）、缓存（caches）和交换（swap）的内存总数。 12345 # free total used free shared buffers cachedMem: 32869744 25434276 7435468 0 412032 23361716-/+ buffers/cache: 1660528 31209216Swap: 4095992 0 4095992 输出有三行： 第一行：表明全部内存、已用内存、空闲内存、共用内存（主要被 tmpfs（/proc/meninfo 中的 Shmem 项）使用）、用于缓冲的内存以及缓存内容大小。 全部：全部已安装内存（/proc/meminfo 中的 MemTotal 项） 已用：已用内存（全部计算 － 空间＋缓冲＋缓存） 空闲：未使用内存（/proc/meminfo 中的 MemFree 项） 共用：主要被 tmpfs 使用的内存（/proc/meminfo 中的 Shmem 项） 缓冲：被内核缓冲使用的内存（/proc/meminfo 中的 Buffers 项） 缓存：被页面缓存和 slab 使用的内存（/proc/meminfo 中的 Cached 和 SSReclaimable 项） 第二行：表明已用和空闲的缓冲/缓存 第三行：表明总交换内存（/proc/meminfo 中的 SwapTotal 项）、空闲内存（/proc/meminfo 中的 SwapFree 项）和已用交换内存。 以 MB 为单位显示系统内存 默认情况下， free 命令以 KB - Kilobytes 为单位输出系统内存，这对于绝大多数管理员来说会有一点迷糊（当系统内存很大的时候，我们中的许多人需要把输出转化为以 MB 为单位，从而才能够理解内存大小）。为了避免这个迷惑，我们在 ‘free’ 命令后面加上 -m 选项，就可以立即得到以 ‘MB - Megabytes’ 为单位的输出。 12345 # free -m total used free shared buffers cachedMem: 32099 24838 7261 0 402 22814-/+ buffers/cache: 1621 30477Swap: 3999 0 3999 如何从上面的输出中检查剩余多少空闲内存？主要基于已用（used）和空闲（free）两列。你可能在想，你只有很低的空闲内存，因为它只有 10%， 为什么？ 全部实际可用内存 ＝ （全部内存 － 第 2 行的已用内存） 全部内存 ＝ 32099 实际已用内存 ＝ 1621 （ = 全部内存 - 缓冲 - 缓存） 全部实际可用内存 ＝ 30477 如果你的 Linux 版本是最新的，那么有一个查看实际空闲内存的选项，叫做可用（available） ，对于旧的版本，请看显示 -/+ buffers/cache 那一行对应的空闲（free）一列。 如何从上面的输出中检查有多少实际已用内存？基于已用（used）和空闲（free）一列。你可能想，你已经使用了超过 95% 的内存。 全部实际已用内存 ＝ 第一列已用 － （第一列缓冲 ＋ 第一列缓存） 已用内存 ＝ 24838 已用缓冲 ＝ 402 已用缓存 ＝ 22814 全部实际已用内存 ＝ 1621 以 GB 为单位显示内存 默认情况下， free 命令会以 KB - kilobytes 为单位显示输出，这对于大多数管理员来说会有一些迷惑，所以我们使用上面的选项来获得以 MB - Megabytes 为单位的输出。但是，当服务器的内存很大（超过 100 GB 或 200 GB）时，上面的选项也会让人很迷惑。所以，在这个时候，我们可以在 free 命令后面加上 -g 选项，从而立即得到以 GB - Gigabytes 为单位的输出。 12345 # free -g total used free shared buffers cachedMem: 31 24 7 0 0 22-/+ buffers/cache: 1 29Swap: 3 0 3 显示全部内存行 默认情况下， free 命令的输出只有三行（内存、缓冲/缓存以及交换）。为了统一以单独一行显示（全部（内存＋交换）、已用（内存＋（已用－缓冲/缓存）＋交换）以及空闲（内存＋（已用－缓冲/缓存）＋交换），在 ‘free’ 命令后面加上 -t 选项。 123456 # free -t total used free shared buffers cachedMem: 32869744 25434276 7435468 0 412032 23361716-/+ buffers/cache: 1660528 31209216Swap: 4095992 0 4095992Total: 36965736 27094804 42740676 按延迟运行 free 命令以便更好的统计 默认情况下， free 命令只会显示一次统计输出，这是不足够进一步排除故障的，所以，可以通过添加延迟（延迟是指在几秒后再次更新）来定期统计内存活动。如果你想以两秒的延迟运行 free 命令，可以使用下面的命令（如果你想要更多的延迟，你可以按照你的意愿更改数值）。 下面的命令将会每 2 秒运行一次直到你退出： 123456789101112131415 # free -s 2 total used free shared buffers cachedMem: 32849392 25935844 6913548 188 182424 24632796-/+ buffers/cache: 1120624 31728768Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25935288 6914104 188 182424 24632796-/+ buffers/cache: 1120068 31729324Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25934968 6914424 188 182424 24632796-/+ buffers/cache: 1119748 31729644Swap: 20970492 0 20970492 按延迟和具体次数运行 free 命令 另外，你可以按延迟和具体次数运行 free 命令，一旦达到某个次数，便自动退出。 下面的命令将会每 2 秒运行一次 free 命令，计数 5 次以后自动退出。 12345678910111213141516171819202122232425 # free -s 2 -c 5 total used free shared buffers cachedMem: 32849392 25931052 6918340 188 182424 24632796-/+ buffers/cache: 1115832 31733560Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931192 6918200 188 182424 24632796-/+ buffers/cache: 1115972 31733420Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931348 6918044 188 182424 24632796-/+ buffers/cache: 1116128 31733264Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931316 6918076 188 182424 24632796-/+ buffers/cache: 1116096 31733296Swap: 20970492 0 20970492 total used free shared buffers cachedMem: 32849392 25931308 6918084 188 182424 24632796-/+ buffers/cache: 1116088 31733304Swap: 20970492 0 20970492 人类可读格式 为了以人类可读的格式输出，在 free 命令的后面加上 -h 选项，和其他选项比如 -m 和 -g 相比，这将会更人性化输出（自动使用 GB 和 MB 单位）。 1234 # free -h total used free shared buff/cache availableMem: 2.0G 1.6G 138M 20M 188M 161MSwap: 2.0G 1.8G 249M 取消缓冲区和缓存内存输出 默认情况下， 缓冲/缓存 内存输出是同时输出的。为了取消缓冲和缓存内存的输出，可以在 free 命令后面加上 -w 选项。（该选项在版本 3.3.12 上可用） 注意比较上面有缓冲/缓存的输出。 1234 # free -wh total used free shared buffers cache availableMem: 2.0G 1.6G 137M 20M 8.1M 183M 163MSwap: 2.0G 1.8G 249M 显示最低和最高的内存统计 默认情况下， free 命令不会显示最低和最高的内存统计。为了显示最低和最高的内存统计，在 free 命令后面加上 -l 选项。 1234567 # free -l total used free shared buffers cachedMem: 32849392 25931336 6918056 188 182424 24632808Low: 32849392 25931336 6918056High: 0 0 0-/+ buffers/cache: 1116104 31733288Swap: 20970492 0 20970492 阅读关于 free 命令的更过信息 如果你想了解 free 命令的更多可用选项，只需查看其 man 手册。 123 # free --helpor# man free via: http://www.2daygeek.com/free-command-to-check-memory-usage-statistics-in-linux/ 作者：MAGESH MARUTHAMUTHU译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"栈","date":"2017-03-16T00:12:58.000Z","path":"2017/03/16/Stack/","text":"定义 栈 (Stack) 是限制在线性表的一端进行插入和删除操作的线性表,也称为后进先出(LIFO, Last In First Out) 或先进后出(FILO, First In Last Out) 线性表。 栈顶 (Top) :允许进行插入、删除操作的一端,也称为表尾，用栈顶指针来指示栈顶元素； 栈底 (Bottom/Base) :固定端,也称为表头； 空栈:当表中没有元素时称为空栈； 设栈 S=(a1, a2, …,an) ,则 a1 称为栈底元素, an 为栈顶元素。栈中元素按 a1 , a2,… an 的次序进栈,出栈的第一个元素应为栈顶元素,即栈的修改是按后进先出的原则进行的。 动态顺序栈 采用动态一维数组来存储栈； 所谓动态指的是栈的大小可以根据需要增加； 用 base 表示栈底指针,栈底固定不变的； 栈顶则随着进栈和退栈操作而变化,用 top( 称为栈顶指针 ) 指向数组中的下一个空闲存储位置； 用 top==base 作为栈空的标记； 进栈：首先将数据元素保存到栈顶 (top 所指的当前位置 ),然后,执行 top加 1 ,使 top 指向栈顶的下 一个存储位置； 出栈：首先执行 top 减 1，使 top 指向栈顶元素的存储位置，然后将栈顶元素取出； 静态顺序栈 采用静态一维数组来存储栈； 栈底固定不变的,而栈顶则随着进栈和退栈操作变化的； 用一个整型变量 top( 称为栈顶指针 ) 指向当前栈顶位置； 用 top=0 表示栈空的初始状态,每次 top 指向栈顶元素在数组中的存储位置； 若栈的数组有 Maxsize 个元素,则 top=Maxsize-1 时栈满； 进栈：先执行 top 加 1,使 top 指向新的栈顶位置,然后将数据元素保存到栈顶 (top 所指的当前位置 )；出栈：先把 top 指向的栈顶元素取出,然后执行 top 减 1 ,使 top 指向新的栈顶位置； C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 //动态顺序栈#define INITSIZE 100 // 栈空间初始分配量#define INCREMENTSIZE 10 // 栈空间分配增量#define OK 1#define ERROR 0typedef int ElemType ;typedef int Status;typedef struct &#123; int top;// 栈顶指针 ElemType *base; // 栈不存在时值为 NULL int stacksize ; //当前已分配空间&#125;SqStack ;//构造空栈Status InitStack(SqStack *s)&#123;// 构造一个空栈 s s-&gt;base=(ElemType *)malloc(INITSIZE * sizeof(ElemType)); if (!s) return ERROR; s-&gt;top=0; s-&gt;stacksize=INITSIZE; return OK;&#125;//返回栈的长度int GetLen(SqStack *s)&#123; return (s-&gt;top);&#125;//查看栈顶元素，不修改Status GetTop(SqStack *s,ElemType *e) &#123; // 只查看,不修改栈 if(s-&gt;top==0) return ERROR; // 栈空,返回出错标志 *e=s-&gt;base[s-&gt;top-1]; return OK;&#125;//push 元素进栈Status Push(SqStack *s,ElemType e)&#123; if(s-&gt;top &gt;= s-&gt;stacksize) &#123;//若栈已满,则增加INCREMENTSIZE 个存储单元 s-&gt;base=(ElemType *)realloc(s-&gt;base,(s-&gt;stacksize + INCREMENTSIZE)*sizeof(ElemType)); if(!s-&gt;base) return ERROR; //存储分配失败 s-&gt;stacksize+=INCREMENTSIZE;&#125; s-&gt;base[s-&gt;top++]=e; //e成为新的栈顶元素,栈顶指针加1 return OK;&#125;//pop 元素出栈Status Pop(SqStack *s,ElemType *e)&#123; if(s-&gt;top==0) return ERROR; // 栈空,返回出错标志 *e=s-&gt;base[--s-&gt;top]; // 等于s-&gt;top--; *e=s-&gt;base[s-&gt;top]; return OK;&#125;//判断栈空int IsStackEmpty(SqStack *s)&#123; if(s-&gt;top == 0) return 1; else return 0;&#125;//遍历Status StackTraverse(SqStack *s, void visit(ElemType *e))&#123; int i; if(s-&gt;top==0) return ERROR; for(i=s-&gt;top-1;i&gt;=0;i--) visit(&amp;s-&gt;base[i]); return OK;&#125;//数制转换void Conversion(int n,int d)&#123;// 将十进制整数 n 转换为 d 进制数 ElemType e; SqStack s; if(!InitStack(&amp;s)) return ERROR; while(n!=0) &#123; // 将余数逐一进栈 Push(&amp;s,n%d); n=n/d; &#125; while(!IsStackEmpty(&amp;s)) &#123; Pop(&amp;s,&amp;e); printf(\"%d \",e); &#125;&#125;//静态存储栈#define MAX_STACK_SIZE 100 // 栈的大小typedef int ElemType ;typedef struct &#123; ElemType stack_array[MAX_STACK_SIZE]; int top;&#125; SqStack;//链式栈typedef struct Node&#123; ElemType data; struct Node *next;&#125; LinkedStack;// 创建一个带头结点的空栈LinkedStack *InitStack(void)&#123; LinkedStack *s; s=(LinkedStack *)malloc(sizeof(LinkedStack)); s-&gt;next=NULL; return s;&#125;//求栈长int GetLen(LinkedStack *s)&#123; int i=0; LinkedStack *p; p=s-&gt;next; while(p)&#123; i++;p =p-&gt;next;&#125; return i;&#125;//元素进栈Status Push(LinkedStack *s,ElemType e)&#123; LinkedStack *p; p=(LinkedStack *)malloc(sizeof(LinkedStack)); if(!p) return ERROR;//存储分配失败 p-&gt;data = e; p-&gt;next=s-&gt;next; // 新结点插入到头结点之后 s-&gt;next=p; return OK;&#125;//元素出栈Status Pop(LinkedStack *s,ElemType *e)&#123; LinkedStack *p; if(!s-&gt;next) return ERROR; p=s-&gt;next; *e=p-&gt;data; // 取栈顶元素 s-&gt;next=p-&gt;next; // 修改栈顶指针 free(p); return OK;&#125; 栈的运用：递归 栈的一个重要应用是在程序设计语言中实现递归调用； 编译器依靠“栈”来管理递归函数的调用； 递归调用:一个函数 ( 或过程 ) 直接或间接地调用自己本身,简称递归 (Recursive)； 递归是程序设计中的一个强有力的工具。因为递归函数结构清晰,程序易读,正确性很容易得到证明； 为了使递归调用不至于无终止地进行下去,实际上有效的递归调用函数 ( 或过程 ) 应包括两部分:递推规则 ( 方法 ) ,终止条件； 举例：求单链表表尾元素 1234567891011 struct LNode &#123; ElemType data;struct Lnode *next;&#125;;LNode *L;ElemType FoundTail(LNode *L)&#123; if ( L-&gt;next == NULL ) return L.data; else return FoundTail(L-&gt;next);&#125; 递归算法优缺点 优点 结构清晰,程序易读； 编写容易,因为编译程序代替用户完成了栈的管理； 正确性容易得到证明；缺点 往往比较耗时耗空间。这是由于递归函数会不断进行函数的调用操作,而函数的调用是比较消耗资源的； 可将递归函数转化为非递归函数； 递归实现:函数调用 在一个函数的运行期间调用另一个函数时,在运行该被调用函数之前,需先完成三项任务： 将所有的实在参数、返回地址等信息传递给被调用函数保存； 为被调用函数的局部变量分配存储区； 将控制转移到被调用函数的入口； 从被调用函数返回调用函数之前,要完成下列三项任务： 保存被调用函数的计算结果； 释放被调用函数的数据区； 依照被调函数保存的返回地址将控制转移到调用函数； 递归实现 递归函数的执行过程可视为同一函数进行嵌套调用；调用层次 递归工作栈:整个递归调用过程期间使用的数据存储区； 递归工作记录:每一层递归所需的信息 ( 包括:实参,局部变量和上一层的返回地址 ) 合成一个记录； 每进入一层递归,就产生一个新的工作记录压入栈顶;每退出一层递归,就从栈顶弹出一个工作记录； 当前活动记录:栈顶记录,指示当前层的执行情况； 当前环境指针:递归工作栈的栈顶指针； 从被调函数返回调用函数的一般步骤： 若栈为空,则执行正常返回； 从栈顶弹出一个工作记录； 将“工作记录”中的参数值、局部变量值赋给相应的变量;读取返回地址； 将函数值赋给相应的变量； 转移到返回地址；"},{"title":"Linux 是什么","date":"2017-03-10T07:34:06.000Z","path":"2017/03/10/What-Is-Linux/","text":"正如上面的问题所述，我们将要了解： Linux 是什么？ 简单来说， Linux 是一个基于 Unix 的开源操作系统。 就像 Windows 或者 Mac OS 一样。 1991 年 10 月 5 日， Linus Torvalds 首次发布 Linux 内核。 Linux 内核是 Linux 系统的一个非常重要的组成部分。目前， Linux 主要用于多种服务器和超级计算机等。它也被用于手机操作系统，比如 Android 操作系统是基于 Linux 内核的。 在早期，Linux 作为一个免费的操作系统被用于基于 Intel ×86 的个人电脑上。因为 Linux 是一个开源操作系统，所以它的源代码可以被修改或使用，也可以在有 GPL（通用公共许可证）这样许可证下被任何人发布。简而言之，如果具备一定知识，知道自己在干什么，那么任何人都可以从 Linux 那儿获得自己的操作系统。正因此，才有了许多 Linux 发行版。 那么， Linux 发行版是什么？ 它是基于 Linux 内核的一个操作系统。它带有用户可以使用的软件集合。更多的，它还包含系统管理包。目前有许多 Linux 发行版。因为我们不能数清目前所有的 Linux 发行版，所以我们来看一下一些有名的版本：Ubuntu、Fedora、Opensuse、Red hat Linux 和 Debian 等是几个非常受欢迎的 Linux 发行版。 Ubuntu， 一个非常受欢迎的 Linux 发行版和第三受欢迎的操作系统 Linux 发行版是一个已经准备好可以在个人电脑上安装的完整包。一旦用户在桌面或者服务器上安装了 Linux 发行版，就可以使用各种现成的软件和应用程序。现在，很多 Linux 发行版都具有很好的图形用户界面（GUI），这使得它们成为 Windows 系统或 Mac 系统的一个很好的替代品。 目前， Linux 发行版在性能、界面、可访问性以及最重要的 - 用户友好性等方面都有了很大的提高。一些发行版比如 Ubuntu 和 Linux mint 等，随着用户数量的一天天增加，赢得了很好的市场地位。 Ubuntu 是紧随 Windows 和 Mac 第三受欢迎的操作系统。 对以上做个总结，那就是 Linux 是一个非常强大的操作系统（是的，它很强大）。日复一日，它将获得更多的用户影响力和声誉。所以，如果你还没有在你的电脑上尝试过使用任何 Linux 系统，那么我建议你尝试一下。我们敢保证， Linux 一定不会让你失望的。 via: http://www.techphylum.com/2014/05/what-is-linux-brief-description.html?m=1 作者：sumit rohankar译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"《Linux 命令行大全》学习笔记 - Part 2","date":"2017-03-05T05:02:11.000Z","path":"2017/03/05/Linux-Command-Line-learning-notes-Part2/","text":"第二部分 配置与环境 Chapter 11 环境 检查环境 1234567 $ printnev : 显示环境变量，可以在后面跟变量名，如： printnev USER$ set : 不带参数时，显示 shell 变量、环境变量和已定义 shell 函数$ echo $variable_name : 查看单个变量的值$ alias : 不带参数，查看别名 一些变量 DISPLAY : 运行图形界面环境时界面的名称 EDITOR : 用于文本编辑的程序名称 SHELL : 本机 shell 名称 HOME : 本机主目录路径名 LANG : 定义了本机语言的字符集和排序规则 OLD_PWD : 先前工作目录 PAGER : 用于分页输出的程序名称，一般为 /usr/bin/less PATH : 以冒号分割的一个目录列表 PS1 : 提示符字符串 1 PWD : 当前工作目录 TERM : 终端类型名称 TZ : 指定本机所处的时区 USER : 用户名 环境建立 login shell 启动文件： /etc/pofile ~/.bash_profile ~/.bash_login ~/.profile non-login shell 启动文件： /etc/bash.bashrc ~/.bashrc ： 用户个人启动文件 修改环境 一般修改 .bashrc 文件，比如设置别名。 激活修改：可以有两种方法：一种是关闭 shell 重新启动；另一种是强制启动，运行命令$ source .bashrc。 123 - $ export : 将环境导入随后要运行的程序中，如 export PATH；- $ alias new_name='command' : 设置别名，保存到 .bashrc 文件中以后永久起效； Chapter 12 VI 简介 启动和退出 12345 - $ vi/vi &lt;file&gt; : 启动；- $ q : 退出；- $ q! : 强制退出； 编辑模式 1234567 - 按&lt;i&gt;键 : 进入插入模式；- 按&lt;ESC&gt;键 ： 返回命令模式；- :w :保存文件（命令模式下）；- :wq :保存并退出； 移动光标（命令模式下） 1234567891011121314151617181920212223242526272829 - L ：右移一位==右方向键；- H ：左移一位==左方向键；- J ：下移一行==下方向键；- K ：上移一行==上方向键；- 数字 0 ：至本行行首；- ^ ：至本行第一个非空字符；- $ ：至本行的末尾；- 小写 w：至下一单词或标点的开头；- 大写 W：至下一单词的开头，忽略标点；- 小写 b：至上一单词或标点开头；- 大写 B：至上一单词开头，忽略标点；- Ctrl+F/Page Down：下翻一页；- Ctrl+B/Page Up：上翻一页；- number+G(大写)：至第number行- G(大写)：至文件最后一行； 基本编辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 添加文本- a ：将光标移动到行尾然后按&lt;a&gt;就可以越过行尾开始编辑；- A ：直接将光标移动到行尾并越过行尾进行编辑；行插入- 小写 o：插入一行，在当前行的下方；- 大写 O：插入一行，在当前行的上方；注：按&lt;ESC&gt;退回命令模式并按&lt;u&gt;可取消上面的行插入操作；u 键可撤回操作，每按一次撤销一次；删除文本- x：当前字符；- nx：当前字符和之后n-1个字符（指定删除字符数）；- dd：当前行；- ndd：当前行和之后n-1行；- dw：当前字符到下一单词的起始；- d$：当前字符到当前行的末尾；- d0：当前字符到当前行的起始；- d^：当前字符到当前行下一个非空字符；- dG：当前行到文件末尾；- dnG：当前行到文件第n行；注：命令d不只是删除文本，而是杂剪切文本，用户每次使用d命令之后，都会复制删除的内容进缓存，然后可以使用p（小写）命令将内容粘贴到光标之后，或使用P(大写)将内容粘贴到光标之前；复制命令- yy：当前行；- nyy：当前行和之后n-1行；- yW：当前字符到下一单词的起始；- y$：当前字符到当前行的末尾；- y0：当前字符到当前行的起始；- y^：当前字符到当前行下一个非空字符；- yG：当前行到文件末尾；- ynG：当前行到文件第n行；合并行- J：合并行； 查找和替换 12345678910111213141516 行内搜索&lt;f&gt; : 行内搜索，比如先后按下 fa 会将光标移到本行下一个出现 a 的地方；输入分号可以重复上一次搜索；搜索整个文件命令 / 可以完成对单词或短语的搜索，比如输入 /line 然后回车，会在文件中搜索字符串 line ;#### 全局搜索和替换:%s/Line/line/g : 将文件中的每一个 Line 替换为 line注： % 确定操作的范围，单独表示从第一行到最后一行，还可具体指定，比如 1,5 表示从第一行到第五行；1,$ 表示从第一行到文件最后一行；s 指定操作为替换操作；/Line/line 为搜索和替换的文本；g 代指全局-global，表示对每一行每一个都替换，如果缺失，只替换每一行的第一个； 编辑多个文件 vi file1 file2 file3... 切换文件：:n 切换到下一个文件；:N 切换回上一个文件；当用户从一个文件切换到另一个文件时，vi 会要求用户先保存对当前文件的修改，若不想保存，可以在命令后面添加感叹号； :buffers 查看正在编辑的文件列表 :buffers 2 切换到第二个文件 :e file 在现有编辑会话中添加另一个文件来进行编辑 文件之间内容复制：先切换到第一个文件:buffers 1，然后复制比如一行 yy，然后切换到第二个文件:buffers 2 ，然后粘贴 p； 插入整个文件先打开一个文件，然后把光标移到要插入的文件前，然后 :r anotherfile ，将把文件内容插入光标前 文件保存 ZZ(大写)：保存并退出:wq 保存并退出w filename 另存为filename Chapter 13 定制提示符 略… Part 2 结束！"},{"title":"链式线性表","date":"2017-03-02T07:58:45.000Z","path":"2017/03/02/Link-List/","text":"线性表的链式表示和实现 线性表的链式存储是指用一组任意的 ( 连续的或不连续的 ) 存储单元存储线性表中的数据元素； 为了正确表示数据元素与其直接后续数据元素之间的逻辑关系，在存储每个元素值的同时，还必须存储指示其直接后继的地址 ( 或位置 )，称为指针 (pointer) 或链 (link)，这两部分组成了链表中的结点； 分类 单链表：每一个结点只包含一个指向直接后继的指针域； 双向链表：每一个结点包含两个指针域,其一指向直接后继,另一指向直接前驱； 循环链表：整个链表的指针域链接成一个或多个环； 双向循环链表：将头结点和尾结点链接起来的双向链表； 为操作方便,总是在链表的第一个结点之前附设一个头结点:头结点的数据域可以不存储任何信息 ( 或存储链表长度等信息 ),头结点的指针域存储指向第一个结点的指针 ( 即第一个结点的存储位置 )。 C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//宏定义#define OK 1#define ERROR 0#define OVERFLOW -1#define LESS -1#define GREATER 1#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量#define LISTINCREMENT 10 //线性表存储空间的分配增量typedef int Status;typedef int ElemType;//结点的类型定义typedef struct Lnode&#123; ElemType data; /* 数据域,保存结点的值 */ struct Lnode *next; /* 指针域 */ &#125;Lnode, LinkList;/* 结点的类型 *///结点赋值LNode *p;p=(LNode*)malloc(sizeof(LNode));p-&gt;data=20; p-&gt;next=NULL ;//创建单链表LinkList *CreateList_L(int n) &#123;// 逆序输入随机生成的 n 个元素的值// 建立带表头结点的单链表 LLinkList *L,*p; int i;// 先建立一个带头结点的空单链表L = (LinkList *)malloc(sizeof(LNode));L-&gt;next = NULL;for (i=n; i&gt;0; --i) &#123;p = (LinkList *)malloc(sizeof(LNode)); // 生成新结点p-&gt;data =random(200);// 随机生成一个 200 以内的数字p-&gt;next = L-&gt;next; L-&gt;next = p; // 插入到表头&#125;return L;&#125; // CreateList_L//单链表的插入Status ListInsert_L(LinkList *L, int i, ElemType e) &#123; // 在带头结点的单链表 L 的第 i 个元素之前插入元素e LinkList *p, *s; p = L; int j = 0; while (p &amp;&amp; j &lt; i-1) &#123;// 寻找第 i-1 个结点度、 p = p-&gt;next； ++j; &#125;// i 小于 1( 导致 j&gt;i-1 成立 ) 或者大于表长 ( 导致 p 为 NULL) if(!p || j &gt; i-1) return ERROR; s = (LinkList *)malloc(sizeof(LNode)); // 生成新结点 s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入 L 中 p-&gt;next = s; return OK;&#125; // LinstInsert_L//单链表的删除Status ListDelete_L(LinkList *L, int i, ElemType *e) &#123;// 在带头结点的单链表 L 中删除第 i 个元素,并由 e 返回其值 int j = 0; LinkList *p,*q; p = L; while (p-&gt;next &amp;&amp; j &lt; i-1) &#123; // 寻找第 i 个结点,并令 p 指向其前趋 p = p-&gt;next; ++j; &#125; // i 小于 1( 导致 j&gt;i-1 成立 ) 或者大于表长 ( 导致 p-&gt;next 为 NULL) if (!(p-&gt;next) || j &gt; i-1) return ERROR; q = p-&gt;next; p-&gt;next = q-&gt;next; // 删除并释放结点 e = q-&gt;data; free(q); return OK;&#125; // ListDelete_L//单链表查找Status GetElem_L(LinkList *L,int i, ElemType *e) &#123;// L 为带头结点的单链表的头指针// 当第 i 个元素存在时,其值赋给 e 并返回 OK ,否则返回 ERROR// 初始化, p 指向第一个结点, j 为计数器 LinkList *p; p = L-&gt;next; int j = 1; while (p &amp;&amp; j&lt;i) &#123; // 顺指针向后查找,直到 p 指向第 i 个元素或 p 为空 p = p-&gt;next; ++j; &#125; if ( !p || j&gt;i ) return ERROR; // 第 i 个元素不存在 *e = p-&gt;data; // 取第 i 个元素 return OK;&#125; // GetElem_L//合并有序链表LinkList *MergeList_L(LinkList *La, LinkList *Lb) &#123;// 合并 两非递减单链表 La 和 Lb ,成新的单链表 Lc , Lc的元素也按值非递减排列。 pa, pb 为两个链表的当前结点。 LinkList *Lc, *pa, *pb, *pc; //pc 为合并后链表的最后一个结点 pa = La-&gt;next; pb = Lb-&gt;next; Lc = pc = La; // 用 La 的头结点作为 Lc 的头结点 while (pa &amp;&amp; pb) &#123; if (pa-&gt;data &lt;= pb-&gt;data) &#123; pc-&gt;next = pa; pc = pa; pa = pa-&gt;next; &#125; else &#123; pc-&gt;next = pb; pc = pb; pb = pb-&gt;next; &#125; &#125; pc-&gt;next = pa ? pa : pb; // 插入剩余段 free(Lb); // 释放 Lb 的头结点 Return Lc;&#125; // MergeList_L 当前链表存在的问题： 链表的表长是隐含的； 若要在链表的最后一个元素之后插入元素,那么要遍历整个链表； 结点的当前位置很重要； 改进的措施： 增加变量,分别表示:表长、表尾、当前位置； 将操作中的参数“位序 i ” 改为“当前位置”； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254 //改进的单链表// 结点类型typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; Link, Position;// 链表类型typedef struct &#123; // head, tail 分别指向头结点和最后一个结点的指针 Link *head, *tail;// current 指向当前被访问的结点的指针// Link *current; // 其初始位置指向头结点// int curpos; // 指示当前指针位置 , 初值为 0 int len;// 指示链表长度&#125; LinkList;//构造新链表LinkList *InitList()&#123; LinkList *L; Link *p; L=(LinkList *)malloc(sizeof(LinkList)); if (!L) return NULL; p=(Link *)malloc(sizeof(LNode)); if(!p) return NULL; L-&gt;len=0; L-&gt;head=L-&gt;tail=p; return L;&#125;// 使得 p 指向 L 的第 i 个结点,并返回 pLink *LocatePos(LinkList *L, int i)&#123; Link *cur; int j=1; cur=L-&gt;head; while(cur &amp;&amp; j&lt;=i) &#123; // 寻找第 i 个结点 cur=cur-&gt;next; j++; &#125; if (!cur) return NULL; return cur;&#125;// 将 s 所指结点插入在链表 L 的 h 所指的结点之后Status InsAfter (LinkList *L, Link *h, Link *s)&#123; if(!L-&gt;head) return ERROR; L-&gt;len++; if (L-&gt;tail==h) L-&gt;tail=s; s-&gt;next=h-&gt;next; h-&gt;next=s; return OK;&#125;//在链表L的第i个结点前插入元素Status ListInsert_L(LinkList *L, int i, ElemType e)&#123; // 在链表 L 的第 i 个结点之前插入元素 e Link *p,*s; int j=0; p=L-&gt;head; while (p &amp;&amp; j&lt;i-1) &#123;// 寻找第 i-1 个结点 p=p-&gt;next;j++; &#125; if(!p || j&gt;i-1) return ERROR; s= MakeNode(e); if (!s) return ERROR; if(L-&gt;tail==p) L-&gt;tail=s; L-&gt;len++; s-&gt;next=p-&gt;next; p-&gt;next=s; return OK;&#125;//单链表运用-一元多项式// 用带头结点的有序链表表示多项式typedef struct node&#123;int c; // 多项式,系数, 可以用 float 类型int e; // 多项式,指数struct node *next;&#125;Polynomial;//创建一元多项式// 输入 m 项的系数和指数,建立表示一元多项式的有序链表PPolynomial *Create(int m)&#123; Polynomial *head,*p,*q; int i;// 生成头结点 p=head=(Polynomial*) malloc(sizeof(Polynomial)); for(i=1;i&lt;=m;i++)&#123; // 依次输入 m 个非零项 q=(Polynomial *)malloc(sizeof(Polynomial)); scanf(“%d %d”,&amp;q-&gt;c,&amp;q-&gt;e); p-&gt;next = q; p=q; &#125; p-&gt;next=NULL; return head;&#125; // Create//多项式相加void Plus(Polynomial *pa,Polynomial *pb)&#123; Polynomial*h,*p1,*p2,*q; h=pa; p1=pa-&gt;next;p2=pb-&gt;next; //p1,p2 分别指向 pa 和 pb 的第一个结点 while(p1!=NULL &amp;&amp; p2!=NULL) switch(Compare(p1-&gt;e, p2-&gt;e)) &#123; case 1: &#123; //p1 所指结点的指数值大,将 p2 的结点连接到 h h-&gt;next=p2; h=p2; p2=p2-&gt;next; break; &#125; case -1: &#123;//p2 所指结点的指数大,将 p1 的结点连接到 h h-&gt;next=p1; h=p1; p1=p1-&gt;next; break; &#125; case 0: &#123; // p1, p2 的指数一样大 if(p1-&gt;c + p2-&gt;c !=0) &#123; // 系数相加,和不为 0 ,修改 p1 的系数 p1-&gt;c =p1-&gt;c +p2-&gt;c; h-&gt;next=p1; h=p1; p1=p1-&gt;next; q=p2; p2=p2-&gt;next; free(q); &#125; else &#123; // 系数相加,和为 0 ,则去掉结点 q=p1;p1=p1-&gt;next;free(q); q=p2;p2=p2-&gt;next;free(q); &#125; Status Compare(int a,int b)&#123; if(a&gt;b) return 1; if(a&lt;b) return -1; return 0; &#125; &#125;&#125; if(p1!=NULL) h-&gt;next =p1; else h-&gt;next= p2; free(pb);&#125;//单链表的 C 数组实现:静态链表#define MAXSIZE 1000typedef struct SLinked&#123;ElemType data;int cur;&#125; SLinkedList[MAXSIZE];SLinkedList s;//静态链表初始化void InitList(SLinkedList space)&#123; for(int i=0;i&lt;MAXSIZE-1;i++) space[i].cur=i+1; space[MAXSIZE-1].cur=0;&#125;// 创建一个含有 n 个结点的静态链表,返回表头在存储数组的位置int CreateList(SLinkedList space,int n)&#123; int head,k,s,i; k=AllocNode(space); // 从空闲链表中取得一个空结点 head=k; for(i=1;i&lt;=n;i++)&#123; s=AllocNode(space); scanf(\"%d\",&amp;space[s].data); space[k].cur=s; k=s; &#125; space[k].cur=0; return head;&#125;//从空闲链表中分配一个结点和释放一个结点// 若空闲链表非空,则返回分配的结点下标,否则返回 0int AllocNode(SLinkedList space)&#123;int i;i=space[0].cur;if(i==0) return 0;space[0].cur=space[i].cur;return i;&#125;// 将下标为 i 的空闲结点回收到备用链表void FreeNode(SLinkedList space,int i)&#123;space[i].cur=space[0].cur;space[0].cur=i;&#125;// 在以 head 为表头的静态链表中,在第 i 个结点之前插入一个值为 x 的新结点int Insert(SLinkedList space,int head,int i,ElemType x)&#123; int j,k,m; if(i&lt;1) return 0; k=head;j=0; while (k!=0 &amp;&amp; j&lt;i-1)&#123; // 查找第 i-1 个结点 j++;k=space[k].cur; &#125; if(k==0) return 0; m=AllocNode(space); // 从空闲链表中获取结点, m 为该结点下标 if (m!=0)&#123; space[m].data=x; space[m].cur=space[k].cur; space[k].cur=m; return 1; &#125; else return 0;&#125;// 在以 head 为表头的静态链表中,删除第 i 个结点int Delete(SLinkedList space,int head,int i, ElemType *e)&#123; int j,k,m; if(i&lt;1) return 0; k=head;j=0; while (k!=0 &amp;&amp; j &lt;i-1)&#123; // 查找第 i-1 个结点 j++;k=space[k].cur; &#125; if(k==0) return 0; m=space[k].cur; space[k].cur=space[m].cur; *e=space[m].data; FreeNode(space,m); return 1;&#125;//在以 head 为表头的静态链表中,确定第 1 个值为 x的结点的位置// 若找到,则返回它在存储数组中的位置,否则返回 0int Locate(SLinkedList space, int head,ElemType x)&#123; int k; k=space[head].cur; // k 指示静态链表中的第一个结点 while(k!=0 &amp;&amp; space[k].data!=x) k=space[k].cur; // 顺链查找 return k;&#125;//集合合并void MergeAB(SLinkedList A, int ha,SLinkedList B, int hb)&#123; int i,j,k,m; ElemType x; j=B[hb].cur; while(j!=0)&#123; // 对 hb 中的每个结点,进行下面的步骤 x=B[j].data; i=Locate(A,ha,x); // 链表 ha 中查找有无 hb 中的元素 if(i==0) Insert(A,ha,1,x); // 将该元素插入 ha ,成为 ha的第一个元素 else &#123; // ha 有 hb 中的元素,则将该元素从 ha 中删除 m=0;k=ha; while(k!=i)&#123; m++;k=A[k].cur; &#125; Delete(A,ha,m,&amp;x); &#125; j=B[j].cur; &#125;&#125; 双向链表：构成链表的每个结点中设立两个指针域,一个指向其直接前趋的指针域 prior ,一个指向其直接后继的指针域 next； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 typedef struct node &#123; ElemType data ; struct node *prior , *next ;&#125; DoubleLinkedList;//创建长度为n的双向链表DoubleLinkedList *CreateDoubleLinkedList(int n)&#123; DoubleLinkedList *head,*p,*s; int i; // 创建头结点 p=head=(DoubleLinkedList *)malloc(sizeof(DoubleLinkedList)); for(i=1;i&lt;=n;i++)&#123; s=(DoubleLinkedList *) malloc(sizeof(DoubleLinkedList)); scanf(\"%d\",&amp;s-&gt;data); s-&gt;prior=p; p-&gt;next=s; p=s; &#125; p-&gt;next= head; head-&gt;prior = p; return head;&#125;//在双向链表中查找第 1 个值为 e 的结点DoubleLinkedList *Locate(DoubleLinkedList *head,ElemType e)&#123; DoubleLinkedList *p; p=head-&gt;next; //p 指向第一个结点 while(p!=head &amp;&amp; p-&gt;data !=e) p=p-&gt;next; if(p==head) return NULL; else return p;&#125;//在双向链表中查找第 1 个值为 e 的结点// 返回指向第 i 个结点的指针DoubleLinkedList *GetElemP(DoubleLinkedList *head,int i) &#123; DoubleLinkedList *p;int j; if(i&lt;1) return 0; p=head-&gt;next; // 初始化, p 指向第一个结点 j=1; //j 为计数器 while(p!=head &amp;&amp; j&lt;i)&#123; // 顺指针向后查找,直到 p 指向第 i 个结点或 p 为空 p=p-&gt;next; j++; &#125; if(p==head &amp;&amp; j&lt;i) return NULL; // 第 i 个元素不存在 return p;&#125;//在双向链表第 i 个结点之前插入元素 eint InsertElem(DoubleLinkedList *head,int i,ElemType e)&#123; DoubleLinkedList *p,*q;int j; if(i&lt;1) return 0; // i 的合法值为 1≤i≤ 表长 +1 p=head;j=0; while(p-&gt;next!=head &amp;&amp; j&lt;i-1)&#123; // 在 L 中确定第 i 个元素的位置指针 p p=p-&gt;next;j++; &#125; if(p-&gt;next!=head || (p-&gt;next == head &amp;&amp; j==i-1))&#123; q=(DoubleLinkedList *)malloc(sizeof(DoubleLinkedList)); q-&gt;data=e; q-&gt;next=p-&gt;next; q-&gt;prior=p; p-&gt;next-&gt;prior=q; p-&gt;next=q; return 1; &#125; else return 0; // 第 i 个元素不存在&#125;//在双向链表中删除第 i 个结点// 当第 i 个结点存在时,删除它并返回其值,否则返回 NULLint DeleteNode(DoubleLinkedList *head,int i,ElemType *e)&#123; DoubleLinkedList *p,*q; int j=0; if(i&lt;1) return 0; p=head-&gt;next; // p 指向第一个结点 while(p != head &amp;&amp; j&lt;i)&#123;// 顺指针向后查找,直到 p 指向第 i 个结点或 p 为空 p=p-&gt;next; j++; &#125; if(p ==head &amp;&amp; j&lt;i ) return 0; // 第 i 个结点不存在 p-&gt;prior-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=p-&gt;prior; *e=p-&gt;data; free(p); return 1;&#125;"},{"title":"顺序线性表","date":"2017-02-28T10:45:44.000Z","path":"2017/02/28/SqList/","text":"线性表（Linear list）定义 线性表是由 n(n&gt;=0) 个数据元素组成的有限序列，且该序列中的所有结点具有相同的数据类型。 线性表的逻辑结构 线性表中的结点可以是单值元素 ( 每个元素只有一个数据项） 线性表中的结点可以是记录型元素 ( 记录 )：每个记录含有多个数据项，每个项称为结点的一个域；每个记录有一个可以唯一标识每个结点的数据项组，称为关键字； 线性表的顺序表示 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素; 用存储位置相邻来表示数据元素之间的有序关系； 顺序线性表的 C 语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//宏定义#define OK 1#define ERROR 0#define OVERFLOW -1#define LESS -1#define GREATER 1#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量#define LISTINCREMENT 10 //线性表存储空间的分配增量typedef int Status;typedef int ElemType;//----线性表动态分配顺序存储结构----typedef struct&#123; ElemType *elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量&#125;SqList;//------构造一个空列表L-------Status InitList_Sq(SqList *L)&#123; L-&gt;elem=(ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType)); if(!L-&gt;elem) exit(OVERFLOW); //存储分配失败 L-&gt;length=0; //空表长度为0 L-&gt;listsize=LIST_INIT_SIZE; //初始存储容量 return OK;&#125;//InitList_Sq//------元素插入-------Status ListInsert_Sq(SqList *L,int i,ElemType e)&#123; //在顺序线性表L的第i个位置之前插入一个新元素e //i的合法值为1&lt;=i&lt;=ListLength_Sq(L)+1 if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; //i值不合法 if(L-&gt;length &gt;=L-&gt;listsize)&#123; //当前存储空间已满，增加分配 ElemType *newbase; newbase=(ElemType *)realloc(L-&gt;elem,(L-&gt;listsize+LISTINCREMENT)*sizeof(ElemType)); if(!newbase) exit(OVERFLOW); //存储分配失败 L-&gt;elem=newbase; //新基址 L-&gt;listsize+=LISTINCREMENT; //增加存储容量 &#125; ElemType *p,*q; q=&amp;(L-&gt;elem[i-1]); //q为插入位置 for(p=&amp;(L-&gt;elem[L-&gt;length-1]);p&gt;=q;--p) *(p+1)=*(p); //插入位置及之后元素右移 *q=e; //插入e ++L-&gt;length; //表长增1 return OK;&#125;//ListInsert_Sq//------元素删除------Status ListDelete_Sq(Sqlist *L,int i,ElemType *e)&#123; //删除第i个元素，并用e返回其值 if(i&lt;1||i&gt;L-&gt;length) return ERROR;//i值不合法 ElemType *p,*q; p=&amp;(L-&gt;elem[i-1]); //p 为被删除元素的位置 *e=*p; //被删除元素赋给p q=L-&gt;elem+L-&gt;length-1; //表尾元素的位置 for(++p;p&lt;=q;++q) *(p-1)=*p; //被删除元素之后元素左移 --L-&gt;length; return OK;&#125;//ListDelete_Sq//--------元素查找-----Status LocateElem_Sq(Sqlist *L,ElemType e,Status (*compare)(ElemType, ElemType))&#123; int i=1; //第一个元素的位序 ElemType *p=L-&gt;elem; while(i&lt;=L-&gt;length&amp;&amp;(*compare)(*p++,e)) ++i; if(i&lt;=L-&gt;length) return i; else return 0;&#125;//LocateElem_SqStatus (*compare)(ElemType a, ElemType b)&#123; if (a&lt;b) return LESS; if (a&gt;b) return GREATER; return 0;&#125;//-----顺序表的合并-------void MergeList_Sq(SqList *La,SqList *Lb,SqList *Lc)&#123; //已知顺序线性表La和Lb的元素按值非递减排列 //归并La和Lb得到新的顺序线性列表Lc,Lc也按非递减排列 ElemType *pa,*pb,*pc,*pa_last,*pb_last; pa=La-&gt;elem; pb=Lb-&gt;elam; Lc-&gt;listsize=Lc-&gt;length=La-&gt;length+Lb-&gt;length; pc=Lc-&gt;elem=(ElemType *)malloc(Lc-&gt;listsize*sizeof(ElemType)); if(!Lc-&gt;elem) exit(OVERFLOW); //存储分配失败 pa_last=La-&gt;elem+La-&gt;length-1; pb_last=Lb-&gt;elem+Lb-&gt;length-1; while(pa&lt;=pa_last&amp;&amp;pb&lt;pb_last)&#123; if(*pa&lt;=*pb) *pc++=*pa++; else *pc++=*pb++; &#125;//归并 while(pa&lt;=pa_last) *pc++=*pa++; //插入La的剩余元素 while(pb&lt;=pb_last) *pc++=*pb++; //插入Lb的剩余元素&#125;//MergeList_Sq//-------打印列表-----void PrintList(SqList L)&#123; for(int i=0;i&lt;L-&gt;length;i++)&#123; printf(\"%d\\t\",l-&gt;elem+i);//L-&gt;elem为首位置 &#125; printf(\"\\n\");&#125;"},{"title":"《Linux 命令行大全》学习笔记 - Part 1","date":"2017-02-03T13:12:16.000Z","path":"2017/02/03/Linux-Command-Line-learnig-notes-Part1/","text":"前言 因对 Linux 命令行的喜爱，故入手《Linux 命令行大全》一书，打算从头至尾阅读、学习一遍，并将书中每一章节的命令集中整理如下。 第一部分：学习 shell Chapter 1 学习 shell $ date : 显示当前系统的时间和日期 $ cal : 显示日历 $ df : 查看磁盘驱动器可用空间 $ free : 显示可用内存 $ exit : 关闭终端窗口 Chapter 2 导航 $ pwd : 显示当前工作目录 $ ls : 列出当前工作目录的文件和目录 $ cd : 更改当前工作目录（路径名） 绝对路径名： 从根目录开始，通向目标目录 相对路径名： 从工作目录开始，通向目标目录 .. : 代表工作目录的父目录 . : 代表工作目录 $ cd .. : 进入工作目录的父目录 $ cd : 将工作目录变成主目录 $ cd - : 将工作目录变成先前工作目录 $ cd ~username : 将工作目录变成 username 的主目录 注：以 . 字符开头的文件名是隐藏的，用 ls 命令无法列出；如需列出，需使用 ls -a 命令（ls 和 -a 之间有空格）。 Chapter 3 Linux 系统 $ ls : 列出可见文件和目录 ls 命令选项 -a : 列出所有文件和目录（包括被隐藏的） -d : 查看目录信息，不列出目录内容（在指定了目录的情况下） -F : 在列出的名字后面加上类型指示符 -h : 以长格式列出，以可读方式显示文件大小 -l : 使用长格式显示结果 -r : 以降序显示结果（默认以升序显示） -S : 按文件大小排序 -t : 按修改时间排序 $ file filename : 文件类型简单说明 $ less filename : 查看文件内容(按 q 退出) less 命令的一些功能键 向下箭头键 : 向下一行 G : 跳转到文本尾 g : 跳转到文本头 /charecters: 向前查找指定字符串 n : 向前查找下一个之前的指定字符串 h : 显示帮助屏幕 q : 退出 less 命令、 注：命令行中复制粘贴文件的方法：双击文件名复制，中键单击将可将其粘贴进命令行 Chapter 4 操作文件和目录 通配符 * : 匹配任意多个字符 ? : 匹配任意单个字符 [charecters] : 匹配任意一个属于字符集中的字符 [!charecters] : 匹配任意一个不属于字符集中的字符 [[:class:]] : 匹配任意一个属于指定字符类中的字符 常用字符集 [:alnum:] : 匹配任意一个字母或数字 [:alpha:] : 匹配任意一个字母 [:digit:] : 匹配任意一个数字 [:lower:] : 匹配任意一个小写字母 [:upper:] : 匹配任意一个大写字母 创建目录 $ mkdir dir1/mkdir dir1 dir2 dir3 : 创建目录 复制文件 $ cp item1 item2 : 将单个文件或目录 item1 复制到文件或目录 item2 中 $ cp item… directory : 将多个项目（文件或目录）复制进一个目录中 cp 命令选项 -a : 复制文件和目录及其属性 -i : 在覆盖一个已存在文件前，提示用户确认 -r : 递归复制目录及其内容 -u : 当将文件从一个目录复制到另一个目录时，只复制目标目录中不存在的文件或更新文件 -v : 复制文件时，显示信息性消息 移动/重命名文件 $ mv item1 item2 : 将文件（目录） item1 移动（重命名）为 item2 $ mv item… directory : 将一个或多个条目从一个目录移动到另一个目录下 mv 命令选项 -i : 覆盖一个已存在文件前，提示用户确认 -u : 将文件从一个目录移动到另一个目录，只移动目标目录中不存在的文件或更新文件 -v : 移动文件时显示信息性消息 删除文件和目录 $ rm item… : 删除一个或多个文件或目录 rm 命令选项 -i : 删除一个已存在文件前，提示用户确认 -r : 递归删除目录 -f : 忽略不存在的文件并无需提示确认（该选项会覆盖 -i 选项） -v : 删除文件时显示信息性消息 创建链接 $ ln file link : 创建硬链接 $ ln -s item link : 创建符号链接 注：硬链接： 一个文件的一个或多个文件名，与文件本身无区别，多个文件，均指向同一硬盘地址，会同步更新。符号链接： 又称软链接，一类特殊文件，该文件包含另一文件的路径名，类似 Windows 的快捷方式。 Chapter 5 命令的使用 命令的四种情况 可执行程序 shell 内置命令 shell 函数 alias 命令 显示命令类型 $ type command : 查看命令类型 显示可执行程序位置 $ which pragram : 查看程序位置 获取 shell 内置命令的帮助文档 $ help command : 获取帮助文档，如： help cd 显示命令使用信息 $ command –help : 显示命令使用信息，如： mkdir –help 显示程序的手册页 $ man program : 显示程序手册页 man 手册文档的组织结构 1 : 用户命令 2 : 内核系统调用的程序接口 3 : C 库函数程序接口 4 : 特殊文件 5 : 文件格式 6 : 游戏和娱乐 7 : 其他杂项 8 : 系统管理命令另一种查询方式： $ : man section search_term 比如： man 5 passwd $ apropos command : 显示合适命令，搜索参考条目 $ whatis command : 显示命令的简要描述 显示程序的 info 条目 $ info/info command info 命令 ? : 显示命令帮助 PAGE UP/BACKSPACE : 返回上一页 PAGE DOWN/Spacebar : 翻到下一页 n : 显示下一个节点 p : 显示上一个节点 u : 显示目前显示节点的父节点 ENTER : 进入光标所指的超链接 q : 退出 系统软件包文档文件存放位置： /usr/share/doc 使用别名创建自己的命令 tip : 将多条命令输在同一行中： command1;command2;command3… 创建别名： $ alias name=’command_string’如： alias foo=’cd/usr;ls;cd -‘，则之后就可以用 foo 表示等号后面的命令，可以用 type 命令查看。 删除别名： $ unalias name如： unalias foo ，现在别名就消失了。 Chapter 6 重定向 标准输出重定向 $ command &gt; filename : 将命令的输出结果保存到文件 filename 中 注：若文件不存在，则会创建一个新文件；若文件存在，会从文件开始的地方写入，即会覆盖之前的文件内容，因此，可通过重定向清除文件内容或创建新文件，方法如下： $ &gt; filename : 文件存在则清除了文件内容；文件不存在则创建了一个新文件 （另一重定向符）从文件尾追加输出内容： $ : command &gt;&gt; filename : 命令可以为空；当文件不存在时，和 &gt; 作用相同 标准错误重定向 文件描述符 0 : 标准输入文件 1 : 标准输出文件 2 : 标准错误文件 $ command 2&gt; filename : 将文件描述符紧放在重定向符前面即可将标准错误重定向 stdout 和 stderr 重定向到同一个文件 有两种方法可完成该任务： $ command &gt; filename 2&gt;&amp;1 : 旧版本 shell $ command &amp;&gt; filename : 最近的 bash 版本 处理不想要的输出 将输出重定向到文件 ‘/dev/null’ 中： $ command &gt; /dev/null 或 command 2&gt; /dev/null : 该文件接受输入但不对输入做任何处理 标准输入重定向 cat - 合并文件 $ cat filename : 读取、显示文件内容 $ cat : 后面不跟参数时，它从标准输入读取内容，默认情况下即等待键盘输入 cat 可拼接文件，假设有文件 file.001，file.002，…file.099，要拼接成一个文件 file ，可执行命令： $ cat file.0* &gt; file ：将按顺序拼接文件 $ cat &gt; filename : 从键盘输入内容到文件 filename 中 $ cat &lt; filename : 将标准输入源从键盘变为 filename 管道 $ command1 | command2 : 将 command1 的标准输出传送到 command2 的标准输入中 过滤器 sort : 排序列表 同时多个命令，如： $ ls -l | sort | less : 产生一个排好序的列表 uniq : 报告或忽略文本中重复的行如： $ ls -l | sort | uniq | less : 删除 sort 命令的输出中任意重复的行 wc : 打印行数、字数和字节数 $ wc filename : 依次打印出行数、字数和字节数 多命令，如： $ ls | sort | uniq | wc -l : -l 选项限制命令只报告行数 grep : 打印匹配行 grep pattern file : 打印出所有包含 pattern 的行 多命令，如： $ ls -l | grep zip : 打印出所有包含 zip 的行 grep 选项 -i : 忽略大小写，默认情况下区分大小写 -v : 输出不匹配行 head/tail : 打印文件的开头部分（前 10 行）/结尾部分（后 10 行）可用 ‘-n’ 选项调整行数，命令格式为： $ head/tail -n line_number filename : 输出文件的开头或结尾 line_number 行内容 命令选项也可用于管道中： $ ls | tail -n 5 tail 命令的 ‘-f’ 选项： 实时查看内容，如： $ tail -f /var/logg/messages : 持续监视该文件，一旦添加新行，新行立即显示在屏幕上 tee :从 stdin 读取数据，并同时输出到 stdout 和文件中如： $ ls | tee ls.txt : 将整个目录列表输入到 ls.txt 文件中 Chapter 7 透过 Shell 看世界 扩展 $ echo command : echo 把文本参数打印到标准输出 注：在每次输入命令 ENTER 键时， bash 都会在执行命令前对文本进行多重处理，称为扩展。 路径名扩展 example: $ echo charecter** : 显示以字符 charecter* 开头的所有文件 $ echo *charecter : 显示以字符 charecter 结尾的所有文件 $ echo [[:upper:]]* : 显示所有以大写字母开头的文件 波浪线扩展 ~ : 当把波浪线用在单词的开头，它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录 example: $ echo ~fenglv : 扩展为用户 fenglv 的主目录 算数扩展 shell 支持通过扩展来运行算数表达式，因此可把 shell 提示符当计算器使用： $ echo $((2+2)) : 在标准输出打印出 4;扩展的格式为： $((expression)) 算数运算符 : 加 : 减 : 乘 / : 除 % : 取余 ** : 取幂 注： 表达式可嵌套：echo $(($((52)) * 3))，可改写为：echo $(((52) * 3)) 花括号扩展 花括号扩展的模式信息包括前导字符和附言，最普遍应用为创建一系列的文件和目录。example: $ echo Front-{A,B,C}-BackFront-A-Back Front-B-Back Front-C-Back $ echo Number_{1..5}Number_1 Number_2 Number_3 Number_4 Number_5 $ mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12} $ ls2009-01 2010-01 2011-012009-02 2010-02 2011-02. . .2009-12 2010-12 2011-12 参数扩展 $ echo \\$variable : 触发参数扩展，显示变量内容 $ printenv | less : 查看变量列表 命令替换 命令替换可以把一个命令的输出作为一个扩展模式使用： example: $ echo \\$(ls) : 打印出文件和目录 $ ls -l \\$(which cp) : 显示 cp 所在目录的长信息， which cp 命令的运行结果作为了 ls 命令的一个参数 $ file \\$(ls /usr/bin/* |grep zip) : 管道输出作为 file 的参数 引用 shell 提供了一种引用机制，有选择性的避免不想要的扩展。 example: $ echo this(多空格) is a test: 打印时会除去多余的空白 $ echo The total is \\$100.00 : 打印结果为： The total is 00.00；\\$1 为未定义变量，故被替换为空字符。 双引号 如果把文本放在双引号中，那么特殊字符均会失效（\\$(美元符号)、\\ (反斜杠)、’(反引号) 三者除外）。可用双引号阻止单词分割： $ ls -l two book.txt : 会被当成两个参数，显示错误正确命令： $ ls -l “two book.txt” 注： 参数扩展、算数扩展和命令替换在双引号中依然起用 无引号时，空格、制表符、以及换行均只被当做分割符，但如果加上引号，就变成参数的一部分 单词分割机制会把换行符当成界定符：注意下面两个命令个输出的区别$ echo \\$(cal)$ echo “\\$(cal)” 单引号 单引号会抑制所有的扩展，在单引号中所有的字符都会变成普通字符。 转移字符 当要引用单个字符时，可通过在字符前加反斜杠来实现：（与 C 语言类似） 注： echo 中加 ‘-e’ 选项可以解释转义字符 $ sleep 10 : 等待 10 s(和 C 语言中类似) Chapter 8 高级键盘技巧 编辑命令行 bash 使用了一个名为 Readline 的库，来实现命令行的编辑。 光标移动组合键 Ctrl+A : 移动光标到行首 Ctrl+E : 移动光标到行尾 Ctrl+F : 光标向前移动一个字符＝＝右箭头键 Ctrl+B : 光标向后移动一个字符＝＝左箭头键 Alt+F : 光标向前移动一个字 Alt+B : 光标向后移动一个字 Ctrl+L : 清屏并把光标移到左上角＝＝clear 修改文本 Ctrl+D : 删除光标处的字符 Ctrl+T : 使光标处的字符和它前面的字符对调位置 Alt+T : 使光标处的字和它前面的字对调位置 Alt+L : 把从光标到字尾的字符转换为小写字母形式 Alt+U : 把从光标到字尾的字符转换为大写字母形式 剪切和粘贴 Readline 文档中使用 killing 和 yanking 来指代剪切和粘贴，被剪切内容被放在叫做 king-ring 的缓冲区中。 Ctrl+K : 剪切从光标到行尾的文本 Ctrl+U : 剪切从光标到行首的文本 Alt+D : 剪切从光标到当前词尾的文本 Alt+BACKSPACE: 剪切从光标到词头的文本；如果光标在词头，则剪切前一个单词 Ctrl+Y : 把被剪切到缓冲区中的文本粘贴到光标位置 注：Alt 键相当于元键，按下并释放 Esc 键等同于长按 Alt 键。 自动补全 输入一部分命令后按下 Tab 键，会自动补全当补全内容唯一时。自动补全可针对变量、用户名、命令和主机名等。 两个 Tab : 显示所有可能的补全列表＝＝Alt+$ Alt+* : 插入所有的匹配项 使用历史命令 bash 会保存使用过的命令的历史记录，这些命令的历史记录列表会被保存在用户主目录的 .bash_history 文件中。 搜索历史命令 $ history | less : 查看历史记录的内容列表 默认情况下， bash 会保存用户最近使用过的 500 个命令。 $ history | grep /usr/bin : 找出用来列出 /usr/bin 目录下内容的命令 历史记录命令 Ctrl+P : 移动到前一条历史记录＝＝向上箭头键 Ctrl+N : 移动到后一条历史记录＝＝向下箭头键 Alt+&lt; : 移动到历史记录列表的开始处 Alt+&gt; : 移动到历史记录列表的结尾处，即当前命令行 Ctrl+R : 逆向递增搜索。从当前命令行向前递增搜索 Alt+P : 逆向非递增搜索。按下该组合键，接着输入待搜索字符串，然后按下 Enter 键，才开始搜索 Alt+N : 向前非递增搜索 Ctrl+O : 执行历史记录中的当前项，执行完跳转到下一项 历史记录扩展 $ !! : 重复最后一个执行的命令＝＝先按向上箭头键，再按 Enter 键；后者更简单 $ !number : 重复历史记录中第 number 行的命令 $ ! string : 重复最近以 string 开头的历史记录 $ !?string : 重复最近包含 string 的历史记录 注： Linux 中包含一个 script 程序，该程序记录下 shell 的整个会话并将会话保存到一个文件中，基本语法如下： $ script file : 不指定文件时，默认使用文件 typescript 。 Chapter 9 权限 所有者、组成员和其他所有用户 $ id : 查看用户身份标示的相关信息 读取、写入和执行 当以 ls -l 命令列出文件时，前 10 个字符表示文件属性： 1 : 文件类型 2~4 : 所有者权限 5~7 : 组权限 8~10 : 其他用户权限 文件类型 - : 普通文件 d : 目录文件 l : 符号链接 c : 字符设备文件 b : 块设备文件 权限属性 r : 允许打开和读取文件 w : 允许写入或截短文件，但不允许重命名和删除 r : 允许执行文件 更改文件模式 我们可以使用 chmod 命令来更改文件或目录的模式（权限），但需要注意的是只有文件所有者或者超级用户才能进行更改。 文件模式的八进制和二进制表示法(八进制/二进制：文件模式) 0/000 : — 1/001 : –x 2/010 : -w- 3/011 : -wx 4/100 : r– 5/101 : r-x 6/110 : rw- 7/111 : rwx 可以用三位八进制数字分别设置文件所有者、组成员和其他所有用户的文件权限，如： $ chmod 603 file : 6 表示文件所有者权限；0 表示组成员权限；3 表示其他所有用户权限 符号表示法 chmod 支持符号表示法来指定文件模式。该表示法分为三部分：更改会影响谁、要执行哪个操作以及要设置哪种权限。 u : 表示目录或目录的所有者（user） g : 文件所属群组（group） o : 其他所有用户（other） a : all 简写，以上三者组合 注： 如果没有指定字符，则假定使用 ‘all’; 操作符 ‘+’ 表示添加一种权限； 操作符 ‘-‘ 表示删除一种权限； “=” 表示只有指定的权限可用，其他所有的权限都被删除；example: $ chmod u+x file : 为文件所有者添加可执行权限 $ chmod +x file : 为所有用户添加可执行权限 $ chmod o-rw file : 删除其他所有用户的读写权限 $ chmod u+x,go=rx file : 为文件所有者添加执行权限，同时设置所属群组和其他所有用户具有读权限和可执行权限（指定多种权限时，需用逗号隔开，除逗号外，权限之间不能有空格） 采用 GUI 设置文件模式 右键 － propeties － 进行相关设置更改 使用 umask 命令设置默认权限 umask 命令控制着创建文件时指定给文件的默认权限，它使用八进制表示法来表示从文件模式属性中删除一个位掩码。？ $ umask xxxx : 设置默认权限（xxxx 为四个八进制数字） 四位八进制数，展开成二进制后，对应的文件模式上， 1 出现的位置的权限被隐去/除(不常用)。 更改身份 转化身份的三种方法： 注销系统然后以其他用户身份登录 使用 su 命令 使用 sudo 命令 su - 以其他用户和组 ID 的身份来运行 shell $ su -1 user : 以指定用户 user 来登录 shell 界面，指定用户的 shell 运行环境将被加载；-1 选项常写为 - ，且后者更常用 $ su - : 进入超级用户，需要输入超级用户的密码（结束时输入 exit 退出） $ su -c ‘command’ : 使用执行单个命令，必须要有单引号 sudo - 以另一个用户的身份执行命令 sudo 在很多方面和 su 类似；其中，管理员可以通过配置 sudo 命令，使系统以另一种可控的方式，允许一个普通用户以一个不同的身份（通常是超级用户）执行命令；另外，使用 sudo 命令并不需要输入超级用户密码，用户只需要输入自己的命令来认证。 $ sudo -s : 进入超级用户，需要输入用户自己的密码（同样 exit 退出） $ sudo command : 以超级用户执行命令 $ sudo -l : 查看 sudo 命令可以授予哪些权限 注： su 和 sudo 还有一个不同的地方，su 执行命令时命令是传递到另一个 shell 中执行，因此命令需要用单引号引起来，而 sudo 执行命令时不需要启动一个新的 shell ，因此不需要引号。 chown - 更改文件所有者和所属群组 chown 命令用来更改文件或者目录的所有者和所属群组，使用这个命令需要超级用户权限。 chown 的语法： $ chown owner:group file : 即把文件所有者改为用户 owner，改为属于群组 group;可以直接在前面加 sudo 来执行，参数 owner 和 group 可以为空 chgrp - 更改所属群组 早些时候，chown 只能用来更改所有者，所以更改所属群组要使用命令 chgrp； 该命令的使用方法和 chown 几乎一样，但限制多一些（不常用）。 更改用户密码 $ passwd : 当输入该命令以后， shell 会提醒用户输入旧密码和新密码 该命令有一个很有趣的地方，它会试着强迫用户输入一个“强”密码，因此，它会拒绝短密码、与之前密码相似密码、字典中单词或容易猜到的密码。？在 Ubuntu 系统上测试时发现并非如此机智！！！？ Chapter 10 进程 现代操作系统通常都支持多重任务处理（multitasking）。多重任务处理是指系统通过快速切换运行中的程序来实现多任务的同时执行。 Linux 内核通过进程来管理多重任务。进程是 Linux 用来安排不同程序等待 CPU 调度的一种阻止方式。 进程如何工作 系统启动 － 程序初始化（init）－ 脚本初始化（init script） ps - 查看进程信息 $ ps : 查看进程信息 $ ps x : 显示所有进程 ps x 命令的输出中会有一个新的项： STAT，它是 state 的缩写，表示进程状态： R : 运行状态 S : 睡眠状态 D : 不可中断的睡眠状态 T : 暂停状态 Z : 无效状态 &lt; : 高优先级状态；被赋予更多重要性，分配更多 CPU 时间 N : 低优先级状态 $ ps aux : 显示更多信息 ps aux 的显示信息项（列标题）： USER : 用户 ID，表示进程所有者 %CPU : CPU 使用百分比 %MEM : 内存使用百分比 VSZ : 虚拟耗用内存大小 RSS : 实际使用内存大小 START : 进程开启的时间 top - 动态查看进程信息 ps 命令只是显示 ps 命令执行时刻的进程信息；要查看动态视图，可以使用 top 命令： $ top top 命令以列表形式持续更新进程的当前信息；主要用于查看系统“最高”进程的运行情况；top 命令显示的信息包含两部分：总体＋个体； top 命令的两个常用键盘指令： h : 显示程序的帮助界面 q : 退出命令 注： top 命令输出的信息和 Windows 的任务管理器的运行方式类似，但 top 命令运行的更快，消耗资源要少得多。 控制进程 中断进程 $ xlogo : 显示 logo Ctrl+C : 中断程序 使进程在后台运行 $ app &amp; : 程序 app 将在后台运行，输出显示： [number1] number2 ，其中，number1 为作业编号，Number2 为 PID ? $ jobs : 查看从终端启动的所有作业 使进程回到前台运行 后台运行的进程不会受到任何键盘输入的影响，包括视图中断进程的 Ctrl+C ；要想使进程回到前台来运行，可使用 fg 命令来实现： $ fg %number1 : 即 fg 后面跟百分号和作业编号，两者之间没空格，运行该命令后再按 Ctrl+C 即可结束进程 停止（暂停）进程 当一个进程运行以后，按下 Ctrl+Z 可以暂停进程，比如先在终端启动 xlogo ，然后在按下该组合键，进程就暂停了； 使用 fg (上) 命令可使暂停进程回到前台运行； 使用 bg 命令可使暂停进程到后台运行， bg 命令的语法和 fg 命令相同； 信号 $ kill PID : 终止进程， PID 即为上面的 Number2，也可用 \\$ kill %number1 来终止 使用 kill 命令发送信号到进程 kill 语法： $ kill -signal_number/-signal_name PID/%number1 : signal_number 为信号编号； signal_name 为信号名； 如果不指定信号，则默认发送 TERM（终止）信号。 常用信号： 信号编号：信号名：含义 1 : HUP : 挂起信号 2 : INT : 中断信号 9 : KILL : 杀死信号 15 : TERM : 终止信号 18 : CONT : 继续运行信号 19 : STOP : 暂停信号 注：进程也有所有者，只有进程所有者或超级用户才能使用 kill 命令来给进程发送信号。 其他常用信号： 3 : QUIT : 退出信号 11 : SEGV : 段错误信号 20 : TSTP : 终端暂停信号 28 : WINCH : 窗口改变信号 查看完整的信号列表： $ kill -l 使用 kill 命令发送信号给多个进程 使用 killall 命令可以给指定程序或指定用户的多个进程发送信号；语法如下： $ killall -u user -signal name… 可以有缺省。 注： killall 命令同样需要有超级用户特权。 更多与进程相关的信号 其他与进程相关的命令： pstree : 以树状模式输出进程列表 vmstat : 输出系统资源使用情况的快照，包括内存，交换空间和磁盘 I/O xload : 用来绘制显示系统时间负载情况图形的一种图形化界面程序 tload : 类似 xload ，但图形在终端绘制 Part 1 结束！"},{"title":"3 个针对高级用户的 Vim 编辑器实用技巧","date":"2017-01-27T10:33:13.000Z","path":"2017/01/27/3-Vim-Tricks-for-Advanced-Users/","text":"这篇文章是 Vim 用户指南系列文章中的一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 技巧 3 个针对高级用户的 Vim 编辑器实用技巧 毫无疑问， Vim 是一个很强大的文本编辑器。它提供了大量的特性，这意味着学习并记住 Vim 的所有功能实际上是不可能的。但是我们至少可以不断学习简单的方法来完成事情，从而随着时间的增长，我们使用编辑器的经验将会变得更好。 请记住，在这篇文章中我们将讨论的一些 Vim 编辑器技巧是针对高级用户的。 注：如果你是第一次接触 Vim，你可以首先阅读我们的入门指南。对于已经使用过 Vim 编辑器的用户，我确信 Vim 快捷键速查表将会对你很有帮助。如果你已经是一名有经验的用户，你可能对 一些针对有经验用户的技巧比较感兴趣。 请注意文中提到的所有技巧绝大多数都是在简单、易于理解的代码环境中进行阐述的，因为它们在软件开发中确实很实用。但这并不意味着普通用户(非程序员、没有把 Vim 作为一般的文本编辑器)在他们的工作中用不到。 1、为文件设置特定的变量 有时候，在一个特定文件中，你可能想把输入的制表符用空格代替，或者想要把源代码文件使用两个空格缩进，即便编辑器的默认缩进是四个空格。 基本上我们在这儿讨论对针对文件的的更改。 Vim 提供的这个特性允许你对一个指定的文件更改特定的设置。这个特性叫做 “模式行（Modeline）” 。 比如，如果你想把输入的每一个制表符（Tab）用空格代替，那么你只需要在文件的前几行或最后几行加入下面的模式行： 1 # vim: set expandtab: 如果想把默认缩进从 4 个空格变成 2 个空格，可以在源文件中添加下面的模式行： 1 // vim: noai:ts=2:sw=2 在使用模式行时，请记住下面这几个重要的点： 模式行只能添加在文件中的前五行或者最后五行。 为了使用模式行这个特性，必须在 .vimrc 文件中添加 :set modeline 。 在以 root 用户身份对文件进行编辑的时候该特性失效。 了解更多的信息，请阅读该特性的官方文档。 2、 关键字补全 当你开始写的复杂代码越来越多或者开始在一个大的源文件上编辑时，你会遇到一些变量名字。有时，要记住所有的变量名字不太容易，所以当需要输入变量名字的时候，你通常从已经使用过的地方复制过来。 幸运的是，使用 Vim 你只需要输入变量的几个起始字母即可。在’插入模式’中，按 Ctrl + n 或者 Ctrl + p 可以得到一个匹配的关键词列表。 Ctrl + n 用来插入下一个匹配词； Ctrl + p 给出一个之前匹配的关键词列表。 下图是该特性的一个展示： 正如上面的屏幕截图清晰展示的那样，列表中也会出现其他源文件中包含的词。关于该特性的更多信息，请访问这儿。 3、 搜索 假设你正在调试代码，其中一个需要做的工作是快速查看一个变量在一个文件中所有出现的地方。一个常用的方法是退出‘插入模式’，输入 /[变量名字] 命令，按回车 ，然后返回‘插入模式’，使用 n 和 p 在关键字之间导航。 上面讲到的这种方法没毛病，但是还有一种更简单、更快捷的方法可以来完成这样的搜索。使用这种方法，首先你需要退出‘插入模式’，然后把光标移动到你想要搜索的词/变量下面，这并不费时。接下来，你只需要按 Shift + * 即可。 重复这样做，然后编辑器将会带你找到在文件中所有使用了这个词/变量的地方。 结论 尽管是针对高级用户，但文章中讨论的这些技巧并不难理解，也比较容易使用。如果你具有一定的基础，那么你能够从中获益很多。不必多说，无论是任何新特性或观念，你需要勤于练习这些技巧才能够把它们变成一种习惯。 via: https://www.maketecheasier.com/vim-tips-tricks-advanced-users/ 作者：Himanshu Arora译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"5 个针对有经验用户的 Vim 实用技巧","date":"2017-01-26T10:30:05.000Z","path":"2017/01/26/5-Practical-Skills-of-Vim-for-Experienced-Users/","text":"这篇文章是 Vim 用户指南系列文章中的一篇： Vim 初学者入门指南 Vim 快捷键速查表 5 个针对有经验用户的 Vim 实用技巧 3 个针对高级用户的 Vim 编辑器实用技巧 Vim 编辑器提供了很多的特性，要想全部掌握它们很困难。然而，花费更多的时间在命令行编辑器上总是有帮助的。毫无疑问，和 Vim 用户们进行交流能够让你更快地学习新颖有创造性的东西。 注： 本文中用到的例子，使用的 Vim 版本是 7.4.52 。 1、 同时编辑多个文件 如果你是一名软件开发者或者把 Vim 作为主要的编辑器，那么可能很多时候你需要同时编辑多个文件。“紧跟（following）”是在同时编辑多个文件时可用的实用技巧。 不需要在多个 shell 界面中打开多个文件，你可以通过把多个文件的文件名作为 Vim 命令的参数从而在一个 shell 界面中打开多个文件。比如： 1 vim 文件1 文件2 文件3 第一个文件（例子中的文件1）将成为当前文件并被读入缓冲区。 在编辑器中，使用 :next 或 :n 命令来移动到下一个文件，使用 :prev 或 :N 命令返回上一个文件。如果想直接切换到第一个文件或最后一个文件，使用 :bf 和 :bl 命令。特别地，如果想打开另外的文件并编辑，使用 :e 命令并把文件名作为参数（如果该文件不在当前目录中则需要完整路径做为参数）。 任何时候如果需要列出当前打开的所有文件，使用 :ls 命令。看下面展示的屏幕截图。 注意 ”%a” 表示文件在当前活动窗口，而 “#” 表示上一个活动窗口的文件。 2、 通过自动补全节约时间 想节约时间并提高效率吗？使用缩写吧。使用它们能够快速写出文件中多次出现、复杂冗长的词。在 Vim 中缩写命令写就是 ab 。 比如，当你运行下面的命令以后： 1 :ab asap as soon as possible 文件中出现的每一个 asap 都会被自动替换为 as soon as possible ，就像你自己输入的一样。 类似地，你可以使用缩写来更正常见的输入错误。比如，下面的命令 1 :ab recieve receive 将会自动更正拼写错误，就像你自己输入的一样。如果在一次特殊情况下你想阻止缩写展开或更正发生，那么你只需要在输入一个单词的最后一个字母以后按 Ctrl + V ，然后按空格键。 如果你想把刚才使用的缩写保存下来，从而当你下次使用 Vim 编辑器的时候可以再次使用，那么只需将完整的 ab 命令(没有起始的冒号)添加到 /etc/vim/vimrc 文件中。如果想删除某个缩写，你可以使用 una 命令。比如： una asap 。 3、 切分窗口便于复制/粘贴 有时，你需要从一个文件将一段代码或文本的一部分复制到另一个。当使用 GUI（图形界面）编辑器的时候，这很容易实现，但是当使用一个命令行编辑器的时候，这就变得比较困难并且很费时间。幸运的是， Vim 提供了一种高效、节约时间的方式来完成这件事。 打开两个文件中的一个然后切分 Vim 窗口来打开另一个文件。可以通过使用 split 命令并以文件名作为参数来完成这件事。比如： 1 :split test.c 上面的命令将分离窗口并打开文件 “test.c” 注意到 split 命令水平分离 Vim 窗口。如果你想垂直分离窗口，那么你可以使用 vsplit 命令。当同时打开了两个文件并从一个文件中复制好内容以后，按 Ctrl + W 切换到另一个文件，然后粘贴。 4、 保存一个没有权限的已编辑文件 有时候当你对一个文件做了大量更改以后才会意识到你对该文件仅有 只读 权限。 虽然把文件关闭，获取权限以后再重新打开是一种解决方法。但是如果你已经做了大量更改，这样做会很浪费时间，因为在这个过程中所有的更改都会丢失。 Vim 提供了一种方式来处理这种情况：你可以在编辑器中在保存文件前更改文件权限。命令是： 1 :w !sudo tee % 这个命令将会向你询问密码，就像在命令行中使用 sudo 一样，然后就能保存更改。 一个相关的技巧：在 Vim 中编辑一个文件的时候，如果想快速进入命令行提示符，可以在编辑器中运行 :sh 命令，从而你将进入一个交互的 shell 中。完成以后，运行 exit 命令可以快速回到 Vim 模式中。 5、 在复制/粘贴过程中保持缩进 大多数有经验的程序员在 Vim 上工作时都会启用自动缩进。虽然这是一个节约时间的做法，但是在粘贴一段已经缩进了的代码的时候会产生新的问题。比如，下图是我把一段已缩进代码粘贴到一个在自动缩进的 Vim 编辑器中打开的文件中时遇到的问题： 这个问题的解决方法是 pastetoggle 选项。在 /etc/vim/vimrc 文件中加入下面这行内容： 1 set pastetoggle=&lt;F2&gt; 然后当你在 插入 模式中准备粘贴代码前先按 F2 键，就不会再出现上图中的问题，这样会保留原始的缩进。注意，你可以用其他的任何键来代替 F2，如果它已经映射到了别的功能上。 结论 更进一步的提高你的 Vim 编辑器技巧的唯一方法是，在你日复一日的工作中使用命令行编辑器。留意那些耗时多的操作，然后尝试去寻找是否有编辑器命令可以很快地完成这个操作。 via: https://www.maketecheasier.com/vim-tips-tricks-for-experienced-users/ 作者：Himanshu Arora译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"给 Linux 新手的最佳发行版","date":"2017-01-22T10:35:26.000Z","path":"2017/01/22/the-Best-Linux-System-for-Beginners/","text":"Jack Wallen 为来自不同环境的新手们挑选出专门为他们设计的发行版。CC0社区。 一个很古老的问题，找到适合的 Linux 发行版比简单的指出哪种 Linux 版本受欢迎更重要。为什么这么说？ 让我们设置一个情景：你有一位用户，很有可能，他过去大多数时候都是在 Windows 或者 Mac 系统上工作，他们想让你给他们一个选择的替代品。现在，你想要在很短的时间里直截了当的说明 Linux 系统的工作方式并突出它的强大性和灵活性。 但是，请记住，最重要的一个方面是他们必须能够 get it，即开箱即用。 这就是为什么我们经常需要花费时间来找出哪种版本是最适合新手的 – 因为把新手们带入 Linux 系统是传播 Linux 并增加 Linux 用户的最好方式。 对于新手来说最好的版本是什么？这次，我将要花费一定时间来说明对于来自不同环境的用户哪种版本才是最适合的。此外，你也可以查看我在 2017 最好的发行版中列出的发行版。 从 Windows 7 到 Linux：ZorinOS 当 Windows 8 发布以后，有一个理由让如此多的用户依然坚持使用 Windows 7， 那就是熟悉度。用户们已经在相同的桌面环境上工作了十几年，他们不想转移到 Windows 8 这种更以触摸屏为主的平台上。所以，你会去选择哪种版本呢？你首先必须要考虑的是桌面环境。为什么？因为这是你能够立刻吸引上这些 Windows 7 用户的地方。对于这个任务，还有什么版本会比 ZorinOS 更好呢？ ZorinOS 就是专门作为 Windows 和 Mac 系统的替代品而设计的，所以它下了很大的功夫来模仿 Windows 和 Mac 桌面的外观和感觉。事实上，除了 ZorinOS 以外，你很难找到一个别的 Linux 版本，能够完美的从 Windows 7 转移到 Linux 系统上，同时保留 Linux 系统如此强大、灵活的平台。 除了桌面环境（图片 1）以外， 因为 ZorinOS 完全基于 Ubuntu 系统，所以在其“外表”下面， ZorinOS 和 Ubuntu 以同样的方式工作（所以基本不用去担心硬件不能够被检测到）。同时伴有已经就绪的软件，你便有了针对来自 Windows 7 用户的最完美的 Linux 版本。 图片 1：类 Windows 7 的 ZorinOS 桌面，准备开始服务。使用许可 请注意：然而， ZorinOS 有两个版本： Zorin Ultimate 和 Zorin Core 。 Zorin Core 是免费的，但它不包含几乎所有你能够在 Zorin Ultimate 中找到的软件。如果你想要一个适合于所有来自 Windows 7 用户的开箱即用的版本，那么我强烈推荐购买 Zorin Ultimate（大约需要花费 20 美元）。当然，如果你不想花钱购买 Ultimate 版本，你也可以从 Core 版本包含的软件包管理工具中安装几乎所有你需要的东西。 从 Windows 8 到 Linux ： Ubuntu GNOME 让我们来看看 Windows 8， 它带来了一个以触摸屏为中心的环境，改变了用户与电脑互动的方式。老式的启动菜单、面板、系统托盘桌面已经被触摸屏环境界面所取代。如果你正在找一个能给 Linux 新手们带来不同体验的最好环境，同时功能也要是最好的，那么没有比 Ubuntu GNOME 更合适的了。 Ubuntu GNOME 是 Ubuntu 和 GNOME（图 2）这两个世界之间最好的融合。用一个现代、优雅、简洁并且用户友好的桌面代替了 Unity 界面， 因此 Ubuntu GNOME 不会给任何来自 Windows 8 的用户造成太多的麻烦。该版本不仅基于最新的长期支持版的 Ubuntu 发行版（支持期会很长），同时使用了 GNOME 桌面的最新稳定版本 － 这意味着用户将能够享受到难以置信的稳定体验。 图片 2 ：在 Ubuntu GNOME 中可以发现，在优雅而又简洁。 使用许可 从 Mac 到 Linux ： Elementary OS 毫无疑问，这一场的绝对赢家是 Elementary OS。尽管 Elementary OS 在外观和感觉上所达到的效果和 OS X 桌面非常相似，但实际还有更多优秀的地方。 Elementary OS 同样是基于 Linux 系统的，只不过是它采取了很多 Mac X 桌面的设计元素。 任何的 Mac 用户使用 Elementary OS 的桌面环境（图片 3）都会感觉就像是“在家一样”（使用 Mac 一样）。伴有如此熟悉的文档，同时包含一个熟悉的应用菜单， Elementary OS 总是位于我的‘最佳发行版列表’的顶部。如果我们正在和 Mac 用户讨论迁移，那么没有比 Elementary OS 更好的 Mac 替代品了。 图片 3 ：Elementary OS 桌面的荣耀。使用许可 有一件事情 Mac 用户们将会非常感激，那就是 Elementary OS 的开发者们很好的保持了桌面的一致性。从 dock， 到面板、菜单、到包括的应用，你找不到任何一个看起来或感觉没有归属感的单一元素。 我将在这儿说一个关于 Elementary OS 的预警。你需要安装一个好的浏览器（因为它自带安装的 Epiphany-a 浏览器没有得到许多常用站点的支持），同时，你需要从官方的 LibreOffice 网站下载安装包来安装 LibreOffice （因为在 Elementary OS 的软件中心找到的安装包已经有些过时了）。 从 Android 到 Linux：Ubuntu 这似乎有点像是一个延伸话题，但考虑到 Android 在全球市场中占主导地位，所以你可能遇到一个来自以移动设备为中心的用户，他可能需要一个 Linux 桌面，从而让他一直感觉像是‘在家’一样。对于我来说， Ubuntu 是最显然的赢家。为什么？和其他系统相比， Ubuntu Unity 在桌面上做出了很杰出的工作，它使得桌面感觉像是一个包罗万象的界面。如果你愿意，那么可以包含在线搜索结果（默认情况下禁用），这是在几乎每个移动环境中均可找到的东西。同样， Unity HUD 菜单系统（图片 4）是在任何界面系统中所能找到的最独一无二的菜单系统之一。通过 Unity HUD 菜单系统，用户可以更少的依赖鼠标（就像他们过去在 Android 支持的移动设备上工作一样）。 图片 4： 使用中的 Unity HUD 。使用许可 当然， Ubuntu 也提供了市场上最稳定的桌面平台，所以用户体验近乎完美。 总有一款 Linux 发行版适合你 有一件很重要的事情需要记住，那就是总有一款 Linux 发行版适合你。但是对于那些来自特殊环境的人，我强烈推荐找到一个最喜爱的 Linux 版本，从而能够帮助他们无缝过渡。给自己一个机会尝试一下，看看你是否可以轻松体验到开源和 Linux 的强大。 via: https://www.linux.com/news/best-linux-distributions-new-users 作者：JACK WALLEN译者：ucasFL校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出"},{"title":"五子棋之五元组评分算法","date":"2017-01-07T15:18:59.000Z","path":"2017/01/07/The-Algorithm-of-Gomoku/","text":"前言 本学期，开始学习 $C$ 语言编程课，期末大作业是一个用 C 语言写的五子棋游戏，该大作业占最后期末成绩的百分之五十，所以不容忽视。最后的成绩高低是所有同学进行比赛，看谁的 $AI$ 厉害，然后根据比赛结果评分，冠军组 $100$ 分，而最后一个普通组只有 $65$ 分，分数相差较大。 大概从 $11$ 月中旬就开始写五子棋，当然，整个程序最关键的部分就是 $AI$ ，大概 $12$ 月份刚开始的时候就按照老师讲的算法写出了一个感觉还不错的程序，之后一直没再调试。比赛前最后一周，感觉自己的 $AI$ 还是很弱，于是，开始进行调参，可是花了一周的时间，没什么效果，反而越调越傻。 昨天晚上，也就是比赛前最后一个晚上，到隔壁一个宿舍，问到他们的五子棋情况，发现大家的好像都很厉害，他们都是用博弈树算法搜了很多层，才意识到自己的真的很菜，一周的调参没起到任何效果。然后又听说他们宿舍的另一位搞 $ACM$ 的大神用了一种很好的算法进行评分，搜了 $8$ 步，可以秒杀电脑上五子棋游戏的大师级别。听了那个评分算法，似乎不是很难实现。原本昨天晚上是想继续调参的，但想想按照之前的算法调参好像真的没什么用，干脆按他们说这个算法重新写一个 $AI$ ，说不定效果更好，虽然不一定能写出来，不过豁出去试一试。于是，七点多的时候，回到宿舍，上网搜了一下，发现有人写了一篇关于这种算法的博客，不过，要说很重要的是这篇博客给出了一个比较完美的该算法评分参数，后来，我在该参数的基础上进行了一些修改，我觉得应该比之前好一些。 从 $7$ 点多开始，先思考了一会怎么实现该算法，然后便开始写，大概写了 $3$ 个多小时， $10$ 点多的时候写好，整个 $AI$ 只有 $213$ 行代码。但不幸的是，存在 $bug$ ，调了半个多小时 $bug$ ，终于可以正常下了。简直不可置信，就进行一个评分，然后完全秒杀之前写的 $AI$ ，效果比我想象中要好很多很多。甚是激动，于是奖励自己玩了两个小时手机，所以一不小心就到了凌晨两点半才睡。 今天早上 $10$ 点多醒来，一点半比赛，于是决定再测试一下程序。没想到却发现了两个致命 $bug$ 。第一个是选择最高分时判断是禁手以后忘记把该点赋为 $0$ ，导致程序进入死循环，就不会再落子。这个 $bug$ 解决了以后，又出现了新的 $bug$ ，$AI$ 一次落了两个子，后来找出 $bug$ ：在判断是否禁手时我先进行试探落子，之后忘记恢复，所以才出现一次落了两个子。 于是早饭、午饭都没吃，直接到时间了去教室参加比赛。最后结果 $4$ 胜 $1$ 负进入冠军组，然后又打败老师给的之前一个研究生写的五子棋，直接满分，所以现在 $C$ 语言期末已经有了 $50$ 分，再加上 $20$ 分作业分，就算不参加期末考也已经及格了。 正题 下面，开始说这个算法，其实很简单。 在这之前，先说一下之前的算法：对棋盘上空的点评分，判断在该点落子之后四个方向的格局，比如胜利、活四、半活四、活三等等，然后再判断对手在该点落子以后四个方向的格局，各种情形分别赋分，算出总的分，然后落子，不得不说，这个评分方法真是弱爆了，首先，因为评分偏差，我写了无数个很长 $if$ ，对一些特殊情况单独处理， $AI$ 部分写了 $500$ 多行代码；其次，这种评分在中间位置还好，一旦到了边界，它就会在一些已经不可能形成五连的无意义点落子。 五元组评分算法：所谓五子棋，就是要五子连成线才取得胜利，正规比赛以及我们该比赛的棋盘都是 $15\\times15$ 大小的，所以整个棋盘上有 $572$ 个五元组，每一个点都被包含在 $20$ 个五元组中（边界情况例外）。于是，对点的评分改为：已经被落子的点，直接赋值为 $-1$ ，对于没有被落子的点，计算包含它的所有五元组的情况，然后进行评分，评分方法很简单：看每个五元组里面有几个自己的子以及对手的子，然后给分，不用去管具体位置是什么样的。 算法就是这样。 下面，是我的评分表，我直接把头文件黏贴过来： #ifndef MY_HEAD_H #define MY_HEAD_H #define SIZE 15 #define PLAYER1 1 #define PLAYER2 2 #define FIRST_PLAYER 1 #define SECOND_PLAYER 2 #define M1 35 #define M2 800 #define M3 15000 #define M4 800000 #define O1 20 #define O2 500 #define O3 4000 #define O4 300000 #define VO 7 #define PU 0 #define NO 0 #endif 说明一下，只看 M1 到 M4 和 O1 到 O4 以及最后三个。 Mi表示该五元组上有 $i$ 个自己的子； Oi 表示该五元组上有 $i$ 个对手的子； VO 表示该五元组上没有子，为什么没有子分不是 $0$ ，因为还有更坏的情况：PU 表示五元组上既有自己的子，又有对手的子，所以这时该五元组已经被 污染，不可能再形成五连； NO 表示不存在五连，这是考虑边界情况，这样定义，方便函数的实现和调用。 个人觉得，该评分已经比较完美，也许会有更好的评分。 当然，如果要进行多层搜索的话需要对全局进行评分，试探落子，然后计算所有五元组得分之和，多步试探，最后还是要用到博弈树算法，还不懂具体怎么实现，等到假期再来研究。 $C$ 语言实现的五子棋代码在 $GitHub$ 上：https://github.com/ucasFL/Gomoku/"},{"title":"C 语言指针误用总结","date":"2016-12-20T06:07:41.000Z","path":"2016/12/20/the-Error-Summary-of-C-Pointer-Part1/","text":"前言 一早上的时间折腾在一个很简单的题上，最后发现是指针误用，差点吓得我以后都不敢再用指针了，故作此总结。 在这儿，我把问题简化，只看关键出错地方。 正题 首先，我们看一下， C 语言中的指针是什么：指针是一个保存变量地址的变量，它同时也是一个变量。 看下面一行代码： char *str=&quot;hello,world!&quot; 这行代码表示，str 是一个指针，它指向一个字符串（实际上是指向字符串的第一个字符）。 如果想把该字符串输出，我们可以： printf(&quot;%s\\n&quot;,str); 重点来了，因为对该知识点的错误理解，造成了第一个致命错误，看下面两段代码： 首先，第一段代码是正确的， s[10] 是一个字符串数组，然后通过 scanf 函数读取一串（不超过它长度）字符存入其中。 再看第二段带码，这时候 s 定义成一个字符串指针，所以它只能用来指向一个字符串，然而，我却要读取一段字符串存入其中，而且传递给 scanf 函数的还不是该指针的地址，更是错上加错。 另外，注：上面 str 所指向的字符串是只读的。 接下来，看一个关于交换值的问题，在 C 语言中，函数形参值的改变不会改变实参的值，所以我们要交换两个变量的值时，需要通过指针来访问形参操作数。于是，在这个地方，再次出现严重错误（结构是可以取址，可以整体赋值的）。看下面一段代码： 现在很清楚了，我在函数中交换了两个指针的值，但并没有交换它们所指向的变量的值，所以两个结构的值不会被交换。 于是，我改了一下代码，没想到却把自己推向了更可怕的深渊：segmentation fault。 看下面的代码： 瞬间感觉自己就是一个 ZZ， 很明显，我相当于把一个结构的内容赋给一个指针变量。 正确的代码如下： 后记 一上午的时间就这样过去了，但能够纠正如此严重的一个错误，总算是值得的。 今后对指针的理解会更深，也会更加小心使用了 ^-^"},{"title":"Sudo Apt Update失败的解决办法","date":"2016-12-19T08:23:02.000Z","path":"2016/12/19/the-Solution-of-sudo-apt-update-Failed/","text":"在 ubuntu 系统上，当我们通过 apt 软件包安装新的软件时，都要先进行软件包更新： ~$ sudo apt update 但有时候，会出现 error， 如下图所示： 这时候，我们只需要把 /var/lib/apt/lists 目录中的文件全部删除，然后再重新更新就好了： ~$ rm -r /var/lib/apt/lists ~$ sudo apt update OK ~ 问题解决"},{"title":"个人博客搭建：GitHub+Hexo","date":"2016-12-18T04:06:50.000Z","path":"2016/12/18/Deploy-Blog-with-Hexo-and-GitHub-Pages/","text":"本文中用到的工具有： Linux(是操作系统就行) GitHub Hexo Git Nodejs Markdown(写博客） 前期准备 GitHub 账号申请和建库： 先到GitHub官网： https://github.com/ 申请一个账号。 登录账号，点击页面右上角的+号，然后选择 New repository 新建仓库，仓库名为： user.github.io（注： user 为你的 GitHub 用户名） Git 安装： 安装： ~$ sudo apt update ~$ sudo apt install git 这是在 Linux 系统下的安装，Windows 系统下的安装都一个样，不必多说。之后讲到的命令如果是 Linux 系统，则是在 Linux 命令行下操作；如果是 Windows 系统则是在 Git Bash 下操作。 初始设置： ~$ git config --global user.name &quot;Firstname Lastname&quot; ~$ git config --global user.email &quot;your_email@example.com&quot; 上面的双引号里面的内容是你自己想设置的名字和邮箱。 设置 SSH key： 运行下面命令创建 SSH key： ~$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; Generating public/private rsa key pair Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 按回车键 Enter passphrase (empty for no passphrase): 输入密码 Enter same passphrase again: 再次输入密码 接着会出现以下结果： Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub The key fingerprint is: fingerprint值 your_email@example.com The key&apos;s randomart imageis: 一个图片(略) 添加公开密匙： 点击 GitHub 账户右上角的账户设定： Settings选择： SSH keys 然后会出现 Title 和 Key 两个输入框，第一个输入自己喜欢的名称即可。Key 部分需要粘贴 id_rsa.pub 文件中的内容，内容查看方法如下： ~$ cat ~/.ssh/id_rsa.pub ssh-rsa 公开密匙内容 your_email@example.com 将全部内容复制到 Key 里面，然后点击绿色的 Add SSH Key，完成。 安装 Nodejs： 由于 Hexo 需要 Nodejs 模块的支持，因此，在搭建博客以前需要先安装 Nodejs。 Windows 系统同样直接下载安装即可。 Linux 系统下，我采用的是从源代码编译安装，所以直接到 Nodejs 官网： https://nodejs.org/en/ 下载源代码。 然后到源代码压缩包所在目录，首先解压缩： ~$ tar -zxf node-v6.9.2.tar.gz 然后进入解压后的文件夹，配置、编译、安装： ~$ ./configure ~$ make ~$ make install 前期准备工作至此结束。 搭建博客： 安装 Hexo ~$ sudo npm install hexo-cli -g 初始化：（假设博客根目录即为 blogs） ~$ hexo init blogs ~$ cd blogs/ ~$ sudo npm install 新建博客： ~$ hexo new &quot;title&quot; 生成静态文件： ~$ hexo g(==hexo generate) 预览： ~$ hexo s(==hexo server) 现在，打开浏览器，输入 http://localhost:4000/，然后，就可以看到你的博客了 接下来的步骤很很关键：把博客部署到 GitHub 上。 在博客根目录 blogs 里面有一个 _config.yml 文件，这是博客的配置文件，你可以在里面修改网站名称、作者等。 打开 _config.yml，翻到最下面，修改下面的内容： deploy: type: 改为（实际上是加东西）： deploy: type: git repository: git@github.com:user/user.github.io.git branch: master 注意： user 部分为你的 GitHub 用户名；冒号后面要有一个空格，这是 yml 语法。 然后，安装 hexo-deployer-git： ~$ sudo npm install hexo-deployer-git --save 部署到 GitHub 上面： ~$ hexo d(==hexo deploy) 部署好以后，在浏览器打开 https://user.github.io/ 就可以看到你自己的博客了（同上，user 为你的用户名） 搭建好以后，写博客和发布都很简单方便。 新建： ~$ hexo new &quot;title&quot; 之后便会在 source/_posts/ 目录里生成一个 Markdown 文件，这就是你要写的文章。 文章写好以后，先删除之前的发布内容： ~$ hexo clean 生成： ~$ hexo g(==hexo generate) 预览： ~$ hexo s(==hexo server) 发布： ~$ hexo d(==hexo deploy) 错误总结： ERROR Deployer not found:git解决方法： ~$ sudo npm install hexo-deployer-git --save ERROR Plugin load failed: hexo-server解决方法： ~$ sudo npm install hexo-server /usr/bin/env:node: No such file or directory解决方法： ~$ sudo ls /usr/bin/nodejs/usr/bin/node 好了，整个博客的搭建差不多就完成了。 更改主题： 下面，写一点关于主题的更改，以我现在用的主题 hexo-theme-yilia 为例。 首先进入 themes 目录： ~$ cd blogs/themes/ 然后把你想要的主题克隆下来： ~$ git clone https://github.com/litten/hexo-theme-yilia.git 然后替换主题。进入博客根目录的配置文件 _config.yml，更改主题，将 theme: lanscape 改为： theme: hexo-theme-yilia 至此，主题就替换了。 主题里面也有一个配置文件 _comfig.yml，你可以在里面进行一些更加个性化的配置。 下面，说一个问题，是关于头像的，我在这上面花费了大量时间，结果最后才发现解决办法很简单。 首先，要设置头像路径。 在根目录里面的 source 目录里面新建一个目录： assets ，然后将你想设置的头像拷入该目录，假设头像名为： profile.jpg 然后，打开主题的配置文件 _config.yml ，在 avatar 那儿添加头像路径： avatar: /assets/profile.jpg 下面，需要再修改两个文件: 打开 layout/_partial/left-col.ejs 文件，将 6,7 行改为： &lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar show&quot;&gt; &lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar show&quot; style=&quot;width: 100%;height: 100%;opacity: 1;&quot;&gt; 同样地，再打开 layout/_patial/mobile-nav.ejs ，相应位置也改成上面那样。 文章截断按钮：一般来说我们不希望文章在主页上全文显示，所以我们可以在想截断的地方加上： &lt;!--more--&gt; 这样，文章就不会在主页上全文显示，会出现一个 more&gt;&gt; 按钮，如下图所示。 至此，主题更改完成。 关于主题的问题的解决方法，基本都可以在该主题的 GitHub 项目的 issue 那儿找到：https://github.com/litten/hexo-theme-yilia/issues 后记 写到这儿，基本把需要写的东西都写完了。 最后提一句，博客的写作采用 Markdown 语言。不得不说，恐怕很难找到比 Markdown 更简单的语言了，不然我也不可能随便看了几分钟就开始写这样一篇博客了。 关于 Markdown 语法，请参考： http://www.appinn.com/markdown/ 添加多说评论 首先，需要到多说创建一个站点。 登录网站。 登录后点击我要安装 之后会出现以下界面： 然后填写相关信息创建站点。 多说域名一项即填写duoshuo_shortname。 站点创建完成以后，到主题配置文件中，找到： 12 # Duoshuo ShortNameduoshuo_shortname: 在duoshuo_shortname后面填上刚才创建站点的信息。 域名绑定 当用 Hexo+GitHub 搭建好博客以后，域名为：username.github.io 。但是很多人包括我都会觉得这个域名过于太长，还好 GitHub 支持域名绑定，因此你可以选择一个自己喜欢的域名绑定到博客上，之后，便可通过该域名访问博客。 首先购买一个自己喜欢的域名； 然后进行域名解析； 解析时，需要添加三条记录：两条 A 记录和一条 CNAME 记录； 两条 A 记录的对应值为 GitHub 服务器 ip：分别为：192.30.252.153 和 192.30.252.154，两条都要添加上；CNAME 的对应值为你的博客域名，即username.github.io； 解析完成如下图所示： 然后，到博客根目录的 sources 文件夹新建文件 CNAME，文件内容即为你购买的域名，不需要前缀http://； 之后再重新部署到 GitHub 上就可以通过你购买的域名访问博客了。 添加背景图片 假设背景图片为beijing.jpg，格式不限； 首先，将背景图片放到目录/themes/next/source/images/目录下； 然后，在文件/themes/next/source/css/_custom/custom.styl文件中添加下面一行内容： 1 body &#123; background:url(/images/beijing.jpg);&#125; 注：/images/beijing.jpg即为背景图片的路径。 此时，背景会随着页面移动，要使背景不随页面移动，可改为： 1234 body &#123; background:url(/images/back.jpg); background-attachment: fixed;&#125; 但是，经过一段时间，发现，添加日志背景严重影响阅读，所以便取消了。 页眉背景 假设背景图片为header.jpg; 同样先把图片放到目录/themes/next/source/images/下； 然后在文件/themes/nex/source/CSS/_common/components/header/header.styl中加上下面这行内容： 1 .header &#123; background: url(/images/header.jpg); &#125; 侧栏背景 假设图片为side.jpg 放到同上目录中； 然后在文件/themes/nex/source/CSS/_common/components/sidebar/sidebar.styl中加上下面这行内容： 1 .sidebar &#123; background: url(/images/side.jpg);&#125; 添加动态背景 修改 _layout.swig 模块； 模块位置：themes/next/layout/\\_layout.swig 在末尾加上下面的内容： 123 &lt;!--动态背景－－》&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/js/src/particle.js\" count=\"50\" zindex=\"-2\" opacity=\"1\" color=\"0,104,183\"&gt;&lt;/script&gt; 注： 设置的线条默认为灰色线条和浅绿色线条。 然后在目录 themes/next/source/js/src/ 下新建文件particle.js，文件中写入以下代码： 1 !function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(\"script\"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,\"zIndex\",-1),o:n(i,\"opacity\",.5),c:n(i,\"color\",\"0,0,0\"),n:n(i,\"count\",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=\"rgba(\"+m.c+\",\"+(t+.2)+\")\",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement(\"canvas\"),m=t(),d=\"c_n\"+m.l,l=u.getContext(\"2d\"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText=\"position:fixed;top:0;left:0;z-index:\"+m.z+\";opacity:\"+m.o,e(\"body\")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 鼠标点击小红心 在themes/next/source/js/src/下新建文件love.js，然后在文件中添加以下代码： 1 !function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 下一步，回到themes/next/layout/\\_layout.swig文件，添上以下内容： 12 &lt;!-- 小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt;"},{"title":"不常见但是很有用的 GCC 命令行选项（二）","date":"2016-12-13T10:28:13.000Z","path":"2016/12/13/Uncomman-But-Useful-gcc-Command-Line-Options-2/","text":"gcc 编译器提供了几乎数不清的命令行选项列表。当然，没有人会使用过或者精通它所有的命令行选项，但是有一些命令行选项是每一个 gcc 用户都应该知道的 - 即使不是必须知道。它们中有一些很常用，其他一些不太常用，但不常用并不意味着它们的用处没前者大。 在这个系列的文章中，我们集中于一些不常用但是很有用的 gcc 命令行选项，在第一节已经讲到几个这样的命令行选项。 不知道你是否能够回想起，在这个系列教程的第一部分的开始，我简要的提到了开发者们通常用来生成警告的 -Wall 选项，并不包括一些特殊的警告。如果你不了解这些特殊警告，并且不知道如何生成它们，不用担心，我将在这篇文章中详细讲解关于它们所有的细节。 除此以外，这篇文章也将涉及与浮点值相关的 gcc 警告选项，以及在 gcc 命令行选项列表变得很大的时候如何更好的管理它们。 在继续之前，请记住，这个教程中的所有例子、命令和指令都已在 Ubuntu 16.04 LTS 操作系统和 gcc 5.4.0 上测试过。 生成 -Wall 选项不包括的警告 尽管 gcc 编译器的 -Wall 选项涵盖了绝大多数警告标记，依然有一些警告不能生成。为了生成它们，请使用 -Wextra 选项。 比如，下面的代码： 1234567891011121314 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i=0; /* ... some code here ... */ if(i); return 1; return 0;&#125; 我不小心在 if 条件后面多打了一个分号。现在，如果使用下面的 gcc 命令来进行编译，不会生成任何警告。 1 gcc -Wall test.c -o test 但是如果同时使用 -Wextra 选项来进行编译： 1 gcc -Wall -Wextra test.c -o test 会生成下面这样一个警告： 123 test.c: In function ‘main’:test.c:10:8: warning: suggest braces around empty body in an ‘if’ statement [-Wempty-body] if(i); 从上面的警告清楚的看到， -Wextra 选项从内部启用了 -Wempty-body 选项，从而可以检测可疑代码并生成警告。下面是这个选项启用的全部警告标记。 -Wclobbered -Wempty-body -Wignored-qualifiers -Wmissing-field-initializers -Wmissing-parameter-type （仅针对 C 语言） -Wold-style-declaration （仅针对 C 语言） -Woverride-init -Wsign-compare -Wtype-limits -Wuninitialized -Wunused-parameter （只有和 -Wunused 或 -Wall 选项使用时才会启用） -Wunused-but-set-parameter (只有和-Wunused或-Wall` 选项使用时才会生成） 如果想对上面所提到的标记有更进一步的了解，请查看 gcc 手册。 此外，遇到下面这些情况， -Wextra 选项也会生成警告： 一个指针和整数 0 进行 &lt;， &lt;=， &gt;， 或 &gt;= 比较 （仅 C++）一个枚举类型和一个非枚举类型同时出现在一个条件表达式中 （仅 C++）有歧义的虚拟基底 （仅 C++）寄存器类型的数组加下标 （仅 C++）对寄存器类型的变量进行取址 （仅 C++）基类没有在派生类的复制构建函数中进行初始化 浮点值的等值比较时生成警告 你可能已经知道，浮点值不能进行确切的相等比较（如果不知道，请阅读与浮点值比较相关的 FAQ)。但是如果你不小心这样做了， gcc 编译器是否会报出错误或警告？让我们来测试一下： 下面是一段使用 == 运算符进行浮点值比较的代码： 12345678910111213141516 #include&lt;stdio.h&gt;void compare(float x, float y)&#123; if(x == y) &#123; printf(\"\\n EQUAL \\n\"); &#125;&#125;int main(void)&#123; compare(1.234, 1.56789); return 0;&#125; 使用下面的 gcc 命令（包含 -Wall 和 -Wextra 选项）来编译这段代码： 1 gcc -Wall -Wextra test.c -o test 遗憾的是，上面的命令没有生成任何与浮点值比较相关的警告。快速看一下 gcc 手册，在这种情形下可以使用一个专用的 选项。 12 下面是包含这个选项的命令： gcc -Wall -Wextra -Wfloat-equal test.c -o test 12 下面是这条命令产生的输出： test.c: In function ‘compare’:test.c:5:10: warning: comparing floating point with == or != is unsafe [-Wfloat-equal] if(x == y) 123456789101112 正如上面你所看到的输出那样， `-Wfloat-equal` 选项会强制 gcc 编译器生成一个与浮点值比较相关的警告。这儿是[gcc 手册][8]关于这一选项的说明：&gt; 这背后的想法是，有时，对程序员来说，把浮点值考虑成近似无限精确的实数是方便的。如果你这样做，那么你需要通过分析代码，或者其他方式，算出这种计算方式引入的最大或可能的最大误差，然后进行比较时（以及产生输出时，不过这是一个不同的问题）允许这个误差。特别要指出，不应该检查是否相等，而应该检查两个值是否可能出现范围重叠；这是用关系运算符来做的，所以等值比较可能是搞错了。### 如何更好的管理 gcc 命令行选项如果在你使用的 gcc 命令中，命令行选项列表变得很大而且很难管理，那么你可以把它放在一个文本文件中，然后把文件名作为 gcc 命令的一个参数。之后，你必须使用 `@file` 命令行选项。比如，下面这行是你的 gcc 命令： gcc -Wall -Wextra -Wfloat-equal test.c -o test 12 然后你可以把这三个和警告相关的选项放到一个文件里，文件名叫做 `gcc-options`： $ cat gcc-options-Wall -Wextra -Wfloat-equal 12 这样，你的 gcc 命令会变得更加简洁并且易于管理： gcc @gcc-options test.c -o test``` 下面是 gcc 手册关于 @file 的说明： 从文件中读取命令行选项。读取到的选项随之被插入到原始 @file 选项所在的位置。如果文件不存在或者无法读取，那么这个选项就会被当成文字处理，而不会被删除。 文件中的选项以空格分隔。选项中包含空白字符的话，可以用一个由单引号或双引号包围完整选项。任何字符（包括反斜杠: ‘\\’）均可能通过一个 ‘\\’ 前缀而包含在一个选项中。如果该文件本身包含额外的 @file 选项，那么它将会被递归处理。 结论 在这个系列的教程中，我们一共讲解了 5 个不常见但是很有用的 gcc 命令行选项： -Save-temps、-g、 -Wextra、-Wfloat-equal 以及 @file。记得花时间练习使用每一个选项，同时不要忘了浏览 gcc 手册上面所提供的关于它们的全部细节。 你是否知道或使用其他像这样有用的 gcc 命令行选项，并希望把它们在全世界范围内分享？请在下面的评论区留下所有的细节。 via: https://www.howtoforge.com/tutorial/uncommon-but-useful-gcc-command-line-options-2/ 作者：Ansh译者：ucasFL校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出"}]