<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>春暖花开</title>
  <subtitle>love, life, thinking, coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ucasfl.me/"/>
  <updated>2019-07-11T06:14:40.023Z</updated>
  <id>http://ucasfl.me/</id>
  
  <author>
    <name>Flynn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 合并多个 Commit</title>
    <link href="http://ucasfl.me/2019/07/11/Git-Merge-Commits/"/>
    <id>http://ucasfl.me/2019/07/11/Git-Merge-Commits/</id>
    <published>2019-07-11T06:02:02.000Z</published>
    <updated>2019-07-11T06:14:40.023Z</updated>
    
    <content type="html"><![CDATA[<p>总是记不住 Git 合并 Commit 的命令，故今天记录一下。</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">git rebase -<span class="selector-tag">i</span> HEAD~<span class="number">2</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><code>2</code> 为合并的 Commit 的个数，如果合并 3 个 Commit，则改为 <code>3</code>，同理。</p>
<a id="more"></a>
<p>之后，可能会出现如下内容：</p>
<figure class="highlight vala">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">pick <span class="number">7</span>bb83e2 commit <span class="number">1</span></div><div class="line">pick ae60558 commit <span class="number">2</span></div><div class="line"></div><div class="line"><span class="meta"># Rebase f59dfd0..ae60558 onto f59dfd0 (2 commands)</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># Commands:</span></div><div class="line"><span class="meta"># p, pick = use commit</span></div><div class="line"><span class="meta"># r, reword = use commit, but edit the commit message</span></div><div class="line"><span class="meta"># e, edit = use commit, but stop for amending</span></div><div class="line"><span class="meta"># s, squash = use commit, but meld into previous commit</span></div><div class="line"><span class="meta"># f, fixup = like "squash", but discard this commit's log message</span></div><div class="line"><span class="meta"># x, exec = run command (the rest of the line) using shell</span></div><div class="line"><span class="meta"># d, drop = remove commit</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># These lines can be re-ordered; they are executed from top to bottom.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># If you remove a line here THAT COMMIT WILL BE LOST.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># However, if you remove everything, the rebase will be aborted.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># Note that empty commits are commented out</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><code>commit 1</code> 和 <code>commit 2</code> 为 commit 的消息，<code>commit 1</code> 在前，<code>commit 2</code> 在后。</p>
<p>之后，修改如下：</p>
<figure class="highlight vala">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">pick <span class="number">7</span>bb83e2 commit <span class="number">1</span></div><div class="line">squash ae60558 commit <span class="number">2</span></div><div class="line"></div><div class="line"><span class="meta"># Rebase f59dfd0..ae60558 onto f59dfd0 (2 commands)</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># Commands:</span></div><div class="line"><span class="meta"># p, pick = use commit</span></div><div class="line"><span class="meta"># r, reword = use commit, but edit the commit message</span></div><div class="line"><span class="meta"># e, edit = use commit, but stop for amending</span></div><div class="line"><span class="meta"># s, squash = use commit, but meld into previous commit</span></div><div class="line"><span class="meta"># f, fixup = like "squash", but discard this commit's log message</span></div><div class="line"><span class="meta"># x, exec = run command (the rest of the line) using shell</span></div><div class="line"><span class="meta"># d, drop = remove commit</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># These lines can be re-ordered; they are executed from top to bottom.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># If you remove a line here THAT COMMIT WILL BE LOST.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># However, if you remove everything, the rebase will be aborted.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># Note that empty commits are commented out</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>即，将 <code>commit 2</code> 的 <code>pick</code> 改为 <code>squash</code>。然后保存退出，之后还会出现 commit 消息的修改，修改完保存退出即可。</p>
<p>如果前一个 commit 已经 push 到了远程仓库中，那么还需要 <code>force push</code> 一下：</p>
<figure class="highlight armasm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="symbol">git</span> <span class="keyword">push </span>-f</div></pre>
      </td>
    </tr>
  </table>
</figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是记不住 Git 合并 Commit 的命令，故今天记录一下。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git rebase -&lt;span class=&quot;selector-tag&quot;&gt;i&lt;/span&gt; HEAD~&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 为合并的 Commit 的个数，如果合并 3 个 Commit，则改为 &lt;code&gt;3&lt;/code&gt;，同理。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://ucasfl.me/categories/Git/"/>
    
    
      <category term="Git" scheme="http://ucasfl.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>CPython 学习笔记</title>
    <link href="http://ucasfl.me/2019/02/22/CPython-Summary/"/>
    <id>http://ucasfl.me/2019/02/22/CPython-Summary/</id>
    <published>2019-02-22T03:09:19.000Z</published>
    <updated>2019-02-25T03:07:15.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文为查阅相关资料的过程中随手记录的，故内容较为杂乱，无任何章节可言。</p>
<p>Python 源代码执行流程：</p>
<p><img src="/photos/py/py.png" alt=""></p>
<p>Python 基于栈式执行，CPython 主要使用三种类型的栈：</p>
<ul>
  <li>call stack：一个 frame 表示一个活动的函数调用</li>
  <li>data stack：也称作 evaluation stack，每一个函数对应一个 data stack，函数在其中进行数据操纵，包括函数参数，返回地址等</li>
  <li>block stack：用于跟踪控制结构的确定类型：如循环，<code>try/except</code> 块，<code>with</code> 块等</li>
</ul>
<a id="more"></a>
<p>反汇编Python字节码：<code>dis</code> 库，例如：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">import</span> dis</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">	print(<span class="string">'hello, world!'</span>)</div><div class="line"></div><div class="line">dis.dis(hello)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>输出如下：<br>
  <figure class="highlight lsl">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (print)</div><div class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> ('hello')</div><div class="line">            <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></div><div class="line">            <span class="number">6</span> POP_TOP</div><div class="line">            <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (None)</div><div class="line">           <span class="number">10</span> RETURN_VALUE</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>可通过 <code>__code__</code> 属性访问函数 code object，如 <code>hello.__code__</code>，同时，code 对象拥有如下一些属性：</p>
<ul>
  <li><code>co_consts</code>：由函数中出现的任何<strong>文字</strong>(如常数、字符串)组成的元组</li>
  <li><code>co_varnames</code>：一个包含所有函数体中使用到的局部变量的名字的元组</li>
  <li><code>co_names</code>：一个包含任何函数中引用过的非局部名字的元组，包括变量名，调用的函数名等</li>
  <li><code>co_code</code>：原始字节码</li>
</ul>
<p>Python 解释器是一个字节码解释器，模拟真实计算机的软件。</p>
<p>解释器在执行字节码时操作的是数据栈。</p>
<p>Frame：一个 frame 是一些信息的集合和代码的上下文。frame 在 Python 代码执行时动态地创建和销毁，每个 frame 对应函数的一次调用，所以每个 frame 只有一个 code object 与之关联，相反，一个 code object 可以有多个 frame，如递归函数。总的来说，Python 程序的每个作用域有一个 frame，比如每个模块，每个函数调用，每个类定义。</p>
<p>每个 frame 都有自己特定的 data stack 和 block stack 。</p>
<p>例如：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(y)</span>:</span></div><div class="line"><span class="meta">... </span>    z = y + <span class="number">3</span>     <span class="comment"># &lt;--- (3) ... and the interpreter is here.</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> z</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    a = <span class="number">1</span></div><div class="line"><span class="meta">... </span>    b = <span class="number">2</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> a + bar(b) <span class="comment"># &lt;--- (2) ... which is returning a call to bar ...</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo()             <span class="comment"># &lt;--- (1) We're in the middle of a call to foo ...</span></div><div class="line"><span class="number">3</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>假设此时，解释器正在 <code>foo</code> 函数的调用中，紧接着调用 <code>bar</code> ，则 call stack，data stack，block stack 的示意图如下：</p>
<p><img src="/photos/py/ic.png" alt=""></p>
<p>现在，解释器在 <code>bar</code> 函数的调用中，call stack 中有三个 frame，一旦 <code>bar</code> 返回，与之对应的 frame 就会被弹出并丢弃。</p>
<p>字节码指令<code>RETURN_VALUE</code>告诉解释器在 frame 间传递一个值。首先，它把位于调用栈栈顶的 frame 中的 data stack 的栈顶值弹出。然后把整个 frame 弹出丢弃，最后把这个值压到下一个 frame 的 data stack 中。</p>
<h3 id="Python-代码编译过程："><a href="#Python-代码编译过程：" class="headerlink" title="Python 代码编译过程："></a>Python 代码编译过程：</h3>
<ul>
  <li>解析源代码生成解析树(parse tree)</li>
  <li>将解析树转换成抽象语法树 AST</li>
  <li>生成符号表</li>
  <li>根据 AST 生成 code object：AST -&gt; 控制流图 -&gt; code object</li>
</ul>
<p>使用 <code>parser</code> 模块可以获得 Python 代码的 parse tree：</p>
<figure class="highlight inform7">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">&gt;&gt;&gt;code_str = <span class="string">""</span><span class="string">"def hello_world():</span></div><div class="line">                     return 'hello world'</div><div class="line">              "<span class="string">""</span></div><div class="line">&gt;&gt;&gt; import parser</div><div class="line">&gt;&gt;&gt; from pprint import pprint</div><div class="line">&gt;&gt;&gt; st = parser.suite(code_str)</div><div class="line">&gt;&gt;&gt; pprint(parser.st2list(st))</div><div class="line"><span class="comment">[257,</span></div><div class="line"><span class="comment">[269,</span></div><div class="line"><span class="comment">[294,</span></div><div class="line"><span class="comment">[263,</span></div><div class="line">    <span class="comment">[1, 'def']</span>,</div><div class="line">    <span class="comment">[1, 'hello_world']</span>,</div><div class="line">    <span class="comment">[264, <span class="comment">[7, '(']</span>, <span class="comment">[8, ')']</span>]</span>,</div><div class="line">    <span class="comment">[11, ':']</span>,</div><div class="line">    <span class="comment">[303,</span></div><div class="line">    <span class="comment">[4, '']</span>,</div><div class="line">    <span class="comment">[5, '']</span>,</div><div class="line">    <span class="comment">[269,</span></div><div class="line">    <span class="comment">[270,</span></div><div class="line">    <span class="comment">[271,</span></div><div class="line">        <span class="comment">[277,</span></div><div class="line">        <span class="comment">[280,</span></div><div class="line">        <span class="comment">[1, 'return']</span>,</div><div class="line">        <span class="comment">[330,</span></div><div class="line">        <span class="comment">[304,</span></div><div class="line">            <span class="comment">[308,</span></div><div class="line">            <span class="comment">[309,</span></div><div class="line">            <span class="comment">[310,</span></div><div class="line">            <span class="comment">[311,</span></div><div class="line">                <span class="comment">[314,</span></div><div class="line">                <span class="comment">[315,</span></div><div class="line">                <span class="comment">[316,</span></div><div class="line">                <span class="comment">[317,</span></div><div class="line">                    <span class="comment">[318,</span></div><div class="line">                    <span class="comment">[319,</span></div><div class="line">                    <span class="comment">[320,</span></div><div class="line">                    <span class="comment">[321,</span></div><div class="line">                        <span class="comment">[322, <span class="comment">[323, <span class="comment">[3, '"hello world"']</span>]</span>]</span>]]]]]]]]]]]]]]]]],</div><div class="line">    <span class="comment">[4, '']</span>]],</div><div class="line">    <span class="comment">[6, '']</span>]]]],</div><div class="line"><span class="comment">[4, '']</span>,</div><div class="line"><span class="comment">[0, '']</span>]</div><div class="line">&gt;&gt;&gt;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>使用 <code>ast</code> 模块来获取 Python 代码的 AST：<br>
  <figure class="highlight python">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">&gt;&gt;&gt;code_str = <span class="string">"""def hello_world():</span></div><div class="line">                     return 'hello world'</div><div class="line">              """</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>node = ast.parse(code_str, mode=<span class="string">"exec"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(node)</div><div class="line">(<span class="string">"Module(body=[FunctionDef(name='hello_world', args=arguments(args=[], "</span></div><div class="line"><span class="string">'vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), '</span></div><div class="line"><span class="string">"body=[Return(value=Str(s='hello world'))], decorator_list=[], "</span></div><div class="line"><span class="string">'returns=None)])'</span>)</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>Names and binding in Python：在 Python 中，对象通过名字引用，binding 即名字与对象的绑定，名字仅仅是与对象相联系的符号，是对象的引用，没有类型，对象具有类型。</p>
<p>Code Blocks: A code block is a piece of program code that is executed as a single unit in python. Modules, functions and classes are all examples of code blocks. Commands typed in interactively at the REPL, script commands run with the -c option are also
  code blocks.</p>
<p>Namespaces：在 Python 中，名字空间通过字典映射实现，包含所有内建函数的内建名字空间可通过 <code>__builtins__.__dict__</code> 访问。</p>
<h3 id="Python-Objects"><a href="#Python-Objects" class="headerlink" title="Python Objects"></a>Python Objects</h3>
<p>Python 中的所有对象，函数、变量等，都是 <code>PyObject</code> ，或者说 <code>PyObject</code> 是所有 Python 对象的超类。</p>
<p><code>PyObject</code> 定义：<br>
  <figure class="highlight thrift">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> </span>&#123;</div><div class="line">    _PyObject_HEAD_EXTRA</div><div class="line">    Py_ssize_t ob_refcnt;</div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *ob_type;</span></div><div class="line">&#125; PyObject;</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p><code>_PyObject_HEAD_EXTRA</code> 是一个宏，<code>ob_refcnt</code> 用于内存管理，表明该对象的引用次数，<code>ob_type</code> 是指向 type object 的指针。一个有趣的事,<code>type</code> 函数的 type 就是 <code>type</code>，因此，<code>type</code> 函数的 <code>ob_type</code> 域指向自身。</p>
<ul>
  <li><code>type</code> 类型是所有内建类型的元类型</li>
  <li><code>object</code> 类型是所有用户自定义类型的元类型</li>
</ul>
<h3 id="Code-Objects"><a href="#Code-Objects" class="headerlink" title="Code Objects"></a>Code Objects</h3>
<p>Code Objects 是已编译可执行 Python 代码，其中包含可运行的字节码指令。</p>
<p>给定一个函数，我们可以通过 <code>__code__</code> 属性访问函数体的 code object：</p>
<figure class="highlight ruby">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span></span>:</div><div class="line">...     print(<span class="string">"hello, world!"</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; hello.__code_<span class="number">_</span></div><div class="line">&lt;code object hello at <span class="number">0x7fd58d3b4ed0</span>, file <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>&gt;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>Code Object 的 <code>co_code</code> 属性包含字节码指令序列：<br>
  <figure class="highlight llvm">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">&gt;&gt;&gt; hello.__code__.co_code</div><div class="line">b't\<span class="keyword">x</span><span class="number">00</span>d\<span class="keyword">x</span><span class="number">01</span>\<span class="keyword">x</span><span class="number">83</span>\<span class="keyword">x</span><span class="number">01</span>\<span class="keyword">x</span><span class="number">01</span>\<span class="keyword">x</span><span class="number">00</span>d\<span class="keyword">x</span><span class="number">00</span>S\<span class="keyword">x</span><span class="number">00</span>'</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>字节码指令的大小为两字节，一字节为 opcode(现为两字节大小)，另一字节为 opcode 的参数。如果 opcode 不需要参数，则对应参数部分为 0。</p>
<h3 id="Frames-Objects"><a href="#Frames-Objects" class="headerlink" title="Frames Objects"></a>Frames Objects</h3>
<p>Frame object 为 code object 的执行提供上下文信息。</p>
<p>通过 <code>sys._getframe()</code> 访问 frame object：</p>
<figure class="highlight ruby">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; import sys</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; f = sys._getframe()</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; f</div><div class="line">&lt;frame object at <span class="number">0x7fd580fd0b28</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; dir(f)</div><div class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'clear'</span>, <span class="string">'f_back'</span>, <span class="string">'f_builtins'</span>, <span class="string">'f_code'</span>, <span class="string">'f_globals'</span>, <span class="string">'f_lasti'</span>, <span class="string">'f_lineno'</span>, <span class="string">'f_locals'</span>, <span class="string">'f_trace'</span>]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>在一个 code object 执行前，都需要创建一个 frame object，该 frame object 包含该 code object 执行需要的所有名字空间，一个指向当前执行的线程的引用，data stack，block stack，以及其它 code object 执行需要的重要信息。</p>
<p>在 Python 代码执行过程中，需要通过调用 <code>PyFrame_New</code> 函数创建很多次 frame object，为了减少函数调用带来的开销，采用了两种优化方式：</p>
<ul>
  <li>Code object 有一个域 <code>co_zombieframe</code> ，当一个 object 执行过后，对应的 frame 不会立刻释放，而会保存到 <code>co_zombieframe</code> 中，从而当下次执行相同的 code object 时，不需要再次分配内存创建新的 frame；</li>
  <li>Python 虚拟机维护一个预分配好的空闲 frame 列表，供 code object 使用； </li>
</ul>
<h3 id="解释器状态和线程状态"><a href="#解释器状态和线程状态" class="headerlink" title="解释器状态和线程状态"></a>解释器状态和线程状态</h3>
<p>Interpreter state 保存一个 Python 进程中一系列协作线程共享的全局状态。</p>
<p>一个 thread state 与一个正在运行的 Python 进程的 native OS thread 相联系。</p>
<p>解释器状态、线程状态和 frame 之间的关系：</p>
<p><img src="/photos/py/state.png" alt=""></p>
<h3 id="The-evaluation-loop-ceval-c"><a href="#The-evaluation-loop-ceval-c" class="headerlink" title="The evaluation loop, ceval.c"></a>The evaluation loop, ceval.c</h3>
<p>Python 虚拟机循环迭代 code object 的每一条指令并执行：<code>Python/ceval.c</code>，关键函数：<code>PyEval_EvalFrameEx</code>。</p>
<p>在 <code>PyEval_EvalFrameEx</code> 函数执行 Python 字节码之前，需要进行大量的设置工作，包括错误检查、frame 创建和初始化等(<code>_PyEval_EvalCodeWithName</code> 函数)。</p>
<h3 id="Block-Stack"><a href="#Block-Stack" class="headerlink" title="Block Stack"></a>Block Stack</h3>
<p>通过 block stack，能够很方便地实现异常处理，且仅用于处理循环和异常。<code>PyFrame_BlockSetup</code> 函数创建一个一个新的 block 并 push 到 block stack。</p>
<h3 id="从-Class-code-到字节码"><a href="#从-Class-code-到字节码" class="headerlink" title="从 Class code 到字节码"></a>从 Class code 到字节码</h3>
<p>创建类的过程大致如下：</p>
<ul>
  <li>将类定义语句放入一个 code object 中</li>
  <li>确定该类实例的合适元类</li>
  <li>为该类的名字空间准备一个字典</li>
  <li>在该名字空间内执行上述对应的 code object</li>
  <li>通过实例化元类创建类对象</li>
</ul>
<p>元类确定：</p>
<ul>
  <li>如果没有给定基类或明确的元类，则使用 <code>type()</code></li>
  <li>如果给定了明确的元类但不是 <code>type()</code> 的实例，则使用该元类</li>
  <li>如果给定了 <code>type()</code> 的实例作为明确元类，或者定义了基类，则使用最派生的元类。</li>
</ul>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3>
<p>生成器对象包含一个 frame object 和 code object，当生成器函数被调用时，它并不会运行，而是返回一个生成器对象，只有将生成器对象作为一个参数传入内建的 <code>next</code> 函数时，生成器对象才能够运行：即在生成器对象所包含的 frame object 内调用 <code>PyEval_EvalFrameEx</code> 函数。</p>
<p>当生成器函数执行遇到 <code>YIELD_VALUE</code> opcode 时，该 opcode 会使得执行暂停，并将栈顶值返回给调用者。暂停意味着当前正在执行的 frame 退出了，但是它并不会被释放，因为该 frame 还在被生成器对象引用，并且能够再次执行，即再次以该 frame 作为参数调用 <code>PyEval_EvalFrameEx</code> 函数时。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3>
<ul>
  <li><a href="https://leanpub.com/insidethepythonvirtualmachine/read" target="_blank" rel="external">Inside the Python virtual machine</a></li>
  <li><a href="https://opensource.com/article/18/4/introduction-python-bytecode" target="_blank" rel="external">An introduction to Python bytecode</a></li>
  <li><a href="http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html" target="_blank" rel="external">A Python Interpreter Written in Python</a></li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为查阅相关资料的过程中随手记录的，故内容较为杂乱，无任何章节可言。&lt;/p&gt;
&lt;p&gt;Python 源代码执行流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/photos/py/py.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Python 基于栈式执行，CPython 主要使用三种类型的栈：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;call stack：一个 frame 表示一个活动的函数调用&lt;/li&gt;
  &lt;li&gt;data stack：也称作 evaluation stack，每一个函数对应一个 data stack，函数在其中进行数据操纵，包括函数参数，返回地址等&lt;/li&gt;
  &lt;li&gt;block stack：用于跟踪控制结构的确定类型：如循环，&lt;code&gt;try/except&lt;/code&gt; 块，&lt;code&gt;with&lt;/code&gt; 块等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CPython" scheme="http://ucasfl.me/categories/CPython/"/>
    
    
      <category term="CPython" scheme="http://ucasfl.me/tags/CPython/"/>
    
  </entry>
  
  <entry>
    <title>向量量化与乘积量化简介</title>
    <link href="http://ucasfl.me/2019/01/13/VQ-and-PQ-introduction/"/>
    <id>http://ucasfl.me/2019/01/13/VQ-and-PQ-introduction/</id>
    <published>2019-01-13T05:36:07.000Z</published>
    <updated>2019-01-13T08:26:51.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="向量量化-VQ"><a href="#向量量化-VQ" class="headerlink" title="向量量化-VQ"></a>向量量化-VQ</h3>
<p>向量量化（Vector Quantization）是一个常见的压缩技术，广泛用于信号处理和数据压缩等领域。VQ 一个比较正式的定义是将一个向量空间中的点用其中的一个有限子集来进行编码的过程。它是一种基于块编码规则的有损数据压缩方法，基本思想是：将若干个标量数据组构成一个矢量，然后在矢量空间给以整体量化，从而压缩了数据而不损失多少信息。</p>
<a id="more"></a>
<p>VQ实际上就是一种逼近，它的思想和“四舍五入”有异曲同工之妙，都是用一个和一个数最接近的整数来近似表示这个数。用二维图像压缩来说明，将图像的每个像素点当作一个数据，跑一下 K-means 聚类，假设将图像聚为k类，就会得到每类的质心centroids，共k个，然后用这些质心的像素值来代替对应的类里的所有点的像素值。这样就起到了压缩的目的，因为只需要编码k个像素值（和图像每个像素点对这k个值的索引）就可以表示整张图像了。当然，这会存在失真。最偏激的情况是原图像每个像素就是一个类，那就没有失真了，当然也没有了压缩。</p>
<p>VQ 问题可以描述如下：给定一个已知统计属性的矢量源（也就是训练样本集，每一个样本是一个矢量）和一个失真测度，同时给定码矢的数量（也就是我们要把这个矢量空间划分为多少部分，或者说量化为多少种值），然后寻找一个具有最小平均失真度的码书（所有码矢的集合）和空间的划分。简单描述为：给定T（训练集）和N（码矢数目），找到能使Dave（平均失真度）最小的C（码书）和P（空间划分）。</p>
<p>如果 C 和 P 是上面最小化问题的一个解，那么需要满足两个条件：</p>
<ul>
  <li>最近邻条件</li>
  <li>质心条件</li>
</ul>
<h3 id="乘积量化-PQ"><a href="#乘积量化-PQ" class="headerlink" title="乘积量化-PQ"></a>乘积量化-PQ</h3>
<p>乘积量化（Product quantization），这里的乘积是指笛卡尔积，其思想是把原向量空间分解为若干个低维向量空间的笛卡尔积，并对分解得到的低维向量空间分别做量化，这样每个向量就能由多个低维向量的量化 code 表示。</p>
<p>PQ 本质上是一种数据压缩表达方法，可用于相似搜索、模型压缩等领域，特别是深度神经网络的模型压缩上。PQ 算法可以理解为对 VQ 做了一次分治，首先把原始向量空间分解为 m 个低维向量空间的笛卡尔积，并对分解得到的低维向量空间分别做量化。对低维向量空间的量化同样是使用 K-means 算法。换句话描述就是，把原始 D 维向量（比如 D = 128 ）分成 m 组（比如 m = 4 ），每组就是 D’ = D / m 维的子向量（比如 D’ = D / m = 128 / 4 = 32 ），各自用
  K-means 算法学习到一个码本，然后这些码本的笛卡尔积就是原始 D 维向量对应的码本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;向量量化-VQ&quot;&gt;&lt;a href=&quot;#向量量化-VQ&quot; class=&quot;headerlink&quot; title=&quot;向量量化-VQ&quot;&gt;&lt;/a&gt;向量量化-VQ&lt;/h3&gt;
&lt;p&gt;向量量化（Vector Quantization）是一个常见的压缩技术，广泛用于信号处理和数据压缩等领域。VQ 一个比较正式的定义是将一个向量空间中的点用其中的一个有限子集来进行编码的过程。它是一种基于块编码规则的有损数据压缩方法，基本思想是：将若干个标量数据组构成一个矢量，然后在矢量空间给以整体量化，从而压缩了数据而不损失多少信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://ucasfl.me/categories/Algorithms/"/>
    
    
      <category term="VQ PQ" scheme="http://ucasfl.me/tags/VQ-PQ/"/>
    
  </entry>
  
  <entry>
    <title>华为校招面试总结</title>
    <link href="http://ucasfl.me/2018/10/15/huawei-interview-summary/"/>
    <id>http://ucasfl.me/2018/10/15/huawei-interview-summary/</id>
    <published>2018-10-15T10:15:13.000Z</published>
    <updated>2019-02-22T13:30:14.706Z</updated>
    
    <content type="html"><![CDATA[<p>前天晚上参加了华为的校招笔试，结果昨天早上刚睡醒就收到短信通知今天面试…</p>
<p>今天去参加了面试，现在把面试中的一些问题总结一下。<del>虽然我对这次面试并不满意，估计也不太可能拿到 offer</del></p>
<p>拿到华为 offer 了，如果考研失败就滚去搬砖(18年11月6号)。</p>
<p>399 分，所以研究生应该稳了(19年2月22日)。</p>
<a id="more"></a>
<p>面试貌似是三轮，两轮业务面试，一轮综合面试，但是不知道为什么，我面了一轮业务面试之后，就直接通知综合面试了。</p>
<p>接下来，说一说面试的情况吧。</p>
<h3 id="业务面试"><a href="#业务面试" class="headerlink" title="业务面试"></a>业务面试</h3>
<p>不知道是面试官的原因，还是华为的面试就是这样，感觉整个业务面试没有问太多很有深度的问题，也没有考算法，只问了一些操作系统，C++，数据结构方面的基础知识。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4>
<p>首先问的是几个操作系统方面的问题。</p>
<p><em>“操作系统有哪几个主要模块?”</em><br><em>“进程管理，虚存管理，文件管理/文件系统，输入输出系统“</em></p>
<p>操作系统课上学的大概就这几个模块吧，同步与通信不知道算不算一个单独的模块。</p>
<p><em>“内核是什么？”</em><br><em>“内核是操作系统最重要的组成部分，是计算机软件与硬件的接口……”</em></p>
<p>回答记不太清了，这个问题当时我还真不知道怎么回答，内核是什么是知道的，却没有想好怎么描述比较好，但是我觉得回答的不太好总比什么都不说好。<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/297824" target="_blank" rel="external">百度百科</a>关于内核的定义是这样的：操作系统内核是指大多数操作系统的核心部分。它由操作系统中用于管理存储器、文件、外设和系统资源的那些部分组成。操作系统内核通常运行进程，并提供进程间的通信。后来想想，当时的回答最大的缺点是少了一句：管理计算机资源的系统软件</p>
<p><em>“虚地址通过什么转换成物理地址，如何转换？”</em><br><em>“MMU，转换时，先从虚地址中取出段号，从段表中到对应的段，然后取出页号，从页表中找出对应的页表项，从而得到物理页号，加上偏移得到物理地址”</em></p>
<p>我回答的实际上是“段页式”管理的转换方法。MMU 的转换分“硬件控制的 TLB” 和”软件控制的 TLB“ 两种。</p>
<p>硬件控制的 TLB：<br><img src="/photos/huawei/ying.png" alt=""></p>
<p>软件控制的 TLB：<br><img src="/photos/huawei/ruan.png" alt=""></p>
<p><em>“写程序时，你看到的是虚地址还是物理地址？”</em><br><em>“虚地址”</em></p>
<p>下面问了几个 C++ 的问题。</p>
<p><em>“虚函数是什么？”</em><br><em>“带有 <code>virtual</code> 关键字的成员函数，基类中定义的虚函数可以在派生类中重新实现。”</em></p>
<p><em>“有一个虚函数在基类和派生类中均有实现，现在用一个基类指针指向一个派生类对象，当调用该虚函数时，会调用基类的虚函数还是派生类的虚函数？”</em><br><em>“派生类，因为虚函数支持动态绑定。”</em></p>
<p><em>“它是如何调用的？”</em><br><em>“通过查虚函数表。”</em><br><em>“通过什么指针调用？”</em><br><em>“不知道。”</em></p>
<p>说实话，这两个问题我是有点懵的，这似乎是要问 C++ 底层的东西了，虽然我也大概知道一些关于虚函数表，虚函数调用的东西，但是并不是很清楚，于是没有回答上来。然后，面试官在纸上写了一个，通过 <code>this</code> 指针调用。原来这个问题他想要的答案只是通过 <code>this</code> 指针调用，是我自己把问题想复杂了。</p>
<p><em>“纯虚函数是什么？”</em><br><em>“纯虚函数就是只定义不实现的虚函数。”</em></p>
<p><em>“含有虚函数的类可以实例化吗？”</em><br><em>“不可以”</em></p>
<p>含有纯虚函数的类是抽象类，不可以实例化。只有实现了该纯虚函数的派生类才可以实例化。</p>
<p>最后问了几个数据结构方面的问题。</p>
<p><em>“栈和队列的区别是什么?“</em><br><em>“栈是先进后出，队列是先进先出。”</em></p>
<p><em>“什么是平衡二叉树。”</em><br><em>“平衡二叉树首先是一棵二叉树，然后满足左右子树的高度差不超过 1，并且这是一个递归定义，即子树的左右子树高度差也不能超过 1。”</em></p>
<p><em>“二叉树有几种遍历方式？”</em><br><em>“三种，前序遍历，中序遍历，后序遍历。”</em></p>
<p>其实，当时想起来了还有层次遍历，但是当时不知道脑子中了什么邪，就是没有接着说层次遍历。然后，面试官在纸上画了一棵三层的满二叉树。让我写出三种遍历方式对应的遍历序列。写完后，他看了看，对我说是不是有点不太对，我又看了一遍，没问题啊，然后他说可能是我记不太清了…</p>
<p>大概就问了这些问题，之后他问我有没有什么想问的问题，我问了下关于新员工的入职培训，近期项目，以及新员工的薪资：13k~16k X 15。看来网上流传的白菜价大概八九不离十吧。</p>
<p>业务面试就结束了，让我等待后续的面试通知。</p>
<h3 id="综合面试"><a href="#综合面试" class="headerlink" title="综合面试"></a>综合面试</h3>
<p>综合面试没有问什么技术问题。大概问了这么些问题：</p>
<p>最近有做过些什么项目？项目是干什么的？你在项目中做了什么工作？收获了什么？</p>
<p>这个问题问的算是最具体的一个，我觉得自己回答的并不好。</p>
<p>大学里学了些什么课程？入职之后遇到困难你会怎么办？刚入职时可能会要接触很多新的东西，之前不会的东西，你怎么看？如果有一个任务，在规定期限你完成不了你会怎么办？未来五年的人生你想达到什么目标？十年呢？你对华为了解多吗，以你的了解，华为是一家什么样的公司？对加班有什么看法？你希望华为带给你什么？你认为你能够给华为带来什么？假如有别的公司和华为同时给了你 offer，你会如何选，选择的时候你会看重公司的什么方面？比如一个 BAT 公司和华为同时给了你 offer？</p>
<p>大概还记得的就这么多问题，都是一些开放性的问题，说不上有什么标准答案。后面面试官又问我有没有在准备考研，如果考上研了和工作会选择什么？这个问题我没有回答。首先，问我有没有在准备考研我没有想撒谎，就实话说了，然后问我选什么没有回答上，于是就结束了，告诉我等待后续通知。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
<p>最后，总结一下自己的经验吧：</p>
<ol>
  <li>自己的专业知识要掌握扎实，这是前提条件，否则笔试都过不了，更别提面试了。</li>
  <li>项目经历很重要， HR 不仅要考察你的专业能力，还要看你过去做过些什么东西，如果你有参与过一些比较大的项目，并且能够把项目描述清楚，以及你在项目中所做的贡献和从中的收获，那么会是很大的加分项。</li>
  <li>良好的表达能力和沟通能力，要能够清晰明确的回答出问题，尤其是一些观点性问题，由于答案不是唯一的，此时，表达能力尤为重要。</li>
  <li>放平心态，千万不要因为紧张导致原本知道的东西都回答不上来。但是也不要一听完问题就急于回答，可以稍微思考一下，组织一下语言。</li>
  <li>公司除了看你的能力，还要看你对工作的态度，对公司的看法等各方面的情况，因此这些方面的问题不容忽视，尤其要能够清楚地让对方知道你能够为公司带来什么。</li>
</ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天晚上参加了华为的校招笔试，结果昨天早上刚睡醒就收到短信通知今天面试…&lt;/p&gt;
&lt;p&gt;今天去参加了面试，现在把面试中的一些问题总结一下。&lt;del&gt;虽然我对这次面试并不满意，估计也不太可能拿到 offer&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;拿到华为 offer 了，如果考研失败就滚去搬砖(18年11月6号)。&lt;/p&gt;
&lt;p&gt;399 分，所以研究生应该稳了(19年2月22日)。&lt;/p&gt;
    
    </summary>
    
      <category term="Interview" scheme="http://ucasfl.me/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://ucasfl.me/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>华为校招笔试总结</title>
    <link href="http://ucasfl.me/2018/10/13/huawei-Application-Summary/"/>
    <id>http://ucasfl.me/2018/10/13/huawei-Application-Summary/</id>
    <published>2018-10-13T13:00:54.000Z</published>
    <updated>2019-02-22T13:12:38.496Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上参加了华为今年的校招笔试（软件类）。华为的笔试题只有三个算法题，三个题相对来说都比较简单，没有太大难度。<br>
  <a id="more"></a>
</p>
<p><strong>1. n个人（n &gt;= 1) 站成一个环，编号为 1 ~ n，即编号为 n 的人与编号为 1 的人相邻，从第一个人开始报数，假如编号为 x 的报数为 m ，则该人出局，出局后不再参加报数，出局这一个人的后面一个人从 1 开始继续报数，直到所有人都出局，要求输出出局的编号序列。</strong></p>
<p>该题为著名的<a href="https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/348830?fr=aladdin" target="_blank" rel="external">约瑟夫环</a>问题，实现方法很多。可通过模拟，也可通过数学公式推导，网上有现成的代码，不过考试的时候我没有上网找，是自己实现的，算是一个数学推导的方法吧。</p>
<p>考试时的 AC 代码：</p>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">/*************************************************************************</span></div><div class="line">    &gt; Filename: dele.cpp</div><div class="line">    &gt; Author: Lv Feng</div><div class="line">    &gt; Mail: lvfeng97@outlook.com</div><div class="line">    &gt; Date: 2018-10-13</div><div class="line"> ************************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> <span class="keyword">int</span> &amp;m)</span></span>&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; people;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</div><div class="line">	  people.push_back(i);</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator cur = people.begin();</div><div class="line">	<span class="keyword">int</span> loc;</div><div class="line">	<span class="keyword">while</span>(people.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">		loc = (cur - people.begin() + m) % people.size() - <span class="number">1</span>; </div><div class="line">		<span class="keyword">if</span> (loc == <span class="number">-1</span>)&#123;</div><div class="line">			loc = people.size() - <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; people[loc] &lt;&lt; <span class="string">' '</span>;</div><div class="line">		cur = people.erase(people.begin() + loc);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt;  people[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> num;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; num;</div><div class="line">	<span class="keyword">int</span> data[num][<span class="number">2</span>];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != num; ++i)&#123;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; data[i][<span class="number">0</span>] &gt;&gt; data[i][<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != num; ++i)&#123;</div><div class="line">		Solve(data[i][<span class="number">0</span>], data[i][<span class="number">1</span>]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>n 个数用 vector 存储，每次确定一个出列的数，然后输出该数并将该数从 vector 中删除，算法时间复杂度为 O(n)。<code>main</code> 函数中的 <code>num</code> 变量表示测试数据的组数。</p>
<p><strong>2. 给定一个 10X10 的方格，数组中的数均为 0 或 1，每一个为 1 的方格的面积为 1，要求求出 1 的连通区域的最大面积（连通区域由上下左右为 1 的方格组成，不包括对角线）</strong></p>
<p>本题中，<code>10x10</code> 的方格可以看成是一个二维数组，每次从一个没有遍历过的为 1 的元素出发，向四周遍历，所有为 1 的元素都遍历一遍就可求出最大连通面积。</p>
<p>考试时的 AC 代码如下：</p>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">/*************************************************************************</span></div><div class="line">    &gt; Filename: max.cpp</div><div class="line">    &gt; Author: Lv Feng</div><div class="line">    &gt; Mail: lvfeng97@outlook.com</div><div class="line">    &gt; Date: 2018-10-13</div><div class="line"> ************************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Len = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> data[<span class="number">10</span>][<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> visited[Len][Len];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != Len; ++i)</div><div class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != Len; ++j)</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; data[i][j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getS</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(data[m][n] == <span class="number">0</span> || visited[m][n])</div><div class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		s += <span class="number">1</span>;</div><div class="line">		visited[m][n] = <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (m - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</div><div class="line">			s += getS(m<span class="number">-1</span>, n);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (m + <span class="number">1</span> &lt; Len)&#123;</div><div class="line">			s += getS(m+<span class="number">1</span>, n);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (n - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</div><div class="line">			s += getS(m, n<span class="number">-1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (n + <span class="number">1</span> &lt;Len)&#123;</div><div class="line">			s += getS(m, n+ <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> maxS = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> tmp;</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i != Len; ++i)&#123;</div><div class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j != Len; ++j)&#123;</div><div class="line">			<span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="number">100</span>);</div><div class="line">			tmp = getS(i, j);</div><div class="line">			maxS = (tmp &gt; maxS)? tmp: maxS;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; maxS &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	input();</div><div class="line">	Solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>上面的代码实现中，从每一个元素开始都进行了一次遍历，实际上是不需要的，比如，对于值为 0 的元素，不需要从它开始进行遍历，另外，对于每一个 1 ，实际上也只需要遍历一次，但这儿遍历了多次，因为从每一个 1 出发都进行了一次遍历，如果数组不是 <code>10x10</code>，比如是 <code>1000x1000</code> ，那么这样可能会导致超时。</p>
<p>优化后的代码如下：</p>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">/*************************************************************************</span></div><div class="line">    &gt; Filename: max.cpp</div><div class="line">    &gt; Author: Lv Feng</div><div class="line">    &gt; Mail: lvfeng97@outlook.com</div><div class="line">    &gt; Date: 2018-10-13</div><div class="line"> ************************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Len = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> data[<span class="number">10</span>][<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> visited[Len][Len];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != Len; ++i)</div><div class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != Len; ++j)</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; data[i][j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getS</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(!data[m][n] || visited[m][n])</div><div class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		s += <span class="number">1</span>;</div><div class="line">		visited[m][n] = <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (m - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</div><div class="line">			s += getS(m<span class="number">-1</span>, n);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (m + <span class="number">1</span> &lt; Len)&#123;</div><div class="line">			s += getS(m+<span class="number">1</span>, n);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (n - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</div><div class="line">			s += getS(m, n<span class="number">-1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (n + <span class="number">1</span> &lt;Len)&#123;</div><div class="line">			s += getS(m, n+ <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> maxS = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> tmp;</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i != Len; ++i)&#123;</div><div class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j != Len; ++j)&#123;</div><div class="line">			<span class="keyword">if</span>(!data[i][j] || visited[i][j])</div><div class="line">			  <span class="keyword">continue</span>;</div><div class="line">			tmp = getS(i, j);</div><div class="line">			maxS = (tmp &gt; maxS)? tmp: maxS;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; maxS &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	input();</div><div class="line">	Solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>实际上，只是在 <code>for</code> 循环里面多了一个 <code>if</code> 判断，这样对于为 0 的元素，就不用进入函数，减少了函数调用的开销，同时，不需要从每一个 1 都开始进行一次遍历，因此，不需要每次循环都对 <code>visited</code> 数组进行一次 <code>memset</code> 。</p>
<p><strong>3. 如果一个整数序列从前往后读和从后往前读序列相同，则称该序列为回文序列，如 (1)，(1, 3, 1) ，(23, 25, 25, 23)，给定一个整数序列，定义对该整数序列的一次操作如下：从该序列中选出两个数，将两个数相加，将相加后的和放入原来两个数在的位置（只放一个和），问任意给定一个序列，需要多少次这样的操作可将该序列变成一个回文序列。</strong></p>
<p>例如，序列为 (1, 1, 1, 3)，则两次操作可将其变为回文序列：(1, 1, 1, 3) -&gt;(2, 1, 3) -&gt; (3, 3)，即先将 1,2 两个数相加，再将 1,2 两个数相加。显然任意给定一个包含 n 个数的序列，最多进行 n-1 次操作即可将其变为回文序列，此时，序列中只有一个数。</p>
<p>一个序列要是回文序列，那么前后的数要分别相同，因此，我们设置两个指针，分别指向第一个数和最后一个数，如果第一个数和最后一个数相同，那么第一个指针加一，第二个指针减一，继续判断，如果不等，则将小的哪一端的数加到与它相邻的数上面，并将指针加一… 重复下去，直到第一个指针不小于第二个指针为止，此时的序列即为回文序列，这样便可求出操作次数。</p>
<ul>
  <li>Input : data[n];</li>
  <li>output : OpTime;</li>
</ul>
<ol>
  <li>Optime = 0; low = 0, high = n - 1;</li>
  <li>if (low &lt; high)
    <ul>
      <li>if (data[low] == data[high]) low = low + 1, high = high - 1, goto 2;</li>
      <li>else if (data[low] &lt; data [high]) data[low + 1] = data[low+1] + data[low], OpTime = OpTime + 1, low = low + 1, goto 2;</li>
      <li>else data[high - 1] = data[high-1] + data[high], OpTime = OpTime + 1, high = high - 1, goto 2</li>
    </ul>
  </li>
  <li>else return OpTime;</li>
</ol>
<p>AC 代码如下：</p>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">/*************************************************************************</span></div><div class="line">  &gt; Filename: huiwen.cpp</div><div class="line">  &gt; Author: Lv Feng</div><div class="line">  &gt; Mail: lvfeng97@outlook.com</div><div class="line">  &gt; Date: 2018-10-13</div><div class="line"> ************************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxNum = <span class="number">50</span>;</div><div class="line"><span class="keyword">int</span> data[MaxNum];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)&#123;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; data[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> Time = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(low &lt; high)&#123;</div><div class="line">		<span class="keyword">if</span> (data[low] == data[high])&#123;</div><div class="line">			++low;</div><div class="line">			--high;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(data[low] &lt; data[high])&#123;</div><div class="line">			++Time;</div><div class="line">			data[low+<span class="number">1</span>] += data[low];</div><div class="line">			++low;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			++Time;</div><div class="line">			data[high<span class="number">-1</span>] += data[high];</div><div class="line">			--high;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> Time;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	input();</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; Solve() &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天晚上参加了华为今年的校招笔试（软件类）。华为的笔试题只有三个算法题，三个题相对来说都比较简单，没有太大难度。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://ucasfl.me/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://ucasfl.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识整理</title>
    <link href="http://ucasfl.me/2018/09/10/os-review/"/>
    <id>http://ucasfl.me/2018/09/10/os-review/</id>
    <published>2018-09-10T14:00:00.000Z</published>
    <updated>2018-10-11T01:37:19.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter01-操作系统简介"><a href="#Chapter01-操作系统简介" class="headerlink" title="Chapter01 操作系统简介"></a>Chapter01 操作系统简介</h2>
<p><em>什么是操作系统</em></p>
<ul>
  <li>在应用和硬件之间的一层软件</li>
  <li>对上层软件提供硬件的抽象</li>
  <li>对底层硬件进行管理：共享和隔离</li>
  <li>对底层硬件的处理：细节实现</li>
</ul>
<a id="more"></a>
<h3 id="操作系统概观"><a href="#操作系统概观" class="headerlink" title="操作系统概观"></a>操作系统概观</h3>
<p><em>典型Unix操作系统结构</em></p>
<ul>
  <li>用户层
    <ul>
      <li>应用：程序员编写并编译后的用户程序</li>
      <li>库：精心设计的代码，预编译好的对象，通过头文件定义，通过链接器引入，类似函数调用程序加载时必须定位</li>
    </ul>
  </li>
  <li>核心层
    <ul>
      <li>可移植层：系统调用功能的集合</li>
      <li>机器相关层：启动，初始化，中断和例外，I/O设备驱动，内存管理，处理器调度，模式切换</li>
    </ul>
  </li>
</ul>
<p><em>四个段</em></p>
<ul>
  <li>代码段：指令序列</li>
  <li>数据段：全局数据，可能需要初始化
    <ul>
      <li>代码段/数据段由编译器静态分配，产生名字和符号索引</li>
      <li>链接器翻译索引和重定位地址</li>
      <li>加载器最终完成在内存的布局</li>
    </ul>
  </li>
  <li>堆
    <ul>
      <li>链接器和加载器确定起始地址</li>
      <li>由库函数malloc()/free()等进行分配和释放</li>
      <li>应用程序通过库函数进行管理，可能随机分配</li>
    </ul>
  </li>
  <li>栈
    <ul>
      <li>由编译器布局</li>
      <li>进程创建或结束时分配/释放</li>
      <li>相对于栈指针寻址，局部</li>
    </ul>
  </li>
</ul>
<p><em>中断</em></p>
<ul>
  <li>由外部事件触发</li>
  <li>中断处理程序运行在核心态</li>
  <li>最中恢复被中断的进程</li>
</ul>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3>
<p><em>保护机制</em></p>
<ul>
  <li>CPU
    <ul>
      <li>核心有能力把用户的CPU抢走，避免用户永久占用</li>
      <li>用户不能拥有这种能力</li>
    </ul>
  </li>
  <li>内存
    <ul>
      <li>防止一个用户修改其他用户的代码和数据</li>
      <li>防止用户修改内核的代码和数据结构</li>
    </ul>
  </li>
  <li>I/O：防止用户执行非法的I/O操作</li>
</ul>
<p><em>1.体系结构的支持：特权态</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch1/int-eret.png" alt="特权指令"></p>
<p><em>X86 Protection Rings</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch1/x86.png" alt="x86 protection rings"></p>
<p><em>2.层次结构</em>：不同层之间隐藏信息，层间存在依赖关系</p>
<ul>
  <li>优点：层功能独立</li>
  <li>缺点：效率低、不灵活</li>
</ul>
<p><em>3.一体结构（宏内核）</em></p>
<ul>
  <li>所以操作系统函数是一体的</li>
  <li>系统调用接口</li>
  <li>例子：Linux, BSD Unix, Windows</li>
  <li>优点L：共享内核地址空间，性能高</li>
  <li>缺点：不稳定，不灵活</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch1/syscall.png" alt="syscall"></p>
<p><em>4.微内核</em></p>
<ul>
  <li>操作系统服务作为常规的进程</li>
  <li>用户通过消息获取服务进程的服务</li>
  <li>例子：Mach, L4, MacOS</li>
  <li>优点：灵活，故障隔离</li>
  <li>缺点：效率低（需要穿越多个边界），保护机制不完整，内核和服务不方便共享数据</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch1/microkernel.png" alt="microkernel"></p>
<p><em>5.库操作系统（LibOS)</em></p>
<ul>
  <li>应用程序直接通过库与底层硬件交互</li>
  <li>例子：ExoKernel, EXOS</li>
  <li>优点：效率高</li>
  <li>缺点：通用性差</li>
</ul>
<p><em>6.虚拟机</em></p>
<ul>
  <li>虚拟机管理器：虚拟硬件，运行多个OS</li>
  <li>例子：IBM VM/370, Java VM, Vmware, Xen</li>
</ul>
<p><em>两种实现VMM的例子</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch1/vmm.png" alt="vmm"></p>
<p><em>OS状态切换</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch1/sw.png" alt="os switch"></p>
<p><em>7.系统调用机制</em></p>
<ul>
  <li>假设：
    <ul>
      <li>用户代码 是任意的</li>
      <li>用户无法修改核心内存</li>
    </ul>
  </li>
  <li>设计考虑：
    <ul>
      <li>系统调用参数传递</li>
      <li>系统模式从用户态切换到核心态</li>
      <li>执行系统调用功能</li>
      <li>返回结果，切换到用户态</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch1/syscc.png" alt="syscc"></p>
<p><em>8.中断与异常</em></p>
<ul>
  <li>中断源：
    <ul>
      <li>硬件（外部设备）</li>
      <li>软件 INT n</li>
    </ul>
  </li>
  <li>例外：
    <ul>
      <li>程序错误：fault, trap, abort</li>
      <li>软件生成：INT 3</li>
      <li>硬件检查例外（machine check）</li>
    </ul>
  </li>
</ul>
<p><em>9.系统调用</em></p>
<ul>
  <li>操作系统的API：应用和操作系统之间的接口</li>
  <li>种类：
    <ul>
      <li>进程管理</li>
      <li>内存管理</li>
      <li>文件管理</li>
      <li>设备管理</li>
      <li>通信</li>
    </ul>
  </li>
</ul>
<p><em>10.参数传递</em></p>
<ul>
  <li>寄存器传参：
    <ul>
      <li>寄存器个数</li>
      <li>可用寄存器个数</li>
      <li>系统调用参数个数</li>
      <li>编译器填充的代码</li>
    </ul>
  </li>
  <li>内存向量（数组）传参
    <ul>
      <li>一个寄存器传递起始地址</li>
      <li>向量位于用户地址空间</li>
    </ul>
  </li>
  <li>堆栈传参
    <ul>
      <li>类似内存向量</li>
      <li>遵循过程调用的约定</li>
    </ul>
  </li>
</ul>
<h2 id="Chapter02-进程和线程"><a href="#Chapter02-进程和线程" class="headerlink" title="Chapter02 进程和线程"></a>Chapter02 进程和线程</h2>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3>
<p><em>1.进程的起源</em></p>
<p>IBM 7090 机器上第一次实现了多个程序共同运行，”进程”开始登上历史舞台。</p>
<p><em>2.进程的概念</em></p>
<ul>
  <li>进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程</li>
  <li>进程刻画了一个程序运行所需要的资源</li>
  <li>进程 VS 程序：
    <ul>
      <li>进程 &gt; 程序
        <ul>
          <li>程序只是进程状态的一部分</li>
          <li>例子：多个用户可以运行相同的程序</li>
        </ul>
      </li>
      <li>进程 &lt; 程序
        <ul>
          <li>一个程序可以创建多个进程</li>
          <li>例子：创建新进程</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>3.并发性和进程</em></p>
<ul>
  <li>并发性：
    <ul>
      <li>一个系统中有上百个作业”同时“运行</li>
      <li>CPU是共享的，I/O设备也是</li>
      <li>每一个作业都希望能拥有自己的计算机</li>
    </ul>
  </li>
  <li>进程并发性：
    <ul>
      <li>将复杂的问题分解为多个简单的问题</li>
      <li>用进程来代表简单的问题</li>
      <li>一次只处理一个问题</li>
      <li>每一个进程就好像拥有了自己的计算机</li>
    </ul>
  </li>
</ul>
<p><em>4.进程并发性</em></p>
<ul>
  <li>虚拟化：
    <ul>
      <li>每个进程运行一段时间</li>
      <li>使得一个CPU变成”多个“</li>
      <li>每一个进程就好像拥有了自己的CPU</li>
    </ul>
  </li>
  <li>I/O并行性
    <ul>
      <li>CPU计算与I/O操作交叠</li>
      <li>每一个进程运行的很快，就如同拥有了自己的计算机</li>
      <li>减少了总共的完成时间</li>
    </ul>
  </li>
  <li>CPU并行性
    <ul>
      <li>多个CPU</li>
      <li>进程并行的运行</li>
      <li>加速</li>
    </ul>
  </li>
</ul>
<p><em>5.最简单的进程</em></p>
<ul>
  <li>顺序执行：
    <ul>
      <li>在进程内部没有并发性</li>
      <li>一切都是顺序发生</li>
      <li>需要一些协调机制</li>
    </ul>
  </li>
  <li>进程状态：寄存器，内存，I/O设备（文件系统，通信端口）…</li>
</ul>
<p><em>6.进程的表示</em></p>
<p><em>进程在内核中的表示</em></p>
<ul>
  <li>每个进程的创建和销毁都由内核负责，每个进程都需要在内核登记信息</li>
  <li>内核用进程控制块（PCB）来保存进程的信息</li>
  <li>PCB是进程在内核中的表示，也是一种索引</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/pcb.png" alt="pcb"></p>
<p><em>进程控制块包含的信息</em></p>
<ul>
  <li>进程标识信息</li>
  <li>与各种资源相关的信息：
    <ul>
      <li>CPU相关的进程管理信息：
        <ul>
          <li>状态：
            <ul>
              <li>就绪态：准备运行</li>
              <li>运行态：正在运行</li>
              <li>阻塞态：等待资源</li>
            </ul>
          </li>
          <li>寄存器：EFLAGS，以及其他的CPU状态</li>
        </ul>
      </li>
      <li>内存管理信息：
        <ul>
          <li>栈、代码段和数据段</li>
          <li>段、页表、统计信息等</li>
        </ul>
      </li>
      <li>I/O和文件管理：通信端口、目录、文件描述符等</li>
    </ul>
  </li>
</ul>
<p><em>7.进程的原语</em></p>
<ul>
  <li><strong>创建和终止</strong>：Exec, Fork, Wait, Kill</li>
  <li><strong>信号</strong>：动作，返回，信号处理函数</li>
  <li><strong>操作</strong>：阻塞，放弃CPU控制权</li>
  <li><strong>同步</strong></li>
</ul>
<p><em>构造一个进程</em></p>
<ul>
  <li>创建进程：创建与初始化PCB
    <ul>
      <li>将数据和代码加载至内存</li>
      <li>创建一个空的调用栈</li>
      <li>初始化进程的状态</li>
      <li>把进程状态标志为就绪态</li>
    </ul>
  </li>
  <li>克隆：复制与修改PCB
    <ul>
      <li>停止当前进程，并保存其状态</li>
      <li>备份当前代码、数据、栈和OS的状态</li>
      <li>把备份后的进程标志为就绪态</li>
    </ul>
  </li>
</ul>
<p><em>8.进程的状态</em></p>
<ul>
  <li>进程的声明周期：
    <ul>
      <li>非抢占式内核：
        <ul>
          <li>进程创建</li>
          <li>进程执行</li>
          <li>进程等待</li>
          <li>进程结束</li>
        </ul>
      </li>
      <li>抢占式内核：
        <ul>
          <li>进程创建</li>
          <li>进程执行</li>
          <li>进程等待</li>
          <li>进程抢占</li>
          <li>进程唤醒</li>
          <li>进程结束</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>进程创建</em>：</p>
<p>何时创建进程？</p>
<ul>
  <li>系统初始化时</li>
  <li>用户请求创建一个新进程</li>
  <li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
<p><em>进程执行</em>：</p>
<ul>
  <li>内核选择一个就绪的进程，为它分配一个处理器的时间片，并开始执行（时间片倒计时）</li>
</ul>
<p><em>进程等待</em>：</p>
<ul>
  <li>进程进入等待（阻塞）的情况：
    <ul>
      <li>请求并等待系统服务，无法马上完成</li>
      <li>启动某种操作，无法马上完成</li>
      <li>需要的数据没有到达</li>
    </ul>
  </li>
  <li>只有进程自身才能知道何时需要等待某种事件的发生</li>
</ul>
<p><em>进程抢占</em>：</p>
<ul>
  <li>进程会被抢占的情况：
    <ul>
      <li>高优先级进程就绪</li>
      <li>进程的时间片用完</li>
    </ul>
  </li>
</ul>
<p><em>进程唤醒</em>：</p>
<ul>
  <li>唤醒进程的情况：
    <ul>
      <li>被阻塞进程需要的资源可被满足</li>
      <li>被阻塞进程等待的事件到达</li>
    </ul>
  </li>
  <li>进程只能被别的进程或操作系统唤醒</li>
</ul>
<p><em>进程结束</em>：</p>
<ul>
  <li>进程结束的情况：
    <ul>
      <li>正常退出（自愿的）</li>
      <li>错误退出（自愿的）</li>
      <li>致命错误（强制性的）</li>
      <li>被其他进程所杀（强制性的）</li>
    </ul>
  </li>
</ul>
<p>进程的状态转换图如下：</p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/state-sw.png" alt="state-sw"></p>
<p>sleep()系统调用对应的进程状态变化：</p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/sleep.png" alt="sleep"></p>
<p><em>9.进程上下文切换</em></p>
<ul>
  <li>保存上下文：所有寄存器，所有协同处理器的状态</li>
  <li>开始新的上下文：相反的操作过程</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3>
<p><em>1.线程的概念</em></p>
<p>IBM System/360 引入线程</p>
<ul>
  <li>线程是进程的一部分，描述指令流执行状态，是CPU调度的基本单位</li>
  <li>线程在同一进程的地址空间内，可共享变量</li>
</ul>
<p><em>2.线程与并发性</em></p>
<ul>
  <li>线程：
    <ul>
      <li>位于进程内部的一段顺序执行流</li>
      <li>位于进程内部的所有线程共享地址空间</li>
    </ul>
  </li>
  <li>线程并发性：
    <ul>
      <li>相较信号，用线程更容易实现I/O交叠</li>
      <li>人们更愿意一次做多件事情：web服务器</li>
      <li>服务器服务多个请求</li>
      <li>多个CPU共享内存</li>
    </ul>
  </li>
</ul>
<p><em>3.线程的表示</em></p>
<p>线程控制块（TCB）：</p>
<ul>
  <li>状态：
    <ul>
      <li>就绪态：准备运行</li>
      <li>运行态：正在运行</li>
      <li>阻塞态：等待资源</li>
    </ul>
  </li>
  <li>寄存器</li>
  <li>程序计数器</li>
  <li>栈</li>
  <li>代码</li>
</ul>
<p><em>典型的线程API</em>：</p>
<ul>
  <li>创建：fork, join</li>
  <li>互斥：acquire, release</li>
  <li>条件变量：wait, signal, broadcast</li>
  <li>警报：alert, alertwait, testalert</li>
</ul>
<p>最简单的进程只有一个线程</p>
<p><em>4.进程 VS 线程</em></p>
<ul>
  <li>地址空间：
    <ul>
      <li>进程之间一般不会共享内存</li>
      <li>进程切换会切换页表和其他内存机制</li>
      <li>进程中的线程共享整个地址空间</li>
    </ul>
  </li>
  <li>权限：
    <ul>
      <li>进程拥有自己的权限，如文件访问权限</li>
      <li>进程中的线程共享所有的线程</li>
    </ul>
  </li>
</ul>
<p><em>线程上下文切换</em>：</p>
<ul>
  <li>保存上下文：
    <ul>
      <li>所有寄存器</li>
      <li>所有协同处理器的状态</li>
    </ul>
  </li>
  <li>开始新的上下文：相反的操作过程</li>
  <li>可能触发进程的上下文切换</li>
</ul>
<p><em>过程调用</em>：</p>
<p>调用者或者被调用者保存部分上下文</p>
<p><em>5.线程 VS 过程</em></p>
<ul>
  <li>线程可能会乱序的恢复
    <ul>
      <li>不能用栈保存状态</li>
      <li>每一个线程都有自己的栈</li>
    </ul>
  </li>
  <li>线程切换不会太频繁
    <ul>
      <li>不会划分寄存器</li>
      <li>线程有“自己”的CPU</li>
    </ul>
  </li>
  <li>线程可以是异步的
    <ul>
      <li>过程可以利用编译器异步地保存状态</li>
      <li>线程可以异步的运行</li>
    </ul>
  </li>
  <li>多线程
    <ul>
      <li>多线程可以并行的在多个CPU上运行</li>
      <li>过程调用是线性的</li>
    </ul>
  </li>
</ul>
<p><em>6.线程的分类</em></p>
<ul>
  <li>用户线程：由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/user-th.png" alt="user-th"></p>
<ul>
  <li>内核线程：由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/kernel-th.png" alt="kernel-th"></p>
<ul>
  <li>轻量级进程：内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/light-ph.png" alt=""></p>
<p>用户线程和内核线程的关系：</p>
<ul>
  <li>一对一：每一个用户级线程都拥有自己的内核栈</li>
  <li>多对一：一个进程的所有线程共享同一个内核栈</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/func.png" alt="func"></p>
<p>不同映射关系的对比：</p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/cmp.png" alt="cmp"></p>
<p><em>总结</em></p>
<ul>
  <li>进程：应用并发性的抽象</li>
  <li>线程：应用内部并发性的抽象</li>
</ul>
<h3 id="非抢占式调度与抢占式调度"><a href="#非抢占式调度与抢占式调度" class="headerlink" title="非抢占式调度与抢占式调度"></a>非抢占式调度与抢占式调度</h3>
<p><em>7.非抢占式线程</em> </p>
<p><em>宏内核结构</em>：</p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/kernel.png" alt="kernel"></p>
<ul>
  <li>内核拥有自己的地址空间，并与所有的进程共享</li>
  <li><strong>内核包含</strong>：
    <ul>
      <li>引导加载程序</li>
      <li>BIOS</li>
      <li>核心驱动</li>
      <li>线程</li>
      <li>调度器</li>
    </ul>
  </li>
  <li><strong>调度器</strong>：
    <ul>
      <li>使用就绪队列来存放所有的就绪线程</li>
      <li>线程上下文切换在相同的地址空间进行调度</li>
      <li>进程上下文切换在新的地址空间进行调度</li>
    </ul>
  </li>
</ul>
<p><em>非抢占式调度状态转换图</em>：</p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/non-sw.png" alt=""></p>
<p><em>非抢占式调度器</em>：</p>
<ul>
  <li>非抢占式调度器的启动：
    <ul>
      <li><code>block()</code></li>
      <li><code>yield()</code></li>
    </ul>
  </li>
  <li>最简单的形式（调度器）：
    <ol>
      <li>保存当前进程/线程状态</li>
      <li>选择下一个待运行的进程/线程</li>
      <li>分派（加载并跳转到相应PCB/TCB）</li>
    </ol>
  </li>
</ul>
<p><em>保存线程上下文</em>：</p>
<ul>
  <li>在线程的栈上保存上下文：
    <ul>
      <li>许多处理器有专门的指令来高效的保存上下文</li>
      <li>但是，需要处理溢出的问题</li>
    </ul>
  </li>
  <li>保存前需要检查：
    <ul>
      <li>确保栈上没有溢出的问题</li>
      <li>把上下文保存到TCB中</li>
      <li>效率不是很高，但是没有溢出的问题</li>
    </ul>
  </li>
</ul>
<p><em>8.抢占式线程</em></p>
<p>通过中断进行抢占</p>
<ul>
  <li>为什么要抢占：
    <ul>
      <li>利用时钟中断进行CPU管理</li>
      <li>异步I/O和计算交叠在一起</li>
    </ul>
  </li>
  <li>中断：
    <ul>
      <li>发生在指令之间</li>
      <li>发生在一条指令执行期间（非原子指令）</li>
    </ul>
  </li>
  <li>操纵中断
    <ul>
      <li>关闭中断</li>
      <li>开启中断</li>
      <li>Non-Masking Interrupts (NMI)</li>
    </ul>
  </li>
</ul>
<p><em>抢占式调度的状态转换图</em>：</p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch2/switch.png" alt="switch"></p>
<p><em>抢占式调度的中断处理</em>：</p>
<ul>
  <li>I/O中断处理：
    <ol>
      <li>保存当前进程/线程到它们的PCB/TCB</li>
      <li>进行I/O</li>
      <li>调用调度器</li>
    </ol>
  </li>
  <li>时间中断处理：
    <ol>
      <li>保存当前进程/线程到它们的PCB/TCB</li>
      <li>关中断，增加计数器，检查当前状态是否处于用户态，如果是，则首先进入内核，然后进行中断处理，否则（处于内核态），直接返回（内核态不能被中断）</li>
      <li>调用调度器</li>
    </ol>
  </li>
  <li>问题：
    <ul>
      <li>打开/关闭中断</li>
      <li>确保在多处理器环境下也可以工作</li>
    </ul>
  </li>
</ul>
<p><em>抢占式调度面临的问题</em>：</p>
<ul>
  <li>问题： 中断随时随地都可能发生</li>
  <li>简单方法：时刻关注是否发生中断或抢占</li>
  <li>目标：
    <ul>
      <li>不要时刻关注抢占和中断</li>
      <li>底层行为被封装在“原语”中</li>
      <li>同步“原语“关注抢占</li>
      <li>OS和应用使用同步原语</li>
    </ul>
  </li>
</ul>
<p><em>9.用户线程 VS 内核线程</em></p>
<ul>
  <li>用户级线程：
    <ul>
      <li>用户级线程库实现线程上下文切换</li>
      <li>时间中断会引入抢占</li>
      <li>当用户级线程被I/O阻塞时，整个进程都会被阻塞</li>
    </ul>
  </li>
  <li>内核级线程：
    <ul>
      <li>内核级线程被内核调度器调度</li>
      <li>由于跨域了保护边界，内核级线程的上下文切换开销远大于用户级线程</li>
    </ul>
  </li>
  <li>混合：有可能实现一个混合的调度器，但是会很复杂</li>
</ul>
<p><em>总结</em>：</p>
<ul>
  <li>非抢占式线程：
    <ul>
      <li>调度器</li>
      <li>上下文保存的位置</li>
    </ul>
  </li>
  <li>抢占式线程：
    <ul>
      <li>中断随时都可能发生</li>
    </ul>
  </li>
  <li>用户线程 VS 内核线程：
    <ul>
      <li>主要的区别是所选择的调度器</li>
    </ul>
  </li>
</ul>
<h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3>
<p><em>1.调度器工作</em>：</p>
<ul>
  <li>保存当前进程/线程状态（PCB/TCB）</li>
  <li>选择下一个待运行的进程/线程</li>
  <li>分派（加载并跳转到相应PCB/TCB）</li>
</ul>
<p><em>2.何时调度？</em></p>
<ul>
  <li>进程/线程创建</li>
  <li>进程/线程退出</li>
  <li>I/O阻塞、同步</li>
  <li>I/O中断</li>
  <li>时间中断</li>
</ul>
<p><em>3.调度准则</em></p>
<ul>
  <li>假设：
    <ul>
      <li>一个用户运行一个程序，一个程序创建一个线程</li>
      <li>程序之间是独立的</li>
    </ul>
  </li>
  <li>批处理和实时交互系统设计目标：
    <ul>
      <li>保证公平性</li>
      <li>每个作业都有机会运行，没有人会“饥饿”</li>
      <li>最大化CPU资源利用率</li>
      <li>最大化吞吐率：最小化开销，最大化资源利用率</li>
      <li>最小化周转时间
        <ul>
          <li>批处理作业：执行时间（从提交到完成）</li>
        </ul>
      </li>
      <li>缩短响应时间
        <ul>
          <li>交互式作业：响应时间</li>
        </ul>
      </li>
      <li>均衡性：满足用户需求</li>
    </ul>
  </li>
</ul>
<p><em>4.先到先服务（FCFS）算法</em></p>
<ul>
  <li>一直运行到结束（过去）</li>
  <li>一直运行到阻塞或主动放弃CPU</li>
  <li>用于非抢占式调度</li>
</ul>
<p>优点：</p>
<ul>
  <li>实现简单</li>
</ul>
<p>缺点：</p>
<ul>
  <li>平均响应时间波动大</li>
  <li>I/O资源和CPU资源的利用率较低</li>
</ul>
<p><em>5.最短时间优先（STCF)</em></p>
<ul>
  <li>非抢占式调度</li>
</ul>
<p><em>6.最短剩余时间优先（SRTCF)</em></p>
<ul>
  <li>选择就绪队列中剩余时间最短进程占用CPU进入运行状态</li>
  <li>就绪队列按剩余时间来排序</li>
</ul>
<p>优点：</p>
<ul>
  <li>平均响应时间短</li>
</ul>
<p>缺点：</p>
<ul>
  <li>可能会造成饥饿：连续的短进程流会使长进程无法获得CPU资源</li>
  <li>需要预知未来</li>
</ul>
<p><em>7.时间片轮转算法（RR）</em></p>
<ul>
  <li>和FCFS算法类似，但是增加了时间片</li>
  <li>时间片结束时，调度器按FCFS算法切换到下一个就绪进程</li>
  <li>轮转调度是抢占式调度</li>
</ul>
<p><em>时间片长度选择</em>：</p>
<ul>
  <li>大时间片：
    <ul>
      <li>等待时间过长</li>
      <li>极端情况下退化为FCFS</li>
    </ul>
  </li>
  <li>小时间片：
    <ul>
      <li>响应时间快</li>
      <li>产生大量上下文切换，影像系统吞吐</li>
    </ul>
  </li>
  <li>经验规则：选择一个合适的时间片，使上下文切换开销处于1%以内</li>
</ul>
<p><em>8.虚拟轮转算法（VRR）</em></p>
<ul>
  <li>引入辅助队列FIFO（先入先出）</li>
  <li>I/O密集型进程会进入辅助队列而不是就绪队列以备调度</li>
  <li>引入优先级：辅助队列比就绪队列有更高的优先级</li>
</ul>
<p><em>9.多级队列（MQ）与优先级</em></p>
<ul>
  <li>将就绪队列分为多个独立的子队列，每个队列可有自己的调度算法：前台RR，后台FCFS</li>
  <li>队列之间
    <ul>
      <li>每个队列分配一个优先级和相应时间片</li>
      <li>队列间按照时间片调度</li>
    </ul>
  </li>
</ul>
<p><em>10.多级反馈队列（MLFQ）算法</em></p>
<ul>
  <li>进程可在不同队列中移动的多级队列算法</li>
  <li>特征：
    <ul>
      <li>时间片大小由优先级级别增加而增加</li>
      <li>进程在当前的时间片没有完成，则降到下一个优先级</li>
      <li>CPU密集型进程的优先级下降很快，I/O密集型进程停留在高优先级</li>
    </ul>
  </li>
</ul>
<p><em>11.彩票调度</em></p>
<ul>
  <li>动机：SRTCF可以保证平均响应延迟，但是不公平</li>
  <li>彩票方法：
    <ul>
      <li>给每个作业一定数量的彩票</li>
      <li>随机抽取一张中奖彩票（运行相应进程）</li>
      <li>为了近似SRTCF，给短作业更多的彩票</li>
      <li>为了避免“饥饿”，给每个作业至少一张彩票</li>
      <li>相互合作的进程可以交换彩票</li>
    </ul>
  </li>
</ul>
<p><em>12.公平共享调度（FSS）</em></p>
<ul>
  <li>FSS控制用户对系统资源的访问
    <ul>
      <li>一些用户组比其他用户组更重要</li>
      <li>保证不重要的组无法垄断资源</li>
      <li>未使用的资源按比例分配</li>
      <li>没有达到资源使用率目标的组获得更高的优先级</li>
    </ul>
  </li>
</ul>
<p><em>13.调度算法总结</em></p>
<ul>
  <li>先到先服务调度算法：不公平，平均响应时间差</li>
  <li>最短时间优先调度算法：
    <ul>
      <li>不公平，平均响应时间短</li>
      <li>需要预测未来</li>
      <li>可能导致饥饿</li>
    </ul>
  </li>
  <li>时间片轮转调度算法：公平，平均响应时间较差</li>
  <li>虚拟轮转算法：公平，平均响应时间短</li>
  <li>多级反馈队列算法：集成多种调度算法</li>
  <li>彩票调度算法：公平，平均响应时间好</li>
  <li>公平共享调度算法：公平第一位</li>
</ul>
<p><em>14.多处理器/集群调度</em></p>
<ul>
  <li>设计 问题：进程/线程到处理器分配</li>
  <li>协同调度：
    <ul>
      <li>一个进程的多个线程共同运行</li>
      <li>一个应用的多个进程共同运行</li>
    </ul>
  </li>
  <li>专用的处理器分配：线程会在一个专用的处理器上运行直到完成</li>
</ul>
<p><em>15.实时调度</em></p>
<ul>
  <li>
    <p>两种类似的实时：</p>
    <ul>
      <li>硬实时：必须满足，否则会导致错误</li>
      <li>软实时：大多时候满足，没有强制性</li>
    </ul>
  </li>
  <li>
    <p>接纳控制：</p>
    <ul>
      <li>只有当系统能够保证所有进程的实时性的前提下，新的实时进程才会被接纳</li>
      <li>如果满足下面的条件，作业就是可调度的：</li>
    </ul>
    <p>$$\sum\frac{C_I}{T_i} \le 1$$，其中，$C_i=$计算时间，$T_i=$周期</p>
  </li>
</ul>
<p><em>16.速率单调调度</em></p>
<ul>
  <li>假设：
    <ul>
      <li>每个进程必须在其周期内完成</li>
      <li>进程之间没有依赖关系</li>
      <li>每个进程在每个周期内需要的CPU时间相同</li>
      <li>非周期性进程没有截止日期</li>
      <li>进程抢占瞬间发生（没有开销）</li>
    </ul>
  </li>
  <li>基本思想：
    <ul>
      <li>给每个进程分配一个固定的优先级=出现频率</li>
      <li>运行最高优先级的进程</li>
      <li>证明是最优的</li>
    </ul>
  </li>
</ul>
<p><em>17.最早最终时速优先调度（EDS）</em></p>
<ul>
  <li>假设：
    <ul>
      <li>当进程需要CPU时间时，它会宣布其最终时限</li>
      <li>不一定是周期性进程</li>
      <li>需要的CPU时间可以变化</li>
    </ul>
  </li>
  <li>EDS的基本思想：
    <ul>
      <li>根据最终时限对就绪的进程进行排序</li>
      <li>运行列表中的第一个进程（最早最终时限优先）</li>
      <li>当新的进程就绪时，并且其最终时限快来临时，它会抢占当前进程</li>
    </ul>
  </li>
</ul>
<p><em>18.BSD多队列调度</em></p>
<ul>
  <li>“一秒钟”抢占：进程如果在一秒内没有阻塞或者完成，就会被抢占</li>
  <li>优先级每秒重新计算</li>
</ul>
<p><em>19.Linux中的调度</em></p>
<ul>
  <li>分时共享调度：
    <ul>
      <li>每个进程都会有优先级和Credits</li>
      <li>I/O事件会提升优先级</li>
      <li>拥有最多Credits的进程会优先运行</li>
      <li>时间中断会减少进程的Credits</li>
      <li>如果所有进程的Credits都耗尽了，内核会重新给进程分配：Credits = Credits / 2 + Priority</li>
    </ul>
  </li>
  <li>实时调度：
    <ul>
      <li>软实时</li>
      <li>内核不会被用户代码抢占</li>
    </ul>
  </li>
</ul>
<p><em>20.Windows中的调度</em></p>
<ul>
  <li>分类和优先级</li>
  <li>优先级驱动的调度器</li>
  <li>多处理器调度</li>
</ul>
<h3 id="调度前沿扩展"><a href="#调度前沿扩展" class="headerlink" title="调度前沿扩展"></a>调度前沿扩展</h3>
<p><em>NUMA调度</em></p>
<p><em>分布式调度</em></p>
<p><em>虚拟机调度</em></p>
<h2 id="Chapter03-同步与通信"><a href="#Chapter03-同步与通信" class="headerlink" title="Chapter03 同步与通信"></a>Chapter03 同步与通信</h2>
<h3 id="临界区与原子操作"><a href="#临界区与原子操作" class="headerlink" title="临界区与原子操作"></a>临界区与原子操作</h3>
<p><em>1.同步与通信的概念</em></p>
<p>通信的两大作用：</p>
<ul>
  <li>并发进程/线程之间需要进行信息同步和数据传输</li>
  <li>信息同步：
    <ul>
      <li>保障多进程/多线程正确的使用共享资源</li>
      <li>共享资源可以是：
        <ul>
          <li>一个变量</li>
          <li>一块缓冲区</li>
          <li>一个文件</li>
          <li>一个设备等</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>数据传输：
    <ul>
      <li>便于将单个任务切分、模块化提高并发度</li>
    </ul>
  </li>
</ul>
<p><em>2.临界区</em></p>
<ul>
  <li>临界区：进程中访问临界资源的一段需要互斥执行的代码</li>
  <li>进入临界区：
    <ul>
      <li>检查可否进入临界区的一段代码</li>
      <li>如可进入，设置相应“正在访问临界区”的标志</li>
    </ul>
  </li>
  <li>退出临界区：清除“正在访问临界区”标志</li>
</ul>
<p><em>3.原子操作</em></p>
<ul>
  <li>原子操作是指一次不存在任何中断或失败的操作
    <ul>
      <li>要么操作成功完成</li>
      <li>或者操作没有执行</li>
      <li>不会出现部分执行的状态</li>
    </ul>
  </li>
  <li>对临界区的操作必须是原子操作</li>
  <li>操作系统需要利用同步机制在并发执行的同时，保证一些操作是原子操作</li>
</ul>
<p><em>同步机制设计</em></p>
<ol>
  <li>识别出共享资源与使用者</li>
  <li>设计合适的同步机制</li>
  <li>验证临界区是否符合原子操作</li>
</ol>
<p><em>4.临界区的保障</em></p>
<ul>
  <li>基于软件</li>
  <li>硬件中断</li>
  <li>原子操作指令与互斥锁</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/linjie.png" alt="linjie"></p>
<p><em>基于软件的方法</em></p>
<ul>
  <li>
    <p>线程可通过共享一些共有变量来同步它们的行为</p>
  </li>
  <li>
    <p><em>Peterson</em>算法：满足线程Ti和Tj之间互斥的经典的基于软件的解决办法：</p>
    <ul>
      <li>
        <p>共享变量：</p>
        <figure class="highlight c">
          <table>
            <tr>
              <td class="gutter">
                <pre><div class="line">1</div><div class="line">2</div></pre>
              </td>
              <td class="code">
                <pre><div class="line"><span class="keyword">int</span> turn;<span class="comment">//表示该谁进入临界区</span></div><div class="line"><span class="keyword">bool</span> flag[];<span class="comment">//表示进程是否准备好进入临界区</span></div></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
      <li>
        <p>进入区代码：</p>
        <figure class="highlight c">
          <table>
            <tr>
              <td class="gutter">
                <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
              </td>
              <td class="code">
                <pre><div class="line">flag[i] = <span class="literal">true</span>;</div><div class="line">turn = j;</div><div class="line"><span class="keyword">while</span>(flag[j] &amp;&amp; turn = j)</div></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
      <li>
        <p>退出区代码：</p>
        <figure class="highlight c">
          <table>
            <tr>
              <td class="gutter">
                <pre><div class="line">1</div></pre>
              </td>
              <td class="code">
                <pre><div class="line">flag[i] = <span class="literal">false</span>;</div></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
    </ul>
  </li>
  <li>
    <p><em>Dekkers</em>算法</p>
  </li>
  <li>
    <p>缺点：</p>
    <ul>
      <li>复杂：需要两个进程/线程之间的共享数据项</li>
      <li>需要“忙等待”：浪费CPU时间</li>
    </ul>
  </li>
</ul>
<p><em>禁用中断实现互斥</em></p>
<ul>
  <li>使用中断：
    <ul>
      <li>实现抢占式CPU调度</li>
      <li>通过在acquire和release之间禁止上下文切换来提供互斥</li>
      <li>两种类型的事件能引起切换：
        <ul>
          <li>内部事件：放弃CPU控制权</li>
          <li>外部事件：使得CPU重新调度</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>禁用中断以屏蔽外部事件：
    <ul>
      <li>引入不可中断的代码区域</li>
      <li>大多数时候用串行思维</li>
      <li>延迟处理外部事件</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>禁用中断后，进程无法被停止：
        <ul>
          <li>整个系统都会为此停下来</li>
          <li>可能导致其他进程处于“饥饿”状态</li>
        </ul>
      </li>
      <li>临界区可能很长：无法确定响应中断所需要的时间（可能存在硬件影响）</li>
    </ul>
  </li>
</ul>
<p><em>原子操作指令</em></p>
<ul>
  <li>
    <p>现代CPU都提供一些特殊的原子操作指令</p>
  </li>
  <li>
    <p>测试和置位（TAS/TS）指令：</p>
    <ul>
      <li>
        <p>从内存单元中读取值</p>
      </li>
      <li>
        <p>测试该值是否为1，然后返回真或假</p>
      </li>
      <li>
        <p>内存单元值设置为1</p>
        <figure class="highlight c">
          <table>
            <tr>
              <td class="gutter">
                <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
              </td>
              <td class="code">
                <pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *Target)</span></span>&#123;</div><div class="line">    <span class="keyword">bool</span> rv = *Target;</div><div class="line">    *Target = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> rv;</div><div class="line">&#125;</div></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
    </ul>
  </li>
  <li>
    <p>交换指令：</p>
    <ul>
      <li>
        <p>交换寄存器与内存：</p>
        <figure class="highlight c">
          <table>
            <tr>
              <td class="gutter">
                <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
              </td>
              <td class="code">
                <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(<span class="keyword">bool</span> *a, <span class="keyword">bool</span> *b)</span></span>&#123;</div><div class="line">    <span class="keyword">bool</span> tmp = *a;</div><div class="line">    *a = *b;</div><div class="line">    *b = tmp;</div><div class="line">&#125;</div></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
    </ul>
  </li>
  <li>
    <p>Fetch-and-Add或Fetch-and-Op：</p>
    <ul>
      <li>用于大型共享内存多处理器系统的原子指令</li>
    </ul>
  </li>
  <li>
    <p>Load Linked 和Conditional Store（LL - SC）：</p>
    <ul>
      <li>在一条指令中读一个值（LL）</li>
      <li>做一些操作</li>
      <li>Store时，检查LL之后，值是否被修改过。如果没有，则OK，否则，从头再来</li>
    </ul>
  </li>
</ul>
<p><em>使用TAS指令实现锁</em></p>
<ul>
  <li>忙等待：</li>
</ul>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">class</span> Lock&#123;</div><div class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">Lock::Acquire()&#123;</div><div class="line">    <span class="comment">//如果锁被释放，TAS读取0并将值设置为1：锁被设置为忙并且需要等待完成</span></div><div class="line">    <span class="comment">//如果锁处于忙状态，TAS指令读取1并将值设置为1：不改变锁的状态并且需要循环</span></div><div class="line">    <span class="comment">//返回值为之前的值</span></div><div class="line">    <span class="keyword">while</span> (test-and-<span class="built_in">set</span>(value))</div><div class="line">        ;</div><div class="line">&#125;</div><div class="line">Lock::Release()&#123;</div><div class="line">    value = <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>无忙等待：</li>
</ul>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">class</span> Lock&#123;</div><div class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line">    WaitQueue q;</div><div class="line">&#125;</div><div class="line">Lock::Acquire()&#123;</div><div class="line">    <span class="keyword">while</span> (test-and-<span class="built_in">set</span>(value))&#123;</div><div class="line">        add <span class="keyword">this</span> TCB to wait <span class="built_in">queue</span> q;</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Lock::Release()&#123;</div><div class="line">    value = <span class="number">0</span>;</div><div class="line">    remove one thread t from q;</div><div class="line">    wakeup(t);</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>优点：
    <ul>
      <li>适用于单处理器或者共享主存的多处理器中任意数量的进程同步</li>
      <li>简单并且容易证明</li>
      <li>支持多临界区</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>忙等待消耗处理器时间</li>
      <li>可能导致饥饿：进程离开临界区时有多个等待进程的情况</li>
      <li>死锁：
        <ul>
          <li>拥有临界区的低优先级进程</li>
          <li>请求访问临界区的高优先级进程获得处理器并等待临界区</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>总结</em></p>
<ul>
  <li>软件方法：实现复杂</li>
  <li>中断：
    <ul>
      <li>有很多问题</li>
      <li>实现之后，只能用于单核处理器</li>
    </ul>
  </li>
  <li>原子操作指令与锁：
    <ul>
      <li>大多数时间在用户层自旋</li>
      <li>线程数比处理器数目多</li>
    </ul>
  </li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3>
<p><em>1.一些定义</em></p>
<ul>
  <li>进程和线程等价</li>
  <li>资源：
    <ul>
      <li>可抢占：CPU（可以被夺取）</li>
      <li>不可抢占：磁盘，文件，互斥锁…</li>
    </ul>
  </li>
  <li>使用资源：请求，使用，释放</li>
  <li>饥饿：进程无限等待</li>
  <li>死锁：如果一个进程集合中所有进程都在等待一个事件，且等待的事件只能由集合中其他进程触发，则称该进程集合死锁</li>
</ul>
<p><em>2.死锁发生的条件</em></p>
<ul>
  <li>互斥：
    <ul>
      <li>所有资源都被分配给恰好一个进程</li>
    </ul>
  </li>
  <li>占有和等待：
    <ul>
      <li>持有资源的进程可以请求新的资源</li>
    </ul>
  </li>
  <li>不可抢占：
    <ul>
      <li>资源不可被夺走</li>
    </ul>
  </li>
  <li>环路等待：
    <ul>
      <li>进程以环路的方式进行等待</li>
    </ul>
  </li>
</ul>
<p><em>3.策略</em></p>
<ul>
  <li>忽略问题：是用户的错</li>
  <li>检查并恢复：事后修复问题</li>
  <li>动态避免：小心的分配资源</li>
  <li>预防：破坏四个条件中的一个</li>
</ul>
<p><em>4.忽略问题：鸵鸟算法</em></p>
<ul>
  <li>操作系统内核死锁：
    <ul>
      <li>重启</li>
    </ul>
  </li>
  <li>设备驱动死锁：
    <ul>
      <li>卸载设备</li>
      <li>重启</li>
    </ul>
  </li>
  <li>应用程序挂起：
    <ul>
      <li>杀死并重启程序</li>
    </ul>
  </li>
  <li>应用程序运行一段时候后挂起：
    <ul>
      <li>给程序设定一个checkpoint</li>
      <li>改变运行环境（重启操作系统）</li>
      <li>从上一个checkpoint重新开始</li>
    </ul>
  </li>
</ul>
<p><em>5.检测和恢复</em></p>
<ul>
  <li>检测：
    <ul>
      <li>扫描资源分配图</li>
      <li>发现圈</li>
    </ul>
  </li>
  <li>恢复（很困难）
    <ul>
      <li>杀死进程/线程</li>
      <li>回滚死锁线程的操作</li>
    </ul>
  </li>
</ul>
<p><em>6.避免</em></p>
<ul>
  <li>安全状态：
    <ul>
      <li>未发生死锁</li>
      <li>存在一个调度方案，使得所有进程能够完成（即使所有进程同时请求最大资源）</li>
    </ul>
  </li>
  <li>银行家算法：
    <ul>
      <li>单个资源：
        <ul>
          <li>每个进程有一个贷款额度</li>
          <li>总的资源可能不能满足所有的贷款额度</li>
          <li>跟踪分配的和仍然需要的资源</li>
          <li>每次分配时检查安全性</li>
        </ul>
      </li>
      <li>多个资源：
        <ul>
          <li>两个矩阵：已分配和仍然需要</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>7.银行家算法</em></p>
<ul>
  <li>
    <p>数据结构：</p>
    <ul>
      <li>n: 线程数量，m: 资源类型数量</li>
      <li>Available（剩余空闲量）：长度为 m 的向量
        <ul>
          <li>当前有Available[j]个类型Rj的资源实例可用</li>
        </ul>
      </li>
      <li>Allocation（已分配量）: n x m 矩阵
        <ul>
          <li>线程 Ti 当前分配了 Allocation[i, j] 个 Rj 的实例 </li>
        </ul>
      </li>
      <li>Need（未来需要量）：n x m 矩阵
        <ul>
          <li>线程 Ti 未来需要 Need[i, j] 个 Rj 资源实例</li>
        </ul>
      </li>
      <li>Need[i, j] = Max[i, j] - Allocation[i, j]</li>
    </ul>
  </li>
  <li>
    <p>算法描述：</p>
    <ul>
      <li>
        <p>初始化：</p>
        <ul>
          <li>Ri 是线程 Ti 的资源请求向量</li>
          <li>Ri[j] 是线程 Ti 请求 Rj 的实例</li>
        </ul>
      </li>
      <li>
        <p>循环：依次处理线程 Ti, i = 1, 2, 3, …</p>
        <ol>
          <li>
            <p>如果 Ri &lt;= Need[i] ，转到 2，否则，拒绝资源申请，因为线程已经超过了其最大要求</p>
          </li>
          <li>
            <p>如果 Ri &lt;= Available ，转到 3，否则，Ti 必须等待，因为资源不可用</p>
          </li>
          <li>
            <p>通过安全状态判断来确定是否分配资源给 Ti ：</p>
            <ul>
              <li>
                <p>首先生成一个需要判断状态是否安全的资源分配环境：</p>
                <figure class="highlight c">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
                      </td>
                      <td class="code">
                        <pre><div class="line">Available = Available - Ri;</div><div class="line">Allocation[i] = Allocation[i] + Ri;</div><div class="line">Need[i] = Need[i] - Ri;</div></pre>
                      </td>
                    </tr>
                  </table>
                </figure>
              </li>
              <li>
                <p>调用安全状态判断：如果返回是安全，将资源分配给 Ti，如果返回结果是不安全，系统会拒绝 Ti 的资源请求</p>
              </li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>
<p><em>8.预防</em></p>
<ul>
  <li>
    <p>避免互斥：</p>
    <ul>
      <li>有些资源物理上不可共享：打印机，磁带等</li>
      <li>有些可设计成共享：只读文件，内存等，读写锁</li>
      <li>有些可以通过假脱机进行虚拟化：
        <ul>
          <li>使用存储，将一个资源虚拟化成多个资源</li>
          <li>使用队列进行调度</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>避免占有和等待：</p>
    <ul>
      <li>两阶段加锁：
        <ul>
          <li>阶段 I：试图对所有所需的资源加锁</li>
          <li>阶段 II：如果成功，使用资源，然后释放资源；否则，释放所有的资源，并从头开始</li>
        </ul>
      </li>
      <li>应用：电信公司的电路交换</li>
    </ul>
  </li>
  <li>
    <p>允许抢占：</p>
    <ul>
      <li>使调度器了解资源分配情况</li>
      <li>方法：
        <ul>
          <li>如果系统无法满足一个已占有资源的进程的请求，抢占该进程并释放所有的资源</li>
          <li>只在系统能满足所有资源时进行调度</li>
        </ul>
      </li>
      <li>其他方法：抢占占有被请求的资源的进程</li>
    </ul>
  </li>
  <li>
    <p>避免环路等待：</p>
    <ul>
      <li>对所有资源制定请求顺序</li>
      <li>方法：
        <ul>
          <li>对每个资源分配唯一的 id</li>
          <li>所有请求必须按 id 升序提出</li>
        </ul>
      </li>
      <li>变种：
        <ul>
          <li>对每个资源分配唯一的 id</li>
          <li>进程不能请求比当前所占有的资源编号低的资源</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>9.权衡和应用</em></p>
<ul>
  <li>对应用程序忽略问题：
    <ul>
      <li>处理死锁是应用开发者的问题</li>
      <li>OS 提供打破应用程序死锁的机制</li>
    </ul>
  </li>
</ul>
<ul>
  <li>内核不应该出现死锁：
    <ul>
      <li>使用预防方法</li>
      <li>最流行的做法是在所有地方使用避免环路等待原则</li>
    </ul>
  </li>
</ul>
<h3 id="信号量、管程与条件变量"><a href="#信号量、管程与条件变量" class="headerlink" title="信号量、管程与条件变量"></a>信号量、管程与条件变量</h3>
<p><em>1.信号量</em></p>
<ul>
  <li>
    <p>信号量是操作系统提供的一种协调共享资源访问的方法</p>
  </li>
  <li>
    <p>信号量的组成：</p>
    <ul>
      <li>
        <p>一个整形变量：表示系统资源的数量</p>
      </li>
      <li>
        <p>两个原子操作：</p>
        <ul>
          <li>
            <p>P 操作（又称 Down 或 Wait）：等待信号量为正，然后将信号量减一</p>
            <figure class="highlight c">
              <table>
                <tr>
                  <td class="gutter">
                    <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
                  </td>
                  <td class="code">
                    <pre><div class="line">P(s)&#123;</div><div class="line">    <span class="keyword">while</span>(s &lt;= <span class="number">0</span>)&#123;</div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">    --s;</div><div class="line">&#125;</div></pre>
                  </td>
                </tr>
              </table>
            </figure>
          </li>
          <li>
            <p>V 操作（又称 Up 或 Signal）：将信号量加一</p>
            <figure class="highlight c">
              <table>
                <tr>
                  <td class="gutter">
                    <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
                  </td>
                  <td class="code">
                    <pre><div class="line">V(s)&#123;</div><div class="line">    ++s;</div><div class="line">&#125;</div></pre>
                  </td>
                </tr>
              </table>
            </figure>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>信号量的实现：</p>
    <figure class="highlight c++">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre>
          </td>
          <td class="code">
            <pre><div class="line"><span class="keyword">class</span> Semaphore&#123;</div><div class="line">    <span class="keyword">int</span> sem;</div><div class="line">    WaitQueue q;</div><div class="line">&#125;;</div><div class="line">Semaphore::P()&#123;</div><div class="line">    --sem;</div><div class="line">    <span class="keyword">if</span> (sem &lt; <span class="number">0</span>)&#123;</div><div class="line">        Add <span class="keyword">this</span> thread t to q;</div><div class="line">        block(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Semphore::V()&#123;</div><div class="line">    ++sem;</div><div class="line">    <span class="keyword">if</span> (sem &lt;= <span class="number">0</span>)&#123;</div><div class="line">        Remove one thread t from q;</div><div class="line">        wakeup(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>信号量的使用：</p>
    <ul>
      <li>互斥访问：保护临界区互斥访问，<code>Semaphore(1)</code></li>
      <li>条件同步：多线程之间同步，<code>Semaphore(N &gt;= 0)</code></li>
    </ul>
  </li>
</ul>
<p><em>用信号量实现有限缓冲区</em></p>
<ul>
  <li>
    <p>问题描述：</p>
    <ul>
      <li>一个或多个生产者在生成数据后放在一个缓冲区里</li>
      <li>单个消费者从缓冲区中取出数据处理</li>
      <li>任何时刻只能有一个生产者或消费者可访问缓冲区</li>
    </ul>
  </li>
  <li>
    <p>问题分析：</p>
    <ul>
      <li>互斥访问：任何时候只能有一个线程操作缓冲区</li>
      <li>条件同步：缓冲区空时，消费者必须等待生产者；缓冲区满时，生产者必须等待消费者</li>
    </ul>
  </li>
  <li>
    <p>实现：</p>
    <figure class="highlight c++">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre>
          </td>
          <td class="code">
            <pre><div class="line"><span class="keyword">class</span> BoundedBuffer&#123;</div><div class="line">    mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</div><div class="line">    fullBuffers = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line">    emptyBuffers = <span class="keyword">new</span> Semaphore(n);</div><div class="line">&#125;;</div><div class="line">BoundedBuffer::Deposit(c)&#123;</div><div class="line">    emptyBuffers-&gt;P();</div><div class="line">    mutex-&gt;P();</div><div class="line">    Add c to the buffer;</div><div class="line">    mutex-&gt;V();</div><div class="line">    fullBuffers-&gt;V();</div><div class="line">&#125;</div><div class="line">BoundedBuffer::Remove(c)&#123;</div><div class="line">    fullBuffers-&gt;P();</div><div class="line">    mutex-&gt;P();</div><div class="line">    Remove c from buffer;</div><div class="line">    mutex-&gt;V();</div><div class="line">    emptyBuffers-&gt;V();</div><div class="line">&#125;</div></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
</ul>
<p><em>2.管程</em></p>
<ul>
  <li>管程是一种用于多线程互斥访问共享资源的程序结构
    <ul>
      <li>采用面向对象方法，简化了线程间的同步控制</li>
      <li>任意时刻最多只有一个线程执行管程代码</li>
      <li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li>
    </ul>
  </li>
  <li>管程的组成：
    <ul>
      <li>一个锁：控制管程代码的互斥访问</li>
      <li>0 个或多个条件变量：管理共享数据的并发访问</li>
    </ul>
  </li>
</ul>
<p><em>条件变量</em></p>
<ul>
  <li>
    <p>条件变量是管程内的等待机制，每个条件变量表示一种等待原因，对应一个等待队列</p>
  </li>
  <li>
    <p><code>Wait()</code>操作：</p>
    <ul>
      <li>将自己阻塞在等待队列中</li>
      <li>唤醒一个等待者或释放管程中的互斥访问</li>
    </ul>
  </li>
  <li>
    <p><code>Signal()</code>操作：</p>
    <ul>
      <li>将等待队列中的一个线程唤醒</li>
      <li>如果等待队列为空，则等同空操作</li>
    </ul>
  </li>
  <li>
    <p>条件变量额实现：</p>
    <figure class="highlight c++">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre>
          </td>
          <td class="code">
            <pre><div class="line"><span class="keyword">class</span> Condition&#123;</div><div class="line">    <span class="keyword">int</span> numWaiting = <span class="number">0</span>;</div><div class="line">    WaitQueue q;</div><div class="line">&#125;;</div><div class="line">Condition::Wait(Lock)&#123;</div><div class="line">    ++numWaiting;</div><div class="line">    Add <span class="keyword">this</span> thread t to q;</div><div class="line">    release(Lock);</div><div class="line">    schedule();</div><div class="line">    acquire(Lock);</div><div class="line">&#125;</div><div class="line">Condition::Signal()&#123;</div><div class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>)&#123;</div><div class="line">        Remove one thread t from q;</div><div class="line">        wakeup(t);</div><div class="line">        --numWaiting;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
</ul>
<p><em>用管程实现生产者-消费者问题</em></p>
<figure class="highlight c++">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">class</span> BoundedBuffer&#123;</div><div class="line">    Lock lock;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    Condition notFull, notEmpty;</div><div class="line">&#125;;</div><div class="line">BoundedBuffer::Deposit(c)&#123;</div><div class="line">    lock-&gt;Acquire();</div><div class="line">    <span class="keyword">while</span> (count == n)&#123;</div><div class="line">        notFull.Wait(&amp;lock);</div><div class="line">    &#125;</div><div class="line">    Add c to the buffer;</div><div class="line">    ++count;</div><div class="line">    notEmpty.Signal();</div><div class="line">    lock-&gt;Release();</div><div class="line">&#125;</div><div class="line">BoundedBuffer::Remove(c)&#123;</div><div class="line">    lock-&gt;Acquire();</div><div class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</div><div class="line">        notEmpty.Wait();</div><div class="line">    &#125;</div><div class="line">    Remove c from buffer;</div><div class="line">    --count;</div><div class="line">    notFull.Signal();</div><div class="line">    lock-&gt;Release();</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><em>Signal之后的选择</em></p>
<ul>
  <li>让被唤醒的线程立刻执行，并挂起发送方（Hoare)
    <ul>
      <li>如果发送方有其他工作要做，会很麻烦</li>
      <li>很难确定没有其他工作要做，因为 Signal 的实现并不知道它是如何被使用的</li>
    </ul>
  </li>
  <li>退出管程（Hansen)：Signal 必须是管程中的过程的最后一个语句</li>
  <li>继续执行(Mesa)
    <ul>
      <li>易于实现</li>
      <li>然后，被唤醒的进程实际执行时，条件可能不为真</li>
    </ul>
  </li>
</ul>
<p><em>3.Mesa风格管程</em></p>
<ul>
  <li>将条件变量与一个互斥量关联</li>
  <li><code>Wait(mutex, condition)</code>：
    <ul>
      <li>原子解锁 mutex，并加入 condition 对应的队列（阻塞该线程）</li>
      <li>被唤醒时，重新锁定（mutex）</li>
    </ul>
  </li>
  <li><code>Signal(condition)</code>：
    <ul>
      <li>当没有线程阻塞于该条件变量时，什么也不做</li>
      <li>如果有被阻塞的线程，唤醒至少一个</li>
    </ul>
  </li>
  <li><code>Broadcast</code>：唤醒所有等待的线程</li>
</ul>
<p><em>4.屏障原语</em></p>
<ul>
  <li>功能：
    <ul>
      <li>指定一个屏障变量</li>
      <li>广播给其他 n - 1 个线程</li>
      <li>若屏障变量的值达到 n，则继续</li>
    </ul>
  </li>
  <li>在某些并行计算机上，有硬件支持：
    <ul>
      <li>多播网络</li>
      <li>计数逻辑</li>
      <li>用户级屏障变量</li>
    </ul>
  </li>
</ul>
<p><em>5.等价性</em></p>
<ul>
  <li>信号量：
    <ul>
      <li>适合发送信号</li>
      <li>不适合实现 mutex，因为容易引入 bug</li>
    </ul>
  </li>
  <li>管程：
    <ul>
      <li>适合调度和 mutex</li>
      <li>用作发送信号时，开销可能会比较大</li>
    </ul>
  </li>
</ul>
<p><em>操作系统提供的同步机制总结</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/Sum.png" alt="sum"></p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3>
<p><em>1.基本概念</em></p>
<ul>
  <li>进程间通信（IPC, Inter-Process Communication）</li>
  <li>不同进程间进行通信和同步的机制</li>
  <li>两个原语：
    <ul>
      <li>Send(message)</li>
      <li>Receive(message)</li>
    </ul>
  </li>
  <li>进程通信流程：
    <ul>
      <li>建立通信链路</li>
      <li>Send/Recv交换数据</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/comm.png" alt="communication"></p>
<p><em>2.消息队列</em></p>
<ul>
  <li>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</li>
  <li>每个消息（Message）是一个字节序列</li>
  <li>相同标识的消息按照先进先出顺序组成一个消息队列</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/msg-queue.png" alt="msg-queue"></p>
<ul>
  <li>消息队列的系统调用：
    <ul>
      <li><code>msgget(key, flags)</code> ：获取消息队列标识</li>
      <li><code>msgsnd(QID, buf, size, flags)</code>：发送消息</li>
      <li><code>msgrcv(QID, buf, size, type, flags)</code>：接收消息</li>
      <li><code>msgctl(...)</code>：消息队列控制</li>
    </ul>
  </li>
</ul>
<p><em>3.共享内存</em></p>
<ul>
  <li>共享内存是操作系统把同一个物理区域同时映射到多个进程的内存地址空间的通信机制</li>
  <li>每个进程将共享内存区域映射到私有地址空间</li>
  <li>优点：快速、方便的共享数据</li>
  <li>缺点：必须用额外的同步机制来协调数据访问</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/shm.png" alt="shm"></p>
<ul>
  <li>共享内存系统调用：
    <ul>
      <li><code>shmget(key, size, flags)</code>：创建共享段</li>
      <li><code>shmat(shmid, *shmaddr, flags)</code>：把共享段映射到进程地址空间</li>
      <li><code>shmdt(*shmaddr)</code>：取消共享段到进程地址空间的映射</li>
      <li><code>shmctl(...)</code>：共享段控制</li>
    </ul>
  </li>
  <li>需要信号量等机制协调共享内存的访问冲突</li>
</ul>
<p><em>4.管道</em></p>
<ul>
  <li>进程间基于内存文件的通信机制
    <ul>
      <li>子进程从父进程继承文件描述符</li>
      <li>默认文件描述符：0 为stdin，1为stdout，2为stderr</li>
    </ul>
  </li>
  <li>进程不知道的另一端
    <ul>
      <li>可能从键盘，文件，程序读取</li>
      <li>可能写入到终端，文件，程序</li>
    </ul>
  </li>
</ul>
<p><em>管道示例</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/pipe.png" alt="pipe"></p>
<ul>
  <li>与管道相关的系统调用：
    <ul>
      <li>读管道：<code>read(fd, buffer, nbytes)</code>
        <ul>
          <li>C语言中的scanf()是基于它实现的</li>
        </ul>
      </li>
      <li>写管道：<code>write(fd, buffer, nbytes)</code>
        <ul>
          <li>C语言中的printf()是基于它实现的</li>
        </ul>
      </li>
      <li>创建管道：<code>pipe(rgfd)</code>
        <ul>
          <li>rgfd 是 2 个文件描述符组成的数组</li>
          <li>rgfd[0] 是读文件描述符</li>
          <li>rgfd[1] 是写文件描述符</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>5.信号</em></p>
<ul>
  <li>进程间的软件中断通知和处理机制，如 SIGKILL, SIGSTOP, SIGCONT等</li>
  <li>信号的接收处理：
    <ul>
      <li>捕获：执行进程指定的信号处理函数被调用</li>
      <li>忽略：执行操作系统指定的缺省处理，例如进程终止，进程挂起等</li>
      <li>屏蔽：禁止进程接收和处理信号（可能是暂时的）</li>
    </ul>
  </li>
  <li>不足：传递的信息量少，只有一个信号类型</li>
  <li>信号的实现：</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/signal.png" alt="signal"></p>
<p><em>6.缓冲消息</em></p>
<ul>
  <li>无缓存：
    <ul>
      <li>发送方必须等待接收方接收消息</li>
      <li>每个消息都要握手</li>
    </ul>
  </li>
  <li>有界缓冲：
    <ul>
      <li>缓冲区长度有限</li>
      <li>缓冲区满则发送阻塞</li>
      <li>使用一个管程</li>
    </ul>
  </li>
  <li>无界缓冲：
    <ul>
      <li>“无限”长度</li>
      <li>发送方永远不阻塞</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/buf-msg.png" alt="buf-msg"></p>
<p><em>7.直接通信</em></p>
<ul>
  <li>只有接收端有缓冲：
    <ul>
      <li>多个进程可能向接收方发送消息</li>
      <li>从特定的进程接收消息需要遍历整个缓冲区</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/dir1.png" alt="dir1"></p>
<ul>
  <li>每个发送者有一个缓冲区：
    <ul>
      <li>每个发送者发送给多个接收者</li>
      <li>获取消息仍需要遍历缓冲区</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/dir2.png" alt="dir2"></p>
<p><em>8.间接通信</em></p>
<ul>
  <li>使用信箱：
    <ul>
      <li>允许多对多通信</li>
      <li>需要打开/关闭信箱</li>
    </ul>
  </li>
  <li>缓冲：在信箱需要有一个缓冲区以及互斥锁和条件变量</li>
  <li>消息长度：不确定，可以把大消息切成多个包</li>
  <li>信箱和管道对比：
    <ul>
      <li>信箱允许多对多通信</li>
      <li>管道隐含一个发送一个接收</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/mbox.png" alt="mbox"></p>
<p><em>9.同步和异步</em></p>
<ul>
  <li>同步：
    <ul>
      <li>发送：
        <ul>
          <li>如果资源忙则阻塞</li>
          <li>启动数据传输</li>
          <li>直到源缓冲用完后在阻塞</li>
        </ul>
      </li>
      <li>接收：如果有消息则返回数据</li>
    </ul>
  </li>
  <li>异步：
    <ul>
      <li>发送：
        <ul>
          <li>如果资源忙则阻塞</li>
          <li>启动数据传输并且立即返回</li>
          <li>结束：
            <ul>
              <li>需要应用检查状态</li>
              <li>通知或者向应用发信号</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>接收：
        <ul>
          <li>如果有消息则返回数据</li>
          <li>如果无消息则返回状态</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>10.例外</em></p>
<ul>
  <li>进程结束：
    <ul>
      <li>R等待S发来的消息但S已经结束：R会永久阻塞</li>
      <li>S发送了一个消息给R，但R已经结束：S没有缓冲，永久阻塞</li>
    </ul>
  </li>
  <li>消息丢失：
    <ul>
      <li>使用确认（ack）和超时检测（timeout）和重传消息：
        <ul>
          <li>需要接收者每收到一个消息发送一个确认</li>
          <li>发送者阻塞知道ack到达或者超时</li>
          <li>status = send(dest, msg, timeout)</li>
          <li>如果超时发生且没收到确认，重发消息</li>
        </ul>
      </li>
      <li>问题：
        <ul>
          <li>重复</li>
          <li>丢失确认消息</li>
        </ul>
      </li>
      <li>重传必须处理：
        <ul>
          <li>在接收端消息重复</li>
          <li>发送端确认乱序</li>
        </ul>
      </li>
      <li>重传：
        <ul>
          <li>使用序列号确认是否重复</li>
          <li>在接收端删掉重复消息</li>
          <li>发送端收到乱序确认时重传</li>
        </ul>
      </li>
      <li>减少确认消息：
        <ul>
          <li>批量传送确认</li>
          <li>接收者发送no ack</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch3/drop.png" alt="drop"></p>
<ul>
  <li>消息损坏：
    <ul>
      <li>检测：
        <ul>
          <li>发送端计算整个消息的校验并随消息发送校验和</li>
          <li>在接收端重新计算校验和并和消息中的校验和对比</li>
        </ul>
      </li>
      <li>纠正：
        <ul>
          <li>重传</li>
          <li>使用纠错码恢复</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2 id="Chapter04-虚存管理"><a href="#Chapter04-虚存管理" class="headerlink" title="Chapter04 虚存管理"></a>Chapter04 虚存管理</h2>
<h3 id="虚存和地址转换"><a href="#虚存和地址转换" class="headerlink" title="虚存和地址转换"></a>虚存和地址转换</h3>
<p><em>1.现有计算机体系结构</em></p>
<ul>
  <li>冯诺依曼结构</li>
  <li>层次化存储结构</li>
  <li>内存DRAM：快，但贵，容量小，易失性</li>
  <li>外存磁盘：持久化，便宜，容量大，但慢</li>
</ul>
<p><em>2.最简单的系统</em></p>
<ul>
  <li>只有物理内存：应用程序直接使用物理内存</li>
  <li>物理内存静态划分</li>
</ul>
<p><em>3.进程保护</em></p>
<ul>
  <li>一个进程出错不能影响其他进程</li>
  <li>对每次内存访问都进行检查，只允许合法的内存访问</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/pth-pro.png" alt="pth-protect"></p>
<p><em>4.扩展内存和应用透明</em></p>
<ul>
  <li>一个进程必须能运行在不同的物理内存区域上</li>
  <li>一个进程必须能运行在不同的物理内存大小上</li>
</ul>
<p><em>5.问题</em></p>
<ul>
  <li>如何高效使用内存空间？
    <ul>
      <li>同时运行多个进程：系统运行的进程越多越好</li>
      <li>保护：
        <ul>
          <li>一个用户进程不能读取，更不能修改另一个用户进程的内存</li>
          <li>用户进程不能破坏内核的内存</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>基本内存抽象：
    <ul>
      <li>地址空间：进程的内存视图 -&gt; 虚拟视图</li>
      <li>透明、高效、安全保护</li>
    </ul>
  </li>
</ul>
<p><em>6.虚拟内存</em></p>
<ul>
  <li>独立的进程地址空间：
    <ul>
      <li>给每个进程一个很大的、静态的虚拟地址空间</li>
    </ul>
  </li>
  <li>虚实地址转换/映射：
    <ul>
      <li>当一个进程运行时，每次访存通过地址转换获得实际的物理内存地址</li>
    </ul>
  </li>
  <li>磁盘作为内存的延展（磁盘交换区）
    <ul>
      <li>只装载部分地址空间至内存</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/trans.png" alt="vm-phy"></p>
<p><em>地址空间</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/addr-space.png" alt="addr-space"></p>
<ul>
  <li>独立的进程地址空间：[0, max - 1]，程序员看到的是虚地址</li>
  <li>运行时装载部分地址空间</li>
  <li>每次访存：虚地址 -&gt; 物理地址
    <ul>
      <li>CPU看到的是虚地址</li>
      <li>进程看到的是虚地址</li>
      <li>内存与 I/O 设备看到的是物理地址</li>
    </ul>
  </li>
  <li>如果访问到未装载的地址空间：通知OS将它加载进内存空间</li>
</ul>
<p><em>虚存的好处</em></p>
<ul>
  <li>灵活：进程在执行时才放进内存，一部分在内存，另一部分在磁盘</li>
  <li>简单：进程的内存访问变得非常简单</li>
  <li>高效：
    <ul>
      <li>20/80原则：20%的内存承担80%的访问</li>
      <li>将20%放进物理内存</li>
    </ul>
  </li>
</ul>
<p><em>7.地址映射</em></p>
<ul>
  <li>目标：
    <ul>
      <li>隐式：对于每个内存访问，转换是隐式的</li>
      <li>快速：命中内存时，必须非常快</li>
      <li>例外：不命中时触发一个例外</li>
      <li>保护：对用户进程的错误进行保护</li>
    </ul>
  </li>
</ul>
<p><em>基址 + 长度</em>：（Cray-1 采用的方法）</p>
<ul>
  <li>连续分配：
    <ul>
      <li>为每个进程分配地址连续的内存</li>
      <li>用一个二元组来限定其内存区域：
        <base, bound="">
      </base,></li>
    </ul>
  </li>
  <li>保护：一个进程只能访问[base, base + bound]区间的内存</li>
  <li>上下文切换：保存/恢复基址寄存器以及上限寄存器</li>
  <li>好处：
    <ul>
      <li>简单：重定位时将虚地址和基址相加</li>
      <li>支持换出：多进程并发执行</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>外部碎片：随着进程的换入换出，内存产生很多空洞</li>
      <li>难以支持进程增大</li>
      <li>难以共享内存</li>
    </ul>
  </li>
</ul>
<p><em>8.地址转换实现</em></p>
<ul>
  <li>早期基于软件的静态地址转换：
    <ul>
      <li>针对每个启动的进程，特权软件loader重写其实际物理地址，即将其虚地址转换为物理地址</li>
      <li>没有内存保护，无效地址和恶意地址也会被转换</li>
    </ul>
  </li>
  <li>操作系统职责负责虚地址到物理地址转换的硬件单元
    <ul>
      <li>内存管理：新进程分配空间，结束的进程回收空间</li>
      <li>进程切换时base-bound的管理：保存当前进程的base-bound值，设置即将运行的进程的base-bound值</li>
      <li>异常处理：内存越界访问，无效地址等</li>
    </ul>
  </li>
</ul>
<p><em>MMU</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/mmu.png" alt="mmu"></p>
<ul>
  <li>负责虚地址到物理地址转换的硬件单元</li>
  <li>通常在片内实现，每个CPU有一个base寄存器和一个register寄存器</li>
  <li>虚存地址转换为物理地址，每条load和store指令都需要地址转换</li>
  <li>内存保护，检查地址是否有效</li>
  <li>特殊指令操作base和bound寄存器</li>
</ul>
<p>CPU发出的是虚地址，内存和I/O设备接收的是物理地址</p>
<p><em>9.分段</em></p>
<p>段间不连续分配：</p>
<ul>
  <li>把程序逻辑上划分为若干段：代码、栈、堆</li>
  <li>每个段分配连续内存，段间不必连续</li>
  <li>每个进程有一张段表：（seg, size）</li>
  <li>每个段采用基址 + 长度</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/seg.png" alt="seg"></p>
<ul>
  <li>如果访问地址的offset &gt;= 段size，则memory violation</li>
  <li>如果访问地址所在的seg的valid为0，则segment fault</li>
  <li>保护：每个段有（nil, read, write, exec）</li>
  <li>上下文切换：保存/恢复段表和指向段表的内核指针</li>
  <li>好处：高效，易共享</li>
  <li>不足：管理复杂，外部碎片（段间碎片）</li>
</ul>
<p><em>10.分页</em></p>
<ul>
  <li>使用固定大小的映射单元</li>
  <li>把虚存划分为固定大小的单元（称为页，page）</li>
  <li>把物理内存划分为同样大小的单元（称为页框，page frame）</li>
  <li>按需加载</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/page.png" alt="page"></p>
<ul>
  <li>页表：
    <ul>
      <li>记录 虚页 -&gt; 物理页的映射</li>
      <li>每个进程一个页表</li>
    </ul>
  </li>
  <li>每个表项有若干个控制位：按页保护（read, write, exe）</li>
  <li>上下文切换：与分段类似，保存/恢复页表地址</li>
  <li>好处：分配简单，易共享</li>
  <li>不足：页表很大，进程地址空间有很多空洞，对应的页表项无用</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/page-frame.png" alt="page-frame"></p>
<p><em>分段 VS 分页</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/seg-vs-page.png" alt="seg-vs-page"></p>
<p><em>11.页表项</em></p>
<ul>
  <li>表达一个映射关系：虚页号 -&gt; 物理页</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/ptm.png" alt="ptm"></p>
<ul>
  <li>
    <p>控制位：</p>
    <ul>
      <li>P：标识该页在内存（Present）或不在内存（Absent）</li>
      <li>R/W：read, write, exe</li>
      <li>U/S：user/supervisor，标识用户态进程是否可以访问</li>
      <li>A：标识该页是否被访问</li>
      <li>D：标识该页是否为脏</li>
      <li>G, PAT, PCD, PWT：标识Cache工作方式</li>
    </ul>
  </li>
</ul>
<p><em>页表项（PTE）的数目</em></p>
<ul>
  <li>假设4KB的页，低12位为页内偏移</li>
  <li>32位地址的机器：
    <ul>
      <li>每个进程的页表有$2^{20}$个页表项（~ 4MB）</li>
      <li>页表所需内存空间 = 进程数量 X $2^{20}$</li>
      <li>如果有10K个进程，内存放不下所有的页表</li>
    </ul>
  </li>
  <li>64位地址的机器：
    <ul>
      <li>每个进程的页表有$2^{52}$个页表项</li>
      <li>页表所需内存空间 = 进程数量 X $2^{52}$</li>
      <li>一个进程的页表可能磁盘都存不下</li>
    </ul>
  </li>
</ul>
<p><em>12.分段 + 分页</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/seg-page.png" alt="seg-page"></p>
<ul>
  <li>先将进程划分为若干段</li>
  <li>每个段采用分页</li>
  <li>段表记录它的页表地址</li>
</ul>
<p><em>13.多级页表</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/multi-page.png" alt="multi-page"></p>
<p>虚地址除去offset的部分划分为多个段</p>
<ul>
  <li>每段对应一级页表</li>
  <li>多个页表</li>
</ul>
<p><em>例：二级页表</em></p>
<ul>
  <li>每个页表4KB，1024个表项</li>
  <li>下级页表每一项映射一页（4KB）</li>
  <li>上级页表的每一项映射4MB的地址空间</li>
  <li>对于大地址空间，大部分程序只需要几个页表</li>
</ul>
<p><em>14.反向页表</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/reverse-page.png" alt="reverse-page"></p>
<p>按物理页索引，记录每个物理页对应的进程ID及虚页</p>
<ul>
  <li>主要思想：
    <ul>
      <li>每个物理页一个PTE</li>
      <li>地址转换：哈希查找，Hash(Vpage, pid) -&gt; Ppage#</li>
    </ul>
  </li>
  <li>好处：
    <ul>
      <li>页表大小与地址空间大小无关，只与物理内存大小有关</li>
      <li>对于大地址空间，页表较小</li>
    </ul>
  </li>
  <li>坏处：查找难，管理哈希链等的开销</li>
</ul>
<p><em>15.TLB</em></p>
<p>加速地址转换：</p>
<ul>
  <li>程序只知道虚地址：每个程序或进程的地址空间是[0, Max - 1]</li>
  <li>每个虚地址必须进行转换：
    <ul>
      <li>可能需要逐级查找多级页表</li>
      <li>页表保存在内存中，一个内存访问变成多个内存访问</li>
    </ul>
  </li>
  <li>解决办法：将使用最多的那部分页表项缓存在更快速的存储器中</li>
</ul>
<p><em>TLB硬件</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/tlb.png" alt="tlb"></p>
<ul>
  <li>所有表项同时查找，速度快</li>
</ul>
<p><em>TLB表项的格式</em></p>
<ul>
  <li>共有（必须的）的位：
    <ul>
      <li>VP#（虚页号）：与虚地址进行匹配</li>
      <li>PP#（物理页号）：转换后的实际地址</li>
      <li>Valid位：标识此表项是否有效</li>
      <li>访问控制位：允许用户/内核访问，以及何种访问（nil, read, write）</li>
    </ul>
  </li>
  <li>可选的位
    <ul>
      <li>进程标签（pid）</li>
      <li>访问控制位（R位）</li>
      <li>修改标识位（W）</li>
      <li>允许缓存否</li>
    </ul>
  </li>
</ul>
<p><em>硬件控制的TLB</em></p>
<ul>
  <li>CPU把一个虚地址VA给MMU进行转换</li>
  <li>MMU先查TLB，VA = VP# || offset，将该虚页号同时与TLB中所有表项相比较</li>
  <li>TLB hit（命中）：TLB中找到含VP#的表项
    <ul>
      <li>如果有效（TLB的valid位为1），取表项中的物理页号</li>
      <li>如果无效，则等同于TLB miss</li>
    </ul>
  </li>
  <li>如果TLB miss（不命中）：TLB中没有含VP#的表项
    <ul>
      <li>MMU硬件在页表中进行查找，得到PTE</li>
      <li>将找到的PTE加载进TLB（如果没有空闲表项，替换一个TLB表项）</li>
      <li>并取TLB表项中的物理页号</li>
    </ul>
  </li>
</ul>
<p><em>软件控制的TLB</em></p>
<ul>
  <li>CPU把一个虚地址vaddr给MMU进行转换</li>
  <li>MMU先查TLB，vaddr = vpage# || offset，将该虚页号同时与TLB中所有表项进行比较</li>
  <li>TLB hit：TLB中找到含vpage#的表项
    <ul>
      <li>如果有效，取表项中的物理页号</li>
      <li>如果无效，则等同于TLB miss</li>
    </ul>
  </li>
  <li>如果TLB不命中：产生TLB fault
    <ul>
      <li>进入内核异常处理程序（软件）</li>
      <li>如果没有空闲TLB表项，则替换一个TLB表项</li>
      <li>在页表中进行查找，得到PTE</li>
      <li>将该PTE加载进TLB</li>
      <li>重新执行发生TLB不命中的指令</li>
    </ul>
  </li>
</ul>
<p><em>硬件控制 VS 软件控制</em></p>
<ul>
  <li>硬件控制：
    <ul>
      <li>高效</li>
      <li>不灵活</li>
      <li>需要更多的空间来保存页表</li>
    </ul>
  </li>
  <li>软件控制：
    <ul>
      <li>大大简化了MMU的逻辑，使得CPU芯片上更多的面积用于缓存</li>
      <li>灵活</li>
      <li>能够处理大的虚地址空间：软件可以使用反向页表，进行哈希映射</li>
    </ul>
  </li>
</ul>
<p><em>16.缓存 VS TLB</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/cache-vs-tlb.png" alt="cache-vs-tlb"></p>
<ul>
  <li>相似之处：缓存一部分内存，不命中时替换</li>
  <li>不同之处：关联度，一致性：PTE修改</li>
</ul>
<p><em>17.TLB设计问题</em></p>
<ul>
  <li>替换哪个TLB表项：随机或伪LRU</li>
  <li>上下文切换时需要做什么：
    <ul>
      <li>有进程标签：修改TLB寄存器和进程寄存器的内容</li>
      <li>无进程标签：作废整个TLB内容</li>
    </ul>
  </li>
  <li>修改一个页表项时需要做什么：
    <ul>
      <li>修改内存中的PTE</li>
      <li>将对应的TLB表项置为无效（TLB flush）</li>
    </ul>
  </li>
  <li>减少TLB不命中的开销：
    <ul>
      <li>增大TLB：很小的TLB，很好的TLB命中率
        <ul>
          <li>不能太大，CPU的面积有限</li>
        </ul>
      </li>
      <li>基于预测的preload</li>
      <li>页表缓存：缓存包含TLB表项的页表所在页，由软件管理</li>
    </ul>
  </li>
</ul>
<p><em>一致性问题</em></p>
<ul>
  <li>缓存：“侦听”协议
    <ul>
      <li>维护DRAM的一致性，即使在有DMA的情况下</li>
    </ul>
  </li>
  <li>TLB与DRAM之间的一致性：任何时候修改一个页表项都需要TLB flush</li>
  <li>TLB “shut down”
    <ul>
      <li>在共享内存的多处理器上，有些内存页面同时被多个处理器访问
        <ul>
          <li>内核页面、多个进程共享的用户页面，多线程被调度到不同的处理器上</li>
        </ul>
      </li>
      <li>一个处理器修改一个页表项，需要所有处理器都TLB flush</li>
      <li>在TLB flush期间，所有处理器都不响应中断</li>
    </ul>
  </li>
</ul>
<p><em>18.总结</em></p>
<ul>
  <li>虚拟内存：虚拟化使得软件开发变得容易，而且内存资源利用率高</li>
  <li>进程地址空间：分离地址空间能够提供保护和错误隔离</li>
  <li>地址转换：
    <ul>
      <li>虚地址与物理地址</li>
      <li>MMU</li>
    </ul>
  </li>
  <li>TLB
    <ul>
      <li>加速地址转换的专门硬件</li>
      <li>但引入一致性问题</li>
    </ul>
  </li>
  <li>地址映射：
    <ul>
      <li>基址 + 长度：简单，但有很大的局限性</li>
      <li>分段：有用，但太复杂</li>
      <li>分页：页与页框，页表与PTE</li>
      <li>大页表优化：分段 + 分页，多级页表，反向页表</li>
    </ul>
  </li>
</ul>
<h3 id="页替换"><a href="#页替换" class="headerlink" title="页替换"></a>页替换</h3>
<p><em>1.进程加载</em></p>
<ul>
  <li>简单办法：将整个进程加载进内存 -&gt; 运行 -&gt; 退出
    <ul>
      <li>慢（对于大进程）</li>
      <li>浪费空间（一个进程并不是时刻都需要所有的内存）</li>
    </ul>
  </li>
  <li>解决办法：
    <ul>
      <li>按需加载页：只将实际使用的页加载进内存</li>
      <li>换页：内存中只放频繁使用的那些页</li>
    </ul>
  </li>
  <li>机制：一部分虚存映射到内存，一部分虚存映射到磁盘</li>
</ul>
<p><em>2.换页步骤</em></p>
<ul>
  <li>内存访问（可能导致TLB不命中）</li>
  <li>若TLB不命中，进行页表查找，得到PTE</li>
  <li>若PTE的valid位 = 0（页不在内存），触发缺页（Page Fault）</li>
  <li>虚存管理中的缺页处理接管控制，将页从磁盘读到内存</li>
  <li>更新PTE：填入pp#，将valid位置为1</li>
  <li>把PTE加载进TLB</li>
  <li>重新执行该指令：重新进行内存访问</li>
</ul>
<p><em>换页</em></p>
<ul>
  <li>缺页可能发生在一条指令执行的中途</li>
  <li>应用程序透明：必须让用户程序不感知缺页</li>
  <li>需要保存状态并从断点处继续执行</li>
</ul>
<p><em>页替换</em></p>
<ul>
  <li>需要的页不在内存里 -&gt; 需换入 -&gt; 需为它分配一个页框</li>
  <li>可能此时没有空闲页框</li>
  <li>VM需要进行页替换</li>
</ul>
<p><em>3.缺页处理</em></p>
<p>进程A发生缺页，发生缺页的页记为VP</p>
<ul>
  <li>陷入内核，保存进程A的当前状态：PC，寄存器</li>
  <li>调用OS的缺页处理程序：
    <ul>
      <li>检查地址和操作类型的合法性，不合法，则给进程A发signal或者kill</li>
      <li>为VP分配一个物理页框，记为PP:
        <ul>
          <li>如果有空闲页框PP1，则用它，PP = PP1</li>
          <li>如果没有空闲页框，选择一个状态为used页框PP2
            <ul>
              <li>如果它是脏的（M位 = 1），则把它写回磁盘</li>
              <li>PTE表项valid位置为0，flush TLB表项</li>
              <li>写回完成后，PP = PP2</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>找到VP对应的磁盘页，把它读到这个页框（PP）中</li>
      <li>修改VP的PTE：填入PP#，将valid位置为1，并把该PTE加载进TLB</li>
    </ul>
  </li>
  <li>恢复进程A的状态，重新执行发生缺页的指令</li>
</ul>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4>
<p><em>1.最优算法（MIN）</em></p>
<ul>
  <li>算法：替换在未来最长一段时间里不用的页</li>
</ul>
<ul>
  <li>前提：知道未来所有的访问</li>
  <li>好处：最优方案，可作为一种离线分析手段</li>
  <li>坏处：
    <ul>
      <li>在线系统无法采用，因为不知道未来的访问顺序</li>
      <li>没有线性时间复杂度的实现</li>
    </ul>
  </li>
</ul>
<p><em>TLB和页表</em></p>
<p>用于换页的位：</p>
<ul>
  <li>R位：访问标志位，当访问该页中的某个位置时置位</li>
  <li>M位：修改标志位，当对该页中某个位置进行写时置位</li>
</ul>
<p><em>2.NRU（Not Recently Used）</em></p>
<ul>
  <li>算法：按下面顺序，随机选择一个页：
    <ul>
      <li>未访问过且未修改过</li>
      <li>未访问过且修改过</li>
      <li>访问过且未修改过</li>
      <li>访问过且修改过</li>
    </ul>
  </li>
  <li>好处：可实现</li>
  <li>坏处：需要扫描内存中所有页的R位和M位</li>
</ul>
<p><em>3.FIFO</em></p>
<ul>
  <li>算法：选择最老的页换掉</li>
  <li>好处：开销最小</li>
  <li>坏处：频繁使用的页被替换</li>
</ul>
<p><em>4.有第二次机会的FIFO</em></p>
<ul>
  <li>核心思想：
    <ul>
      <li>尽量让频繁使用的页留在内存，不被替换</li>
      <li>替换时给访问过的页第二次机会，在内存中呆更长时间</li>
    </ul>
  </li>
  <li>算法：
    <ul>
      <li>检查最老页的R位，如果为0，替换它</li>
      <li>如果为1，将它清0，并把它移到队尾，继续查找</li>
    </ul>
  </li>
  <li>好处：实现简单</li>
  <li>坏处：最坏情况时可能需要很长时间</li>
</ul>
<p><em>5.Clock</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/clock.png" alt="clock"></p>
<ul>
  <li>改进Second Chance在替换时移动页的开销</li>
  <li>算法：把所有页框组织成环形链表
    <ul>
      <li>用一个表针指向最老的页</li>
      <li>发生缺页时，按表针走动方向来检查页</li>
    </ul>
  </li>
  <li>第二次机会：
    <ul>
      <li>如果R位为1，将其置为0，且表针向前移一格</li>
      <li>如果R位为0，替换它</li>
    </ul>
  </li>
</ul>
<p><em>6.双表针的Clock算法</em></p>
<ul>
  <li>对Clock的替换加以控制</li>
  <li>方法：增加一个表针
    <ul>
      <li>前表针扫描页，把R位清0</li>
      <li>后表针扫描页，把R位为0的页加入替换页链表</li>
      <li>扫描方向相同，扫描速度相同</li>
    </ul>
  </li>
  <li>替换控制
    <ul>
      <li>扫描速度：
        <ul>
          <li>控制替换速度</li>
          <li>空闲内存多，扫描速度慢</li>
          <li>空闲内存少，扫描速度快</li>
        </ul>
      </li>
      <li>表针间距：
        <ul>
          <li>页框再次被访问的时间窗口</li>
          <li>控制页在内存里的最长停留时间</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>7.LRU</em></p>
<ul>
  <li>替换最长时间没有使用的页：
    <ul>
      <li>将所有页框组织成一个链表</li>
      <li>前端为最久未访问的页（LRU端）：替换的页</li>
      <li>后端为最近刚访问的页（MRU端）：新加载的页和命令的页</li>
      <li>每次命中将页重新插入MRU端</li>
    </ul>
  </li>
  <li>好处：对MIN算法的很好近似</li>
  <li>坏处：实现困难</li>
</ul>
<p><em>8.近似LRU</em></p>
<ul>
  <li>记录每个页访问时间戳，替换时间戳最小的页
    <ul>
      <li>使用一个硬件计数器，每执行完一条指令，计数器加一</li>
      <li>每一个内存访问，将当前计数器值作为时间戳，保存在该页的PTE中</li>
      <li>替换时选择时间戳最小的页</li>
      <li>坏处：开销太大，不可行</li>
    </ul>
  </li>
  <li>NFU：记录每个页的访问次数，替换访问次数最少的页：
    <ul>
      <li>每页有一个访问计数器，用软件模拟</li>
      <li>每个时钟中断时，所有页的计数器分别与它的R位值相加</li>
      <li>坏处：Never Forget，过去频繁访问，现在不访问的页，替换不出去</li>
    </ul>
  </li>
</ul>
<p><em>9.Aging</em></p>
<ul>
  <li>消除过去访问的影响
    <ul>
      <li>每个时钟中断时，先将所有页计数器右移一位，再将每页计数器最高位与该页的R位相加</li>
      <li>替换时，选择计数器值最小的页</li>
    </ul>
  </li>
  <li>Aging与LRU的主要区别：
    <ul>
      <li>记录下来的历史更短</li>
      <li>无法区分访问的先后顺序</li>
    </ul>
  </li>
</ul>
<p><em>10程序的行为</em></p>
<ul>
  <li>80/20原则：
    <ul>
      <li>80%的访问只涉及20%的内存空间</li>
      <li>80%的访问来自20%的代码</li>
    </ul>
  </li>
  <li>空间局部性：相邻的页很可能会被访问</li>
  <li>时间局部性：被访问的页很可能在不远的将来再被访问</li>
</ul>
<p><em>11.工作集</em></p>
<ul>
  <li>主要思想：
    <ul>
      <li>工作集被定义为在最近K次访问的那些页</li>
      <li>把工作集放进内存能大大的减少缺页</li>
    </ul>
  </li>
  <li>工作集的近似：一个进程在过去T秒钟里使用的页</li>
  <li>一个算法：记录页的”上次访问时间“
    <ul>
      <li>在缺页时，扫描该进程所有的页</li>
      <li>如果R位为1，将该页的上次访问时间设置为当前时间</li>
      <li>如果R位为0，计算当前时间与上次访问时间之差$\Delta$
        <ul>
          <li>如果$\Delta &gt; T$，该页在过去T秒里没有访问过，则替换它</li>
          <li>否则，检查下一页</li>
        </ul>
      </li>
      <li>将发生缺页的页加入工作集</li>
    </ul>
  </li>
</ul>
<p><em>12.WSClock</em></p>
<ul>
  <li>将页框组织成环形链表</li>
  <li>按表针走动顺序来检查页</li>
  <li>如果R位为1:
    <ul>
      <li>将R位置为0，该页的上次访问时间设置为当前时间</li>
      <li>检查下一页</li>
    </ul>
  </li>
  <li>如果R位为0：
    <ul>
      <li>$\Delta = $ 当前时间 - 上次访问时间</li>
      <li>如果$\Delta \le T$，该页在过去T秒里访问过，检查下一页</li>
      <li>如果$\Delta &gt; T$，该页在过去T秒里没有访问过，而且M位为1，将该页加入写回链表，并检查下一页</li>
      <li>如果$\Delta &gt; T$，该页在过去T秒里没有访问过，并且M位为0，替换该页</li>
    </ul>
  </li>
</ul>
<h3 id="虚存设计"><a href="#虚存设计" class="headerlink" title="虚存设计"></a>虚存设计</h3>
<p><em>1.颠簸</em></p>
<ul>
  <li>频繁发生缺页，运行速度很慢</li>
  <li>进程被阻塞，等待页从磁盘取进内存</li>
  <li>原因：
    <ul>
      <li>进程的工作集 &gt; 可用的物理内存</li>
      <li>进程过多，即使单个进程都小于内存</li>
      <li>内存没有被很好的回收利用</li>
    </ul>
  </li>
</ul>
<p><em>哪些工作集放进内存</em></p>
<ul>
  <li>进程分为两组：
    <ul>
      <li>活跃组：工作集加载进内存</li>
      <li>不活跃组：工作集不加载进内存</li>
    </ul>
  </li>
  <li>如何确定哪些进程是不活跃的
    <ul>
      <li>等待事件</li>
      <li>等待资源</li>
    </ul>
  </li>
  <li>两个调度器
    <ul>
      <li>长期调度器决定：
        <ul>
          <li>哪些进程可以同时运行</li>
          <li>哪些是不活跃的进程，把它们换出到磁盘</li>
          <li>哪些是活跃的进程，把它们换入内存</li>
        </ul>
      </li>
      <li>短期调度器决定把CPU分配给哪个调度器</li>
    </ul>
  </li>
</ul>
<p><em>如何选择被替换的页</em></p>
<ul>
  <li>全局选择：
    <ul>
      <li>从所有进程的所有页框中选择</li>
      <li>可替换其它进程的页框</li>
    </ul>
  </li>
  <li>局部选择：只从本进程的页框中选择</li>
</ul>
<p><em>全局选择 VS 局部选择</em></p>
<ul>
  <li>全局选择：
    <ul>
      <li>从所有进程的所有页框中选择</li>
      <li>可替换其他进程的页框</li>
      <li>每个进程运行期间，其内存大小是动态变化的</li>
      <li>好处：简单</li>
      <li>坏处：没有隔离，受其它进程的页替换干扰，不能控制各个进程的内存使用量</li>
    </ul>
  </li>
  <li>局部选择：
    <ul>
      <li>只从本进程自己的页框中选择</li>
      <li>一个进程运行期间，其内存大小是不变的
        <ul>
          <li>页框池：分配给进程的页框的集合，进程间池大小可不同</li>
        </ul>
      </li>
      <li>好处：隔离，不影响其它进程</li>
      <li>坏处：不灵活，进程增大会出现颠簸，难以充分利用内存（每个进程对内存的需求不一样）</li>
    </ul>
  </li>
</ul>
<p><em>2.平衡分配</em></p>
<p>局部选择 + 池大小动态分配</p>
<ul>
  <li>每个进程有自己的页框池</li>
  <li>从自己的池中分配页，且从自己的工作集中替换页</li>
  <li>用一种机制来运行时动态调整每个池的大小</li>
  <li>进程加载方式：进程换入时
    <ul>
      <li>纯粹的按需加载页 -&gt; 大量的page fault -&gt; 加载慢</li>
      <li>预加载：先加载部分页 -&gt; 初始池大小</li>
      <li>如果初始池大小 ~ 工作集 -&gt; 加载快，减少page fault开销</li>
    </ul>
  </li>
  <li>初始池大小：
    <ul>
      <li>固定分配：所有进程都一样</li>
      <li>平均分配：
        <ul>
          <li>内存总量 / 当前运行态进程数量</li>
          <li>进程大小差异很大</li>
        </ul>
      </li>
      <li>根据进程大小按比例分配：
        <ul>
          <li>（进程大小 / 当前运行态进程的总大小）X 内存数量</li>
          <li>当前运行的进程的总大小是变化的</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>动态调整池大小：进程大小变化
    <ul>
      <li>PFF算法
        <ul>
          <li>缺页率PFF：进程每秒产生多少次缺页</li>
          <li>对于大多数替换策略，PFF随分配给进程的内存增加而减少</li>
        </ul>
      </li>
      <li>根据进程的PFF来调整分配给它的内存量
        <ul>
          <li>两个阀值A和B，A为上限，B为下限</li>
          <li>当PFF高于A，就增加其内存</li>
          <li>当PFF低于B，就减少其内存</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>3.钉住页（pin/lock）</em></p>
<ul>
  <li>DMA进行过程中，需要传输的页不能被换出，否则CPU就会把新内容写入这些页</li>
  <li>系统调用接口：
    <ul>
      <li>pin：把虚页钉在内存，使它们不会被换出</li>
      <li>unpin：取消pin，使它们可以被换出</li>
    </ul>
  </li>
  <li>如何设计：
    <ul>
      <li>用一个数据结构来记录所有被钉住的页</li>
      <li>换页算法在替换页时检查该数据结构，如果页被钉住，则不替换它，重新选择一页</li>
    </ul>
  </li>
</ul>
<p><em>4.交换空间管理</em></p>
<ul>
  <li>交换区
    <ul>
      <li>后备存储</li>
      <li>在磁盘上</li>
      <li>专门用于存储进程换出页</li>
      <li>交换分区：用专门的磁盘分区</li>
      <li>交换文件：用一些文件</li>
    </ul>
  </li>
  <li>交换空间管理：
    <ul>
      <li>静态分配</li>
      <li>动态分配</li>
    </ul>
  </li>
</ul>
<p><em>静态分配</em></p>
<ul>
  <li>创建进程时分配，进程结束时回收</li>
  <li>大小：进程映像</li>
  <li>进程控制表记录交换空间的磁盘地址</li>
  <li>绑定：一个虚存页 &lt;–&gt; 一个磁盘页，磁盘页称为shadow page</li>
  <li>初始化：
    <ol>
      <li>按需换入：进程映像拷贝到交换区</li>
      <li>按需换出：进程映像加载进内存</li>
    </ol>
  </li>
  <li>缺点：难以增长</li>
</ul>
<p><em>动态分配</em></p>
<ul>
  <li>创建进程时不分配</li>
  <li>页换出时分配，页换入时回收</li>
  <li>虚页与磁盘页不绑定，多次换出，分配不同的磁盘页</li>
  <li>PTE中记录页的磁盘地址</li>
  <li>一个优化：程序正文段
    <ul>
      <li>直接用磁盘中的可执行文件作为交换区</li>
      <li>换出时直接抛弃</li>
      <li>好处：减少了交换区的大小，减少了不必要的拷贝和写回</li>
    </ul>
  </li>
</ul>
<p><em>PTE</em></p>
<ul>
  <li>虚页 -&gt; 页框和磁盘</li>
  <li>如果valid bit = 1，对应物理页号pp#</li>
  <li>如果valid bit = 0，对应磁盘页号dp#</li>
</ul>
<p><em>换出</em></p>
<ul>
  <li>将PTE和TLB置为无效</li>
  <li>将页拷贝到磁盘</li>
  <li>将磁盘页号填入PTE</li>
</ul>
<p><em>换入</em></p>
<ul>
  <li>找一个空闲页框（可能触发替换）</li>
  <li>将页从磁盘拷贝到这个页框中</li>
  <li>将页框号填入PTE中，并将PTE置为有效</li>
</ul>
<p><em>5.清零页</em></p>
<ul>
  <li>将页清零
    <ul>
      <li>把页置为全0</li>
      <li>堆和栈的数据都需要初始化</li>
    </ul>
  </li>
  <li>对于数据段和栈段的页，当它们第一次发生page fault时，将它们清零</li>
  <li>有一个专门的线程来做清零</li>
</ul>
<p><em>6.共享页</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/shm.png" alt="shmj"></p>
<ul>
  <li>两个进程的页表共享一些物理页</li>
</ul>
<p><em>7.写时复制（copy on write）</em></p>
<ul>
  <li>该技术用于创建子进程（fork系统调用）</li>
  <li>原理：
    <ul>
      <li>子进程的地址空间使用其父进程相同的映射</li>
      <li>将所有的页置成read-only</li>
      <li>将子进程置成ready</li>
      <li>对于读，没有问题</li>
      <li>对于写，产生page fault:
        <ul>
          <li>修改PTE，映射到一个新的物理页</li>
          <li>将页内容全部拷贝到新物理页</li>
          <li>重新运行发生缺页的指令</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>8.UNIX的地址空间</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch4/unix.png" alt="unix"></p>
<ul>
  <li>正文段：只读，大小不变</li>
  <li>数据段：
    <ul>
      <li>初始化数据</li>
      <li>未初始化数据：BSS</li>
      <li>brk区用于增长或缩小</li>
    </ul>
  </li>
  <li>栈段</li>
  <li>内存映射文件
    <ul>
      <li>将一个文件映射进虚存</li>
      <li><code>mmap</code>和<code>unmap</code></li>
      <li>像访问内存一样访问文件</li>
    </ul>
  </li>
</ul>
<p><em>9.Linux地址空间</em></p>
<ul>
  <li>32位地址空间：3GB用户空间，1GB内核空间</li>
  <li>栈段从3GB位置向下增长，初始时保存进程的环境变量和命令行参数</li>
  <li>数据段：大小可变，BSS为未初始化的全局变量，页加载时初始化为0</li>
  <li>2.6.11及以后的Linux使用4级页表</li>
  <li>物理页分配采用伙伴算法</li>
</ul>
<p><em>10.Linux的页替换</em></p>
<p>方法：</p>
<ul>
  <li>保持一定数量的空闲页</li>
  <li>文件缓存，未使用的共享页使用Clock算法</li>
  <li>用户进程的内存使用改进的Clock算法</li>
</ul>
<p>改进的Clock算法：</p>
<ul>
  <li>两条LRU链</li>
  <li>Active list：所有进程的工作集</li>
  <li>Inactive list：回收的候选页</li>
  <li>Refill将页从Active list移动到Inactive list</li>
</ul>
<h2 id="Chapter05-输入-输出"><a href="#Chapter05-输入-输出" class="headerlink" title="Chapter05 输入/输出"></a>Chapter05 输入/输出</h2>
<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3>
<p><em>1.输入和输出</em></p>
<ul>
  <li>计算机的工作是处理数据
    <ul>
      <li>计算：CPU，高速缓存，内存</li>
      <li>将数据传入及传出计算机系统：数据在I/O设备以及内存之间来回传输</li>
    </ul>
  </li>
  <li>I/O设备面临多种挑战：多种类型、大量产商、需要大量设备驱动，设备驱动运行于内核态，其bug常常引发宕机</li>
  <li>OS的目标：
    <ul>
      <li>提供一种通用的、一致的、方便的、可靠的方法来访问各种I/O设备</li>
      <li>充分发挥I/O设备的性能</li>
    </ul>
  </li>
</ul>
<p><em>2.硬件架构</em></p>
<ul>
  <li>计算机硬件
    <ul>
      <li>CPU核和高速缓存</li>
      <li>内存控制器</li>
      <li>内存</li>
      <li>I/O总线</li>
    </ul>
  </li>
  <li>I/O硬件
    <ul>
      <li>I/O总线或互连</li>
      <li>I/O设备控制器或适配器</li>
      <li>I/O设备</li>
    </ul>
  </li>
</ul>
<p><em>3.设备控制器</em></p>
<ul>
  <li>控制设备的逻辑：解析主机发来的命令，控制设备进行操作</li>
  <li>组成：
    <ul>
      <li>与主机的接口：用于与主机之间的信息传递
        <ul>
          <li>硬件接口：PCie, SATA, USB</li>
          <li>接收主机的命令和数据，或把设备的数据和状态等返回给主机</li>
        </ul>
      </li>
      <li>控制寄存器：1个或多个，用于控制设备操作
        <ul>
          <li>写控制寄存器，命令设备干指定的事情，比如传数据、接收数据、开、关</li>
          <li>读设备寄存器，获得设备的状态，比如忙、闲、就绪</li>
        </ul>
      </li>
      <li>数据缓冲区：用于数据缓冲或缓存，DRAM
        <ul>
          <li>缓冲CPU发给设备的数据</li>
          <li>缓存设备的数据</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>4.与I/O设备进行交互：寻址</em></p>
<ul>
  <li>I/O端口：独立的I/O端口空间
    <ul>
      <li>端口号：8位或16位的数值</li>
      <li>只能通过I/O指令访问</li>
      <li>I/O指令是特权指令，用户程序不能访问</li>
      <li>内存地址空间与I/O地址空间分离
        <ul>
          <li>控制线：指示CPU发出的地址是内存空间还是I/O空间</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>内存映射I/O：使用统一地址空间
    <ul>
      <li>预留一部分内存地址空间</li>
      <li>内存地址与I/O地址无重叠
        <ul>
          <li>CPU发出的地址，所有内存模块和所有设备都要解析</li>
        </ul>
      </li>
      <li>优势：访存指令可以用来访问设备的控制寄存器
        <ul>
          <li>编程方便</li>
          <li>保护方便、灵活：利用虚存的保护机制，放在内核空间或某个进程的虚空间</li>
          <li>高效：减少指令</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>5.与I/O设备进行数据传输</em></p>
<ul>
  <li>数据传输
    <ul>
      <li>启动设备 + 数据传输</li>
      <li>启动时间（开销）：CPU用于启动设备进行操作的时间</li>
      <li>带宽：启动设备后数据传输的速率</li>
      <li>延迟：传输一字节的时间 = 启动时间 + 将一字节传输到目的地的时间</li>
    </ul>
  </li>
  <li>通用方法：
    <ul>
      <li>不同的传输速率</li>
      <li>字符设备：对字节流传输的抽象，打印机、网卡等，以若干字节为传输粒度，从而分摊开销</li>
      <li>块设备：以块为存储粒度和传输粒度，按块寻址，整块读写</li>
    </ul>
  </li>
</ul>
<h4 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h4>
<p><em>1.PIO（Programmed I/O）</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/pio.png" alt="pio"></p>
<ul>
  <li>简单的串行控制器
    <ul>
      <li>状态寄存器：就绪，忙…</li>
      <li>数据寄存器</li>
    </ul>
  </li>
  <li>查询输出：
    <ul>
      <li>CPU：
        <ul>
          <li>等待设备状态变为非“忙”</li>
          <li>写数据到数据寄存器</li>
          <li>通知设备“就绪”</li>
        </ul>
      </li>
      <li>设备：
        <ul>
          <li>等待直到状态变为“就绪”</li>
          <li>清除“就绪”标志，设置“忙”标志</li>
          <li>从数据寄存器中拿走数据</li>
          <li>清除“忙”标志</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>PIO的轮询</em></p>
<ul>
  <li>等待直到设备状态变为非“忙”
    <ul>
      <li>轮询：不停的检查设备状态，“忙等”</li>
    </ul>
  </li>
  <li>好处：简单</li>
  <li>坏处：慢，浪费CPU</li>
  <li>改进：中断机制可避免CPU轮询</li>
</ul>
<p><em>2.中断</em></p>
<p>例子：鼠标</p>
<ul>
  <li>简单的鼠标控制器：状态寄存器 + 数据寄存器</li>
  <li>输入：
    <ul>
      <li>鼠标：
        <ul>
          <li>等待直到设备状态变为“完成”</li>
          <li>将$\Delta X,\Delta Y$和按键的值保存到数据寄存器</li>
          <li>发中断</li>
        </ul>
      </li>
      <li>CPU（中断处理）
        <ul>
          <li>清除“完成”标志</li>
          <li>将$\Delta X,\Delta Y$和按键的值读到内核缓冲区（内存）中</li>
          <li>置“完成”标志</li>
          <li>调用调度器</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>3.DMA</em></p>
<p>例子：磁盘</p>
<ul>
  <li>一个简单的磁盘控制器
    <ul>
      <li>状态寄存器</li>
      <li>DMA内存地址和字节数</li>
      <li>DMA控制寄存器：命令、设备、传输模式及粒度</li>
      <li>DMA数据缓冲区</li>
    </ul>
  </li>
  <li>DMA写：
    <ul>
      <li>CPU：
        <ul>
          <li>等待DMA设备状态为“就绪”</li>
          <li>清除“就绪”</li>
          <li>设置DMA命令为write，地址和大小</li>
          <li>设置“开始”</li>
          <li>阻塞当前的进程/线程</li>
        </ul>
      </li>
      <li>磁盘控制器：
        <ul>
          <li>DMA方式将数据传输到缓冲区（count–; addr++）</li>
          <li>当count == 0，发中断</li>
        </ul>
      </li>
      <li>CPU（中断处理）
        <ul>
          <li>将被该DMA阻塞的进程/线程加到就绪队列</li>
          <li>将数据从缓冲区写入磁盘</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>4.I/O软件栈</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/io-softwarestack.png" alt="io-softwarestack"></p>
<p><em>5.设备驱动</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/driver.png" alt="driver"></p>
<ul>
  <li>给操作系统的其他模块提供操作设备的API</li>
  <li>与设备控制器交互
    <ul>
      <li>与设备控制器进行交互以进行数据传输：命令、参数、数据</li>
    </ul>
  </li>
  <li>主要功能
    <ul>
      <li>初始化设备</li>
      <li>解析OS发来的命令</li>
      <li>多个请求的调度</li>
      <li>管理数据传输</li>
      <li>接收和处理中断</li>
      <li>维护驱动与内核数据的完整性</li>
    </ul>
  </li>
</ul>
<p><em>6.设备驱动操作接口</em></p>
<ul>
  <li><code>init(deviceNumber)</code>：初始化硬件</li>
  <li><code>open(deviceNumber)</code>：初始化驱动并分配资源</li>
  <li><code>close(deviceNumber)</code>：清除，回收资源，关闭设备</li>
  <li>设备驱动的类型：
    <ul>
      <li>字符设备：可变长度的数据传输
        <ul>
          <li>字符设备接口：
            <ul>
              <li><code>read(deviceNumber, bufferAddr, size)</code>：从字节流设备上读”size”字节数据</li>
              <li><code>write(deviceNumber, bufferAddr, size)</code>：将”bufferAddr”中“size”字节数据写入字符流设备</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>块设备：以固定大小的块为粒度的数据传输
        <ul>
          <li>块设备接口：
            <ul>
              <li><code>read(deviceNumber, deviceAddr, bufferAddr)</code>：从设备传输一个块的数据到内存</li>
              <li><code>write(deviceNumber, deviceAddr, bufferAddr)</code>：从内存传输一个块的数据到设备</li>
              <li><code>seek(deviceNumber, deviceAddr)</code>：将磁头移动到指定块</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>7.UNIX设备驱动接口</em></p>
<ul>
  <li><code>init()</code>：初始化硬件</li>
  <li><code>start()</code>：开机时初始化，需要系统服务</li>
  <li><code>halt()</code>：在系统关机前要调用</li>
  <li><code>intr(vector)</code>：在发生硬件中断时由内核调用</li>
  <li><code>read(...)</code>, <code>write(...)</code>：数据传输</li>
  <li><code>poll(pri)</code></li>
  <li><code>ioctl(dev, cmd, arg, mode)</code>：特殊请求处理</li>
</ul>
<p><em>8.设备驱动的工作流程</em></p>
<ul>
  <li>准备工作
    <ul>
      <li>参数检查，请求格式转换</li>
      <li>设备状态检查：忙 -&gt; 请求入队列</li>
      <li>可能开设备或上电</li>
    </ul>
  </li>
  <li>操纵设备
    <ul>
      <li>将控制命令写入设备的控制寄存器</li>
      <li>检查设备状态：就绪 -&gt; 写下一命令</li>
      <li>直到设备完成所有命令</li>
    </ul>
  </li>
  <li>阻塞等待
    <ul>
      <li>等待设备完成工作</li>
      <li>被中断唤醒</li>
      <li>有的设备不需要等待，如显示器</li>
    </ul>
  </li>
  <li>错误处理：检查设备返回结果，如果错误，可能重试</li>
  <li>返回调用者</li>
</ul>
<p><em>9.设计问题</em></p>
<ul>
  <li>静态安装设备驱动：新设备的启动需要重启OS</li>
  <li>动态挂载设备驱动：
    <ul>
      <li>不需要重启，而是采用间接指针</li>
      <li>将驱动加载进内核空间</li>
      <li>安装入口点，维护相关的数据结构</li>
      <li>初始化设备驱动</li>
    </ul>
  </li>
</ul>
<p><em>动态绑定设备驱动</em></p>
<ul>
  <li>间接指针
    <ul>
      <li>设备入口点：所有设备的入口点</li>
    </ul>
  </li>
  <li>加载设备驱动：
    <ul>
      <li>分配内核空间</li>
      <li>存储驱动代码</li>
      <li>与入口点关联</li>
    </ul>
  </li>
  <li>删除设备驱动：
    <ul>
      <li>删除入口点</li>
      <li>释放内核空间</li>
    </ul>
  </li>
</ul>
<p><em>10.设备驱动的利与弊</em></p>
<ul>
  <li>灵活性：
    <ul>
      <li>用户可以下载和安装设备驱动</li>
      <li>供应商可以基于开放硬件平台</li>
    </ul>
  </li>
  <li>安全隐患：
    <ul>
      <li>设备驱动运行于内核态</li>
      <li>有bug的设备驱动会导致内核崩溃，或者引入安全漏洞</li>
    </ul>
  </li>
  <li>如何让设备驱动更安全：
    <ul>
      <li>检查设备驱动的代码</li>
      <li>为设备驱动构建状态机模型</li>
    </ul>
  </li>
</ul>
<p><em>11.同步I/O与异步I/O</em></p>
<ul>
  <li>同步I/O：
    <ul>
      <li><code>read()</code>和<code>write()</code>将阻塞用户进程，直到读写完成</li>
      <li>在一个进程做同步I/O时，OS调度另一个进程执行</li>
    </ul>
  </li>
  <li>异步I/O：
    <ul>
      <li><code>aio\_read()</code>和<code>aio\_write()</code>不阻塞用户进程</li>
      <li>在I/O完成之前，用户进程可以做其他事情</li>
      <li>I/O完成将通知用户进程</li>
    </ul>
  </li>
</ul>
<p><em>同步读</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/same-read.png" alt="same"></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/same-read-word.png" alt="same-read-word"></p>
<p><em>异步读</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/diff-read.png" alt="diff-read"></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/diff-read-word.png" alt="diff-read-word"></p>
<p><em>12.为什么内核需要缓冲</em></p>
<ul>
  <li>生产者与消费者之间速度不匹配
    <ul>
      <li>字符设备和块设备等</li>
      <li>适配不同的数据传输大小</li>
    </ul>
  </li>
  <li>DMA需要连续的物理内存
    <ul>
      <li>I/O设备看到的是物理内存</li>
      <li>用户程序使用的是虚拟内存</li>
    </ul>
  </li>
  <li>缓存
    <ul>
      <li>服务对同一数据的请求</li>
      <li>减少I/O操作</li>
    </ul>
  </li>
</ul>
<p><em>总结</em></p>
<ul>
  <li>I/O设备
    <ul>
      <li>PIO简单，但不高效</li>
      <li>中断机制支持CPU和I/O重叠</li>
      <li>DMA高效，但需要复杂的软件</li>
    </ul>
  </li>
  <li>设备驱动
    <ul>
      <li>直接操纵设备的代码</li>
      <li>OS代码量中占主导</li>
      <li>设备驱动引入安全漏洞</li>
    </ul>
  </li>
  <li>异步I/O
    <ul>
      <li>异步I/O允许用户程序的计算与I/O重叠</li>
    </ul>
  </li>
</ul>
<h3 id="磁盘和RAID"><a href="#磁盘和RAID" class="headerlink" title="磁盘和RAID"></a>磁盘和RAID</h3>
<p><em>1.磁盘</em></p>
<ul>
  <li>持久化的，大容量，低成本的存储设备：机械，速度慢</li>
  <li>多种尺寸</li>
  <li>多种容量</li>
  <li>多种接口</li>
</ul>
<p><em>典型的磁盘控制器</em></p>
<ul>
  <li>与主机的接口：SATA, SAS, FC</li>
  <li>缓存：缓冲数据</li>
  <li>控制逻辑：
    <ul>
      <li>读写请求</li>
      <li>请求调度</li>
      <li>缓存替换</li>
      <li>坏块检测和重映射</li>
    </ul>
  </li>
</ul>
<p><em>磁盘的结构</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/disk.png" alt="disk"></p>
<ul>
  <li>盘片：一组，按一定速率旋转</li>
  <li>磁道：
    <ul>
      <li>用于盘片表面的同心圆</li>
      <li>用于记录数据的磁介质</li>
      <li>bit沿着每条磁道顺序排列</li>
    </ul>
  </li>
  <li>扇区：磁道划分为固定大小的单元，一般为512字节</li>
  <li>磁头：一组，用于读写磁道上的数据</li>
  <li>磁臂：一组，用于移动磁头</li>
  <li>柱面：由所有盘片上半径相同的磁道组成</li>
  <li>Zone：
    <ul>
      <li>不同磁道的扇区数目不同：外道多，内道少</li>
      <li>所有柱面划分为Zone，同一Zone每条磁道的扇区数目相同</li>
    </ul>
  </li>
</ul>
<p><em>2.磁盘扇区</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/sector.png" alt="sector"></p>
<ul>
  <li>扇区的创建：
    <ul>
      <li>磁盘格式化</li>
      <li>逻辑块地址映射到物理块地址</li>
    </ul>
  </li>
  <li>扇区的格式：
    <ul>
      <li>头部：ID，损坏标志位…</li>
      <li>数据区：实际用于存储数据的区域</li>
      <li>尾部：ECC校验码</li>
    </ul>
  </li>
  <li>坏扇区：发现坏扇区，先用ECC纠错，如果不能纠错，用备用扇区替代，坏扇区不再使用</li>
  <li>磁盘容量：格式化损坏20%左右（每个扇区的头部、尾部加坏扇区）</li>
</ul>
<p><em>读写操作</em></p>
<p>读写某个柱面的某个扇区：</p>
<ul>
  <li>定位柱面，移动磁臂使磁头对准柱面：寻道seek</li>
  <li>等待扇区旋转到磁头下方：旋转rotation</li>
  <li>进行数据读写：数据传输</li>
</ul>
<p><em>3.磁盘性能</em></p>
<ul>
  <li>有效带宽 = 数据量 / 耗时</li>
  <li>耗时：
    <ul>
      <li>寻道时间：把磁头移动到目标柱面的时间</li>
      <li>旋转延迟：等待目标扇区旋转到磁头下方的时间</li>
      <li>数据传输时间</li>
    </ul>
  </li>
  <li>对于小粒度的访问，时间主要花费在寻道时间和旋转时间上
    <ul>
      <li>磁盘的传输带宽被浪费</li>
      <li>缓存：每次读写临近的多个扇区，而不是一个扇区</li>
      <li>调度算法：减少寻道开销</li>
    </ul>
  </li>
</ul>
<p><em>4.磁盘缓存</em></p>
<ul>
  <li>方法：
    <ul>
      <li>用少量的DRAM来缓存最近访问的块</li>
      <li>由控制器管理，OS无法控制</li>
      <li>块替换策略：LRU</li>
    </ul>
  </li>
  <li>优点：如果访问具有局部性，读性能收益</li>
  <li>缺点：需要额外的机制来保障写的可靠性</li>
</ul>
<h4 id="请求调度算法"><a href="#请求调度算法" class="headerlink" title="请求调度算法"></a>请求调度算法</h4>
<p><em>1.FIFO</em></p>
<ul>
  <li>按照请求到达的先后顺序依次服务</li>
  <li>好处：公平性，服务顺序是应用预期的</li>
  <li>坏处：
    <ul>
      <li>请求到来的随机性，经常长距离的寻道</li>
      <li>可能发生极端情况，比如横扫整个磁盘</li>
    </ul>
  </li>
</ul>
<p><em>2.SSF（shortest seek first）</em></p>
<ul>
  <li>方法：选择磁头移动距离最短的请求，记入旋转时间</li>
  <li>好处：试图减少寻道时间</li>
  <li>坏处：可能会产生饥饿</li>
</ul>
<p><em>3.电梯调度</em></p>
<ul>
  <li>方法：
    <ul>
      <li>磁头按一个方向到另一端，再折回，按反方向回到这端，不断往返</li>
      <li>只服务当前移动方向上寻道距离最短的请求</li>
      <li>LOOK：如果磁盘移动方向上没有请求，就折回</li>
    </ul>
  </li>
  <li>好处：消除饥饿，请求的服务时间有上限</li>
  <li>坏处：反方向的请求需等待更长时间</li>
</ul>
<p><em>4.C-Scan（Circular Scan）</em></p>
<ul>
  <li>方法：
    <ul>
      <li>将SCAN改为折回时不服务请求</li>
      <li>类似将两类连起来成一个环</li>
      <li>C-LOOK</li>
    </ul>
  </li>
  <li>好处：服务时间趋于一致</li>
  <li>坏处：折回时不干事</li>
</ul>
<p><em>4.RAID</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/raid.png" alt="raid"></p>
<ul>
  <li>主要思想：由多个磁盘构成一个存储设备</li>
  <li>好处：
    <ul>
      <li>提高性能：多个磁盘并行工作</li>
      <li>提高容量：聚合多个磁盘的空间</li>
      <li>提高可靠性：数据冗余，磁盘损坏，数据不损坏</li>
    </ul>
  </li>
  <li>坏处：成本高，控制器变得复杂</li>
  <li>牵涉的问题：
    <ul>
      <li>块映射：逻辑块LBN -&gt; &lt;磁盘#, 块#&gt;</li>
      <li>冗余机制</li>
    </ul>
  </li>
</ul>
<p><em>5.RAID0-0</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/raid0.png" alt="raid0"></p>
<ul>
  <li>以条带为粒度映射到N个磁盘（轮转）</li>
  <li>1 strip = n个块</li>
  <li>无冗余</li>
  <li>容量：N X 当个磁盘容量</li>
  <li>可靠性：$\text{(单个磁盘可靠性)}^N$</li>
  <li>性能：
    <ul>
      <li>带宽 = N X 单个磁盘带宽</li>
      <li>延迟 = 单个磁盘延迟</li>
    </ul>
  </li>
</ul>
<p><em>6.RAID-1</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/raid1.png" alt="raid1"></p>
<ul>
  <li>镜像</li>
  <li>镜像级别R：数据存R份</li>
  <li>通常与RAID-0结合使用：RAID-01或RAID-10</li>
  <li>容量：（N X 单个磁盘容量）/ R</li>
  <li>可靠性（R = 2）
    <ul>
      <li>容忍任何一个磁盘坏</li>
      <li>特殊情况下可容忍 N/2 个磁盘坏</li>
    </ul>
  </li>
  <li>带宽：
    <ul>
      <li>写带宽：（N X 单个磁盘写带宽）/ 2</li>
      <li>读带宽：N X 单个磁盘读带宽</li>
    </ul>
  </li>
  <li>延迟：
    <ul>
      <li>读延迟：等于单个磁盘读一块的延迟</li>
      <li>写延迟：略大于单个磁盘写一块的延迟</li>
    </ul>
  </li>
</ul>
<p><em>7.RAID-4</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/raid4.png" alt="raid4"></p>
<ul>
  <li>条带化 + 一个校验块</li>
  <li>所有校验块在同一块磁盘上（校验盘）</li>
  <li>缺点：校验块为写性能瓶颈，易坏</li>
</ul>
<p>每次写都更新校验块：</p>
<p>方法一：读所有数据盘</p>
<ol>
  <li>并行读所有磁盘对应的块</li>
  <li>计算新校验块</li>
  <li>并行写新块和新校验块</li>
</ol>
<p>方法二：读一个数据盘和磁盘块</p>
<ol>
  <li>并行读一个旧数据块和旧校验块</li>
  <li>计算新校验块：$Pnew = (Bold \oplus Bnew) \oplus Pold$</li>
  <li>并行写新块和新校验块</li>
</ol>
<ul>
  <li>容量：（N - 1）X 当个磁盘容量</li>
  <li>可靠性：只容忍任何一个磁盘坏，用XOR重构坏盘数据</li>
  <li>延迟：读延迟等于单个磁盘的延迟写延迟约等于2倍单个磁盘延迟</li>
  <li>带宽：
    <ul>
      <li>读带宽 = （N - 1）X 单个磁盘带宽</li>
      <li>校验盘为写瓶颈，所有校验块串行写</li>
      <li>写带宽 = 单个磁盘带宽 / 2</li>
    </ul>
  </li>
</ul>
<p><em>8.RAID-5</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/raid5.png" alt="raid5"></p>
<ul>
  <li>条带粒度映射 + 一个校验块</li>
  <li>校验块分散在不同的磁盘上</li>
  <li>Rebuild：复杂，速度慢</li>
  <li>写带宽 = （N X 单个磁盘带宽）/ 4，校验块并行写</li>
</ul>
<p><em>9.卷管理</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/vomn.png" alt="vomn"></p>
<ul>
  <li>虚拟块设备：
    <ul>
      <li>将多个磁盘聚集起来，在其上创建一个或多个逻辑卷</li>
      <li>逻辑卷：一个虚拟块设备</li>
      <li>采用RAID技术将逻辑卷的块地址映射到物理设备</li>
      <li>提供虚拟的容量和性能：增大或缩小逻辑卷不影响已存储的数据</li>
    </ul>
  </li>
  <li>提供可靠的块存储：
    <ul>
      <li>采用RAID技术容忍物理设备故障</li>
      <li>提供块级别的错误发现</li>
    </ul>
  </li>
  <li>实现：
    <ul>
      <li>OS内核的逻辑卷管理：Windows, MacOS, Linux等</li>
      <li>存储设备控制器（存储系统）</li>
    </ul>
  </li>
</ul>
<p><em>10.存储系统的演进</em></p>
<ul>
  <li>企业数据中心：
    <ul>
      <li>数据集中存储</li>
      <li>大容量、高可靠、高可用的存储系统</li>
    </ul>
  </li>
  <li>SAN存储系统：
    <ul>
      <li>SAN：存储专用网络</li>
      <li>FC或iSCSI接口</li>
      <li>多主机共享</li>
    </ul>
  </li>
  <li>容灾：远程恢复，由备份生成远程镜像，或者将远程镜像合并到备份中</li>
  <li>存储架构演进：NAS -&gt; NAS + Dedup -&gt; 全球范围的分布式存储</li>
</ul>
<p><em>11.总结</em></p>
<ul>
  <li>磁盘：
    <ul>
      <li>内部很复杂</li>
      <li>密度按摩尔定律增长</li>
      <li>大块读写才能获得高带宽</li>
      <li>需要磁盘调度来减少寻道开销</li>
    </ul>
  </li>
  <li>RAID提高了可靠性和I/O带宽</li>
  <li>卷管理提供虚拟块设备</li>
  <li>存储系统是一个复杂的专用系统：
    <ul>
      <li>硬件&amp;软件（存储设备控制器）</li>
      <li>企业存储系统已发展成复杂的分布式系统</li>
    </ul>
  </li>
</ul>
<h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3>
<p><em>1.闪存（Flash memory）</em></p>
<ul>
  <li>全电子器件，无机械部件</li>
  <li>非易失性存储</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/flash-vs.png" alt="flash-vs"></p>
<p><em>2.基于闪存的Solid State Drive（SSD）</em></p>
<ul>
  <li>用很多闪存芯片来构成一个持久化存储设备SSD</li>
  <li>多个闪存芯片：并行I/O，提高I/O性能</li>
  <li>与主机的接口：提供标准块设备接口</li>
  <li>数据缓存与缓冲：SRAM</li>
  <li>闪存控制器固件FTL：控制逻辑
    <ul>
      <li>主机命令转换成闪存命令</li>
      <li>逻辑块地址转换成闪存的物理地址</li>
      <li>缓存替换</li>
      <li>页聚合写</li>
    </ul>
  </li>
</ul>
<p><em>3.闪存组织</em></p>
<ul>
  <li>页：
    <ul>
      <li>由数据区和Out of Band(OOB)区组成</li>
      <li>数据区用于存储实际数据</li>
      <li>OOB区用于记录：ECC，状态信息，逻辑页号</li>
      <li>页大小：4KB ~ 16KB</li>
      <li>数百页每块</li>
      <li>块大小：~MB</li>
    </ul>
  </li>
</ul>
<p><em>4.闪存的操作接口</em></p>
<p>读：read a page</p>
<ul>
  <li>读的粒度是页</li>
  <li>读很快</li>
  <li>读延迟与位置无关，也与上一次读的位置无关</li>
</ul>
<p>擦除：erase a block</p>
<ul>
  <li>把整个块写成全1</li>
  <li>擦除的粒度是块，必须整块擦除</li>
  <li>很慢</li>
  <li>需软件把块内有效数据拷贝到其他地方</li>
</ul>
<p>写：program a page</p>
<ul>
  <li>擦除后才能写，因为写只能把1写成0</li>
  <li>写的粒度是页</li>
  <li>写比读慢，比擦除快</li>
</ul>
<p><em>页的状态</em></p>
<p>Invalid, Erased, Valid</p>
<ul>
  <li>初始状态为Invalid</li>
  <li>读：不改变页的状态</li>
  <li>擦除：块内所有页的状态变为Erased</li>
  <li>写：只能写状态为Erased的页，写完后，页状态变为Valid</li>
</ul>
<p><em>5.闪存的性能和可靠性</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/flash-ch.png" alt="flash-ch"></p>
<ul>
  <li>性能：
    <ul>
      <li>写延迟比读高十倍多</li>
      <li>写延迟波动幅度大</li>
      <li>擦除很慢：磁盘定位延迟</li>
      <li>延迟随密度增加而增大</li>
    </ul>
  </li>
  <li>可靠性：
    <ul>
      <li>磨损：擦写次数有限，随密度增加而减少</li>
      <li>干扰：读写一个页，相邻页中一些位的值发生翻转</li>
    </ul>
  </li>
</ul>
<p><em>6.SSD面临问题</em></p>
<ul>
  <li>一个基本问题：逻辑块与物理块的映射</li>
  <li>挑战：擦除后写，读快写慢，毫秒级擦除操作</li>
  <li>SSD内部硬件（数据通路）：数据传输，数据读/写/擦除（Flash控制器）</li>
  <li>SSD内部固件（软件）：
    <ul>
      <li>Flash Translation Layer（FTL）</li>
      <li>地址映射</li>
      <li>垃圾回收</li>
      <li>环块管理</li>
    </ul>
  </li>
</ul>
<p><em>7.最简单的FTL：直接映射</em></p>
<p>逻辑块的第N块直接映射到物理页的第N页</p>
<ul>
  <li>读操作很容易：读逻辑第K块 = 读物理第K页</li>
  <li>写操作很麻烦：写逻辑第K块
    <ul>
      <li>第K页所在闪存块，记为B0</li>
      <li>把B0整个块读出来</li>
      <li>把B0整个块擦除</li>
      <li>B0中的旧页和新的第K页：以顺序方式一页一页再写入B0</li>
    </ul>
  </li>
  <li>缺陷：写性能极差，小粒度随机写性能比磁盘还差</li>
</ul>
<p><em>8.Log-Structure FTL：页级映射</em></p>
<ul>
  <li>核心思想：异地更新
    <ul>
      <li>像LFS那样顺序写闪存</li>
      <li>每次写页，写到一个新位置，即写到日志末尾</li>
      <li>映射表：LBN -&gt; 物理页地址PPA</li>
    </ul>
  </li>
  <li>写一个逻辑页K：
    <ul>
      <li>写到当前块中下一个空闲页</li>
      <li>在映射表中记录：逻辑页K -&gt; 物理页P</li>
    </ul>
  </li>
  <li>读一个逻辑页K：
    <ul>
      <li>查映射表，获得逻辑页K对应的物理页地址P</li>
      <li>读物理页P</li>
    </ul>
  </li>
  <li>页级映射表：LBN -&gt; PPA
    <ul>
      <li>整个放在内存中</li>
      <li>持久化：利用页的OOB区来保存映射表</li>
      <li>随着写页而被写到闪存</li>
      <li>掉电或重启，扫描OOB区恢复映射表</li>
    </ul>
  </li>
  <li>优点：
    <ul>
      <li>性能更好，减少写放大</li>
      <li>可靠性更好，自动写所有页</li>
    </ul>
  </li>
  <li>问题：
    <ul>
      <li>重写逻辑页产生垃圾页：每次写到新位置，导致原先页的内容无效</li>
      <li>内存开销大：映射表全部放在内存，映射表的大小和SSD容量成正比</li>
    </ul>
  </li>
</ul>
<p><em>9.垃圾回收</em></p>
<ul>
  <li>思想：
    <ul>
      <li>选择一个含垃圾页的擦除块</li>
      <li>把其中的活页拷贝到日志末尾（读&amp;重写）</li>
      <li>回收整个块，并把它擦除</li>
    </ul>
  </li>
  <li>判断页的死活：
    <ul>
      <li>每页记录它对应的逻辑块地址（OOB）</li>
      <li>查映射表，如果映射表中该逻辑块对应的物理页是该页，则该页是活页</li>
    </ul>
  </li>
  <li>问题：开销非常大
    <ul>
      <li>活页需拷贝：读&amp;写</li>
      <li>开销与活页所占的比例成正比</li>
    </ul>
  </li>
</ul>
<p><em>10.块级映射</em></p>
<ul>
  <li>块级映射：
    <ul>
      <li>逻辑地址空间划分成chunk，chunk size = 物理块size</li>
      <li>映射表：chunk# -&gt; 物理块地址PBA</li>
    </ul>
  </li>
  <li>读一个逻辑页：
    <ul>
      <li>逻辑页地址 = chunk# + 偏移</li>
      <li>用chunk#查映射表，获得对应的物理块地址PBA</li>
      <li>物理页地址 = PBA + 偏移</li>
    </ul>
  </li>
  <li>问题：小粒度写性能差
    <ul>
      <li>写粒度小于物理块：拷贝活页，写放大</li>
      <li>小粒度写很常见</li>
    </ul>
  </li>
</ul>
<p><em>11.混合映射</em></p>
<ul>
  <li>思想：
    <ul>
      <li>将物理块划分为两类：数据块和日志块</li>
      <li>逻辑块都写入日志块</li>
      <li>数据块采用块级映射，数据映射表</li>
      <li>日志块采用页级映射，日志映射表</li>
      <li>适当的时候把日志块合并为数据块</li>
    </ul>
  </li>
  <li>读一个逻辑块：
    <ul>
      <li>先查日志映射表，按页级映射的方法</li>
      <li>如果没找到，再查数据映射表，按块级映射的方法</li>
    </ul>
  </li>
</ul>
<p><em>switch merge</em></p>
<ul>
  <li>把日志块直接转成数据块：前提是整个日志块的顺序与chunk一致</li>
  <li>把原来的数据块回收擦除</li>
  <li>优点：开销小，只修改映射表，无数据拷贝</li>
</ul>
<p><em>Partial merge</em></p>
<ul>
  <li>从数据块拷贝部分页到日志块：日志块前部页序与chunk一致</li>
  <li>把日志块转成数据块，把原来的数据块回收擦除</li>
  <li>有数据拷贝开销</li>
</ul>
<p><em>Full merge</em></p>
<ul>
  <li>分配一个新的日志块，从数据块和日志块分别拷贝部分页到新日志块</li>
  <li>把新日志块转成数据块</li>
  <li>把原来的数据块和日志块都回收擦除</li>
  <li>开销很大，需要拷贝整个物理块的数据</li>
</ul>
<p><em>12.磨损均衡</em></p>
<ul>
  <li>目标：让所有块被擦除的次数近似</li>
  <li>动态磨损均衡：
    <ul>
      <li>每次写时，选择擦除次数较少或最少的块</li>
      <li>局限性：不同数据的修改频率不同</li>
    </ul>
  </li>
  <li>静态磨损均衡：
    <ul>
      <li>不会被回收的物理块：长时间不再修改的逻辑块，冷块</li>
      <li>不再重写，不再有磨损</li>
      <li>解决办法：FTL定期重写冷块</li>
    </ul>
  </li>
</ul>
<p><em>总结</em></p>
<ul>
  <li>闪存的特性：
    <ul>
      <li>读延迟很低：随机读的性能远优于硬盘</li>
      <li>写慢：必须先擦除再写</li>
      <li>磨损：每个块擦写次数有上限</li>
    </ul>
  </li>
  <li>FTL的主要功能：</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch5/ftl.png" alt="ftl"></p>
<h2 id="Chapter06-文件系统"><a href="#Chapter06-文件系统" class="headerlink" title="Chapter06 文件系统"></a>Chapter06 文件系统</h2>
<h3 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h3>
<p><em>1.为什么需要文件系统</em></p>
<ul>
  <li>持久化保存数据需求
    <ul>
      <li>进程结束，关机/关电，宕机，掉电</li>
      <li>持久化存储设备：磁盘，SSD等</li>
    </ul>
  </li>
  <li>FS是对持久化数据存储的抽象
    <ul>
      <li>给用户和程序开发者提供一个逻辑上的持久化存储：简单，易理解，操作方便</li>
      <li>将复杂的、公共的管理功能从用户程序中移出</li>
      <li>简化编程 -&gt; 加速计算机应用的发展</li>
    </ul>
  </li>
  <li>对FS的基本需求
    <ul>
      <li>能够保存大量复杂多样的信息 -&gt; 管理问题</li>
      <li>多个进程同时访问 -&gt; 并发控制，语义问题</li>
      <li>多用户共享&amp;私有 -&gt; 保护问题</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/s-vs-m.png" alt="s-vs-m"></p>
<p><em>2.文件系统的用户视图</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/user-view.png" alt="user-view"></p>
<ul>
  <li>文件：数据组织的单位
    <ul>
      <li>文件是命名的字节数组</li>
      <li>用户将数据组织成文件，根据文件名来访问对应的数据</li>
      <li>FS不感知文件的内容：使用它的进程解析内容</li>
    </ul>
  </li>
  <li>目录：文件组织的单位
    <ul>
      <li>一组文件和目录的命令集合</li>
      <li>父目录、子目录</li>
      <li>无重名</li>
    </ul>
  </li>
  <li>名字空间：树形层次结构
    <ul>
      <li>文件系统的逻辑视图</li>
    </ul>
  </li>
</ul>
<p><em>3.文件</em></p>
<ul>
  <li>文件名：由字母、数字及某些特殊字符组成的字符串
    <ul>
      <li>用户根据文件名来访问文件</li>
      <li>大多数OS中文件名不超过255个字符</li>
      <li>文件扩展名：描述文件的用户，如 .c, .h, .gz, .tex, .pdf </li>
    </ul>
  </li>
  <li>文件属性：
    <ul>
      <li>文件大小、所有者、时间戳、访问权限</li>
      <li>文件逻辑地址：指示数据在文件中的地址</li>
    </ul>
  </li>
  <li>文件内容：无结构
    <ul>
      <li>OS将文件视为无结构的字符数组</li>
      <li>程序开发者可以定义任意结构的文件</li>
    </ul>
  </li>
  <li>文件的类型：常规文件、目录文件、设备文件、可执行文件</li>
  <li>文件的访问：
    <ul>
      <li>打开文件 &amp; 文件描述符</li>
      <li>当前位置：文件逻辑地址，[0, fsize -1] （每个文件）</li>
      <li>访问方式：读、写、执行</li>
    </ul>
  </li>
  <li>i-node：FS用来描述文件的数据结构
    <ul>
      <li>每个文件用一个i-node来描述</li>
      <li>文件元数据</li>
      <li>ino：inode number，唯一标识一个文件（在一个FS内）</li>
    </ul>
  </li>
</ul>
<p><em>4.文件访问接口（系统调用）</em></p>
<ul>
  <li>创建文件：<code>fd = creat(fname, mode)</code>，fd为文件描述符</li>
  <li>删除文件：<code>unlink(fname)</code></li>
  <li>打开文件：<code>fd = open(fname, flags, mode)</code></li>
  <li>关闭文件：<code>clode(fd)</code></li>
  <li>读文件：<code>rn = read(fd, buf, count)</code>，从当前位置读count个字节到buf中</li>
  <li>写文件：<code>wn = write(fd, buf, count)</code>，从当前位置写count个字节
    <ul>
      <li>追加写：用O_APPEND模式打开文件</li>
    </ul>
  </li>
  <li>定位文件：<code>lseek(fd, offset, whence)</code></li>
  <li>写回文件：<code>fsync(fd)</code></li>
  <li>截断文件：<code>truncate(fname, length)</code></li>
  <li>获取属性：<code>stat(fname, attbuf)</code>或<code>fstat(fd, attbuf)</code></li>
</ul>
<p><em>5.文件访问模式</em></p>
<ul>
  <li>顺序访问：
    <ul>
      <li>从头到尾依次访问每个文件块</li>
      <li>例子：观看一部电影，阅读一篇文章</li>
      <li>顺序访问文件不等于磁盘上顺序访问扇区</li>
    </ul>
  </li>
  <li>随机访问：
    <ul>
      <li>每次随机访问一个文件块</li>
      <li>例子：读邮箱中的邮件</li>
    </ul>
  </li>
  <li>按关键字访问：
    <ul>
      <li>查找包含关键字的文件及段落</li>
      <li>FS没有提供此功能</li>
      <li>例子：数据库查找和索引</li>
    </ul>
  </li>
</ul>
<p><em>6.目录</em></p>
<ul>
  <li>路径：
    <ul>
      <li>根目录 &amp; 当前目录</li>
      <li>.：当前目录</li>
      <li>..：父目录</li>
      <li>绝对路径 VS 相对路径</li>
    </ul>
  </li>
  <li>目录：一种特殊的文件
    <ul>
      <li>具有名字和属性</li>
      <li>目录和文件用相同的数据结构：inode，用一个标志i_mode来区分文件和目录</li>
      <li>目录内容：描述它所包含的目录和文件集合
        <ul>
          <li>有结构：逻辑上是一张表</li>
          <li>目录项：每个成员一项</li>
          <li>不同FS采用不同的结构</li>
          <li>由FS负责维护和解析目录内容</li>
          <li>访问文件 VS 访问目录：不同的系统调用</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>7.目录访问接口：系统调用</em></p>
<ul>
  <li>创建目录：<code>mkdir(dirname, mode)</code></li>
  <li>删除目录：<code>rmdir(dirname)</code></li>
  <li>打开目录：<code>fd = open(dirname, flags)</code></li>
  <li>关闭目录：<code>close(fd)</code></li>
  <li>读目录：<code>readdir(fd, direntbuf, count)</code>，从当前位置读count个目录项</li>
  <li>硬链接：<code>link(oldpath, newpath)</code></li>
  <li>符号链接：<code>symlink(srcpath, linkpath)</code></li>
  <li>重命名文件：<code>rename(oldpath, newpath)</code></li>
</ul>
<p><em>8.硬链接</em></p>
<ul>
  <li>多个用户共享一个文件
    <ul>
      <li>每个用户有自己的主目录</li>
      <li>各自主目录下维护一个文件 -&gt; 多个相同的文件</li>
      <li>缺点：浪费空间，文件修改繁琐，一致性问题</li>
    </ul>
  </li>
  <li>为文件共享提供一种手段
    <ul>
      <li>link系统调用或ln命令</li>
      <li>为文件创建一个新名字，无数据拷贝</li>
      <li>多个名字指向同一个文件</li>
      <li>一个文件可以有多个名字，甚至可以位于多个目录中</li>
    </ul>
  </li>
  <li>实现：<code>link(oldpath, newpath)</code>
    <ul>
      <li>新旧两个名字指向同一个i-node</li>
      <li>i-node引用计数：记录指向该文件有多少个名字</li>
    </ul>
  </li>
  <li>例子：<code>ln C1/C2/C3/foo /B1/B2/goo</code></li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/link.png" alt="link"></p>
<p><em>9.符号链接</em></p>
<ul>
  <li>硬链接的限制：
    <ul>
      <li>不允许对目录做link</li>
      <li>不能跨FS做link</li>
    </ul>
  </li>
  <li>另一种文件共享的手段：
    <ul>
      <li>symlink系统调用或<code>ln -s</code>命令</li>
      <li><code>ln -s source link_name</code></li>
    </ul>
  </li>
</ul>
<p><em>10.rename</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/rename.png" alt="rename"></p>
<ul>
  <li>只改变文件名字，无数据拷贝</li>
  <li>保证原子性</li>
</ul>
<p><em>11.文件系统物理结构（磁盘布局）</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/layout.png" alt="layout"></p>
<ul>
  <li>引导块：启动OS的代码</li>
  <li>超级块：定义一个FS及其相关的信息</li>
  <li>空闲空间管理相关的信息</li>
  <li>i-node表：每个i-node描述一个文件或目录</li>
  <li>数据块：文件块或目录块</li>
</ul>
<p><em>12.FS相关的接口（系统命令）</em></p>
<ul>
  <li>创建文件系统：<code>mkfs</code></li>
  <li>删除文件系统：<code>rmfs</code></li>
  <li>挂载文件系统：<code>mount -t fstype dev dir</code></li>
  <li>卸载文件系统：<code>umount dev|dir</code></li>
  <li>显示已安装FS：<code>mount</code>或<code>mount dev|dir</code></li>
  <li>同步文件系统：<code>sync</code></li>
  <li>获取文件系统属性：<code>df</code></li>
  <li>…</li>
  <li>创建、删除、安装，卸载只允许特权用户调用</li>
</ul>
<p><em>13.虚拟文件系统（VFS）</em></p>
<ul>
  <li>新需求：多种类型文件系统，同时挂载不同类型的FS</li>
  <li>面向对象的编程思想：
    <ul>
      <li>VFS：实现FS接口和通用功能，规定PFS API</li>
      <li>PFS：磁盘布局、数据结构、磁盘空间管理、名字空间管理…</li>
    </ul>
  </li>
  <li>虚拟文件系统开关表：用于文件系统的挂载与卸载
    <ul>
      <li>每一种类型的文件系统有一个表项
        <ul>
          <li>文件系统类型的名字</li>
          <li>初始化函数指针，用于<code>mount</code></li>
          <li>清除函数指针，用于<code>umount</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>14.超级块</em></p>
<ul>
  <li>定义一个文件系统：
    <ul>
      <li>数据块的大小</li>
      <li>i-node的大小</li>
      <li>数据块总数</li>
      <li>i-node总数</li>
      <li>根目录ino</li>
      <li>i-node表的起始地址</li>
      <li>空闲数据块指针</li>
      <li>空闲i-node指针</li>
    </ul>
  </li>
  <li>当前状态：
    <ul>
      <li>数据块使用情况：已使用的块数，预留的块数，剩余的块数…</li>
      <li>i-node使用情况：已使用的个数，剩余的个数…</li>
    </ul>
  </li>
  <li><code>mkfs</code>：创建磁盘布局，初始化超级块，bitmap，根i-node等</li>
</ul>
<p><em>15.mount</em></p>
<ul>
  <li>前提：
    <ul>
      <li>文件系统类型必须事先已注册到内核</li>
      <li>挂载目录必须已经创建好</li>
    </ul>
  </li>
  <li>步骤：
    <ol>
      <li>根据文件系统类型，假设为ext4，查VFS开关表，找到ext4文件系统类型的初始化函数，即<code>ext4_mount()</code></li>
      <li>调用<code>ext4_mount</code>：读取超级块，读取根目录i-node</li>
      <li>初始化一些内存数据结构：超级块，根i-node等</li>
    </ol>
  </li>
</ul>
<p><em>16.i-node</em></p>
<ul>
  <li>ino：i-node number，即i-node的ID</li>
  <li>文件属性信息：
    <ul>
      <li>mode：文件类型和访问权限</li>
      <li>size：文件大小</li>
      <li>nlinks：硬链接数</li>
      <li>uid：所有者的user ID</li>
      <li>gid：所有者的group ID</li>
      <li>ctime：文件创建的时间戳</li>
      <li>atime：上一次访问文件的时间戳</li>
      <li>mtime：上一次修改文件的时间戳</li>
    </ul>
  </li>
  <li>文件块的索引信息：文件块的磁盘位置信息，不同FS采用不同的索引机制</li>
</ul>
<p><em>17.目录</em></p>
<ul>
  <li>目录内容为它所包含的所有子目录和文件的名字及其ino，不包含子目录的内容</li>
  <li>逻辑上，目录是一张映射表，目录项：文件名 -&gt; ino</li>
  <li>路径解析：
    <ul>
      <li>根据路径名，获得其ino</li>
      <li>逐级目录查找</li>
    </ul>
  </li>
</ul>
<p><em>18.打开文件</em></p>
<ul>
  <li><code>fd = open(pname, flags, mode)</code></li>
  <li>打开文件信息表</li>
  <li>Open：通过打开文件描述符把进程与文件的i-node进行关联：
    <ol>
      <li>参数检查</li>
      <li>路径名解析和权限检查，得到pname的ino，读出它的i-node</li>
      <li>将i-node拷贝至一个内存i-node结构中</li>
      <li>创建一个打开文件描述符</li>
      <li>在PCB中分配一个空闲的打开文件指针来指向该打开文件描述符</li>
      <li>返回这个指针的下标，即文件描述符fd</li>
    </ol>
  </li>
</ul>
<p><em>总结</em></p>
<ul>
  <li>FS名字空间是由目录和文件构成的树形层次化结构
    <ul>
      <li>文件是无结构的命名字节数组</li>
      <li>目录是文件和子目录的命名集合</li>
      <li>文件和目录有各自的访问接口</li>
    </ul>
  </li>
  <li>FS磁盘布局和主要数据结构：
    <ul>
      <li>超级块：定义一个文件系统</li>
      <li>i-node：定义一个文件/目录，根据ino定位i-node的磁盘位置</li>
      <li>目录：一种特殊的文件，文件名 -&gt; ino的映射表</li>
    </ul>
  </li>
</ul>
<h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3>
<h4 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h4>
<p><em>1.连续分配</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/linear.png" alt="linear"></p>
<ul>
  <li>分配连续的磁盘块给文件
    <ul>
      <li>文件粒度分配</li>
      <li>位图：找到N个连续的“0”</li>
      <li>链表：找到size&gt;=N的区域</li>
    </ul>
  </li>
  <li>文件元数据：记录第一块的地址，以及块的个数N</li>
  <li>优点：
    <ul>
      <li>顺序访问性能高</li>
      <li>随机访问时定位数据块也容易</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>不知道文件最终多大，无论创建时，还是写数据块时</li>
      <li>文件难以变大</li>
      <li>外部碎片化</li>
    </ul>
  </li>
</ul>
<p><em>2.文件块索引：链表结构</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/link-list.png" alt="link-list"></p>
<ul>
  <li>分配不连续的磁盘块给文件：块粒度分配</li>
  <li>文件元数据：
    <ul>
      <li>记录第一块的地址</li>
      <li>每一块指向下一块的地址</li>
      <li>最后一块指向NULL</li>
    </ul>
  </li>
  <li>优点：
    <ul>
      <li>无外部碎片，而且文件变大很容易</li>
      <li>空闲空间链表：与文件块类似</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>随机访问性能极差：定位数据块需要按指针顺序遍历链表</li>
      <li>可靠性差：一个块坏掉意味着其余的数据全部”丢失“</li>
      <li>块内有效数据的大小不再是2的幂次，导致额外的磁盘数据拷贝</li>
    </ul>
  </li>
</ul>
<p><em>3.文件块索引：文件分配表（FAT）</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/fat.png" alt="fat"></p>
<ul>
  <li>一张有N个项的表，假设磁盘有N块
    <ul>
      <li>每个磁盘块有一个表项：要么为空，要么为该文件下一块的地址</li>
      <li>位于磁盘分区的头部</li>
    </ul>
  </li>
  <li>文件元数据：
    <ul>
      <li>记录第一块的地址：链表头指针</li>
      <li>每个磁盘块全部存数据，无指针</li>
    </ul>
  </li>
  <li>优点：
    <ul>
      <li>简单</li>
      <li>文件块大小为2的幂</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>随机访问性能不好：定位数据需要遍历链表</li>
      <li>浪费空间：额外的空间存储FAT表</li>
    </ul>
  </li>
</ul>
<p><em>4.文件块索引：单级索引</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/single.png" alt="single"></p>
<ul>
  <li>文件元数据
    <ul>
      <li>用户定义文件长度上限max size</li>
      <li>file header：一个指针数组，指向每个块的磁盘地址</li>
    </ul>
  </li>
  <li>优点：
    <ul>
      <li>文件在限制内可变大</li>
      <li>随机访问性能高，数据块直接定位</li>
    </ul>
  </li>
  <li>缺点：不灵活，文件长度难以事先知道</li>
</ul>
<p><em>5.文件块索引：两级索引</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/indirect.png" alt="indirect"></p>
<ul>
  <li>思路：
    <ul>
      <li>采用连续分配，允许不连续</li>
      <li>不定长分配</li>
    </ul>
  </li>
  <li>文件元数据：
    <ul>
      <li>小文件有10个指针，指向10个可变长度段（base, size）</li>
      <li>大文件有10个间接指针，每个指向可变长度的间址块</li>
    </ul>
  </li>
  <li>优点：支持文件变大（最大为10GB）</li>
  <li>缺点：不灵活，外部碎片</li>
</ul>
<p><em>6.文件块索引：多级索引（UNIX）</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/multi.png" alt="multi"></p>
<ul>
  <li>块粒度分配</li>
  <li>文件元数据：13个指针
    <ul>
      <li>10个直接指针</li>
      <li>11：一级间接指针</li>
      <li>12：二级间接指针</li>
      <li>13：三级间接指针</li>
    </ul>
  </li>
  <li>优点：小文件访问方便，支持文件变大</li>
  <li>缺点：文件大小有上限（16G多），大量寻道</li>
</ul>
<p><em>7.文件块索引：Extents</em></p>
<ul>
  <li>Extent是若干个连续磁盘块（长度不固定）
    <ul>
      <li>同一extent中的所有块：要么都是空闲块，要么都属于某个文件</li>
      <li>extent：
        <starting block,="" length="">
      </starting></li>
    </ul>
  </li>
  <li>XFS提出的方法：
    <ul>
      <li>无论文件块还是空闲块都采用extents来组织</li>
      <li>文件块索引采用extent B树</li>
      <li>每个extent：
        <ul>
          <li>文件块号、长度（块数）、磁盘起始块号</li>
          <li>文件元数据：记录B树的根节点地址</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>8.名字空间管理</em></p>
<ul>
  <li>FS接口：
    <ul>
      <li>目录树：多级目录，文件</li>
      <li>用户/进程按路径名访问文件或目录</li>
    </ul>
  </li>
  <li>名字空间相关的操作：
    <ul>
      <li>目录访问：创建/删除目录，创建/删除文件，链接，重命名，读目录</li>
      <li>路径名解析</li>
    </ul>
  </li>
  <li>FS内部：
    <ul>
      <li>根据ino定位i-node的磁盘位置</li>
      <li>根据i-node定位文件块的磁盘位置（文件块索引）</li>
      <li>文件名与i-node分离存储</li>
      <li>文件名保存在目录内容中：目录项为
        <fname, ino="">
      </fname,></li>
    </ul>
  </li>
</ul>
<p><em>9.创建文件或目录</em></p>
<ul>
  <li>例：创建文件”/home/example/os/fs_lecture.pdf”</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/create-file.png" alt="create-file"></p>
<p><em>10.删除文件或目录</em></p>
<ul>
  <li>例：删除文件“/home/test/os/fs_lecture.pdf”</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/delete-file.png" alt="delete-file"></p>
<h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4>
<p><em>1.线性表</em></p>
<ul>
  <li>原理：
    <ul>
      <li>&lt;文件名，ino&gt;线性存储
        <ul>
          <li>每一项不定长：
            <ino，名字长度，下一项起始偏移，名字>
          </ino，名字长度，下一项起始偏移，名字></li>
        </ul>
      </li>
      <li>创建文件：
        <ul>
          <li>先查看是否有重名文件</li>
          <li>如果没有，在表末添加一个entry：
            <newfile, ino="">
          </newfile,></li>
        </ul>
      </li>
      <li>删除文件：
        <ul>
          <li>用文件名查找</li>
          <li>删除匹配的entry</li>
          <li>紧缩：将之后的entry都向前移动</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>优点：空间利用率高</li>
  <li>缺点：
    <ul>
      <li>大目录性能差：线性查找磁盘I/O多</li>
      <li>删除时紧缩很费时</li>
    </ul>
  </li>
</ul>
<p><em>2.B树</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/b-tree.png" alt="b-tree"></p>
<ul>
  <li>原理：
    <ul>
      <li>用B树来存储&lt;文件名，ino&gt;，以文件名排序（字典序）</li>
      <li>创建/删除/查找：在B树中进行</li>
    </ul>
  </li>
  <li>优点：大目录性能高，B树查找减少磁盘I/O</li>
  <li>缺点：
    <ul>
      <li>小目录不高效</li>
      <li>占用更多空间</li>
      <li>实现复杂</li>
    </ul>
  </li>
</ul>
<p><em>3.哈希</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/hash.png" alt="hash"></p>
<ul>
  <li>原理：
    <ul>
      <li>用哈希表将文件名映射到ino：
        <ul>
          <li>hash_func(filename) -&gt; hval -&gt; bucket</li>
          <li>在bucket中线性查找文件名</li>
        </ul>
      </li>
      <li>文件名是变长的</li>
      <li>创建/删除需要分配/回收空间</li>
    </ul>
  </li>
  <li>优点：简单，查找速度快</li>
  <li>缺点：对于很大的目录，效率不如B树；哈希表浪费空间</li>
</ul>
<p><em>4.虚拟页表 VS 文件块索引</em></p>
<ul>
  <li>页表：
    <ul>
      <li>维护进程地址空间与物理内存地址空间的映射关系</li>
      <li>虚页号 -&gt; 物理页号</li>
      <li>检查访问权限，地址合法性</li>
      <li>如果映射关系在TLB中，一个cycle就完成转换</li>
    </ul>
  </li>
  <li>文件块索引：
    <ul>
      <li>维护文件块与磁盘逻辑块之间的映射关系</li>
      <li>文件和文件内偏移 -&gt; 磁盘逻辑块号</li>
      <li>检查访问权限，地址合法性</li>
      <li>由软件（OS）实现，可能引入多次I/O</li>
    </ul>
  </li>
</ul>
<p><em>4.文件系统 VS 虚存</em></p>
<ul>
  <li>相似点：
    <ul>
      <li>位置透明性：用户不感知物理地址</li>
      <li>固定粒度分配：块/页</li>
      <li>保护：读/写/执行权限</li>
    </ul>
  </li>
  <li>FS比VM容易的地方：
    <ul>
      <li>FS的映射可以慢</li>
      <li>文件比较稠密，经常是顺序访问</li>
      <li>页表处理的进程地址空间非常稀疏，通常是随机访问</li>
    </ul>
  </li>
  <li>FS比VM难的地方：
    <ul>
      <li>每层路径解析都可能引入I/O</li>
      <li>文件缓存的空间（内存）总是不够的</li>
      <li>文件长度差距大：很多不足10KB，有的又大于GB</li>
      <li>FS的实现必须是可靠的</li>
    </ul>
  </li>
</ul>
<p><em>5.最初的UNIX FS</em></p>
<ul>
  <li>简单的磁盘布局：
    <ul>
      <li>文件块大小 = 扇区大小（512B)</li>
      <li>i-node区在前，数据区在后</li>
      <li>空闲块/i-node链表：Super Block中记录头指针</li>
    </ul>
  </li>
  <li>文件块索引采用三级间址，目录采用线性表</li>
  <li>存在的问题：带宽很低，文件个数有上限</li>
</ul>
<p><em>导致带宽低的原因</em></p>
<ul>
  <li>数据块的存储位置：数据块存储在内存的柱面，i-node存储在外层的柱面</li>
  <li>经常要长距离寻道：
    <ul>
      <li>i-node与其数据块离得很远</li>
      <li>同一目录里的文件，其i-node也离得很远</li>
      <li>一个文件的数据块散布在磁盘上的任意位置</li>
    </ul>
  </li>
  <li>未考虑给文件分配连续磁盘块：
    <ul>
      <li>空闲块采用链表组织</li>
      <li>链表上相邻的块其物理地址不连续</li>
      <li>磁盘空间碎片：一个文件的数据块散布在磁盘上的任意位置</li>
      <li>磁盘碎片整理工具：拷贝数据块&amp;修改i-node</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/non-lianxu.png" alt="non-lianxu"></p>
<ul>
  <li>小粒度访问多：采用512B的块
    <ul>
      <li>有利于减少块内碎片：小文件不足一个块，最后一个数据块通常不满</li>
      <li>无法发挥磁盘带宽：块越大，带宽越高</li>
      <li>文件块索引大，索引开销高</li>
    </ul>
  </li>
</ul>
<p><em>6.BSD FFS（Fast File System）</em></p>
<ul>
  <li>大文件块：4KB或8KB
    <ul>
      <li>数据块大小记录在超级块中</li>
      <li>空间利用率问题：小文件，大文件的最后一块可能非常小
        <ul>
          <li>FFS的解决办法：数据块划分为若干更小的子块（分片），子块为512B</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>位图（BM）：取代空闲块链表
    <ul>
      <li>尽量连续分配</li>
      <li>预留10%的磁盘空间</li>
    </ul>
  </li>
</ul>
<p><em>FFS的磁盘布局</em></p>
<ul>
  <li>柱面组（CG, Cylinder Group）
    <ul>
      <li>每N个连续的柱面为一个CG</li>
      <li>把磁盘划分为若干个柱面组，将文件和目录分散存储于每个柱面组</li>
      <li>每个CG类似一个sub FS</li>
    </ul>
  </li>
</ul>
<p><em>FFS的放置策略</em></p>
<ul>
  <li>减少长距离寻道：把相关的东西放在同一CG</li>
  <li>目录放置：
    <ul>
      <li>选择CG：目录个数少，空闲i-node个数多，空闲块多</li>
      <li>所有的目录尽可能均衡分布在所有CG上</li>
    </ul>
  </li>
  <li>文件放置：
    <ul>
      <li>文件块选择其i-node所在的CG</li>
      <li>同一目录下的文件选择目录所在的CG</li>
    </ul>
  </li>
</ul>
<p><em>FFS的其他优化</em></p>
<ul>
  <li>大文件：
    <ul>
      <li>避免占满一个CG</li>
      <li>i-node所在CG：前10块（直接指针指向）</li>
      <li>每个间址块及其指向的块在同一CG</li>
      <li>不同间址块及其指向的块在不同CG</li>
    </ul>
  </li>
  <li>顺序访问性能：
    <ul>
      <li>一块一块的顺序读写，避免额外的旋转延迟</li>
      <li>FFS：逻辑块到物理块的映射采用间隔方式</li>
    </ul>
  </li>
</ul>
<h3 id="文件系统可靠性"><a href="#文件系统可靠性" class="headerlink" title="文件系统可靠性"></a>文件系统可靠性</h3>
<h4 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h4>
<p><em>1.路径名解析</em></p>
<p>例子：在UNIX中查找/usr/ast/mbox</p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/lookup-mbox.png" alt="lookup-mbox"></p>
<p><em>I/O性能</em></p>
<ul>
  <li>读一个文件：/home/example/foo，假设读它的第一块：</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/read-foo.png" alt="read-foo"></p>
<ul>
  <li>写一个新文件：/home/example/goo，假设只写入一个块：</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/create-foo.png" alt="create-foo"></p>
<p><em>2.文件缓存</em></p>
<ul>
  <li>使用内核空间的一部分内存来缓存磁盘块</li>
  <li>读操作：先检查该块是否在缓存中
    <ul>
      <li>在：将缓存块的内容拷贝到用户buffer中</li>
      <li>不在：分配一个缓存块（可能需要替换），把磁盘块读到缓存，再把缓存块拷贝到用户buffer</li>
    </ul>
  </li>
  <li>写操作：先检查该块是否在缓存中
    <ul>
      <li>在：将用户buffer的内容拷贝到缓存块中</li>
      <li>不在：分配一个缓存块（可能需要替换），将用户buffer的内容拷贝到缓存块中</li>
      <li>将该缓存块写回磁盘（根据缓存管理策略）</li>
    </ul>
  </li>
  <li>缓存设计问题：
    <ul>
      <li>缓存什么</li>
      <li>缓存大小</li>
      <li>何时放进缓存</li>
      <li>怎么替换，替换谁</li>
      <li>写回策略</li>
    </ul>
  </li>
</ul>
<p><em>缓存大小</em></p>
<ul>
  <li>文件缓存与VM竞争有限的内存空间</li>
  <li>两种方法：固定大小 &amp; 可变大小</li>
  <li>如何调整缓存大小：
    <ul>
      <li>由用户决定</li>
      <li>工作集思想：在不超过阀值时动态调整</li>
    </ul>
  </li>
</ul>
<p><em>为什么缓存位于内核空间</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/loc.png" alt="loc"></p>
<ul>
  <li>DMA：DMA需要绑定物理内存</li>
  <li>多用户进程：共享缓存</li>
  <li>经典的替换策略：全局LRU</li>
</ul>
<p><em>3.预取</em></p>
<ul>
  <li>文件访问具有局部性：
    <ul>
      <li>空间局部性</li>
      <li>时间局部性</li>
    </ul>
  </li>
  <li>最优：在要用之前刚好预取进来</li>
  <li>通常的策略：
    <ul>
      <li>针对顺序访问的预取：访问第i块时，预取随后的k个块
        <ul>
          <li>指针文件块分配连续的磁盘块</li>
          <li>Linux采用此方法</li>
        </ul>
      </li>
      <li>针对i-node的预取：在读取目录项时，同时读取对应的i-nodes</li>
    </ul>
  </li>
  <li>高级策略：预取同一目录下的所有小文件</li>
</ul>
<p><em>4.替换策略</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/lru.png" alt="lru"></p>
<ul>
  <li>原理：用过去预测未来，LRU效果好</li>
  <li>LRU策略：
    <ul>
      <li>哈希表 + 双向链表：MRU端为链头，LRU端为链尾</li>
      <li>如果b在缓存，则将它移到链头，返回b</li>
      <li>否则，替换链尾的块，从磁盘读取b，将它插入链头</li>
    </ul>
  </li>
</ul>
<p><em>5.写回策略</em></p>
<ul>
  <li>写与读是不同的：数据必须写到磁盘才能持久化</li>
  <li>Write through：
    <ul>
      <li>每个写操作，不仅更新缓存块，而且立即更新磁盘块</li>
      <li>缓存内容与磁盘块内容是一致的</li>
      <li>简单，但是磁盘写没有减少</li>
    </ul>
  </li>
  <li>Write back：
    <ul>
      <li>写缓冲：每个写操作只更新缓存块，并将其标记为“dirty”</li>
      <li>之后再将它写到磁盘</li>
      <li>写操作块，减少磁盘写：缓存吸纳多次写，批量写磁盘</li>
    </ul>
  </li>
</ul>
<p><em>写回的复杂性</em></p>
<ul>
  <li>丢数据：
    <ul>
      <li>宕机时，缓存中的“脏”数据将全部丢失</li>
      <li>推迟写磁盘：更好的性能，但损失更大</li>
    </ul>
  </li>
  <li>什么时候写回：
    <ul>
      <li>当一个块被替换出缓存时</li>
      <li>当文件关闭时</li>
      <li>当进程调用<code>fsync</code>时</li>
      <li>固定的时间间隔（UNIX是30秒）</li>
    </ul>
  </li>
  <li>问题：
    <ul>
      <li>执行写操作的进程并不知道数据什么时候落盘了
        <ul>
          <li><code>fsync</code>：让用户控制写回数据</li>
          <li>direct I/O：不使用缓存</li>
        </ul>
      </li>
      <li>上述策略都不足以保证不丢数据：宕机或掉电可能发生在任何时候</li>
    </ul>
  </li>
</ul>
<h4 id="文件系统可靠性-1"><a href="#文件系统可靠性-1" class="headerlink" title="文件系统可靠性"></a>文件系统可靠性</h4>
<p><em>1.威胁FS的因素</em></p>
<ul>
  <li>设备坏
    <ul>
      <li>磁盘损坏或磁盘块损坏</li>
      <li>超级块：整个FS丢失</li>
      <li>位图块，i-node</li>
      <li>数据块：目录、文件、间址块损坏</li>
    </ul>
  </li>
  <li>宕机或掉电：
    <ul>
      <li>软件bug</li>
      <li>缓存中的“脏”数据没有写回磁盘</li>
    </ul>
  </li>
</ul>
<p><em>2.备份与恢复工具</em></p>
<ul>
  <li>物理备份与恢复：设备级，将磁盘块逐一拷贝到另一个磁盘上（备份盘）
    <ul>
      <li>全复制：原始盘与备份盘在物理上一模一样</li>
      <li>增量肤质：与上次备份相比，只拷贝发生变化的块</li>
    </ul>
  </li>
  <li>逻辑备份与恢复：文件系统级
    <ul>
      <li>遍历文件系统目录树，从根目录开始</li>
      <li>把你指定的目录和文件拷贝到备份磁盘</li>
      <li>在备份过程中验证文件系统结构</li>
      <li>恢复工具：将你指定的文件或目录树恢复出来</li>
      <li>也有两种：
        <ul>
          <li>全备份：备份整个目录树</li>
          <li>增量备份：只备份发生变化的目录和文件</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>3.持久化与宕机</em></p>
<ul>
  <li>文件系统给用户提供持久化的数据存储
    <ul>
      <li>文件一直要保存完好，除非用户显示删除它们</li>
      <li>如果有备份，可以恢复出已经删除的文件</li>
    </ul>
  </li>
  <li>为什么难：
    <ul>
      <li>机器可能在任意时刻宕机</li>
      <li>宕机使得内存中的数据全部丢失</li>
      <li>一个写操作往往修改多个块，但系统只能保证原子修改一个块</li>
    </ul>
  </li>
</ul>
<p><em>4.宕机破坏文件系统的一致性</em></p>
<ul>
  <li>例：在当前目录/home/test下创建文件testfile</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/testfile1.png" alt="t1"></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/t2.png" alt="t2"></p>
<ul>
  <li>例：在文件/home/test/testfile/文件末尾写入一个数据块</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/wt.png" alt="wt"></p>
<p><em>先写元数据、后写数据</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/metaf.png" alt="metaf"></p>
<p><em>先写数据、后写元数据</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/dataf.png" alt="dataf"></p>
<p><em>5.保证一致性的修改</em></p>
<ul>
  <li>通用方法：按自底向上顺序进行修改
    <ul>
      <li>文件数据块 -&gt; 文件的i-node -&gt; 目录文件 -&gt; 目录i-node…</li>
    </ul>
  </li>
  <li>如果有文件缓存：
    <ul>
      <li>写回所有的数据块</li>
      <li>修改文件的i-node，并把它写回磁盘</li>
      <li>修改目录项，并把它写回磁盘</li>
      <li>修改目录的i-node，并把它写回磁盘</li>
      <li>沿路径向上，直到无修改的目录</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>写性能差：对于磁盘是串行的小粒度随机写，写性能差</li>
      <li>FS不一致：宕机后可能产生垃圾块</li>
    </ul>
  </li>
</ul>
<p><em>7.<code>fsck</code>：UNIX FS一致性检查工具</em></p>
<ul>
  <li>检查并试图恢复FS的一致性：不能解决所有问题，比如数据与元数据不一致</li>
  <li>检查superblock：如果fs size &lt; 已分配块，认为它损坏，切换到另一个副本</li>
  <li>检查块位图
    <ul>
      <li>重构已使用块信息：扫描磁盘上所有的i-node和间址块</li>
      <li>重构已使用i-node信息：扫扫描磁盘上所有目录的目录项</li>
    </ul>
  </li>
  <li>检查i-node
    <ul>
      <li>通过type域的值来判断i-node是否已经损坏</li>
      <li>如果损坏，则清除该i-node及它对应的位图位</li>
    </ul>
  </li>
  <li>检查nlink域
    <ul>
      <li>遍历FS的整个目录树，重新计算每个文件的链接数</li>
      <li>没有目录项指向的i-node，放到lost+found目录下</li>
    </ul>
  </li>
  <li>检查数据块是否冲突
    <ul>
      <li>是否有两个或更多的i-node指向同一个数据块</li>
      <li>把这个数据块的内容复制一遍</li>
    </ul>
  </li>
  <li>检查数据块指针：是否指针越界</li>
  <li>缺点：恢复时间与FS大小成正比，即使只损坏了几个块，需要扫描整个磁盘和遍历FS目录树</li>
</ul>
<p><em>8.恢复磁盘块结构</em></p>
<ul>
  <li>启动块：
    <ul>
      <li>创建一个替代启动块的工具</li>
      <li>复制一份启动块以及内核到U盘</li>
    </ul>
  </li>
  <li>超级块：复制多个副本</li>
  <li>空闲块结构：
    <ul>
      <li>从根目录开始，遍历目录树，得到所有可达文件</li>
      <li>不可达的块都为空闲块</li>
    </ul>
  </li>
</ul>
<p><em>9.事务概念</em></p>
<ul>
  <li>事务概念来自于数据库</li>
  <li>事务是一组操作，具有“ACID”性质：
    <ul>
      <li>Atomicity：原子性，要么所有操作都成功完成，要么一个操作也不曾执行过</li>
      <li>Consistency：一致性，事务完成后，所有状态必须是正确的</li>
      <li>Isolation：隔离性
        <ul>
          <li>事务的中间状态对其他事务不可见</li>
          <li>针对并发执行事务，并发执行的结果等同于顺序执行的结果</li>
        </ul>
      </li>
      <li>Durability：持久性
        <ul>
          <li>一旦一个事务成功完成，其结果是永久性的</li>
          <li>后续事务可基于此结果继续操作</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>10.事务操作接口</em></p>
<ul>
  <li>定义构成事务的一组操作</li>
  <li>原语：
    <ul>
      <li>Begin Transaction：标记一个事务的开始</li>
      <li>Commit（End Transaction）：标记一个事务的成功</li>
      <li>Rollback：回滚，撤销从”Begin Transaction”起发生的所有操作</li>
    </ul>
  </li>
  <li>规则：
    <ul>
      <li>事务可以并发执行</li>
      <li>回滚可以在任意时刻执行</li>
      <li>事务可以嵌套</li>
    </ul>
  </li>
</ul>
<p><em>11.事务的实现：Write-Ahead Log</em></p>
<ul>
  <li>Begin Transaction：在磁盘上记录一条开始日志TxB，标明一个事务开始</li>
  <li>事务中的修改：
    <ul>
      <li>所有修改都记录日志</li>
      <li>事务日志中需要标明事务编号TID</li>
    </ul>
  </li>
  <li>Commit：在磁盘上写一条结束日志TxE，标明一个事务成功完成</li>
  <li>Checkpoint：Commit之后，把该事务中的修改全部写到磁盘上</li>
  <li>清除日志：Checkpoint写完后，清除相应的日志</li>
  <li>宕机恢复：replay
    <ul>
      <li>如果磁盘上没有结束日志TxE，什么也不做</li>
      <li>如果有，按日志重做，然后清除日志</li>
    </ul>
  </li>
  <li>前提假设：
    <ul>
      <li>写到磁盘上的日志和数据都是正确的（错误发现和纠错机制）</li>
      <li>宕机后磁盘仍然是好的</li>
      <li>日志中记录的所有修改必须是幂等的</li>
      <li>每个事务有唯一的编号TID</li>
      <li>必须有办法确认写磁盘完成</li>
    </ul>
  </li>
</ul>
<p><em>12.将事务用于FS</em></p>
<ul>
  <li>日志文件系统（Logging File System）
    <ul>
      <li>用事务来实现一致性的修改</li>
      <li>每个文件操作都作为一个事务：创建/删除文件/目录，重命名，硬链接，软连接，写文件…</li>
    </ul>
  </li>
  <li>宕机恢复：
    <ul>
      <li>按日志重做一遍</li>
      <li>简单、高效：恢复时间与日志大小成正比</li>
      <li>日志必须是幂等的</li>
    </ul>
  </li>
</ul>
<p><em>日志文件系统：data journaling</em></p>
<ul>
  <li>记录所有修改的日志</li>
  <li>例：在一个文件末尾追加一个数据块</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/logfs.png" alt="logfs"></p>
<ul>
  <li>流程：
    <ul>
      <li>写日志：TxB，i-node日志，bitmap日志，数据块日志</li>
      <li>提交日志Commit：写TxE</li>
      <li>Checkpoint：修改磁盘上的i-node、bitmap、数据块</li>
      <li>清除日志</li>
    </ul>
  </li>
  <li>日志开销：所有数据块写两次磁盘</li>
</ul>
<p><em>日志文件系统：metadata journaling</em></p>
<ul>
  <li>只记录元数据修改的日志</li>
  <li>例：在一个文件末尾追加一个数据块</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/metalog.png" alt="metalog"></p>
<ul>
  <li>
    <p>流程：</p>
    <ul>
      <li>写数据块</li>
      <li>写日志：TxB，i-node日志，bitmap日志</li>
      <li>提交日志Commit：写TxE</li>
      <li>Checkpoint：修改磁盘上的i-node，bitmap</li>
      <li>清除日志</li>
    </ul>
  </li>
  <li>
    <p>日志开销：所有数据块只写一次磁盘</p>
  </li>
</ul>
<p><em>13.日志的性能问题</em></p>
<ul>
  <li>性能问题
    <ul>
      <li>频繁写磁盘：每个操作都要同步写磁盘</li>
      <li>写放大：只修改一个块中少量内容</li>
    </ul>
  </li>
  <li>改进办法
    <ul>
      <li>批量提交：以牺牲可靠性换取性能
        <ul>
          <li>先修改内存中的数据结构（bitmap，i-node，数据块）</li>
          <li>日志记录它们的内存地址</li>
          <li>定期提交所有操作的日志</li>
        </ul>
      </li>
      <li>用NVRAM来保存日志
        <ul>
          <li>MVRAM速度快，写日志快，可以大幅度提高写的IOPS</li>
          <li>不丢数据</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>可靠性
    <ul>
      <li>（批量提交）宕机仍然可能丢数据，但不会破坏文件系统结构</li>
      <li>无法应对硬件故障，比如磁盘扇区坏</li>
    </ul>
  </li>
</ul>
<p><em>14.日志管理</em></p>
<p>需要多大的日志？</p>
<ul>
  <li>日志只在宕机恢复时需要</li>
  <li>方法：
    <ul>
      <li>定期做checkpoint：把缓存里的内容刷回磁盘</li>
      <li>checkpoint之后，可以截断日志，从头开始写</li>
      <li>固定大小，循环使用</li>
      <li>日志要足够大以足以容纳所有内存中的修改</li>
    </ul>
  </li>
  <li>实际系统：
    <ul>
      <li>日志大小可配置，通常为百MB</li>
      <li>位于FS内部，一个特殊文件，文件名&amp;i-node</li>
      <li>位于FS外部，专门的日志盘/分区</li>
    </ul>
  </li>
</ul>
<h3 id="LFS（Log-Structured-File-System）"><a href="#LFS（Log-Structured-File-System）" class="headerlink" title="LFS（Log-Structured File System）"></a>LFS（Log-Structured File System）</h3>
<p><em>1.LFS</em></p>
<ul>
  <li>
    <p>目标：提高写性能</p>
  </li>
  <li>
    <p>思想：试图消除对磁盘的小粒度随机写和同步写，像写日志那样大粒度顺序写磁盘</p>
  </li>
  <li>具体：
    <ul>
      <li>每次写文件写到新位置（日志末尾）：out-of-place update（COW）</li>
      <li>不需要bitmap来管理空闲空间</li>
      <li>文件块采用多级索引：文件块位置记录在i-node中</li>
      <li>每次写文件采用一致性修改：先写文件块，再写i-node</li>
    </ul>
  </li>
</ul>
<p><em>大粒度顺序写</em></p>
<ul>
  <li>Segment：大粒度的内存buffer
    <ul>
      <li>缓存多个写，一次把整个segment写到磁盘</li>
    </ul>
  </li>
</ul>
<p><em>i-node</em></p>
<ul>
  <li>每次写文件块，都要写i-node</li>
  <li>每次写到新位置</li>
  <li>一个文件的i-node在磁盘上没有固定位置</li>
</ul>
<p><em>imap</em></p>
<ul>
  <li>imap块随文件块和i-node一起写到日志中</li>
  <li>CR（Checkpoint Region）记录每个imap块的最新磁盘位置</li>
  <li>CP位于磁盘上的固定位置，有两个CR，分别在磁盘头和尾</li>
</ul>
<p><em>目录</em></p>
<ul>
  <li>目录采用与文件一样的方式来写</li>
</ul>
<p><em>读文件</em></p>
<p>假设LFS刚挂载，内存里什么都没有</p>
<ul>
  <li>先读CR，把CR缓存在内存，以后就不用读了</li>
  <li>根据ino，知道它所在的imap块</li>
  <li>查CR，得到imap块所在的磁盘地址</li>
  <li>读imap块，得到ino对应的i-node的磁盘地址</li>
  <li>读i-node，查文件块索引，得到文件块的磁盘地址</li>
  <li>读文件块</li>
</ul>
<p>重写（修改）会产生垃圾</p>
<p><em>修改文件</em></p>
<ul>
  <li>例：修改/home/test/foo的第一块</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/cfoo1.png" alt="cfoo1"></p>
<ul>
  <li>原来的数据块变为无效 -&gt; 垃圾</li>
  <li>例：在/home/test/foo末尾追加写一块</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/cfoo2.png" alt="cfoo2"></p>
<ul>
  <li>原来的i-node变为无效 -&gt; 垃圾</li>
</ul>
<p><em>垃圾回收</em></p>
<ul>
  <li>原理：
    <ul>
      <li>后台进程cleaner周期性的检查一定数量的segment</li>
      <li>把每个segment中的活块拷贝到新的segment中</li>
    </ul>
  </li>
  <li>何时回收：
    <ul>
      <li>周期性回收</li>
      <li>空闲时：无访问或访问少</li>
      <li>磁盘满时</li>
    </ul>
  </li>
  <li>回收什么样的segment：
    <ul>
      <li>热segment：块频繁被重写</li>
      <li>冷segment：部分死块，部分稳定块</li>
      <li>优先回收冷segment，推迟回收热segment</li>
    </ul>
  </li>
</ul>
<p><em>宕机恢复</em></p>
<ul>
  <li>两个CR交替写</li>
  <li>CR的完整性：CR的第一块和最后一块都有一个时间戳</li>
  <li>恢复：
    <ul>
      <li>最后一次完成的Checkpoint：时间戳最新的&amp;完整的CR</li>
      <li>重构最新的修改：根据CR找到日志末尾，检查后续写的segment</li>
    </ul>
  </li>
  <li>恢复快：无需<code>fsck</code>，无需扫描磁盘</li>
</ul>
<h3 id="分布式文件系统和数据保护"><a href="#分布式文件系统和数据保护" class="headerlink" title="分布式文件系统和数据保护"></a>分布式文件系统和数据保护</h3>
<h4 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h4>
<p><em>1.NFS（Network File System）</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfs.png" alt="nfs"></p>
<ul>
  <li>多个客户端（计算机）共享一台文件服务器</li>
</ul>
<p><em>2.NFS架构</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfs-layout.png" alt="nfs-layout"></p>
<p>多Client，单Server</p>
<ul>
  <li>NFS客户端：实现FS功能和接口
    <ul>
      <li>接口：syscall，与本地FS相同接口（透明性）</li>
      <li>把文件访问syscall转换成请求</li>
      <li>把请求发给服务器</li>
      <li>接收服务器发回的请求，并返回给调用者</li>
    </ul>
  </li>
  <li>NFS服务器：
    <ul>
      <li>接收客户请求</li>
      <li>读写本地FS</li>
      <li>把结果发回给客户端</li>
    </ul>
  </li>
  <li>缓存：
    <ul>
      <li>客户端缓存</li>
      <li>服务器端缓存</li>
    </ul>
  </li>
</ul>
<p><em>3.NFS设计</em></p>
<ul>
  <li>设计目标：
    <ul>
      <li>简单</li>
      <li>快速恢复</li>
    </ul>
  </li>
  <li>核心思想：无状态服务器
    <ul>
      <li>服务器不记录客户端打开的文件</li>
      <li>服务器不记录每个打开文件的当前偏移</li>
      <li>服务器不记录被客户端缓存的数据块</li>
    </ul>
  </li>
  <li>核心数据结构：File Handle（FH）
    <ul>
      <li>唯一标识客户端要访问的文件或目录</li>
      <li>Volume ID</li>
      <li>ino</li>
      <li>Generation Number</li>
    </ul>
  </li>
</ul>
<p><em>4.NFS挂载</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfs-mount.png" alt="nfs-mount"></p>
<ul>
  <li>NFS服务器“export”一个目录给客户端
    <ul>
      <li>输出目录表：/etc/exports</li>
      <li>输出目录命名：exportfs</li>
    </ul>
  </li>
  <li>NFS客户端挂载：
    <ul>
      <li>NFS服务器（机器名或网络地址）</li>
      <li>NFS服务器输出目录的路径名</li>
      <li>服务器返回输出目录的File Handle</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfs-cli.png" alt="nfs-cli"></p>
<ul>
  <li>自动挂载</li>
  <li>例：两个客户端挂载同一个服务器输出的目录，挂载之后，三个机器可以共享文件</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfs-share.png" alt="nfs-share"></p>
<p><em>5.NFS Protocol</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfsp.png" alt="nfsp"></p>
<p><em>6.文件访问的实现</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfs-accs.png" alt="nfs-accs"></p>
<ul>
  <li>客户端open一个文件
    <ul>
      <li>open() syscall：路径解析</li>
      <li>向服务器发LOOKUP请求</li>
      <li>接收服务器应答的FH</li>
      <li>将本地fd与FH关联</li>
      <li>fd的偏移置为0</li>
    </ul>
  </li>
  <li>客户端read文件
    <ul>
      <li>read() syscall：fd, buf, count</li>
      <li>根据fd得打FH和偏移</li>
      <li>向服务器发READ请求</li>
      <li>参数为FH，偏移，count</li>
      <li>接收服务器的应答数据</li>
      <li>把应答数据拷贝到buf</li>
      <li>fd的偏移 += count</li>
    </ul>
  </li>
  <li>客户端close文件
    <ul>
      <li>释放fd和打开文件结构</li>
      <li>无需与服务器交互</li>
    </ul>
  </li>
  <li>服务器接收LOOKUP请求
    <ul>
      <li>从目录FH中得到VID和目录ino</li>
      <li>读目录i-node</li>
      <li>读目录块，查找与name匹配的目录项
        <name, ino="">
      </name,></li>
      <li>构造FH：VID，name的ino，gno</li>
      <li>发应答：name的FH</li>
    </ul>
  </li>
  <li>服务器接收READ请求
    <ul>
      <li>从FH中得到VID和文件ino</li>
      <li>打开本地文件ino得到sfd</li>
      <li>设置本地文件的偏移（lseek）</li>
      <li>读本地文件数据到sbuf中：<code>read(sfd, sbuf, count)</code></li>
      <li>关闭本地文件：<code>close(sfd)</code></li>
      <li>发应答：sbuf的数据</li>
    </ul>
  </li>
</ul>
<p><em>7.NFS的失效处理</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nfs-lost.png" alt="nfs-lost"></p>
<ul>
  <li>三种失效
    <ul>
      <li>客户端请求丢失</li>
      <li>服务器宕机</li>
      <li>服务器应答丢失</li>
    </ul>
  </li>
  <li>NFS的策略：retry，客户端会超时重发请求</li>
  <li>前提：协议请求是幂等的</li>
</ul>
<p><em>8.客户端缓存</em></p>
<ul>
  <li>客户端用一部分kernel内存来缓存元数据和数据</li>
  <li>好处：提高文件读写性能，减少和服务器的交互</li>
  <li>缓存一致性问题：
    <ul>
      <li>当多个客户端同时读写同一个文件：多读单写、多写</li>
      <li>当某个客户端写，导致：
        <ol>
          <li>修改不可见：客户端打开文件读到旧版本（服务器不是最新版本）</li>
          <li>陈旧数据：客户端缓存中的数据变旧</li>
        </ol>
      </li>
      <li>NFS解决办法：
        <ul>
          <li>Close-to-open consistency
            <ul>
              <li>flush-on-close</li>
              <li>open时用GETATTR来检查缓存中数据块的有效性</li>
            </ul>
          </li>
          <li>数据块60s过期，属性缓存3s过期</li>
          <li>脏数据：30之内写回NFS服务器</li>
        </ul>
      </li>
      <li>附加手段
        <ul>
          <li>网络锁管理：顺序一致性</li>
          <li>不共享缓存：只能被一个客户端缓存</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>9.服务器端缓存</em></p>
<ul>
  <li>服务器用一部分kernel内存来缓存数据和元数据</li>
  <li>好处：提高文件读写性能，服务器端减少磁盘I/O</li>
  <li>问题：服务器宕机可能丢数据</li>
  <li>解决办法：COMMIT
    <ul>
      <li>服务器把之前WRITE写在缓存中的数据写到持久化存储</li>
      <li>参数：FH，偏移，count</li>
      <li>如果COMMIT超时未收到应答：之前的WRITE和COMMIT本身都要重发</li>
    </ul>
  </li>
</ul>
<p><em>10.NFS的影响力：企业级存储</em></p>
<ul>
  <li>企业数据中心：SAN架构</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/san.png" alt="san"></p>
<ul>
  <li>企业数据中心：NAS架构（快照）</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/nas.png" alt="nas"></p>
<h4 id="WAFL"><a href="#WAFL" class="headerlink" title="WAFL"></a>WAFL</h4>
<p><em>1.NetApp的NFS文件服务器</em></p>
<ul>
  <li>WAFL：Write Anywhere File Layout
    <ul>
      <li>NetApp为其NFS产品设计的文件系统</li>
    </ul>
  </li>
  <li>设计目标：
    <ul>
      <li>请求服务速度快：吞吐率更多，I/O带宽更高</li>
      <li>支持大文件系统，且文件系统不断增长</li>
      <li>高性能软件RAID</li>
      <li>宕机后快速恢复</li>
    </ul>
  </li>
  <li>独特之处：
    <ul>
      <li>引入快照</li>
      <li>使用NVRAM记录日志（写前日志）</li>
      <li>磁盘布局受LFS启发</li>
    </ul>
  </li>
</ul>
<p><em>2.快照（snapshot）</em></p>
<ul>
  <li>快照是文件系统的一个只读版本
    <ul>
      <li>1993年提出</li>
      <li>成为文件服务器必备特性</li>
    </ul>
  </li>
  <li>快照用法：
    <ul>
      <li>系统管理员配置快照的个数和频率</li>
      <li>最初系统能支持20个快照</li>
      <li>用快照恢复其中任何一个文件</li>
    </ul>
  </li>
</ul>
<p><em>3.i-node、间址块和数据块</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/wafl-ino.png" alt="wafl-ino"></p>
<ul>
  <li>WAFL使用4KB
    <ul>
      <li>i-node：借鉴UNIX FS</li>
      <li>16个指针（64B）用于文件索引</li>
    </ul>
  </li>
  <li>文件大小$\le 64B$：文件直接存储在i-node中</li>
  <li>文件大小$\le 64KB$：i-node存储16个指向数据块的指针</li>
  <li>文件大小$\le 64MB$：
    <ul>
      <li>i-node存储16个指向间址块的指针</li>
      <li>每个间址块存储1024个指向数据块的指针</li>
    </ul>
  </li>
  <li>文件大小$&gt; 64MB$：i-node存储16个指向二级间址块的指针</li>
</ul>
<p><em>4.WAFL的磁盘布局</em></p>
<ul>
  <li>主要数据结构
    <ul>
      <li>一个根i-node：整个FS的根</li>
      <li>一个i-node file：包含所有i-node</li>
      <li>一个block map file：指示所有空闲块</li>
      <li>一个i-node map file：指示所有空闲i-node</li>
    </ul>
  </li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/wafl-layout.png" alt="wafl-layout"></p>
<p><em>为什么将元数据存储于文件中</em></p>
<ul>
  <li>元数据块可以写在磁盘上任何位置：这是WAFL名字的由来</li>
  <li>使得动态增加文件系统的大小变得容易
    <ul>
      <li>增加一个磁盘引发i-node个数的增加</li>
      <li>将卷管理集成到WAFL中</li>
    </ul>
  </li>
  <li>能够通过Copy-On-Write（COW）来创建快照
    <ul>
      <li>新的数据和元数据都可以COW写到磁盘上的新位置</li>
      <li>固定元数据位置无法COW</li>
    </ul>
  </li>
</ul>
<p><em>5.快照的实现</em></p>
<ul>
  <li>WAFL将整个FL组织成一棵树</li>
  <li>创建快照：
    <ul>
      <li>复制根i-node</li>
      <li>新的根i-node指向活跃FS</li>
      <li>旧的根i-node指向快照</li>
    </ul>
  </li>
  <li>创建快照之后：
    <ul>
      <li>第一次写一个块：把从它到根的数据块都复制（COW）</li>
      <li>活跃FS的根i-node指向新数据块</li>
      <li>写数据块</li>
      <li>以后对这些数据块的写不再触发COW</li>
    </ul>
  </li>
  <li>每个快照都是一个一致状态的只读FS</li>
</ul>
<p><em>6.文件系统一致性</em></p>
<ul>
  <li>定期创建一致点：特殊的快照，用户不可见</li>
  <li>宕机恢复：
    <ul>
      <li>将文件系统恢复到最后一个一致点</li>
      <li>最后一个一致点之后到宕机前的操作：靠日志进行恢复</li>
    </ul>
  </li>
</ul>
<p><em>7.非易失RAM（Non-Volatile RAM）</em></p>
<ul>
  <li>NVRAM：带电池的DRAM，快，但是电池只能维持几小时~几天</li>
  <li>日志写入NVRAM
    <ul>
      <li>记录自上一个一致点以来的所有写请求</li>
      <li>正常关机：先停用NFS服务，再创建一个快照，然后关闭NVRAM</li>
      <li>宕机恢复：用NVRAM中的日志来恢复从最后一个一致点之后的修改</li>
    </ul>
  </li>
  <li>NVRAM划分为两个日志：一个日志写满后，转向写另一个日志，满的日志写回磁盘</li>
</ul>
<p><em>8.快照数据结构</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/snapshot.png" alt="snapshot"></p>
<ul>
  <li>Block map file
    <ul>
      <li>每个4KB磁盘块，对应一个32位的表项</li>
      <li>表项值为0：该块为空闲块</li>
      <li>第0位等于1：该块属于活动文件系统</li>
      <li>第1位等于1：该块属于第一个快照</li>
      <li>第2位等于1：该块属于第二个快照</li>
      <li>…</li>
    </ul>
  </li>
</ul>
<p><em>9.快照创建</em></p>
<ul>
  <li>问题：
    <ul>
      <li>正在创建快照时，可能有很多NFS请求到来</li>
      <li>文件缓存可能需要写回</li>
      <li>不系统NFS长时间被挂起不处理请求</li>
    </ul>
  </li>
  <li>WAFL的解决方案：
    <ul>
      <li>在创建快照前，将块缓存中的脏块标记为“in-snapshot”</li>
      <li>所有对”in-snapshot“缓存块的修改请求被挂起</li>
      <li>没有标记为”in-snapshot”的缓存数据可以修改，但不能刷回磁盘</li>
    </ul>
  </li>
  <li>步骤：
    <ul>
      <li>为所有“in-snapshot”的文件分配磁盘空间
        <ul>
          <li>将i-node缓存中的脏i-node写回至块缓存</li>
        </ul>
      </li>
      <li>更新block map file：对每个表项，将活动FS位的值拷贝到新快照位</li>
      <li>刷回：
        <ul>
          <li>把所有“in-snapshot”缓存块写到它们新的磁盘位置</li>
          <li>每写回一个块，重启它上面被挂起的NFS请求</li>
          <li>复制根i-node</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><em>10.快照删除</em></p>
<ul>
  <li>删除快照的根i-node</li>
  <li>清除block map file中的位</li>
</ul>
<h4 id="GFS（Google-File-System）"><a href="#GFS（Google-File-System）" class="headerlink" title="GFS（Google File System）"></a>GFS（Google File System）</h4>
<p><em>1.GFS：应用需求</em></p>
<ul>
  <li>大规模集群</li>
  <li>故障常态化</li>
  <li>GB级大文件的持续高带宽</li>
  <li>大粒度顺序写和小粒度随机写</li>
  <li>追加写Append-only：从头写到尾，没有rewrite</li>
</ul>
<p><em>2.GFS：概述</em></p>
<ul>
  <li>逻辑上，三类组件
    <ul>
      <li>客户端提供库函数接口：应用通过专门的库函数访问GFS（用户态）</li>
      <li>大量Chunk Server：存储服务器，存储GFS文件</li>
      <li>单一Master：存储元数据和维护名字空间</li>
    </ul>
  </li>
  <li>物理上，两类机器
    <ul>
      <li>Master是集群中专门一台机器</li>
      <li>集群中其他所有机器，既为客户端，又为Chunk Server</li>
    </ul>
  </li>
  <li>GFS文件
    <ul>
      <li>文件划分为固定长度的Chunk：64MB</li>
      <li>以Chunk为粒度存储在多个Chunk Server上</li>
      <li>大块的好处：
        <ul>
          <li>减少读写时与Master交互</li>
          <li>减少元数据量</li>
          <li>更好的利用网络和磁盘带宽</li>
        </ul>
      </li>
      <li>文件缓存
        <ul>
          <li>客户端不缓存文件：数据量太大</li>
          <li>服务器端利用OS提供的文件缓存</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>文件Chunk：每个Chunk保存多个副本
    <ul>
      <li>容错：可用性，可靠性</li>
      <li>写文件：同时写多分，强一致性</li>
      <li>读文件：选择任意一份，比单复本有更高的带宽</li>
      <li>Chunk多个副本的放置：
        <ul>
          <li>本地性：本地放一份</li>
          <li>网络距离：同一机架放一份</li>
          <li>可用性：不同机架放一份</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>GFS Master：集中式管理
    <ul>
      <li>维护三类元数据信息：名字空间，文件 -&gt; Chunk映射，Chunk -&gt; CS映射</li>
      <li>监测CS的HB，负责故障恢复</li>
      <li>所有元数据信息都维护在Master的内存中</li>
      <li>元数据定期持久化</li>
    </ul>
  </li>
</ul>
<p><em>3.GFS：副本一致性</em></p>
<ul>
  <li>Primary Chunk Server
    <ul>
      <li>每个chunk有一个主服务器，其他为从服务器</li>
      <li>由主服务器确定对chunk的并发写的顺序</li>
    </ul>
  </li>
  <li>三阶段写
    <ol>
      <li>与Master交互，获得主服务器位置</li>
      <li>数据传输到主服务器，保存在服务器的内存</li>
      <li>主从服务器把数据写入本地文件</li>
    </ol>
  </li>
</ul>
<p><em>4.GFS的影像：开源实现HDFS</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/hdfs.png" alt="hdfs"></p>
<ul>
  <li>Hadoop上的分布式文件系统</li>
  <li>比Hadoop的MapReduce计算平台还要更广泛地使用</li>
</ul>
<p><em>5.GFS的发展</em></p>
<ul>
  <li>局限性：
    <ul>
      <li>集中控制，单一元数据服务器：性能瓶颈、FS规模瓶颈</li>
      <li>文件数量越来越多</li>
      <li>应用场景越来越多</li>
      <li>小文件的应用场景越来越多</li>
    </ul>
  </li>
  <li>解决办法：基于分布式大表的元数据管理</li>
</ul>
<p><em>6.分布式文件系统总结</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/sum.png" alt="sum"></p>
<p><em>7.数据保护</em></p>
<ul>
  <li>FS是共享的资源
    <ul>
      <li>很多用户</li>
      <li>文件或目录：共享或私有</li>
    </ul>
  </li>
  <li>访问了不该访问的文件
    <ul>
      <li>失误所至</li>
      <li>蓄意攻击</li>
    </ul>
  </li>
</ul>
<p><em>8.安全与保护</em></p>
<ul>
  <li>不让数据被未经许可的使用
    <ul>
      <li>数据机密性：未经许可，不能看到数据</li>
      <li>数据完整性：未经许可，不能修改或删除数据</li>
      <li>系统可用性：任何人干扰系统使得它不可用</li>
    </ul>
  </li>
  <li>90年代之前：PC和网络尚未普及
    <ul>
      <li>单位的计算机：多用户共享</li>
      <li>任何用户不能读写其他用户的文件</li>
    </ul>
  </li>
  <li>互联网时代
    <ul>
      <li>数据在网络传输过程中被拦截：数据加密</li>
      <li>给一个Internet Server 发送大量的请求</li>
    </ul>
  </li>
</ul>
<p><em>9.保护：策略与机制</em></p>
<ul>
  <li>安全策略：定义目标，即要达到的效果，通常是一组规则，定义可接受的行为和不可接受的行为</li>
  <li>机制：用什么样的方法来达到目标</li>
</ul>
<p><em>10.保护机制</em></p>
<ul>
  <li>Authentication（身份认证）</li>
  <li>Authorization（授权/批准）
    <ul>
      <li>决定“A是不是准许做某件事”</li>
      <li>需要一个简单的数据库</li>
    </ul>
  </li>
  <li>访问控制：
    <ul>
      <li>做出“访问是否准许”的规定</li>
      <li>确保没有漏洞</li>
    </ul>
  </li>
</ul>
<p><em>11.身份认证</em></p>
<ul>
  <li>通常是用密码来验证：一串字符，用户必须记住密码</li>
  <li>密码以加密形式存储：使用一种单向的安全hash算法</li>
  <li>缺点：
    <ul>
      <li>每个用户都要记很多密码</li>
      <li>比较弱：“dictionary attack”</li>
    </ul>
  </li>
</ul>
<p><em>12.保护域</em></p>
<ul>
  <li>规则：每个身份准许做哪些事</li>
  <li>保护矩阵：保护域 VS 保护源</li>
</ul>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/matrix.png" alt="matrix"></p>
<p><em>13.按列：访问控制表（ACL）</em></p>
<p><img src="https://github.com/ucasFL/operatingsystem/blob/master/fig/ch6/acl.png" alt="acl"></p>
<ul>
  <li>每个对象有一个ACL表
    <ul>
      <li>定义每个用户的权限</li>
      <li>每个表项为
        <user, privilege="">
      </user,></li>
    </ul>
  </li>
  <li>简单，大多数系统都采用，如UNIX的owner, group, other</li>
  <li>实现
    <ul>
      <li>ACL实现在内核中</li>
      <li>在登录系统时进行身份验证</li>
      <li>ACL存储在每个文件中或文件元数据中</li>
      <li>打开文件时检查ACL</li>
    </ul>
  </li>
</ul>
<p><em>访问控制</em></p>
<ul>
  <li>需要一个可信权威：进行访问控制，ACL都需要保护</li>
  <li>内核是一个可信权威
    <ul>
      <li>内核什么事都可以做</li>
      <li>如果有bug，整个系统都可能被破坏</li>
      <li>它越小、越简单越好</li>
    </ul>
  </li>
  <li>安全的强度由保护系统链上最薄弱的环节决定</li>
</ul>
<p><em>14.一些简单的攻击</em></p>
<ul>
  <li>滥用合法权利
    <ul>
      <li>UNIX：root能做任何事情</li>
    </ul>
  </li>
  <li>拒绝服务（DoS)
    <ul>
      <li>耗尽系统所有资源</li>
    </ul>
  </li>
  <li>偷听：侦听网络上传输的包</li>
</ul>
<p><strong>没有完美保护的系统，每个系统都有漏洞</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Chapter01-操作系统简介&quot;&gt;&lt;a href=&quot;#Chapter01-操作系统简介&quot; class=&quot;headerlink&quot; title=&quot;Chapter01 操作系统简介&quot;&gt;&lt;/a&gt;Chapter01 操作系统简介&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;什么是操作系统&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在应用和硬件之间的一层软件&lt;/li&gt;
  &lt;li&gt;对上层软件提供硬件的抽象&lt;/li&gt;
  &lt;li&gt;对底层硬件进行管理：共享和隔离&lt;/li&gt;
  &lt;li&gt;对底层硬件的处理：细节实现&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="operating system" scheme="http://ucasfl.me/categories/operating-system/"/>
    
    
      <category term="operating system" scheme="http://ucasfl.me/tags/operating-system/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 与 APA 简介</title>
    <link href="http://ucasfl.me/2018/07/08/LLVM-Pass-and-APA-Introduction/"/>
    <id>http://ucasfl.me/2018/07/08/LLVM-Pass-and-APA-Introduction/</id>
    <published>2018-07-08T05:54:01.000Z</published>
    <updated>2018-08-16T02:19:20.053Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间学习了一些关于 LLVM Pass 和 APA 方面的知识，趁今天有空，做一些总结。</p>
<h3 id="LLVM-Pass"><a href="#LLVM-Pass" class="headerlink" title="LLVM Pass"></a>LLVM Pass</h3>
<p>Pass 是 LLVM 中一个非常重要的框架，在 LLVM 后端的分析、转化、优化等过程中，通常是多个 Pass 一起作用来共同完成的。</p>
<p>每一个 LLVM Pass 都是 <code>Pass</code> 类的一个派生类，通过重写 <code>Pass</code> 类的虚方法来实现自身的功能。根据你想要实现的功能，你可以选择继承<code>ModulePass</code>或<code>FunctionPass</code> 等等一系列Pass.</p>
<a id="more"></a>
<p>下面实现一个简单的Pass: 该 Pass 的功能就是在 <code>main</code> 函数的入口处添加一个打印 <code>hello, world.\n</code> 的语句。在这儿，我们选择继承 <code>ModulePass</code> 来实现：</p>
<figure class="highlight autoit">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/ADT/Statistic.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Function.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Module.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/IRBuilder.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/TypeBuilder.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Pass.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/raw_ostream.h"</span></span></div><div class="line">using namespace llvm<span class="comment">;</span></div><div class="line"></div><div class="line"></div><div class="line">namespace &#123;</div><div class="line">  struct PrintfAfterMain : public ModulePass &#123;</div><div class="line">    <span class="keyword">static</span> char ID<span class="comment">; // Pass identification, replacement for typeid</span></div><div class="line">    PrintfAfterMain() : ModulePass(ID) &#123;&#125;</div><div class="line"></div><div class="line">    virtual bool runOnModule(Module &amp;M) &#123;</div><div class="line">		Function *F = M.getFunction(<span class="string">"main"</span>)<span class="comment">;</span></div><div class="line">		<span class="keyword">if</span> (!F)&#123;</div><div class="line">			errs() &lt;&lt; <span class="string">"Not exist main function.\n"</span><span class="comment">;</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span><span class="comment">;</span></div><div class="line">		&#125;</div><div class="line">		Instruction *inst = &amp;(*F-&gt;begin()-&gt;begin())<span class="comment">;</span></div><div class="line">		IRBuilder&lt;&gt; Builder(inst)<span class="comment">;</span></div><div class="line">		FunctionType *printf_type = TypeBuilder&lt;<span class="built_in">int</span>(char *, ...), <span class="literal">false</span>&gt;::get(getGlobalContext())<span class="comment">;</span></div><div class="line">		Function *<span class="function"><span class="keyword">func</span> = <span class="title">cast</span>&lt;<span class="title">Function</span>&gt;<span class="params">(M.getOrInsertFunction( <span class="string">"printf"</span>, printf_type,</span></span></div><div class="line">      AttributeSet().<span class="title">addAttribute</span><span class="params">(M.getContext()</span>, 1<span class="title">U</span>, <span class="title">Attribute</span>::<span class="title">NoAlias</span>)));</div><div class="line">		Value *helloWorld = Builder.CreateGlobalStringPtr(<span class="string">"hello world!\n"</span>)<span class="comment">;</span></div><div class="line">		Builder.CreateCall(<span class="function"><span class="keyword">func</span>, <span class="title">helloWorld</span>);</span></div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span><span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">  &#125;<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">char PrintfAfterMain::ID = <span class="number">0</span><span class="comment">;</span></div><div class="line"><span class="keyword">static</span> RegisterPass&lt;PrintfAfterMain&gt; X(<span class="string">"PrintfAfterMain"</span>, <span class="string">"PrintfAfterMain World Pass"</span>, <span class="literal">false</span>, <span class="literal">false</span>)<span class="comment">;</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>我们可以看出，通过重写 <code>ModulePass</code> 的虚函数 <code>runOnModule</code>，只需要几行的代码，便可以实现该功能。简单说一些它的逻辑：在 LLVM 中，每一个 Module 可以看做就代表一个程序，<code>ModulePass</code> 就是对一个 Module 进行操作，一个 Module 维护着一个函数列表，一个 Function 维护有一个 BB 块列表，而一个 BB 块维护有一个指令列表，首先通过 Module 的 <code>getFunction</code>  方法找到 <code>main</code> ，如果没找到，说明模块中不存在 <code>main</code> 函数，这时候不需要对模块进行任何更改，直接返回 <code>false</code> 即可，如果存在 <code>main</code> 函数，那么便可以找到它的第一条指令：<code>&amp;(*F-&gt;begin()-&gt;begin())</code>，然后，通过 <code>IRBuilder.CreateCall</code> 创建一个调用 <code>printf</code>  函数打印 <code>hello, world!\n</code>. </p>
<p>通过继承 <code>FunctionPass</code> 也可以实现该功能，<code>FunctionPass</code> 作用在每一个函数上，此时，重写 <code>runOnFunction</code> 方法，判断函数为 <code>main</code> 函数，如果不是，则返回，否则，同上进行指令插桩。</p>
<h3 id="APA"><a href="#APA" class="headerlink" title="APA"></a>APA</h3>
<p>APA 的全称是 automatic pool allocation，它是 LLVM 后端的一个优化框架，通过将分离的数据结构分配到不同的内存池中，从而控制数据结构在内存中布局。</p>
<p>编译原理研讨课上本人做了一个关于 APA 的调研，发现网上关于 APA 的资源很少，并且 APA 项目本身不稳定，甚至代码存在一些未修复的 bug，因此将编译安装/使用 APA 的一些步骤记录如下：</p>
<p>本次实验中使用的是 LLVM 3.3 和 poolalloc r192788</p>
<ul>
  <li>下载 LLVM 3.3</li>
</ul>
<figure class="highlight awk">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">svn co http:<span class="regexp">//</span>llvm.org<span class="regexp">/svn/</span>llvm-project<span class="regexp">/llvm/</span>branches<span class="regexp">/release_33/</span> llvm3.<span class="number">3</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>下载 clang 3.3 到 llvm3.3/tools</li>
</ul>
<figure class="highlight awk">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">cd llvm3.<span class="number">3</span><span class="regexp">/tools/</span></div><div class="line">svn co http:<span class="regexp">//</span>llvm.org<span class="regexp">/svn/</span>llvm-project<span class="regexp">/cfe/</span>branches<span class="regexp">/release_33/</span> clang</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>
    <p>由于我在编译 Compiler RT 的时候发生错误，因此这儿不安装 Compiler RT</p>
  </li>
  <li>
    <p>下载 poolalloc 到 llvm3.3/projects</p>
  </li>
</ul>
<figure class="highlight awk">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">svn co http:<span class="regexp">//</span>llvm.org<span class="regexp">/svn/</span>llvm-project<span class="regexp">/poolalloc/</span>trunk<span class="regexp">/ poolalloc</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>将 poolalloc 还原到版本 192788</li>
</ul>
<figure class="highlight lsl">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">svn update -r <span class="number">192788</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>修复 poolalloc 192788 中的一些bug, 调用 <code>-poolalloc</code> pass 时发生段错误：</li>
</ul>
<figure class="highlight stata">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">cd</span> /path/to/poolalloc</div><div class="line">vi <span class="keyword">include</span>/poolalloc/Heuristic.<span class="built_in">h</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>为 class Heuristic 添加成员方法 setGraphs:<br>
  <figure class="highlight stata">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">void setGraphs(DataStructures <span class="keyword">ds</span>)&#123;</div><div class="line">	<span class="keyword">Graph</span> = <span class="keyword">ds</span>;</div><div class="line">&#125;</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>PoolAllocate.cpp<br>
  <figure class="highlight crystal">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">vi <span class="class"><span class="keyword">lib</span>/<span class="title">PoolAllocate</span>/<span class="title">PoolAllocate</span>.<span class="title">cpp</span></span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>在 <code>line 1252: CurHeuristic-&gt;getLocalPoolNodes (F, LocalNodes);</code> 前插入<code>CurHeuristic-&gt;setGraphs(Graphs);</code></p>
<ul>
  <li>使用 ninja 进行编译安装</li>
</ul>
<p>在 llvm3.3 同目录下：<br>
  <figure class="highlight armasm">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="symbol">mkdir</span> <span class="keyword">build;</span></div><div class="line"><span class="symbol">cd</span> <span class="keyword">build;</span></div><div class="line"><span class="symbol">cmake</span> -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS<span class="symbol">=ON</span> -DCMAKE_INSTALL_PREFIX=/<span class="meta">opt</span>/llvm3.<span class="number">3</span> ../llvm3.<span class="number">3</span></div><div class="line"><span class="symbol">ln</span> -s ../<span class="keyword">build/compile_commands.json </span>..</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>编译：<br>
  <figure class="highlight ebnf">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="attribute">ninja</span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>安装：<br>
  <figure class="highlight cmake">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">sudo ninja <span class="keyword">install</span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<ul>
  <li>查看 poolalloc 是否安装成功：</li>
</ul>
<figure class="highlight crystal">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">cd /opt/llvm3.<span class="number">3</span>/<span class="class"><span class="keyword">lib</span></span></div><div class="line">find .|grep poolmalloc</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>如果能看到poolmalloc的库poolalloc.a、poolalloc.so, 则证明安装成功.</p>
<h3 id="ninja-安装方法"><a href="#ninja-安装方法" class="headerlink" title="ninja 安装方法"></a>ninja 安装方法</h3>
<figure class="highlight vim">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">git clone gi<span class="variable">t:</span>//github.<span class="keyword">com</span>/martine/ninja.git</div><div class="line"><span class="keyword">cd</span> ninja</div><div class="line">./bootstrap.<span class="keyword">py</span></div><div class="line">sudo <span class="keyword">cp</span> ninja /usr/local/bin/</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="使用-DSA"><a href="#使用-DSA" class="headerlink" title="使用 DSA"></a>使用 DSA</h3>
<p>1)查看与dsa相关的选项<br>
  <figure class="highlight crystal">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">opt -load /opt/llvm3.<span class="number">3</span>/<span class="class"><span class="keyword">lib</span>/<span class="title">LLVMDataStructure</span>.<span class="title">so</span> -<span class="title">load</span> /<span class="title">opt</span>/<span class="title">llvm3</span>.3/<span class="title">lib</span>/<span class="title">poolalloc</span>.<span class="title">so</span> --<span class="title">help</span>|<span class="title">grep</span> <span class="title">dsa</span></span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>2)使用dsa(以dsa-local分析为例)<br>
  <figure class="highlight crystal">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">opt -load /opt/llvm3.<span class="number">3</span>/<span class="class"><span class="keyword">lib</span>/<span class="title">LLVMDataStructure</span>.<span class="title">so</span> -<span class="title">load</span> /<span class="title">opt</span>/<span class="title">llvm3</span>.3/<span class="title">lib</span>/<span class="title">poolalloc</span>.<span class="title">so</span> -<span class="title">analyze</span> --<span class="title">dsa</span>-<span class="title">local</span> <span class="title">test</span>.<span class="title">ll</span></span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h3 id="使用poolalloc"><a href="#使用poolalloc" class="headerlink" title="使用poolalloc"></a>使用poolalloc</h3>
<figure class="highlight crystal">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">clang -emit-llvm -c test.c;</div><div class="line"><span class="regexp">/opt/llvm</span>3.<span class="number">3</span>/bin/opt -load /opt/llvm3.<span class="number">3</span>/<span class="class"><span class="keyword">lib</span>/<span class="title">LLVMDataStructure</span>.<span class="title">so</span> -<span class="title">load</span> /<span class="title">opt</span>/<span class="title">llvm3</span>.3/<span class="title">lib</span>/<span class="title">poolalloc</span>.<span class="title">so</span> -<span class="title">poolalloc</span> <span class="title">test</span>.<span class="title">o</span> &gt; <span class="title">test</span>.<span class="title">o1</span>;</span></div><div class="line">/opt/llvm3.<span class="number">3</span>/bin/llvm-dis test.o/test.o1;</div><div class="line"><span class="regexp">//</span>查看前后不同：diff test.o.ll test.o1.ll</div><div class="line">/<span class="regexp">/生成可执行文件：</span></div><div class="line">llc test.o1.ll;</div><div class="line">gcc /opt<span class="regexp">/llvm3.3/lib</span><span class="regexp">/libpoolalloc_rt.a test.o1.s;</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a>Slide</h3>
<p>下面，附上做报告时用的slide:</p>
<p><a href="/slides/Automatic_Pool_Allocation.pdf">Automatic Pool Allocation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间学习了一些关于 LLVM Pass 和 APA 方面的知识，趁今天有空，做一些总结。&lt;/p&gt;
&lt;h3 id=&quot;LLVM-Pass&quot;&gt;&lt;a href=&quot;#LLVM-Pass&quot; class=&quot;headerlink&quot; title=&quot;LLVM Pass&quot;&gt;&lt;/a&gt;LLVM Pass&lt;/h3&gt;
&lt;p&gt;Pass 是 LLVM 中一个非常重要的框架，在 LLVM 后端的分析、转化、优化等过程中，通常是多个 Pass 一起作用来共同完成的。&lt;/p&gt;
&lt;p&gt;每一个 LLVM Pass 都是 &lt;code&gt;Pass&lt;/code&gt; 类的一个派生类，通过重写 &lt;code&gt;Pass&lt;/code&gt; 类的虚方法来实现自身的功能。根据你想要实现的功能，你可以选择继承&lt;code&gt;ModulePass&lt;/code&gt;或&lt;code&gt;FunctionPass&lt;/code&gt; 等等一系列Pass.&lt;/p&gt;
    
    </summary>
    
      <category term="LLVM" scheme="http://ucasfl.me/categories/LLVM/"/>
    
    
      <category term="LLVM Pass/APA" scheme="http://ucasfl.me/tags/LLVM-Pass-APA/"/>
    
  </entry>
  
  <entry>
    <title>记一次意外的移位错误</title>
    <link href="http://ucasfl.me/2018/06/05/An-unexpected-shifting-error/"/>
    <id>http://ucasfl.me/2018/06/05/An-unexpected-shifting-error/</id>
    <published>2018-06-05T04:37:40.000Z</published>
    <updated>2019-02-22T13:51:34.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移位错误"><a href="#移位错误" class="headerlink" title="移位错误"></a>移位错误</h3>
<p>前天晚上，刷<a href="http://www.51nod.com" target="_blank" rel="external">51Nod</a>上面的一个题：通过矩阵快速幂计算斐波那契数列，结果发生了一个意想不到的错误，这件事也告诉了我一个道理：</p>
<p><strong>当代码出错的时候，不要轻易去怀疑工具的问题，而要去想 99% 的可能性是自己的代码有问题.</strong></p>
<a id="more"></a>
<p>下面是最开始的代码：<br>
  <figure class="highlight mipsasm">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></div><div class="line">typedef long long <span class="keyword">ll;</span></div><div class="line">using namespace std<span class="comment">;</span></div><div class="line"></div><div class="line">const <span class="keyword">ll </span>MAXV = <span class="number">1</span>e9 + <span class="number">9</span><span class="comment">;</span></div><div class="line"><span class="keyword">ll </span><span class="keyword">base[2][2] </span>= &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;<span class="comment">;</span></div><div class="line"><span class="keyword">ll </span>Reult[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;<span class="comment">;</span></div><div class="line"></div><div class="line">void <span class="keyword">multi(ll </span>A[][<span class="number">2</span>], <span class="keyword">ll </span><span class="keyword">B[][2])&#123;</span></div><div class="line">	<span class="keyword">ll </span>tmp[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;<span class="comment">;</span></div><div class="line">	for(int i = <span class="number">0</span><span class="comment">; i != 2; ++i)&#123;</span></div><div class="line">		for(int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j != 2; ++j)&#123;</span></div><div class="line">			for(int k = <span class="number">0</span><span class="comment">; k != 2; ++k)&#123;</span></div><div class="line">				tmp[i][<span class="keyword">j] </span>+= (A[i][k] * <span class="keyword">B[k][j]) </span>% MAXV<span class="comment">;</span></div><div class="line">				tmp[i][<span class="keyword">j] </span>%= MAXV<span class="comment">;</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	for(int i = <span class="number">0</span><span class="comment">; i != 2; ++i)&#123;</span></div><div class="line">		for(int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j != 2; ++j)&#123;</span></div><div class="line">			A[i][<span class="keyword">j] </span>= tmp[i][<span class="keyword">j];</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void QuickPow(int N)&#123;</div><div class="line">	while (N)&#123;</div><div class="line">		if (N&amp;<span class="number">1</span>)&#123;</div><div class="line">			<span class="keyword">multi(Reult, </span><span class="keyword">base);</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">multi(base, </span><span class="keyword">base);</span></div><div class="line">		N &gt;&gt;= <span class="number">1</span><span class="comment">;</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	<span class="keyword">ll </span>n<span class="comment">;</span></div><div class="line">	cin &gt;&gt; n<span class="comment">;</span></div><div class="line">	QuickPow(n-1)<span class="comment">;</span></div><div class="line">	cout &lt;&lt; Reult[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt;endl<span class="comment">;</span></div><div class="line">	return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>提交之后，有一部分 test cases 发生错误，而且居然还出现超时.之后查看了一下题目，发现是因为函数 QuickPow 的参数是 <code>int</code> 型，而需要计算的数列的项最大是 10^18，因此，导致发生了溢出，之后，将参数由 <code>int</code> 改为 <code>long long</code> 就好了：<br>
  <figure class="highlight mipsasm">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></div><div class="line">typedef long long <span class="keyword">ll;</span></div><div class="line">using namespace std<span class="comment">;</span></div><div class="line"></div><div class="line">const <span class="keyword">ll </span>MAXV = <span class="number">1</span>e9 + <span class="number">9</span><span class="comment">;</span></div><div class="line"><span class="keyword">ll </span><span class="keyword">base[2][2] </span>= &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;<span class="comment">;</span></div><div class="line"><span class="keyword">ll </span>Reult[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;<span class="comment">;</span></div><div class="line"></div><div class="line">void <span class="keyword">multi(ll </span>A[][<span class="number">2</span>], <span class="keyword">ll </span><span class="keyword">B[][2])&#123;</span></div><div class="line">	<span class="keyword">ll </span>tmp[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;<span class="comment">;</span></div><div class="line">	for(int i = <span class="number">0</span><span class="comment">; i != 2; ++i)&#123;</span></div><div class="line">		for(int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j != 2; ++j)&#123;</span></div><div class="line">			for(int k = <span class="number">0</span><span class="comment">; k != 2; ++k)&#123;</span></div><div class="line">				tmp[i][<span class="keyword">j] </span>+= (A[i][k] * <span class="keyword">B[k][j]) </span>% MAXV<span class="comment">;</span></div><div class="line">				tmp[i][<span class="keyword">j] </span>%= MAXV<span class="comment">;</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	for(int i = <span class="number">0</span><span class="comment">; i != 2; ++i)&#123;</span></div><div class="line">		for(int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j != 2; ++j)&#123;</span></div><div class="line">			A[i][<span class="keyword">j] </span>= tmp[i][<span class="keyword">j];</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void QuickPow(<span class="keyword">ll </span>N)&#123;</div><div class="line">	while (N)&#123;</div><div class="line">		if (N&amp;<span class="number">1</span>)&#123;</div><div class="line">			<span class="keyword">multi(Reult, </span><span class="keyword">base);</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">multi(base, </span><span class="keyword">base);</span></div><div class="line">		N &gt;&gt;= <span class="number">1</span><span class="comment">;</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	<span class="keyword">ll </span>n<span class="comment">;</span></div><div class="line">	cin &gt;&gt; n<span class="comment">;</span></div><div class="line">	QuickPow(n-1)<span class="comment">;</span></div><div class="line">	cout &lt;&lt; Reult[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt;endl<span class="comment">;</span></div><div class="line">	return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>当输入的数过大时，前一个程序由于发生溢出导致计算结果不对我能理解，但是有时候会卡我就无法理解了，讲道理不应该啊，由于两个程序除了一个参数类型之外其他地方完全相同，所以我也就没有怀疑是程序的逻辑出了问题，反而去怀疑是编译器的问题.对目标程序进行反汇编，也没发现什么不对劲的地方，唯一的区别就是前者用的是一个 32 位寄存器传参，后者用的是一个 64 位寄存器传参.</p>
<p>昨天，我去向编译原理老师请教，还在想自己会不会发现了一个天大的编译器错误.当老师给我指出错误的时候，突然觉得无比尴尬，自己宛如一个智障.</p>
<p>错误原因如下：</p>
<p><strong>在C/C++中，无符号数移位是逻辑移位，而有符号数移位是算术移位.我在函数中使用了移位运算，因此，当溢出变为负数之后，我们知道，计算机中数的表示都是补码，负数的符号位是 1 ，因此，算术移位右移时高位补符号位就是补 1，所以导致 N 永远不会变为 0，<code>while</code> 循环永远不会结束，程序自然就卡住了.</strong></p>
<p>看下面一个例子：<br><img src="/photos/shift/sh.png" class="full-image"></p>
<p>从上面例子可以看出，有符号移位是算术移位，右移时高位补符号位.</p>
<h3 id="逻辑移位与算术移位"><a href="#逻辑移位与算术移位" class="headerlink" title="逻辑移位与算术移位"></a>逻辑移位与算术移位</h3>
<p>顺便复习一下逻辑移位和算术移位：</p>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4>
<p>无论左移还是右移，都是补 0.</p>
<h4 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h4>
<p>左移：低位补 0<br>右移：高位补符号位</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;移位错误&quot;&gt;&lt;a href=&quot;#移位错误&quot; class=&quot;headerlink&quot; title=&quot;移位错误&quot;&gt;&lt;/a&gt;移位错误&lt;/h3&gt;
&lt;p&gt;前天晚上，刷&lt;a href=&quot;http://www.51nod.com&quot;&gt;51Nod&lt;/a&gt;上面的一个题：通过矩阵快速幂计算斐波那契数列，结果发生了一个意想不到的错误，这件事也告诉了我一个道理：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当代码出错的时候，不要轻易去怀疑工具的问题，而要去想 99% 的可能性是自己的代码有问题.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://ucasfl.me/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://ucasfl.me/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>如何通过命令行调节音量</title>
    <link href="http://ucasfl.me/2018/03/11/How-to-adjust-volume-in-command-line/"/>
    <id>http://ucasfl.me/2018/03/11/How-to-adjust-volume-in-command-line/</id>
    <published>2018-03-11T14:31:20.000Z</published>
    <updated>2018-03-11T14:34:22.091Z</updated>
    
    <content type="html"><![CDATA[<p>直接使用命令：<br>
  <figure class="highlight crmsh">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">amixer set <span class="keyword">Master</span> <span class="title">100</span>% : 调到最大，参数范围是 <span class="number">0</span>% ~ <span class="number">100</span> %</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<a id="more"></a>
<p>或输入：<br>
  <figure class="highlight ebnf">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="attribute">alsamixer</span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>运行该命令后将会进入命令行图形界面，从而可调节音量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接使用命令：&lt;br&gt;
  &lt;figure class=&quot;highlight crmsh&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;
          &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;
          &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;amixer set &lt;span class=&quot;keyword&quot;&gt;Master&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;100&lt;/span&gt;% : 调到最大，参数范围是 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;% ~ &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; %&lt;/div&gt;&lt;/pre&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Command" scheme="http://ucasfl.me/tags/Command/"/>
    
  </entry>
  
  <entry>
    <title>C++中的关联容器</title>
    <link href="http://ucasfl.me/2018/03/11/Summary-of-Associative-Container-in-C-plus-plus/"/>
    <id>http://ucasfl.me/2018/03/11/Summary-of-Associative-Container-in-C-plus-plus/</id>
    <published>2018-03-11T06:47:30.000Z</published>
    <updated>2018-03-11T11:31:35.840Z</updated>
    
    <content type="html"><![CDATA[<p>关联容器(Associative containers)支持通过键来高效地查找和读取元素。两个基本的关联容器类型是 map, set。</p>
<p>本文主要是对 C++ 中基本的关联容器 map, set 中的类型和支持的操作进行总结。</p>
<p>关联容器支持很多顺序容器也提供的相同操作,此外,还提供管理或使用键的特殊操作。</p>
<h3 id="关联容器类型"><a href="#关联容器类型" class="headerlink" title="关联容器类型"></a>关联容器类型</h3>
<p><img src="/photos/ac/1.png" alt=""></p>
<a id="more"></a>
<h3 id="pair-类型"><a href="#pair-类型" class="headerlink" title="pair 类型"></a>pair 类型</h3>
<p>在头文件 <code>utility</code> 中定义。</p>
<p><img src="/photos/ac/1.png" alt=""><br> <em>pair 类型提供的操作, T1, T2, 为类型，如 <code>pair&lt;string, vector&lt;int&gt; &gt; line;</code></em></p>
<p>pair 类型的使用相当繁琐,因此,如果需要定义多个相同的 pair 类型对象,可考虑利用 typedef 简化其声明。</p>
<p>与其他标准库类型不同,对于 pair 类,可以直接访问其数据成员:其成员都是仅有的,分别命名为 first 和 second。只需使用普通的点操作符——成员访问标志即可访问其成员。</p>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3>
<p>关联容器共享大部分——但并非全部——的顺序容器操作。关联容器不提供front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。</p>
<h3 id="map-容器"><a href="#map-容器" class="headerlink" title="map 容器"></a>map 容器</h3>
<p>map 类型通常可理解为关联数组。同样，要使用 map 类型，也需要包含相应的头文件。</p>
<p>map 的构造函数：</p>
<p><img src="/photos/ac/3.png" alt=""></p>
<p>对于键类型,唯一的约束就是必须支持 &lt; 操作符,至于是否支持其他的关系或相等运算,则不作要求。</p>
<h4 id="map-类定义的类型"><a href="#map-类定义的类型" class="headerlink" title="map 类定义的类型"></a>map 类定义的类型</h4>
<p><img src="/photos/ac/4.png" alt=""></p>
<p>对 map 类型迭代器解引用，会得到一个 pair 类型。</p>
<h4 id="给-map-添加元素"><a href="#给-map-添加元素" class="headerlink" title="给 map 添加元素"></a>给 map 添加元素</h4>
<ul>
  <li>通过下标：下标为键，如果没找到，则添加键值对。使用下标访问 map 与使用下标访问数组或 vector 的行为截然不同:用下标访问不存在的元素将导致在 map 容器中添加一个新元素,它的键即为该下标值。</li>
</ul>
<p>在 map 中，迭代器返回 value_type 类型的值——包含 const key_type 和mapped_type 类型成员的 pair 对象;下标操作符则返回一个 mapped_type 类型的值。</p>
<p>对于 map 容器,如果下标所表示的键在容器中不存在,则添加新元素，而值进行默认初始化。</p>
<p>例如，利用 map 来统计输入单词数的简单方法：<br>
  <figure class="highlight cpp">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; words;</div><div class="line">	<span class="built_in">string</span> word;</div><div class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)&#123;</div><div class="line">		++words[word];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator iter = words.begin(); iter != words.end(); ++iter)&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt;<span class="string">"\t"</span> &lt;&lt; iter-&gt;second &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h4 id="map-的-insert-操作"><a href="#map-的-insert-操作" class="headerlink" title="map 的 insert 操作"></a>map 的 insert 操作</h4>
<p><img src="/photos/ac/5.png" alt=""></p>
<h4 id="不修改map对象的查询操作"><a href="#不修改map对象的查询操作" class="headerlink" title="不修改map对象的查询操作"></a>不修改map对象的查询操作</h4>
<ul>
  <li>m.count(k) : 返回 m 中 k 出现的次数</li>
  <li>m.find(k) : 如果 m 中存在按 k 索引的元素，则返回指向该元素的迭代器，否则，返回超出末端迭代器。</li>
</ul>
<h4 id="map-的删除操作"><a href="#map-的删除操作" class="headerlink" title="map 的删除操作"></a>map 的删除操作</h4>
<p><img src="/photos/ac/6.png" alt=""></p>
<h4 id="map对象的遍历"><a href="#map对象的遍历" class="headerlink" title="map对象的遍历"></a>map对象的遍历</h4>
<p>同样提供 begin, end 运算，以生成用于遍历整个容器的迭代器。</p>
<h3 id="set-容器"><a href="#set-容器" class="headerlink" title="set 容器"></a>set 容器</h3>
<p>set 是键的集合，支持大部分前面的操作，但不支持下标操作。set 支持的操作基本与 map 相同。set 中的键和 map 中的一样，只能做读操作，不能做写操作。</p>
<h3 id="multimap-和-multiset-类型"><a href="#multimap-和-multiset-类型" class="headerlink" title="multimap 和 multiset 类型"></a>multimap 和 multiset 类型</h3>
<p>multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同,只有一个例外:multimap 不支持下标运算。</p>
<h3 id="返回迭代器的关联容器操作"><a href="#返回迭代器的关联容器操作" class="headerlink" title="返回迭代器的关联容器操作"></a>返回迭代器的关联容器操作</h3>
<p><img src="/photos/ac/7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关联容器(Associative containers)支持通过键来高效地查找和读取元素。两个基本的关联容器类型是 map, set。&lt;/p&gt;
&lt;p&gt;本文主要是对 C++ 中基本的关联容器 map, set 中的类型和支持的操作进行总结。&lt;/p&gt;
&lt;p&gt;关联容器支持很多顺序容器也提供的相同操作,此外,还提供管理或使用键的特殊操作。&lt;/p&gt;
&lt;h3 id=&quot;关联容器类型&quot;&gt;&lt;a href=&quot;#关联容器类型&quot; class=&quot;headerlink&quot; title=&quot;关联容器类型&quot;&gt;&lt;/a&gt;关联容器类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/photos/ac/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://ucasfl.me/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://ucasfl.me/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++中三种顺序容器的总结</title>
    <link href="http://ucasfl.me/2018/03/11/Summary-of-Sequential-Container-in-C-plus-plus/"/>
    <id>http://ucasfl.me/2018/03/11/Summary-of-Sequential-Container-in-C-plus-plus/</id>
    <published>2018-03-11T03:51:30.000Z</published>
    <updated>2018-03-11T05:46:18.372Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++ 中，标准库提供了三种顺序容器：vector, list, deque，还有三种顺序容器适配器：stack, queue, priority_queue，要使用这些容器，需要在源程序中包含对应的头文件，如 <code>include&lt;vector&gt;</code>。本文主要总结容器的操作。</p>
<h3 id="容器类型："><a href="#容器类型：" class="headerlink" title="容器类型："></a>容器类型：</h3>
<ul>
  <li>vector: 支持快速随机访问（顺序存储）</li>
  <li>list : 支持快速插入、删除（非顺序存储）</li>
  <li>deque : 双端队列</li>
  <li>stack : 后进先出堆栈</li>
  <li>queue : 先进先出队列</li>
  <li>priority_queue : 有优先级管理的队列</li>
</ul>
<a id="more"></a>
<h3 id="容器构造函数"><a href="#容器构造函数" class="headerlink" title="容器构造函数"></a>容器构造函数</h3>
<p><img src="/photos/cpp/1.png" alt=""></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3>
<p>每种容器类型都提供若干共同工作的迭代器类型。与容器类型一样,所有迭代器具有相同的接口:如果某种迭代器支持某种操作,那么支持这种操作的其他迭代器也会以相同的方式支持这种操作。</p>
<figure class="highlight armasm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="symbol">container</span>&lt;elemtype&gt;::<span class="keyword">iterator </span><span class="keyword">iter; </span>//声明一个迭代器</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>所有容器均支持的迭代器操作：<br>
  <figure class="highlight armasm">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">*<span class="keyword">iter </span>返回迭代器 <span class="keyword">iter </span>所指向的元素的引用</div><div class="line"><span class="keyword">iter-&gt;mem </span>对 <span class="keyword">iter </span>进行解引用,获取指定元素中名为 mem 的成员。等效于(*<span class="keyword">iter).mem</span></div><div class="line">++<span class="keyword">iter/iter++ </span>: 给 <span class="keyword">iter </span>加 <span class="number">1</span>,使其指向容器里的下一个元素</div><div class="line">--<span class="keyword">iter/iter-- </span>: 给 <span class="keyword">iter </span>减 <span class="number">1</span>,使其指向容器里的前一个元素</div><div class="line"><span class="keyword">iter1 </span>== <span class="keyword">iter2/iter1 </span>!= <span class="keyword">iter2 </span>: 比较两个迭代器是否相等(或不等)。当两个迭代器指向同一个容器中的同一个元素,或者当它们都指向同一个容器的超出末端的下一位置时,两个迭代器相等</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>另外，vector 和 deque 的迭代器还提供额外的运算：<br>
  <figure class="highlight armasm">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="keyword">iter </span>+ n / <span class="keyword">iter </span>- n : 在迭代器上加(减)整数值 n,将产生指向容器中前面(后面)第 n个元素的迭代器。新计算出来的迭代器必须指向容器中的元素或超出容器末端的下一位置</div><div class="line"><span class="keyword">iter1 </span>+= <span class="keyword">iter2 </span>/ <span class="keyword">iter1 </span>-= <span class="keyword">iter2</span></div><div class="line">&gt;, &gt;=, &lt;, &lt;= 操作符</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>以上运算符仅适用于 vector 和　deque 的迭代器，因为这两种容器是顺序存储的，能够为元素提供快速，随机的访问它们确保可根据元素位置直接有效地访问指定的容器元素。这两种容器都支持通过元素位置实现的随机访问,因此它们的迭代器可以有效地实现算术和关系运算。</p>
<h3 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h3>
<p>左闭右开：[first, last)</p>
<p>编程意义：</p>
<ol>
  <li>当 first 与 last 相等时,迭代器范围为空;</li>
  <li>当 first 与不相等时,迭代器范围内至少有一个元素,而且 first 指向该区间中的第一元素。此外,通过若干次自增运算可以使 first 的值不断增大,直到 first == last 为止。</li>
</ol>
<h3 id="容器定义的类型别名"><a href="#容器定义的类型别名" class="headerlink" title="容器定义的类型别名"></a>容器定义的类型别名</h3>
<p><img src="/photos/cpp/2.png" alt=""></p>
<h3 id="容器的begin和end操作"><a href="#容器的begin和end操作" class="headerlink" title="容器的begin和end操作"></a>容器的begin和end操作</h3>
<p><img src="/photos/cpp/3.png" alt=""></p>
<p>另外，每个操作都有两个版本：const 和 非const，取决于容器的类型是 const 还是 非const</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3>
<p><img src="/photos/cpp/4.png" alt=""></p>
<p>正如上图所示，<code>push_front</code> 仅适用于 list 和 deque 。</p>
<p>另外，需要注意的是，插入元素之后可能会使之前的迭代器失效，需要谨慎考虑。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3>
<p><img src="/photos/cpp/5.png" alt=""></p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3>
<p><img src="/photos/cpp/6.png" alt=""></p>
<p>vector, deque 是顺序存储的，因此可通过下标访问。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3>
<p><img src="/photos/cpp/7.png" alt=""></p>
<h3 id="赋值与交换"><a href="#赋值与交换" class="headerlink" title="赋值与交换"></a>赋值与交换</h3>
<p><img src="/photos/cpp/8.png" alt=""></p>
<p>swap 相当于先删除，然后再赋值，使用swap可以节省删除的成本。</p>
<h3 id="容器自增长"><a href="#容器自增长" class="headerlink" title="容器自增长"></a>容器自增长</h3>
<p>对于大部分应用,使用 vector 容器是最好的。原因在于,标准库的实现者使用这样内存分配策略:以最小的代价连续存储元素。由此而带来的访问元素的便利弥补了其存储代价。</p>
<p>为了使 vector 容器实现快速的内存分配,其实际分配的容量要比当前所需的空间多一些。vector 容器预留了这些额外的存储区,用于存放新添加的元素。于是,不必为每个新元素重新分配容器。所分配的额外内存容量的确切数目因库的实现不同而不同。比起每添加一个新元素就必须重新分配一次容器,这个分配策略带来显著的效率。</p>
<h3 id="capacity-和-reserve-成员"><a href="#capacity-和-reserve-成员" class="headerlink" title="capacity 和 reserve 成员"></a>capacity 和 reserve 成员</h3>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">c.capacity() : 返回容器容量, <span class="type">capacity</span> &gt;= size</div><div class="line">c.reserve(n) : 将容器的预留量设为 <span class="type">n</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3>
<p>在某些方面，可以将 string 看成是字符的容器，因此，大多数的容器操作也适合于 string 。</p>
<p><img src="/photos/cpp/9.png" alt=""><br> <em>string 特有的插入和删除操作</em></p>
<p><img src="/photos/cpp/10.png" alt=""><br> <em>子串操作</em></p>
<p><img src="/photos/cpp/11.png" alt=""><br> <em>append/replace</em></p>
<p><img src="/photos/cpp/12.png" alt=""><br> <em>append/replace 的参数 args</em></p>
<p><img src="/photos/cpp/13.png" alt=""><br> <em>string 查找operator</em></p>
<p><img src="/photos/cpp/14.png" alt=""><br> <em>args</em></p>
<p><img src="/photos/cpp/15.png" alt=""><br> <em>string compare operator</em></p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3>
<p>除了顺序容器,标准库还提供了三种顺序容器适配器:queue、priority_queue 和 stack。</p>
<p>通用操作和类型：</p>
<p><img src="/photos/cpp/16.png" alt=""></p>
<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4>
<p><img src="/photos/cpp/17.png" alt=""></p>
<h4 id="queue-priority-queue"><a href="#queue-priority-queue" class="headerlink" title="queue/priority queue"></a>queue/priority queue</h4>
<p><img src="/photos/cpp/18.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 C++ 中，标准库提供了三种顺序容器：vector, list, deque，还有三种顺序容器适配器：stack, queue, priority_queue，要使用这些容器，需要在源程序中包含对应的头文件，如 &lt;code&gt;include&amp;lt;vector&amp;gt;&lt;/code&gt;。本文主要总结容器的操作。&lt;/p&gt;
&lt;h3 id=&quot;容器类型：&quot;&gt;&lt;a href=&quot;#容器类型：&quot; class=&quot;headerlink&quot; title=&quot;容器类型：&quot;&gt;&lt;/a&gt;容器类型：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;vector: 支持快速随机访问（顺序存储）&lt;/li&gt;
  &lt;li&gt;list : 支持快速插入、删除（非顺序存储）&lt;/li&gt;
  &lt;li&gt;deque : 双端队列&lt;/li&gt;
  &lt;li&gt;stack : 后进先出堆栈&lt;/li&gt;
  &lt;li&gt;queue : 先进先出队列&lt;/li&gt;
  &lt;li&gt;priority_queue : 有优先级管理的队列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://ucasfl.me/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://ucasfl.me/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 命令行中更改屏幕亮度</title>
    <link href="http://ucasfl.me/2018/03/08/How-to-Change-Brightness-in-Linux-Command-Line/"/>
    <id>http://ucasfl.me/2018/03/08/How-to-Change-Brightness-in-Linux-Command-Line/</id>
    <published>2018-03-08T15:28:59.000Z</published>
    <updated>2018-03-11T03:58:39.322Z</updated>
    
    <content type="html"><![CDATA[<p>寒假的时候，笔记本又坏了，这次比前面两次还要更严重，直接开不了机。于是好了，一个寒假在家什么也没干。到学校的第一天就把电脑送去维修，今天才拿回来。好吧，这已经是第三次维修了。取电脑的时候，我问维修的工程师，这次是哪儿坏了。他回答，主板坏了。我说，主板不是刚刚才换了没多久的吗……他说，又坏了。我竟无言以对。</p>
<p>电脑确实修好了。不过拿回来以后，发现屏幕怎么这么暗，然后我通过桌面设置调节，竟然无法调节，即使调到最大也没变化。我心里一凉，是不是硬件上哪儿又坏了。我切回 Windows 系统，惊喜的发现，亮度是可以调节的，那就好办了，既然是软件的问题，咱就可以自己解决。桌面无法调节，那就直接在命令行手动设置亮度值。</p>
<a id="more"></a>
<p>首先，查看屏幕亮度的最大值：</p>
<figure class="highlight ruby">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">fenglv@segmentfault<span class="symbol">:~</span>$ cat /sys/<span class="class"><span class="keyword">class</span>/<span class="title">backlight</span>/<span class="title">intel_backlight</span>/<span class="title">max_brightness</span> </span></div><div class="line"><span class="number">7500</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>输出结果表明，亮度最大值为 7500 ，因此，可以在 0 ~ 7500 之间。</p>
<p>然后，再查看一下当前的亮度值：</p>
<figure class="highlight ruby">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">fenglv@segmentfault<span class="symbol">:~</span>$ cat /sys/<span class="class"><span class="keyword">class</span>/<span class="title">backlight</span>/<span class="title">intel_backlight</span>/<span class="title">brightness</span> </span></div><div class="line"><span class="number">957</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>当前亮度为 957，这 TM 屏幕能不暗吗？</p>
<p>如果要更改屏幕亮度，那么只需手动更改 <code>/sys/class/backlight/intel_backlight/brightness</code> 文件内容即可。至此，你就应该知道怎么办了。</p>
<h3 id="设置启动时的默认亮度"><a href="#设置启动时的默认亮度" class="headerlink" title="设置启动时的默认亮度"></a>设置启动时的默认亮度</h3>
<p>如果要设置电脑启动时候的默认亮度，那么，只需要在文件 <code>/etc/rc.local</code> <code>exit 0</code> 前面加上如下一行内容：<br>
  <figure class="highlight gradle">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">echo <span class="number">5500</span> &gt; <span class="regexp">/sys/</span><span class="keyword">class</span><span class="regexp">/backlight/i</span>ntel_backlight<span class="regexp">/brightness</span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>如上，我把启动时候的亮度值设置为 5500。</p>
<h3 id="自定义亮度"><a href="#自定义亮度" class="headerlink" title="自定义亮度"></a>自定义亮度</h3>
<p>另外，为了每次方便的设置亮度，我写了一个小脚本，并命名为 <code>chbgn</code> ，然后增加执行权限，并放在 <code>$HOME/bin</code> 目录下，这样，每次要设置亮度的时候就可以很方便的进行交互式设置了，体验不比图形界面差。脚本内容如下：<br>
  <figure class="highlight bash">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="meta">#!/usr/bin/env bash</span></div><div class="line"><span class="comment"># 一个用于调节屏幕亮度的脚本</span></div><div class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$USER</span>"</span> != <span class="string">"root"</span> ]]; <span class="keyword">then</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"The program must be executed under the root user."</span>;</div><div class="line">	<span class="built_in">exit</span> 0;</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span>  -n <span class="string">"Please input the brightness value(0 ~ 7500): "</span>;</div><div class="line"><span class="built_in">read</span> int;</div><div class="line"></div><div class="line">value=`expr <span class="variable">$int</span> + 0`;</div><div class="line">expr <span class="variable">$value</span> &amp;&gt;/dev/null;</div><div class="line"><span class="keyword">if</span> [ $? <span class="_">-ne</span> 0 ]; <span class="keyword">then</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"Input must be an integer. Change brightness failed!!!"</span></div><div class="line">	<span class="built_in">exit</span> 0;</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$value</span> -ge 0 ] &amp;&amp; [ <span class="variable">$value</span> -le 7500 ]; <span class="keyword">then</span></div><div class="line">	<span class="built_in">echo</span> <span class="variable">$value</span> &gt; /sys/class/backlight/intel_backlight/brightness</div><div class="line">	<span class="built_in">echo</span> <span class="string">"The brightness of the Computer has successfully changed ^_^"</span></div><div class="line">	<span class="built_in">exit</span> 0;</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Input must be an integer betwwen 0 and 7500. Change brightness failed!!!"</span>;</div><div class="line"><span class="built_in">exit</span> 0;</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒假的时候，笔记本又坏了，这次比前面两次还要更严重，直接开不了机。于是好了，一个寒假在家什么也没干。到学校的第一天就把电脑送去维修，今天才拿回来。好吧，这已经是第三次维修了。取电脑的时候，我问维修的工程师，这次是哪儿坏了。他回答，主板坏了。我说，主板不是刚刚才换了没多久的吗……他说，又坏了。我竟无言以对。&lt;/p&gt;
&lt;p&gt;电脑确实修好了。不过拿回来以后，发现屏幕怎么这么暗，然后我通过桌面设置调节，竟然无法调节，即使调到最大也没变化。我心里一凉，是不是硬件上哪儿又坏了。我切回 Windows 系统，惊喜的发现，亮度是可以调节的，那就好办了，既然是软件的问题，咱就可以自己解决。桌面无法调节，那就直接在命令行手动设置亮度值。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Command Linux" scheme="http://ucasfl.me/tags/Command-Linux/"/>
    
  </entry>
  
  <entry>
    <title>解决 /Usr/lib/x86_64-Linux-gnu/libstdc++.so.6 Version GLIBCXX_3.4.22&#39; Not Found 的问题</title>
    <link href="http://ucasfl.me/2017/12/21/fix-the-problem-of-that-usr-lib-x86-64-linux-gnu-libstdc-so-6-version-GLIBCXX-3-4-22-not-found/"/>
    <id>http://ucasfl.me/2017/12/21/fix-the-problem-of-that-usr-lib-x86-64-linux-gnu-libstdc-so-6-version-GLIBCXX-3-4-22-not-found/</id>
    <published>2017-12-21T12:48:42.000Z</published>
    <updated>2018-03-11T03:57:02.385Z</updated>
    
    <content type="html"><![CDATA[<p>今天升级了一下 OpenCv，升级完之后，却出问题了，执行<code>import cv2</code> 报下面的错误：</p>
<figure class="highlight crystal">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, in &lt;<span class="class"><span class="keyword">module</span>&gt;</span></div><div class="line"><span class="symbol">ImportError:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libstdc</span>++.<span class="title">so</span>.6: <span class="title">version</span> `<span class="title">GLIBCXX_3</span>.4.22' <span class="title">not</span> <span class="title">found</span> (<span class="title">required</span> <span class="title">by</span> /<span class="title">home</span>/<span class="title">fenglv</span>/<span class="title">FILE</span>/<span class="title">anaconda3</span>/<span class="title">lib</span>/<span class="title">python3</span>.6/<span class="title">site</span>-<span class="title">packages</span>/../../<span class="title">libopencv_objdetect</span>.<span class="title">so</span>.3.3)</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>意思是导入库所需要的 <code>libstdc++.so.6</code> 没有找到，然后，我执行 <code>locate libstdc++.so.6</code> 命令，发现这个库是存在的啊。上网查了一下发现原本是因为升级了 <code>OpenCv</code> 之后需要更高版本的库，而当前的版本过低，所以才出错。</p>
<a id="more"></a>
<p>执行命令 <code>strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX</code> ，果然，显示的版本低于<code>3.4.22</code> 。</p>
<p>之后找到解决办法：</p>
<p>下载最新版的<code>libstdc++</code>，<a href="http://ftp.de.debian.org/debian/pool/main/g/gcc-8/libstdc++-8-dev_8-20171213-1_amd64.deb" target="_blank" rel="external">点击下载</a>，然后解压缩：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">ar -x libstdc++<span class="number">6</span>_8-<span class="number">20171213</span>-<span class="number">1</span>_amd64<span class="selector-class">.deb</span> &amp;&amp; tar xvf data<span class="selector-class">.tar</span><span class="selector-class">.xz</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>之后，直接将解压出来的<code>/usr/x86_64-linux-gnu/libstdc++.so.6.25</code> 复制到<code>/usr/lib/x86_64-linux-gnu/</code> 下，当然，为了保险起见，你也可以先备份一下原文件。然后<br>
  <figure class="highlight crystal">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">cd /usr/bin/<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/</span></div><div class="line">sudo rm lidstdc++.so.<span class="number">6</span></div><div class="line">sudo ln libstdc++.so.<span class="number">6.25</span> libstdc++.so.<span class="number">6</span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>现在，你再次执行命令<code>strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX</code> ，显示的版本号就如下：</p>
<figure class="highlight css">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.1</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.2</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.3</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.4</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.5</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.6</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.7</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.8</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.9</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.10</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.11</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.12</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.13</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.14</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.15</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.16</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.17</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.18</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.19</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.20</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.21</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.22</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.23</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.24</span></div><div class="line"><span class="selector-tag">GLIBCXX_3</span><span class="selector-class">.4</span><span class="selector-class">.25</span></div><div class="line"><span class="selector-tag">GLIBCXX_DEBUG_MESSAGE_LENGTH</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>至此，问题解决～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天升级了一下 OpenCv，升级完之后，却出问题了，执行&lt;code&gt;import cv2&lt;/code&gt; 报下面的错误：&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  File &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, in &amp;lt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;ImportError:&lt;/span&gt; /usr/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;x86_64&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;linux&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;gnu&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;libstdc&lt;/span&gt;++.&lt;span class=&quot;title&quot;&gt;so&lt;/span&gt;.6: &lt;span class=&quot;title&quot;&gt;version&lt;/span&gt; `&lt;span class=&quot;title&quot;&gt;GLIBCXX_3&lt;/span&gt;.4.22&#39; &lt;span class=&quot;title&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;found&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;by&lt;/span&gt; /&lt;span class=&quot;title&quot;&gt;home&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;fenglv&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;FILE&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;anaconda3&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;python3&lt;/span&gt;.6/&lt;span class=&quot;title&quot;&gt;site&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;packages&lt;/span&gt;/../../&lt;span class=&quot;title&quot;&gt;libopencv_objdetect&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;so&lt;/span&gt;.3.3)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;意思是导入库所需要的 &lt;code&gt;libstdc++.so.6&lt;/code&gt; 没有找到，然后，我执行 &lt;code&gt;locate libstdc++.so.6&lt;/code&gt; 命令，发现这个库是存在的啊。上网查了一下发现原本是因为升级了 &lt;code&gt;OpenCv&lt;/code&gt; 之后需要更高版本的库，而当前的版本过低，所以才出错。&lt;/p&gt;
    
    </summary>
    
      <category term="fix-problem" scheme="http://ucasfl.me/categories/fix-problem/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中如何阻止一个包升级</title>
    <link href="http://ucasfl.me/2017/12/17/How-to-hold-a-package-in-Ubuntu/"/>
    <id>http://ucasfl.me/2017/12/17/How-to-hold-a-package-in-Ubuntu/</id>
    <published>2017-12-17T07:27:06.000Z</published>
    <updated>2018-03-14T08:15:43.192Z</updated>
    
    <content type="html"><![CDATA[<p>阻止升级：<br>
  <figure class="highlight coq">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">sudo echo <span class="string">"package hold"</span> | <span class="type">sudo</span> dpkg --<span class="built_in">set</span>-selections</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p><code>package</code> 为包的名字。</p>
<a id="more"></a>
<p>如果要取消，则执行命令：<br>
  <figure class="highlight coq">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">sudo echo <span class="string">"package install"</span> | <span class="type">sudo</span> dpkg --<span class="built_in">set</span>-selections</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阻止升级：&lt;br&gt;
  &lt;figure class=&quot;highlight coq&quot;&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td class=&quot;gutter&quot;&gt;
          &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class=&quot;code&quot;&gt;
          &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo echo &lt;span class=&quot;string&quot;&gt;&quot;package hold&quot;&lt;/span&gt; | &lt;span class=&quot;type&quot;&gt;sudo&lt;/span&gt; dpkg --&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;-selections&lt;/div&gt;&lt;/pre&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt; 为包的名字。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Xrandr 命令 的一些使用</title>
    <link href="http://ucasfl.me/2017/12/10/Linux-commands-of-xrandr/"/>
    <id>http://ucasfl.me/2017/12/10/Linux-commands-of-xrandr/</id>
    <published>2017-12-09T16:53:10.000Z</published>
    <updated>2019-03-21T01:50:37.200Z</updated>
    
    <content type="html"><![CDATA[<p>设置屏幕分辨率：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">xrandr : 显示系统支持的所有分辨率</div><div class="line">xrandr -s <span class="number">0</span> : 设置为系统默认分辨率</div><div class="line">xrandr -s arg : 设置具体分辨率,如 <span class="type">xrandr</span> -s <span class="number">1024</span>x768</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>双屏设置：</p>
<figure class="highlight brainfuck">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">xrandr</span> <span class="comment">:</span> <span class="comment">显示所有显示屏设备名称</span></div><div class="line"><span class="comment">xrandr</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">output</span> <span class="comment">DEV2</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">same</span><span class="literal">-</span><span class="comment">as</span> <span class="comment">DEV1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">auto</span> <span class="comment">:</span> <span class="comment">设置双屏显示相同的内容</span><span class="string">,</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">auto</span> <span class="comment">为最高分辨率，可通过</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mode</span> <span class="comment">arg</span> <span class="comment">设置分辨率</span></div><div class="line"><span class="comment">xrandr</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">output</span> <span class="comment">DEV2</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">right</span><span class="literal">-</span><span class="comment">of</span> <span class="comment">DEV1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">auto</span> <span class="comment">:</span> <span class="comment">右侧扩展</span></div><div class="line"><span class="comment">xrandr</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">output</span> <span class="comment">DEV2</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">left</span><span class="literal">-</span><span class="comment">of</span> <span class="comment">DEV1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">auto</span> <span class="comment">:</span> <span class="comment">左侧扩展</span></div><div class="line"><span class="comment">xrandr</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">output</span> <span class="comment">DEV</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">off</span> <span class="comment">:</span> <span class="comment">关闭显示器</span></div><div class="line"><span class="comment">xrandr</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">output</span> <span class="comment">DEV</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mode</span> <span class="comment">arg</span> <span class="comment">:</span> <span class="comment">双屏分别设置分辨率</span></div></pre>
      </td>
    </tr>
  </table>
</figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设置屏幕分辨率：&lt;/p&gt;
&lt;figure class=&quot;highlight ada&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 Tensorflow 实现神经网络</title>
    <link href="http://ucasfl.me/2017/11/12/an-introduction-to-implementing-neural-networks-using-tensorflow/"/>
    <id>http://ucasfl.me/2017/11/12/an-introduction-to-implementing-neural-networks-using-tensorflow/</id>
    <published>2017-11-12T04:09:50.000Z</published>
    <updated>2018-03-11T03:54:40.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>
<p>如果你一直关注数据科学/机器学习，那么你肯定知道目前深度学习和神经网络非常流行。许多组织/公司都想要雇佣精通深度学习技能的人。从商业竞争到开源项目和支付高额薪水，人们在尝试一切可能的方法来挖掘这一有限的人才。自我驱动的工程师正被汽车工业中的利器所追逐，因为汽车工业正处于近几十年来最大的破坏边缘！</p>
<a id="more"></a>
<p>如果你对深度学习的前景感到兴奋，但还没有开始你的旅途，那么我将会开启你的旅程。从这篇文章开始，我将会写一系列关于深度学习的文章，包括最受欢迎的深度学习库和它们的实现。</p>
<p>在这篇文章中，我将会向你介绍 Tensorflow。读完这篇文章以后，你将会了解神经网络的应用，并且能够使用 TensorFlow 来解决实际生活中的问题。阅读本文前，你需要了解神经网络的基本知识并且对编程比较熟悉。虽然本文中使用的语言是 Python，但我关注得更多的是概念，并且尽可能保持语言的不可知性。</p>
<p>让我们开始吧！</p>
<p><a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/maxresdefault-1.jpg" target="_blank" rel="external"><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/maxresdefault-1-1024x576.jpg" alt="TensorFlow"></a></p>
<h2 id="何时使用神经网络？"><a href="#何时使用神经网络？" class="headerlink" title="何时使用神经网络？"></a>何时使用神经网络？</h2>
<p>神经网络成为人们的关注点已经有很长的一段时间了。如果你想了解关于神经网络和深度学习的更详细的解释，请阅读<a href="https://www.analyticsvidhya.com/blog/2016/08/evolution-core-concepts-deep-learning-neural-networks/" target="_blank" rel="external">这篇文章</a>。它的 “depper” 版本在图像识别、语音和自然语言处理等许多领域都取得了巨大的突破。</p>
<p>最主要的问题是什么时候使用神经网络，什么时候不用？这个领域就像现在的金矿一样，每天都会有许多新的发现。为了成为一个“淘金热”分子，你需要记住下面这些事情：</p>
<ul>
  <li><strong>首先，神经网络需要清晰而详实的数据（主要是大数据）来进行训练</strong>。如果把神经网络想象成一个孩子，他首先需要观察他的父母如何走路，然后尝试独立行走，用他的每一步，学会如何来完成一个特定的任务。他可能会跌倒几次，但经过几次失败的尝试，他便学会了如何走路。如果你不让他自己尝试，那么他可能永远也不能学会走路。你给他接触的越多，那么他就会学得越好。</li>
  <li><strong>使用神经网络来处理一些复杂的问题，比如图像处理是明智的。</strong>神经网络属于一类称为表示学习算法的算法类。这些算法将复杂的问题分解成简单的形式，从而使它们能够理解（或“表示“）。就像你在吃东西的时候，需要先把食物嚼碎，然后才咽下。这比传统（非表示学习）算法更加困难。</li>
  <li><strong>什么时候你能够拥有合适的神经网络来解决问题？</strong>每个问题都有它的困难之处。所以，数据决定了解决问题的方式。比如，如果问题是序列生成，那么递归神经网络更加合适。然而，如果是图像相关的问题，那么改用卷积神经网络会更好。</li>
  <li><strong>最后，但不是不重要，硬件需求对于运行一个深度神经网络模型是至关重要的。</strong>神经网络模型在很早之前就有了，但是在近些年才开始活跃起来，主要原因就是计算资源更好，更强大了。如果你想用神经网络来解决现实生活中的问题，请准备购买一些高端的硬件设备。</li>
</ul>
<h2 id="使用神经网络来解决问题的通常手段"><a href="#使用神经网络来解决问题的通常手段" class="headerlink" title="使用神经网络来解决问题的通常手段"></a>使用神经网络来解决问题的通常手段</h2>
<p>神经网络是一种特殊的机器学习（ML）算法。就像每一个机器学习算法一样，你需要按照通常的机器学习工作流程来进行数据预处理，模型建立和模型评估。为了简单起见，我在下面列出了一个处理神经网络问题的清单：</p>
<ul>
  <li>思考一下，使用神经网络算法来处理该问题是否比用传统算法更好（参考上面章节的清单）</li>
  <li>调查一下，待解决的问题使用哪种神经网络更适合</li>
  <li>使用你选择的语言/库来定义神经网络结构</li>
  <li>将数据转化为正确的格式并进行数据划分</li>
  <li>根据你的需要对数据进行预处理</li>
  <li>添加数据来增大数据量从而更好的训练模型</li>
  <li>将数据”喂给”神经网络进行训练</li>
  <li>训练并监测训练过程中的变化和验证数据集的变化</li>
  <li>测试你的模型，并将它保存下来以便将来使用</li>
</ul>
<p>在这篇文章中，我将重点放在图像数据上。所以在开始探讨 TensorFlow 之前，让我们先理解一下图像数据。</p>
<h2 id="图像数据以及常用于解决图像问题的库"><a href="#图像数据以及常用于解决图像问题的库" class="headerlink" title="图像数据以及常用于解决图像问题的库"></a>图像数据以及常用于解决图像问题的库</h2>
<p>图像数据通常以三维数据的形式排序，每一维分别代表高、宽和颜色通道。比如，此时你在你的电脑上截一张图，它将会先转化为一个三维数组，然后再压缩成 <code>.jpeg</code> 或 <code>.png</code> 文件格式。</p>
<p>虽然这些图像对于人类来说很容易理解，但是计算机却很难理解它们。这种现象被称为“语义鸿沟”。我们的大脑能够在几秒钟的时间内看到图像并理解完整的图像，然而，计算机却只是把图像看成一组数字。所以问题是如何向计算机解释图片？</p>
<p>在早期时候，人们试图将图像分解成机器“可理解”的形式，就像一个模板一样。比如，人脸总是有一种特定的结构，这种结构在每个人中都有一定的保留，例如眼睛、鼻子或脸的形状。但是这种方法很乏味，因为当要识别的对象数量增加时，“模板”就不能保存了。</p>
<p>快速前进到 2012 年，一个深度神经网络赢得了 <code>ImageNet</code> 挑战，这是一个根据自然场景来识别对象的著名挑战。在所有随即到来的 <code>ImageNet</code> 挑战中，它持续占领统治地位，从而证明了用它来解决图像问题的有用性。</p>
<p>所以，人们通常使用哪种语言（库）来解决图像识别问题呢？在一个<a href="https://www.analyticsvidhya.com/blog/2016/08/deep-learning-path/" target="_blank" rel="external">最近的调查中</a>，我发现绝大多数受欢迎的深度学习库都有 Python 接口，紧跟着的是 Lua、Java 和 Matlab 。下面是一些最受欢迎的库：</p>
<ul>
  <li><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="external">Caffe</a></li>
  <li><a href="http://deeplearning4j.org/" target="_blank" rel="external">DeepLearning4j</a></li>
  <li><a href="https://www.tensorflow.org/" target="_blank" rel="external">TensorFlow</a></li>
  <li><a href="http://www.deeplearning.net/software/theano" target="_blank" rel="external">Theano</a></li>
  <li><a href="http://torch.ch/" target="_blank" rel="external">Torch</a></li>
</ul>
<p>现在，你已经知道了一张图像是如何存储的，并且知道了常用的库。下面，让我们来看一下 TensorFlow 能够为我们提供什么。 </p>
<h2 id="TensorFlow-是什么？"><a href="#TensorFlow-是什么？" class="headerlink" title="TensorFlow 是什么？"></a>TensorFlow 是什么？</h2>
<p>我们先看一下官方的定义：</p>
<blockquote>
  <p>“TensorFlow 是一个使用数据流图来进行数值计算的开源软件库。图中的节点表示数学运算，而图中的边表示在节点之间进行传递的多维数据数组（又叫做张量）。灵活的架构允许你在桌面、服务器或移动设备上通过一个单一的 API 使用一个或多个 CPU 或 GPU 部署进行计算。”</p>
</blockquote>
<p><a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/tensors_flowing.gif" target="_blank" rel="external"><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/tensors_flowing.gif" alt="tensors_flowing"></a><a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/tensors_flowing-3.gif" target="_blank" rel="external"><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/tensors_flowing-3.gif" alt="tensors_flowing"></a></p>
<p>如果这听起来很让人迷糊，别担心，下面是我的简单定义：你可以简单的把 TensorFlow 看成一个扭曲的 <code>numpy</code>。如果你过去接触过 <code>numpy</code>，那么理解 TensorFlow 就非常简单了。numpy 和 TensorFlow 之间最主要的区别就是 TensorFLow 使用一种惰性的编程范式。它首先搭建一个把所有操作都定义好了的图，然后，当一个“会话“被调用时，它就会开始”运行“这个图。这个图是可扩展的，只需要改变内部张量（又叫做多维数组）的数据表示即可。构建计算图可以看作是使用
  TensorFlow 的主要工作。如果想了解更多关于计算图的数学组成，请阅读<a href="http://colah.github.io/posts/2015-08-Backprop/" target="_blank" rel="external">这篇文章</a>。</p>
<p>我们很容易把 TensorFlow 归为一个神经网络库，但它不仅仅是这样。的确，它是一个非常强大的神经网络库。但是，它还能够做更多的事情。你可以使用它来构建其他机器学习算法，比如决策树或 K-近邻算法。你可以用它来完成任何你通常用 numpy 来完成的事情。因此它又被形象地称为 “NumPy 类固醇”。</p>
<p>使用 TensorFlow 的优点有：</p>
<ul>
  <li><strong>它具有一个直观的结构。</strong>顾名思义它具有”张量流“。你可以轻松的可视化图的每一个部分。</li>
  <li><strong>对于分布式计算，很容易在 CPU/GPU 上面进行训练。</strong></li>
  <li><strong>平台灵活性。</strong>你可以在任何地方运行你的模型，移动设备、服务器或 PC 。</li>
</ul>
<h2 id="一个典型的-TensorFlow-”流“"><a href="#一个典型的-TensorFlow-”流“" class="headerlink" title="一个典型的 TensorFlow ”流“"></a>一个典型的 TensorFlow ”流“</h2>
<p>每个库都有自己的”实现细节“，即一种遵循其编码范式的编写方式。例如，在实现 <code>scikit-learn</code> 时，你首先创建一个需要的算法对象，然后构建一个训练模型，进而对测试集进行预测，看起来就像下面这样：</p>
<figure class="highlight nix">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment"># 定义机器学习算法的 hyperparamters</span></div><div class="line"><span class="attr">clf</span> = svm.SVC(<span class="attr">gamma=0.001,</span> <span class="attr">C=100.)</span></div><div class="line"><span class="comment"># 训练</span></div><div class="line">clf.fit(X, y)</div><div class="line"><span class="comment"># 测试</span></div><div class="line">clf.predict(X_test)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>正如前面说过的，TensorFlow 遵循一种惰性的编程范式。在 TensorFlow 中运行一个程序的通常工作流如下：</p>
<ul>
  <li><strong>构建一个计算图</strong>，它可以是 TensorFlow 支持的任意一种数学操作。</li>
  <li><strong>初始化变量</strong>，编译之前定义的变量</li>
  <li><strong>创建会话</strong>，这是魔法开始的地方</li>
  <li><strong>在会话中运行图</strong>，编译后的图传到会话中，然后会话开始执行</li>
  <li><strong>关闭会话</strong></li>
</ul>
<p>TensorFlow 中使用的几个术语：</p>
<ul>
  <li>
    <figure class="highlight">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div></pre>
          </td>
          <td class="code">
            <pre><div class="line">占位符：一种将数据输入图表的方法</div></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <figure class="highlight avrasm">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div></pre>
          </td>
          <td class="code">
            <pre><div class="line"><span class="symbol">feed_dict:</span> 一个将数组传递给计算图的字典</div></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
</ul>
<p>让我们写一个小程序并添加两个数字！</p>
<figure class="highlight vim">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"># 导入 TensorFlow</div><div class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></div><div class="line"></div><div class="line"># 搭建计算图</div><div class="line"><span class="keyword">a</span> = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.int16)</div><div class="line"><span class="keyword">b</span> = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.int16)</div><div class="line"></div><div class="line">addition = <span class="keyword">tf</span>.<span class="built_in">add</span>(<span class="keyword">a</span>, <span class="keyword">b</span>)</div><div class="line"></div><div class="line"># 初始化变量</div><div class="line">init = <span class="keyword">tf</span>.initialize_all_variables()</div><div class="line"></div><div class="line"># 创建会话并运行图</div><div class="line">with <span class="keyword">tf</span>.Session() <span class="keyword">as</span> ses<span class="variable">s:</span></div><div class="line">    sess.run(init)</div><div class="line">    <span class="keyword">print</span> <span class="string">"Addition: %i"</span> % sess.run(addition, feed_dict=&#123;<span class="variable">a:</span> <span class="number">2</span>, <span class="variable">b:</span> <span class="number">3</span>&#125;)</div><div class="line"></div><div class="line"># 关闭会话</div><div class="line">sess.<span class="keyword">close</span>()</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h2 id="在-TensorFlow-中实现神经网络"><a href="#在-TensorFlow-中实现神经网络" class="headerlink" title="在 TensorFlow 中实现神经网络"></a>在 TensorFlow 中实现神经网络</h2>
<p><em>注意：我们可以使用不同的神经网络结构来解决问题，但为了简单起见，在这儿，我们致力于一个前馈多层感知机的深层实现。</em></p>
<p>让我们首先记住我们学到的关于神经网络的知识。</p>
<p>一个典型的神经网络实现如下：</p>
<ul>
  <li>定义需要编译的神经网络结构</li>
  <li>将数据传输到模型</li>
  <li>在后台，数据首先被分成批，以便进行摄取，首先对批数据进行预处理，扩充，然后送入神经网络进行训练</li>
  <li>神经网络模型进行增量训练</li>
  <li>在特定时间显示准确率</li>
  <li>训练过后，保存模型，以便日后再次使用</li>
  <li>用新数据测试模型并检查它是如何执行的</li>
</ul>
<p>在这儿，我们解决深度学习实践问题 - <a href="https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-digits/" target="_blank" rel="external">识别数字</a>。让我们先看一下问题陈述。</p>
<p>这是一个图像识别问题，从一个给定的 <code>28x28</code> 的图像中识别数字。我们将所有图像的一个子集用于训练，剩余部分用于测试模型。首先，下载训练和测试文件。数据集包含一个所有图像的压缩文件，以及名字和训练/测试图像相对应的 <code>train.csv</code> 和 <code>test.csv</code> 文件。在数据集中没有提供任何额外的特征，只提供了 <code>.png</code> 格式的原始图像。</p>
<p>正如你所知道的，我们将使用 TensorFlow 来搭建一个神经网络模型。所以你首先需要在你的系统上安装 TensorFlow。请参考<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/g3doc/get_started/os_setup.md" target="_blank" rel="external">官方安装指南</a>，根据你的系统进行安装。</p>
<p>我们将按照上面描述的步骤来搭建神经网络。首先，使用 Python 2.7 核来创建一个 Jupyter notebook，后续步骤如下：</p>
<ul>
  <li>首先导入所有需要的模块：</li>
</ul>
<figure class="highlight haskell">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta"># pylab inline</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="title">from</span> scipy.misc <span class="keyword">import</span> imread</div><div class="line"><span class="title">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>让我们设置一个种子值，从而我们能够控制模型的随机性</li>
</ul>
<figure class="highlight ini">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment"># To stop potential randomness</span></div><div class="line"><span class="attr">seed</span> = <span class="number">128</span></div><div class="line"><span class="attr">rng</span> = np.random.RandomState(seed)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>第一步是设置目录路径，以便安全保存！</li>
</ul>
<figure class="highlight lua">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">root_dir = <span class="built_in">os</span>.path.abspath(<span class="string">'../..'</span>)</div><div class="line">data_dir = <span class="built_in">os</span>.path.join(root_dir, <span class="string">'data'</span>)</div><div class="line">sub_dir = <span class="built_in">os</span>.path.join(root_dir, <span class="string">'sub'</span>)</div><div class="line"></div><div class="line"># check <span class="keyword">for</span> existence</div><div class="line"><span class="built_in">os</span>.path.exists(root_dir)</div><div class="line"><span class="built_in">os</span>.path.exists(data_dir)</div><div class="line"><span class="built_in">os</span>.path.exists(sub_dir)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>现在，让我们读入数据集。数据集是 <code>.csv</code> 文件格式的，并且有一个伴有合适标签的名字。</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">train = pd.read_csv(os<span class="selector-class">.path</span><span class="selector-class">.join</span>(data_dir, <span class="string">'Train'</span>, <span class="string">'train.csv'</span>))</div><div class="line">test = pd.read_csv(os<span class="selector-class">.path</span><span class="selector-class">.join</span>(data_dir, <span class="string">'Test.csv'</span>))</div><div class="line"></div><div class="line">sample_submission = pd.read_csv(os<span class="selector-class">.path</span><span class="selector-class">.join</span>(data_dir, <span class="string">'Sample_Submission.csv'</span>))</div><div class="line"></div><div class="line">train.head()</div></pre>
      </td>
    </tr>
  </table>
</figure>
<table>
  <thead>
    <tr>
      <th></th>
      <th>文件名</th>
      <th>标签</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0.png</td>
      <td>4</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1.png</td>
      <td>9</td>
    </tr>
    <tr>
      <td>2</td>
      <td>2.png</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>3.png</td>
      <td>7</td>
    </tr>
    <tr>
      <td>4</td>
      <td>4.png</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
<ul>
  <li>让我们看一下我们的数据长什么样！读取图片并显示：</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">img_name = rng.choice(train.filename)</div><div class="line">filepath = os<span class="selector-class">.path</span><span class="selector-class">.join</span>(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'train'</span>, img_name)</div><div class="line"></div><div class="line"><span class="selector-tag">img</span> = imread(filepath, flatten=True)</div><div class="line"></div><div class="line">pylab.imshow(<span class="selector-tag">img</span>, cmap=<span class="string">'gray'</span>)</div><div class="line">pylab.axis(<span class="string">'off'</span>)</div><div class="line">pylab.show()</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/3.png" target="_blank" rel="external"><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/3.png" alt="3"></a></p>
<p>上面的图片表示为 numpy 数组，就是下面这样：</p>
<p><a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/one.png" target="_blank" rel="external"><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/one-1024x353.png" alt="one"></a></p>
<ul>
  <li>为了使数据操作更简单，我们把所有图像存为 numpy 数组：</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">temp = []</div><div class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> train<span class="selector-class">.filename</span>:</div><div class="line">    image_path = os<span class="selector-class">.path</span><span class="selector-class">.join</span>(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'train'</span>, img_name)</div><div class="line">    <span class="selector-tag">img</span> = imread(image_path, flatten=True)</div><div class="line">    <span class="selector-tag">img</span> = <span class="selector-tag">img</span>.astype(<span class="string">'float32'</span>)</div><div class="line">    temp.append(img)</div><div class="line">    </div><div class="line">train_x = np.stack(temp)</div><div class="line"></div><div class="line">temp = []</div><div class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> test<span class="selector-class">.filename</span>:</div><div class="line">    image_path = os<span class="selector-class">.path</span><span class="selector-class">.join</span>(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'test'</span>, img_name)</div><div class="line">    <span class="selector-tag">img</span> = imread(image_path, flatten=True)</div><div class="line">    <span class="selector-tag">img</span> = <span class="selector-tag">img</span>.astype(<span class="string">'float32'</span>)</div><div class="line">    temp.append(img)</div><div class="line">    </div><div class="line">test_x = np.stack(temp)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>因为这是一个典型的机器学习问题，为了测试模型的正常功能，我们需要创建一个验证集。我们将数据按 <code>7:3</code> 分为训练集和验证集。</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">split_size = int(train_x<span class="selector-class">.shape</span>[<span class="number">0</span>]*<span class="number">0.7</span>)</div><div class="line"></div><div class="line">train_x, val_x = train_x[:split_size], train_x[split_size:]</div><div class="line">train_y, val_y = train<span class="selector-class">.label</span><span class="selector-class">.values</span>[:split_size], train<span class="selector-class">.label</span><span class="selector-class">.values</span>[split_size:]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>现在，在程序中定义一些我们在后面将会用到的有用函数：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dense_to_one_hot</span><span class="params">(labels_dense, num_classes=<span class="number">10</span>)</span>:</span></div><div class="line">    <span class="string">"""Convert class labels from scalars to one-hot vectors"""</span></div><div class="line">    num_labels = labels_dense.shape[<span class="number">0</span>]</div><div class="line">    index_offset = np.arange(num_labels) * num_classes</div><div class="line">    labels_one_hot = np.zeros((num_labels, num_classes))</div><div class="line">    labels_one_hot.flat[index_offset + labels_dense.ravel()] = <span class="number">1</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> labels_one_hot</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">preproc</span><span class="params">(unclean_batch_x)</span>:</span></div><div class="line">    <span class="string">"""Convert values to range 0-1"""</span></div><div class="line">    temp_batch = unclean_batch_x / unclean_batch_x.max()</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> temp_batch</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_creator</span><span class="params">(batch_size, dataset_length, dataset_name)</span>:</span></div><div class="line">    <span class="string">"""Create batch with random samples and return appropriate format"""</span></div><div class="line">    batch_mask = rng.choice(dataset_length, batch_size)</div><div class="line">    </div><div class="line">    batch_x = eval(dataset_name + <span class="string">'_x'</span>)[[batch_mask]].reshape(<span class="number">-1</span>, input_num_units)</div><div class="line">    batch_x = preproc(batch_x)</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> dataset_name == <span class="string">'train'</span>:</div><div class="line">        batch_y = eval(dataset_name).ix[batch_mask, <span class="string">'label'</span>].values</div><div class="line">        batch_y = dense_to_one_hot(batch_y)</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> batch_x, batch_y</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>现在，到了主要部分。让我们首先来定义神经网络的结构。我们定义一个三层神经网络：输入层、隐含层和输出层。输入层和输出层的神经元数目是固定的，因为输入就是一个 <code>28x28</code> 的图像，输出就是一个 <code>10x1</code> 的表示类别的向量。在隐含层中，我们设置 500 个神经元，这个数目可以根据你的需要来设置。同时，我们也需要对其余变量赋值。阅读<a href="https://www.analyticsvidhya.com/blog/2016/03/introduction-deep-learning-fundamentals-neural-networks/" target="_blank" rel="external">神经网络基础</a>这篇文章来深入了解它是如何工作的。</li>
</ul>
<figure class="highlight nix">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">### set all variables</span></div><div class="line"></div><div class="line"><span class="comment"># number of neurons in each layer</span></div><div class="line"><span class="attr">input_num_units</span> = <span class="number">28</span>*<span class="number">28</span></div><div class="line"><span class="attr">hidden_num_units</span> = <span class="number">500</span></div><div class="line"><span class="attr">output_num_units</span> = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="comment"># define placeholders</span></div><div class="line"><span class="attr">x</span> = tf.placeholder(tf.float32, [None, input_num_units])</div><div class="line"><span class="attr">y</span> = tf.placeholder(tf.float32, [None, output_num_units])</div><div class="line"></div><div class="line"><span class="comment"># set remaining variables</span></div><div class="line"><span class="attr">epochs</span> = <span class="number">5</span></div><div class="line"><span class="attr">batch_size</span> = <span class="number">128</span></div><div class="line"><span class="attr">learning_rate</span> = <span class="number">0.01</span></div><div class="line"></div><div class="line"><span class="comment">### define weights and biases of the neural network (refer this article if you don't understand the terminologies)</span></div><div class="line"></div><div class="line"><span class="attr">weights</span> = &#123;</div><div class="line">    'hidden': tf.Variable(tf.random_normal([input_num_units, hidden_num_units], <span class="attr">seed=seed)),</span></div><div class="line">    'output': tf.Variable(tf.random_normal([hidden_num_units, output_num_units], <span class="attr">seed=seed))</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="attr">biases</span> = &#123;</div><div class="line">    'hidden': tf.Variable(tf.random_normal([hidden_num_units], <span class="attr">seed=seed)),</span></div><div class="line">    'output': tf.Variable(tf.random_normal([output_num_units], <span class="attr">seed=seed))</span></div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>现在，开始创建神经网络计算图：</li>
</ul>
<figure class="highlight ini">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="attr">hidden_layer</span> = tf.add(tf.matmul(x, weights[<span class="string">'hidden'</span>]), biases[<span class="string">'hidden'</span>])</div><div class="line"><span class="attr">hidden_layer</span> = tf.nn.relu(hidden_layer)</div><div class="line"></div><div class="line"><span class="attr">output_layer</span> = tf.matmul(hidden_layer, weights[<span class="string">'output'</span>]) + biases[<span class="string">'output'</span>]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>我们也需要定义神经网络的损失（cost）：</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">cost =　tf.reduce_mean(tf<span class="selector-class">.nn</span><span class="selector-class">.softmax_cross_entropy_with_logits</span>(output_layer, y))</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>设置优化算法，比如后向传播算法（BP 算法）。在这儿，我们使用 <a href="https://arxiv.org/abs/1412.6980" target="_blank" rel="external">Adam</a>，这是一个高效的梯度下降算法的变种。在 TensorFlow 中还有许多可用的优化算法（参考<a href="https://www.tensorflow.org/versions/r0.11/api_docs/python/train.html#optimizers" target="_blank" rel="external">这儿</a>）</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">optimizer = tf<span class="selector-class">.train</span><span class="selector-class">.AdamOptimizer</span>(learning_rate=learning_rate).minimize(cost)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>定义好神经网络结构之后，初始化所有变量：</li>
</ul>
<figure class="highlight ini">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="attr">init</span> = tf.initialize_all_variables()</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>现在，创建一个会话，在会话中运行我们的神经网络。同时，使用我们已经创建好的验证集来验证我们的模型：</li>
</ul>
<figure class="highlight vim">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">with <span class="keyword">tf</span>.Session() <span class="keyword">as</span> ses<span class="variable">s:</span></div><div class="line">    # create initialized variables</div><div class="line">    sess.run(init)</div><div class="line">    </div><div class="line">    ### <span class="keyword">for</span> each epoch, <span class="keyword">do</span>:</div><div class="line">    ###   <span class="keyword">for</span> each batch, <span class="keyword">do</span>:</div><div class="line">    ###     create <span class="keyword">pre</span>-processed batch</div><div class="line">    ###     run optimizer by feeding batch</div><div class="line">    ###     <span class="keyword">find</span> cost <span class="built_in">and</span> reiterate <span class="keyword">to</span> minimize</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> epoch in <span class="built_in">range</span>(epochs):</div><div class="line">        avg_cost = <span class="number">0</span></div><div class="line">        total_batch = <span class="keyword">int</span>(train.shape[<span class="number">0</span>]/batch_size)</div><div class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(total_batch):</div><div class="line">            batch_x, batch_y = batch_creator(batch_size, train_x.shape[<span class="number">0</span>], <span class="string">'train'</span>)</div><div class="line">            _, <span class="keyword">c</span> = sess.run([optimizer, cost], feed_dict = &#123;<span class="keyword">x</span>: batch_x, <span class="keyword">y</span>: batch_y&#125;)</div><div class="line">            </div><div class="line">            avg_cost += <span class="keyword">c</span> / total_batch</div><div class="line">            </div><div class="line">        <span class="keyword">print</span> <span class="string">"Epoch:"</span>, (epoch+<span class="number">1</span>), <span class="string">"cost ="</span>, <span class="string">"&#123;:.5f&#125;"</span>.format(avg_cost)</div><div class="line">    </div><div class="line">    <span class="keyword">print</span> <span class="string">"\nTraining complete!"</span></div><div class="line">    </div><div class="line">    </div><div class="line">    # <span class="keyword">find</span> predictions <span class="keyword">on</span> val <span class="keyword">set</span></div><div class="line">    pred_temp = <span class="keyword">tf</span>.equal(<span class="keyword">tf</span>.argmax(output_layer, <span class="number">1</span>), <span class="keyword">tf</span>.argmax(<span class="keyword">y</span>, <span class="number">1</span>))</div><div class="line">    accuracy = <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.cast(pred_temp, <span class="string">"float"</span>))</div><div class="line">    <span class="keyword">print</span> <span class="string">"Validation Accuracy:"</span>, accuracy.<span class="built_in">eval</span>(&#123;<span class="keyword">x</span>: val_x.reshape(-<span class="number">1</span>, input_num_units), <span class="keyword">y</span>: dense_to_one_hot(val_y)&#125;)</div><div class="line">    </div><div class="line">    predict = <span class="keyword">tf</span>.argmax(output_layer, <span class="number">1</span>)</div><div class="line">    pred = predict.<span class="built_in">eval</span>(&#123;<span class="keyword">x</span>: test_x.reshape(-<span class="number">1</span>, input_num_units)&#125;)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>上面代码的输出如下：</p>
<figure class="highlight http">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="attribute">Epoch</span>: 1 cost = 8.93566</div><div class="line"><span class="attribute">Epoch</span>: 2 cost = 1.82103</div><div class="line"><span class="attribute">Epoch</span>: 3 cost = 0.98648</div><div class="line"><span class="attribute">Epoch</span>: 4 cost = 0.57141</div><div class="line"><span class="attribute">Epoch</span>: 5 cost = 0.44550</div><div class="line"></div><div class="line"><span class="css"><span class="selector-tag">Training</span> <span class="selector-tag">complete</span>!</span></div><div class="line"><span class="selector-tag">Validation</span> <span class="selector-tag">Accuracy</span>: 0<span class="selector-class">.952823</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>为了使用我们的眼睛来测试模型，让我们来看一些它的预测结果：</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">img_name = rng.choice(test.filename)</div><div class="line">filepath = os<span class="selector-class">.path</span><span class="selector-class">.join</span>(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'test'</span>, img_name)</div><div class="line"></div><div class="line"><span class="selector-tag">img</span> = imread(filepath, flatten=True)</div><div class="line"></div><div class="line">test_index = int(img_name.split(<span class="string">'.'</span>)[<span class="number">0</span>]) - <span class="number">49000</span></div><div class="line"></div><div class="line">print <span class="string">"Prediction is: "</span>, pred[test_index]</div><div class="line"></div><div class="line">pylab.imshow(<span class="selector-tag">img</span>, cmap=<span class="string">'gray'</span>)</div><div class="line">pylab.axis(<span class="string">'off'</span>)</div><div class="line">pylab.show()</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>Prediction is: 8</p>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/8.png" alt=""></p>
<ul>
  <li>我们看到模型的性能非常好。现在我们来创建一个子会话：</li>
</ul>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">sample_submission<span class="selector-class">.filename</span> = test<span class="selector-class">.filename</span></div><div class="line"></div><div class="line"> sample_submission<span class="selector-class">.label</span> = pred</div><div class="line"></div><div class="line">sample_submission.to_csv(os<span class="selector-class">.path</span><span class="selector-class">.join</span>(sub_dir, <span class="string">'sub01.csv'</span>), index=False)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>到现在，我们就把已经训练好的神经网络保存下来了。</p>
<h2 id="TensorFlow-的局限性"><a href="#TensorFlow-的局限性" class="headerlink" title="TensorFlow 的局限性"></a>TensorFlow 的局限性</h2>
<ul>
  <li>尽管 TensorFlow 很强大，但它依旧是一个低级库，打个比方，你可以把它看出一个机器级语言。但是大多数情况下，你需要模块化和高层次的接口，比如 keras 这样的库便能够提供。</li>
  <li>TensorFlow 目前仍然在开发中，因此未来还会有很多令人激动的东西到来。</li>
  <li>TensorFlow 依赖于你的硬件配置，硬件配置越高越好。</li>
  <li>对于许多语言，TensorFlow 还没有 API.</li>
  <li>TensorFlow 中还有许多东西需要实现，比如 OpenCL 的支持。</li>
</ul>
<p>上面提到的内容大多数是站在 TensorFlow 开发者的角度的。他们已经制定了一个路线图来说明将来这个库应该如何发展。</p>
<h2 id="TensorFlow-vs-其他库"><a href="#TensorFlow-vs-其他库" class="headerlink" title="TensorFlow vs. 其他库"></a>TensorFlow vs. 其他库</h2>
<p>TensorFlow 是以和 Theano 和 Torch 相似的原则构建的，都是使用数学计算图。但是由于具有分布式计算的支持，TensorFlow 对于解决复杂的问题表现得更好。同时，由于已经支持 TensorFlow 模型的部署（即开源免费），这使得在工业上使用更加容易，对 Deeplearning4j、H2O 和 Turi 这些商业库造成了竞争威胁。TensorFlow 有 Python、C++ 和 Matlab 的 API，接下来可能将要有对其他语言的支持，比如 Ruby 和 R。所以，TensorFlow
  正在试图成为具有普遍语言的机器学习库。</p>
<h2 id="接下来往哪走"><a href="#接下来往哪走" class="headerlink" title="接下来往哪走"></a>接下来往哪走</h2>
<p>你已经看到了如何使用 TensorFlow 来建立一个简单的神经网路。这个代码对于来理解如何开始实现 TensorFlow 是有意义的，所以不要小瞧它。但是请记住现实生活需要解决的问题将会更加复杂，你需要稍微修改一下代码。</p>
<p>上面的许多函数能够被抽象出来，以提供无缝的端到端工作流。如果你使用过 scikit-learn，那么你可能知道一个高级库是如何抽象出底层实现，然后给终端用户提供一个更加简单的接口的。虽然 TensorFlow 已经抽象出了大多数的实现，但高级库正在出现，比如 TF-slim 和 TFlearn 。</p>
<h2 id="有用的资源"><a href="#有用的资源" class="headerlink" title="有用的资源"></a>有用的资源</h2>
<ul>
  <li><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow 官方仓库</a></li>
  <li>Rajat Monga (TensorFlow 技术引导) <a href="https://youtu.be/wmw8Bbb_eIE" target="_blank" rel="external">“TensorFlow for everyone”</a> 视频</li>
  <li>一个专用资源列表](<a href="https://github.com/jtoy/awesome-tensorflow/#github-projects" target="_blank" rel="external">https://github.com/jtoy/awesome-tensorflow/#github-projects</a>)</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2>
<p>我希望你觉得这篇文章很有帮助，现在，是时候来进行更多的练习和阅读了。Good luck！如果你使用一个不同的方法/包/库来实现神经网络，那么我很愿意在评论中跟你互动。如果你有什么建议，也请在评论中告知。为了让自己对神经网络的使用更加熟练，请不要忘记尝试解决我们的深度学习练习问题 - <a href="https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-digits/" target="_blank" rel="external">数字识别</a>。</p>
<p>你可以测试你的技能和知识。查看 <a href="http://datahack.analyticsvidhya.com/contest/all" target="_blank" rel="external">Live Competitions</a>，来和世界上最优秀的数据科学家进行比赛。</p>
<blockquote>
  <p>原文链接：<a href="https://www.analyticsvidhya.com/blog/2016/10/an-introduction-to-implementing-neural-networks-using-tensorflow/" target="_blank" rel="external">https://www.analyticsvidhya.com/blog/2016/10/an-introduction-to-implementing-neural-networks-using-tensorflow/</a></p>
  <p>翻译：<a href="https://fenglv.ac.cn" target="_blank" rel="external">Flynn</a></p>
</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;如果你一直关注数据科学/机器学习，那么你肯定知道目前深度学习和神经网络非常流行。许多组织/公司都想要雇佣精通深度学习技能的人。从商业竞争到开源项目和支付高额薪水，人们在尝试一切可能的方法来挖掘这一有限的人才。自我驱动的工程师正被汽车工业中的利器所追逐，因为汽车工业正处于近几十年来最大的破坏边缘！&lt;/p&gt;
    
    </summary>
    
      <category term="Machine-Learning" scheme="http://ucasfl.me/categories/Machine-Learning/"/>
    
    
      <category term="Tensorflow translation" scheme="http://ucasfl.me/tags/Tensorflow-translation/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 中如何通过命令行开启或禁用触摸板</title>
    <link href="http://ucasfl.me/2017/11/02/How-to-enable-or-disable-touchpad-in-Linux-with-command-line/"/>
    <id>http://ucasfl.me/2017/11/02/How-to-enable-or-disable-touchpad-in-Linux-with-command-line/</id>
    <published>2017-11-02T15:45:10.000Z</published>
    <updated>2018-03-23T03:35:48.264Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在 Linux 中如何使用命令行命令来打开和关闭触摸板。</p>
<a id="more"></a>
<h3 id="xinput"><a href="#xinput" class="headerlink" title="xinput"></a>xinput</h3>
<p>首先，需要了解一个工具：<code>xinput</code></p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">xinput is <span class="selector-tag">a</span> utility to list available <span class="selector-tag">input</span> devices, query information</div><div class="line">about <span class="selector-tag">a</span> device and change <span class="selector-tag">input</span> device settings.</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>上面是 <code>man</code> 手册对它的描述。</p>
<p>要通过触摸板开启或关闭触摸板，首先要要获取触摸板的设备 ID 和属性。</p>
<p>我们可以可以先通过 <code>xinput --list</code> 命令查看有哪些输入设备。下面的结果是在我的笔记本上的输出：</p>
<figure class="highlight crmsh">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">⎡ Virtual core pointer                          <span class="attr">id=</span><span class="number">2</span>    [<span class="keyword">master</span> <span class="title">pointer</span>  (<span class="number">3</span>)]</div><div class="line">⎜   ↳ Virtual core XTEST pointer                <span class="attr">id=</span><span class="number">4</span>    [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎜   ↳ PixArt USB Optical Mouse                  <span class="attr">id=</span><span class="number">10</span>   [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎜   ↳ DELL0767:<span class="number">00</span> <span class="number">06</span>CB:<span class="number">7</span>E92 Touchpad            <span class="attr">id=</span><span class="number">12</span>   [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎜   ↳ SynPS/<span class="number">2</span> Synaptics TouchPad                <span class="attr">id=</span><span class="number">14</span>   [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎣ Virtual core keyboard                         <span class="attr">id=</span><span class="number">3</span>    [<span class="keyword">master</span> <span class="title">keyboard</span> (<span class="number">2</span>)]</div><div class="line">    ↳ Virtual core XTEST keyboard               <span class="attr">id=</span><span class="number">5</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Power Button                              <span class="attr">id=</span><span class="number">6</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Video Bus                                 <span class="attr">id=</span><span class="number">7</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Power Button                              <span class="attr">id=</span><span class="number">8</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Sleep Button                              <span class="attr">id=</span><span class="number">9</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Integrated Webcam                         <span class="attr">id=</span><span class="number">11</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ AT Translated Set <span class="number">2</span> keyboard              <span class="attr">id=</span><span class="number">13</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Dell WMI hotkeys                          <span class="attr">id=</span><span class="number">15</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ DELL Wireless hotkeys                     <span class="attr">id=</span><span class="number">16</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可以看到，第 4 行输出即为触摸板，后面的 <code>id</code> 即为设备号。</p>
<p>下面，查看触摸板的属性：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">xinput <span class="comment">--list-props 12 </span></div><div class="line">＃或</div><div class="line">xinput <span class="comment">--list-props ‘DELL0767:00 06CB:7E92 Touchpad’</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>即使用设备 <code>id</code> 或设备名作为后面的参数均可以。</p>
<p>下面是在我的笔记本上的输出：</p>
<figure class="highlight aspectj">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Device <span class="string">'DELL0767:00 06CB:7E92 Touchpad'</span>:</div><div class="line">	Device Enabled (140):	0</div><div class="line">	Coordinate Transformation Matrix (142):	1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000</div><div class="line">	Device Accel Profile (263):	1</div><div class="line">	Device Accel Constant Deceleration (264):	2.500000</div><div class="line">	Device Accel Adaptive Deceleration (265):	1.000000</div><div class="line">	Device Accel Velocity Scaling (266):	12.500000</div><div class="line">	Synaptics Edges (288):	49, 1180, 50, 879</div><div class="line">	Synaptics Finger (289):	25, 30, 0</div><div class="line">	Synaptics Tap Time (290):	180</div><div class="line">	Synaptics Tap Move (291):	67</div><div class="line">	Synaptics Tap Durations (292):	180, 180, 100</div><div class="line">	Synaptics ClickPad (293):	1</div><div class="line">	Synaptics Middle Button Timeout (294):	0</div><div class="line">	Synaptics Two-Finger Pressure (295):	282</div><div class="line">	Synaptics Two-Finger Width (296):	7</div><div class="line">	Synaptics Scrolling Distance (297):	30, 30</div><div class="line">	Synaptics Edge Scrolling (298):	0, 0, 0</div><div class="line">	Synaptics Two-Finger Scrolling (299):	1, 1</div><div class="line">	Synaptics Move Speed (300):	1.000000, 1.750000, 0.129870, 0.000000</div><div class="line">	Synaptics Off (301):	0</div><div class="line">	Synaptics Locked Drags (302):	0</div><div class="line">	Synaptics Locked Drags Timeout (303):	5000</div><div class="line">	Synaptics Tap Action (304):	2, 3, 0, 0, 1, 3, 2</div><div class="line">	Synaptics Click Action (305):	1, 3, 0</div><div class="line">	Synaptics Circular Scrolling (306):	0</div><div class="line">	Synaptics Circular Scrolling Distance (307):	0.100000</div><div class="line">	Synaptics Circular Scrolling Trigger (308):	0</div><div class="line">	Synaptics Circular Pad (309):	0</div><div class="line">	Synaptics Palm Detection (310):	0</div><div class="line">	Synaptics Palm Dimensions (311):	10, 200</div><div class="line">	Synaptics Coasting Speed (312):	20.000000, 50.000000</div><div class="line">	Synaptics Pressure Motion (313):	30, 160</div><div class="line">	Synaptics Pressure Motion Factor (314):	1.000000, 1.000000</div><div class="line">	Synaptics Resolution Detect (315):	1</div><div class="line">	Synaptics Grab Event Device (316):	0</div><div class="line">	Synaptics Gestures (317):	1</div><div class="line">	Synaptics Capabilities (318):	1, 0, 0, 1, 1, 0, 0</div><div class="line">	Synaptics Pad Resolution (319):	12, 12</div><div class="line">	Synaptics Area (320):	0, 0, 0, 0</div><div class="line">	Synaptics Soft Button Areas (321):	614, 0, 761, 0, 0, 0, 0, 0</div><div class="line">	Synaptics Noise Cancellation (322):	7, 7</div><div class="line">	Device Product ID (258):	1739, 32402</div><div class="line">	Device Node (259):	<span class="string">"/dev/input/event15"</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可以看到，第一个属性即为触摸板状态：1 表示开启，0 表示关闭，属性编号为 140。</p>
<p>之后，我们可以使用下面的命令来开启或关闭触摸板：</p>
<figure class="highlight dsconfig">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment"># 开启触摸板</span></div><div class="line"><span class="string">xinput </span><span class="built_in">set-prop</span> <span class="string">12 </span><span class="string">140 </span>1</div><div class="line"><span class="comment"># 关闭触摸板</span></div><div class="line"><span class="string">xinput </span><span class="built_in">set-prop</span> <span class="string">12 </span><span class="string">140 </span>0</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>其中，设备 ID 和属性编号也可替换为名字。</p>
<p>但是，每次都使用这个命令会比较麻烦，因此，可以通过一个简单的脚本来实现：</p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"on"</span> ]; <span class="keyword">then</span></div><div class="line">	xinput <span class="built_in">set</span>-prop 12 140 1;</div><div class="line">	<span class="built_in">echo</span> <span class="string">"Touchpad successfully enabled!"</span>;</div><div class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"off"</span> ]; <span class="keyword">then</span></div><div class="line">	xinput <span class="built_in">set</span>-prop 12 140 0;</div><div class="line">	<span class="built_in">echo</span> <span class="string">"Touchpad successfully disabled!"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"Please use the program with one of the following arguments:"</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"   (1) on  : enable the touchpad!"</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"   (2) off : disable the touchpad!"</span></div><div class="line"><span class="keyword">fi</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>将该脚本命名为 <code>touchpad</code> ，然后放到 <code>/home/user/bin</code> 目录下。然后，开启或关闭触摸板就很方便了：</p>
<figure class="highlight nginx">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment"># 开启触摸板</span></div><div class="line"><span class="attribute">touchpad</span> <span class="literal">on</span></div><div class="line"><span class="comment"># 关闭触摸板</span></div><div class="line">touchpad <span class="literal">off</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>注意，脚本中的设备 ID 和属性编号应和你的笔记本一致，<code>user</code> 为你的用户名。</p>
<h3 id="gsettings"><a href="#gsettings" class="headerlink" title="gsettings"></a>gsettings</h3>
<p>另外，如果上面的命令不起用了，那么可以试试(Gnome)：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">开启触摸板:</div><div class="line">sudo gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.desktop</span><span class="selector-class">.peripherals</span><span class="selector-class">.touchpad</span> send-events true</div><div class="line">输入时禁用：</div><div class="line">sudo gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.desktop</span><span class="selector-class">.peripherals</span><span class="selector-class">.touchpad</span> disable-while-typing true</div><div class="line">双指滚动</div><div class="line">sudo gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.desktop</span><span class="selector-class">.peripherals</span><span class="selector-class">.touchpad</span> disable-while-typing true</div><div class="line">tap to click:</div><div class="line">sudo gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.desktop</span><span class="selector-class">.peripherals</span><span class="selector-class">.touchpad</span> tap-to-click true</div></pre>
      </td>
    </tr>
  </table>
</figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何在 Linux 中如何使用命令行命令来打开和关闭触摸板。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux touchpad" scheme="http://ucasfl.me/tags/Linux-touchpad/"/>
    
  </entry>
  
  <entry>
    <title>记一下那些年使用 Linux 踩过的坑</title>
    <link href="http://ucasfl.me/2017/10/30/What-the-fuck-problem-with-Linux/"/>
    <id>http://ucasfl.me/2017/10/30/What-the-fuck-problem-with-Linux/</id>
    <published>2017-10-30T11:54:31.000Z</published>
    <updated>2019-02-22T13:57:45.028Z</updated>
    
    <content type="html"><![CDATA[<p>笔记本上装了双系统：Windows 10 + Ubuntu，刚装好 Ubuntu 不久就重新从 Windows 下分了一个盘挂载到 Ubuntu 下。如今，由于基本不再使用 Windows 系统，准确的说就只在虚拟机上使用一下 QQ、微信。于是，我又从 Windows 下分出一个盘，准备挂载到 Ubuntu 下。然而，却突然启动不进去了，直接进入了 <code>emergency mode</code>，尝试重新启动到默认模式，然后出现下面的错误信息：</p>
<a id="more"></a>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">[   84.260812] EXT4-fs (sda7): VFS: can&apos;t find ext4 filesystem.</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>错误信息很直接，说<code>sda7</code>不是<code>ext4</code>文件系统格式。</p>
<p>然后查看分区：<code>fdisk -l</code>，输出如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors</div><div class="line">Units: sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</div><div class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</div><div class="line">Disklabel type: gpt</div><div class="line">Disk identifier: A3FE2E3C-3EBC-401D-8BB3-987D9B33F0EC</div><div class="line"></div><div class="line">Device          Start        End   Sectors   Size Type</div><div class="line">/dev/sda1        2048    1026047   1024000   500M EFI System</div><div class="line">/dev/sda2     1026048    1288191    262144   128M Microsoft reserved</div><div class="line">/dev/sda3     1288192  284209819 282921628 134.9G Microsoft basic data</div><div class="line">/dev/sda4   284211200  508033023 223821824 106.7G Microsoft basic data</div><div class="line">/dev/sda5   508035072  949225471 441190400 210.4G Linux filesystem</div><div class="line">/dev/sda6   949225472  965793791  16568320   7.9G Linux swap</div><div class="line">/dev/sda7   965793792 1298845695 333051904 158.8G Microsoft basic data</div><div class="line">/dev/sda8  1298845696 1718274047 419428352   200G Linux filesystem</div><div class="line">/dev/sda9  1718276096 1927991295 209715200   100G Microsoft basic datamount -o remount,rw /</div><div class="line">mount --all</div><div class="line">chown root:root /usr/bin/sudo</div><div class="line">chmod 4755 /usr/bin/sudo</div><div class="line">/dev/sda10 1927993344 1928998911   1005568   491M Windows recovery environment</div><div class="line">/dev/sda11 1928998912 1951117311  22118400  10.6G Windows recovery environment</div><div class="line">/dev/sda12 1951119360 1953523711   2404352   1.2G Windows recovery environment</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>What ? <code>/dev/sd7</code> 是 Windows 系统的 C 盘，怎么它会在启动的时候挂载呢，而且还是以 <code>ext4</code> 的文件系统格式挂载。想了半天，没发现问题。还好，机智的我赶紧看了一下 <code>/etc/fstab</code> 文件内容：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"># /etc/fstab: static file system information.</div><div class="line">#</div><div class="line"># Use &apos;blkid&apos; to print the universally unique identifier for a</div><div class="line"># device; this may be used with UUID= as a more robust way to name devices</div><div class="line"># that works even if disks are added and removed. See fstab(5).</div><div class="line">#</div><div class="line"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</div><div class="line"># / was on /dev/sda9 during installation</div><div class="line">UUID=e3a38d48-680a-49e5-a98f-ae8bb6a37293 /               ext4    errors=remount-ro 0       1</div><div class="line"># /boot/efi was on /dev/sda1 during installation</div><div class="line">UUID=FE51-6D32  /boot/efi       vfat    umask=0077      0       1</div><div class="line"># swap was on /dev/sda10 during installation</div><div class="line">UUID=c6a51fbb-d72a-4d93-9305-b75aaf6ab1fa none            swap    sw              0       0</div><div class="line">dev/sda7 home/fenglv/FILE ext4 defaults 0 1</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>？？？原来之前挂载到 Ubuntu 上的盘设备名就是 <code>/dev/sda7</code> ，添加一个新的分区后设备名变为了 <code>/dev/sda8</code>，现在的 <code>/dev/sda7</code> 对应的就是 Windows 系统的 C 盘。而我没有修改 <code>/etc/fstab</code> ，所以才导致 Linux 系统启动的时候无法将该设备挂载上。</p>
<p>修改之后终于正常启动了。</p>
<p>然而事情并没有结束。之后，<code>sudo</code> 不能使用了，错误信息如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">sudo: error in /etc/sudo.conf, line 0 while loading plugin `sudoers_policy&apos;</div><div class="line">sudo: /usr/lib/sudo/sudoers.so must be only be writable by owner</div><div class="line">sudo: fatal error, unable to load plugins</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>好吧，直接上网查。最后在 <a href="https://askubuntu.com/questions/637432/sudo-comes-up-with-an-error-cannot-run-anything-as-root" target="_blank" rel="external">askubunntu</a> 上找到了解决办法：启动到 <code>recovery mode</code> ，然后执行下面的命令：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">mount -o remount,rw /</div><div class="line">chmod 644 /usr/lib/sudo/sudoers.so</div><div class="line">chown -R root /usr/lib/sudo</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>至此，全部问题解决。</p>
<p>问题并没有真的结束（文章更新），之后，virtualbox 不能启动了：</p>
<figure class="highlight vim">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">VBoxHeadles<span class="variable">s:</span> Effective UID <span class="keyword">is</span> not root (euid=<span class="number">1000</span> egid=<span class="number">1000</span> uid=<span class="number">1000</span> gid=<span class="number">1000</span>)</div><div class="line">VBoxHeadles<span class="variable">s:</span> Tip! It may <span class="keyword">help</span> <span class="keyword">to</span> reinstall VirtualBox.</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>正确的做法就是按照它的提示把 virtualbox 卸了重新安装。然而，我却去修改<code>/usr/bin</code>的所有者：<code>chown -R root /usr/bin</code> 。这样以后，不但 <code>virtual box</code> 无法启动，<code>sudo</code> 又不能用了，这次的错误信息如下：</p>
<figure class="highlight armasm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="symbol">sudo</span>: /usr/<span class="keyword">bin/sudo </span>must <span class="keyword">be </span>owned <span class="keyword">by </span>uid <span class="number">0</span> <span class="keyword">and </span>have the setuid <span class="keyword">bit </span>set</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>最后找到解决办法：再次进入 <code>recovery mode</code>，执行下面命令：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">mount -o remount,rw /</div><div class="line">mount --all</div><div class="line">chown root:root /usr/bin/sudo</div><div class="line">chmod 4755 /usr/bin/sudo</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>问题解决。</p>
<p>Linux 的权限问题真让人头疼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记本上装了双系统：Windows 10 + Ubuntu，刚装好 Ubuntu 不久就重新从 Windows 下分了一个盘挂载到 Ubuntu 下。如今，由于基本不再使用 Windows 系统，准确的说就只在虚拟机上使用一下 QQ、微信。于是，我又从 Windows 下分出一个盘，准备挂载到 Ubuntu 下。然而，却突然启动不进去了，直接进入了 &lt;code&gt;emergency mode&lt;/code&gt;，尝试重新启动到默认模式，然后出现下面的错误信息：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 主机和 Vbox 下的 Windows 虚拟机创建共享文件夹</title>
    <link href="http://ucasfl.me/2017/10/28/Linux-host-create-share-folder-with-windows-vbox/"/>
    <id>http://ucasfl.me/2017/10/28/Linux-host-create-share-folder-with-windows-vbox/</id>
    <published>2017-10-28T06:42:12.000Z</published>
    <updated>2018-03-11T04:03:08.595Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 下，难免会使用一些 Windows 的软件，此时其中一个选择就是安装虚拟机。下面将阐述如何在 Linux 主机下创建一个和 VirtualBox 下的 Windows 虚拟机的共享文件夹。</p>
<a id="more"></a>
<p>首先确保安装好虚拟机。</p>
<p>第一步，启动虚拟机，点击左上方工具栏 -&gt; 安装增加功能 -&gt; 按照提示安装成功即可。</p>
<p>第一步，打开虚拟机设置 -&gt; 共享文件夹 -&gt; 添加路径 -&gt; 设置共享文件夹名字（假设名字为 Win7，后面会用到。）</p>
<p>第三步，重启虚拟机 -&gt; 打开 cmd -&gt; 输入命令 <code>net use x: \\vboxsvr\Win7</code> 即可。其中 <code>x</code> 为盘符，任意一个未使用的字母均可以，<code>Win7</code> 即为上面设置的共享文件夹名字。</p>
<p>这样，在主机和虚拟机之间就创建了一个共享文件夹。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 下，难免会使用一些 Windows 的软件，此时其中一个选择就是安装虚拟机。下面将阐述如何在 Linux 主机下创建一个和 VirtualBox 下的 Windows 虚拟机的共享文件夹。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 编程风格</title>
    <link href="http://ucasfl.me/2017/10/26/Pythonic-programming-tricks/"/>
    <id>http://ucasfl.me/2017/10/26/Pythonic-programming-tricks/</id>
    <published>2017-10-26T04:10:08.000Z</published>
    <updated>2018-06-13T05:38:38.158Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录在学习过程掌握/学习到的一些 Python 编程的奇技淫巧，即如何写 Pythonic 的 Python 代码。因此，文章将会持续更新，更新时间不限。由于本人知识有限，文中难免会出现不足或错误的地方。文中提到的方法适用于 Python 3，对于 Python 2 不一定完全适用。</p>
<p>2018 年 6 月 13 日更新。</p>
<a id="more"></a>
<h3 id="多变量赋值"><a href="#多变量赋值" class="headerlink" title="多变量赋值"></a>多变量赋值</h3>
<p>变量赋值是编程语言里面最简单的语句之一，通常情况下，我们会这样做：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">a = <span class="number">1</span></div><div class="line">b = <span class="number">2</span></div><div class="line">c = <span class="number">3</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>这样便完成了对三个变量的赋值，但你可以用更简单的方式：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="元素值交换"><a href="#元素值交换" class="headerlink" title="元素值交换"></a>元素值交换</h3>
<p>在编程过程中，交换两个变量的值是非常常见的。一般情况下，我们会用下面这种方式来交换两个变量的值（尤其是对于第一门语言是C/C++的人来说）：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">t = a</div><div class="line">a = b</div><div class="line">b = t</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>这种方式是正确的，没有人敢说它不对，但事实上，在 Python 里，你可以有更简单的方式来完成这件事：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">a, b = b, a</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>没错，一行语句就够了。</p>
<p>对上面两个技巧的解释：在 Python 中，任何以逗号分隔的对象均被当作元组处理，因此<code>1, 2, 3</code>　实际上就是一个元组<code>(1, 2, 3)</code>，赋值过程可以看成是元组的解包 。交换值也是同样的，它相当于把等号右边的元组解包后赋值给了左边的变量。为了提高代码的可读性，上面的例子可以加上括号：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = (<span class="selector-tag">b</span>, a)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="循环遍历区间元素"><a href="#循环遍历区间元素" class="headerlink" title="循环遍历区间元素"></a>循环遍历区间元素</h3>
<p>你可以这样：<br>
  <figure class="highlight stylus">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] :</div><div class="line">	print(i)</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>但更好的方法是：<br>
  <figure class="highlight ada">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">6</span>) :</div><div class="line">	<span class="type">print</span>(i)</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>值得一提的是, <code>range</code> 返回的是生成器对象，生成器比列表更加节省内存。</p>
<h3 id="带有索引位置的集合遍历"><a href="#带有索引位置的集合遍历" class="headerlink" title="带有索引位置的集合遍历"></a>带有索引位置的集合遍历</h3>
<p>遍历集合时，如果需要索引信息，直接迭代是没有的，普通的方式是：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">peoples = [<span class="string">'Tim'</span>, <span class="string">'Bob'</span>, <span class="string">'Ada'</span>]</div><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(peoples)) :</div><div class="line">	print(<span class="selector-tag">i</span>, <span class="string">'---&gt;'</span>, peoples[i])</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>但你还可以这样：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span>, people <span class="keyword">in</span> enumerate(peoples) :</div><div class="line">	print(<span class="selector-tag">i</span>, <span class="string">'---&gt;'</span>, people)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3>
<p>普通方式可以用 <code>+</code> 操作：<br>
  <figure class="highlight stylus">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
        </td>
        <td class="code">
          <pre><div class="line">strs = [<span class="string">'I'</span>, <span class="string">'Love'</span>, <span class="string">'You'</span>]</div><div class="line">s = strs[<span class="number">0</span>]</div><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> strs[<span class="number">1</span>: ]:</div><div class="line">	s += <span class="string">' '</span> + <span class="selector-tag">i</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(s)</span></span></div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>但你还可以使用 <code>join</code> 方法：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">' '</span>.join(strs)</span></span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>与 <code>join</code> 相对应的就是 <code>split</code> 方法，<code>split</code> 方法通过指定分隔符参数来分割字符串，默认为空白符：<br>
  <figure class="highlight ini">
    <table>
      <tr>
        <td class="gutter">
          <pre><div class="line">1</div><div class="line">2</div></pre>
        </td>
        <td class="code">
          <pre><div class="line"><span class="attr">s</span> = <span class="string">'I love you'</span></div><div class="line"><span class="attr">l</span> = s.split() # l = [<span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'you'</span>]</div></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>此外，<code>split</code> 方法还有一个用法。我们知道，在 Python 中，从键盘输入时，<code>input()</code> 方法会读取一整行输入，然后返回一个字符串，如果想要在同一行输入多个整数并赋值给多个对象，那么 <code>split()</code> 方法就派上用场了：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = input().split()</div><div class="line"><span class="selector-tag">a</span> = int(a)</div><div class="line"><span class="selector-tag">b</span> = int(b)</div><div class="line">c = int(c)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>这样，就可以在同一行输入三个整数，然后分别赋值给 a, b, c，当然，此时，仍然是字符串，如果要作为整数使用，那么，使用 <code>int()</code> 转化一下即可。</p>
<h3 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h3>
<p>假设 <code>list1</code> 是一个字符串组成的列表，现在，需要把 <code>list1</code> 中的每一个字符串的每一个小写字母找出来，形成一个新的元组。一般情况下，我们可以这样做：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list1 = [<span class="string">'adg'</span>, <span class="string">'Adf'</span>, <span class="string">'124'</span>]</div><div class="line">list2 = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</div><div class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> i:</div><div class="line">    <span class="keyword">if</span> j &gt;= <span class="string">'a'</span> <span class="keyword">and</span> j &lt;= <span class="string">'z'</span>:</div><div class="line">      list2.append(j)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>但实际上，你只需要用一个语句就可以完成这件事：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list2 = [j <span class="keyword">for</span> i <span class="keyword">in</span> list1 <span class="keyword">for</span> j <span class="keyword">in</span> i <span class="keyword">if</span> j &gt;= <span class="string">'a'</span> <span class="keyword">and</span> j &lt;= <span class="string">'z'</span>]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>没错，Python 就是这么简洁。如果把上面的方括号换成圆括号，那么结果返回的就是一个迭代器，可以使用 <code>next()</code> 方法获取元素：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list2 = (j <span class="keyword">for</span> i <span class="keyword">in</span> list1 <span class="keyword">for</span> j <span class="keyword">in</span> i <span class="keyword">if</span> j &gt;= <span class="string">'a'</span> <span class="keyword">and</span> j &lt;= <span class="string">'z'</span>)</div><div class="line">list2.next() <span class="comment"># 返回'a'</span></div><div class="line">list2.next() <span class="comment"># 返回'd'</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h3>
<p>函数的多个参数可通过一个元组传递，假设有如下函数：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">(x, y)</span>:</span></div><div class="line">  <span class="keyword">return</span> x + y</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可重新定义为：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">(*params)</span>:</span></div><div class="line">  <span class="keyword">return</span> params[<span class="number">0</span>] + params[<span class="number">1</span>]</div><div class="line"><span class="comment">#传递参数</span></div><div class="line">add2(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="comment">#或</span></div><div class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">add2(*tuple1)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>使用双星号则可以传递一个字典：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">with_star</span><span class="params">(**kwds)</span>:</span></div><div class="line">  print(kwds[<span class="string">'name'</span>], <span class="string">' is '</span>, kwds[<span class="string">'age'</span>] ,<span class="string">' years old.'</span>)</div><div class="line">args = &#123;<span class="string">'name'</span> : <span class="string">'Mrs. GUmby'</span>, <span class="string">'age'</span> : <span class="number">42</span>&#125;</div><div class="line">with_star(**args)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="使用两个列表创建字典"><a href="#使用两个列表创建字典" class="headerlink" title="使用两个列表创建字典"></a>使用两个列表创建字典</h3>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">list2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line">d = dict(zip(list1, list2))</div><div class="line">list1 == list(d.keys())</div><div class="line">list2 == list(d.values())</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3>
<p>多态意味着就算不知道变量所引用的对象类型是什么，也可以对它进行操作，看下面的函数：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span> <span class="params">(a, b)</span>:</span></div><div class="line">  <span class="keyword">return</span> a + b</div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 返回３</span></div><div class="line">add(<span class="string">'ab'</span>, <span class="string">'cd'</span>) <span class="comment"># 返回'abcd'</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>很多函数和运算符都是多态的，因此写程序时也应该尽量避免破坏多态，尽量不使用 <code>type, isinstance, issubclass</code> 之类会破坏多态的函数。</p>
<p>多态是 Python 式编程的核心，也被称为 “duck typing”。</p>
<h3 id="打开-关闭文件"><a href="#打开-关闭文件" class="headerlink" title="打开/关闭文件"></a>打开/关闭文件</h3>
<p>执行文件操作时，一定不能忘记 <code>close()</code>，即使代码出错，普遍的方法是在 <code>finally</code> 块中显示的调用 <code>close</code> 方法：</p>
<figure class="highlight livecodeserver">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">f = <span class="built_in">open</span>(<span class="string">'data.txt'</span>)</div><div class="line"><span class="keyword">try</span> :</div><div class="line">	data = f.<span class="built_in">read</span>()</div><div class="line"><span class="keyword">finally</span> :</div><div class="line">	f.<span class="built_in">close</span>()</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>但更简介的方法是：</p>
<figure class="highlight haskell">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="title">with</span> open('<span class="class"><span class="keyword">data</span>.txt') as f :</span></div><div class="line">	<span class="class"><span class="keyword">data</span> = f.read()</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>使用 <code>with</code> 语句，系统会在执行完文件操作之后自动关闭文件对象。</p>
<h3 id="合理使用列表"><a href="#合理使用列表" class="headerlink" title="合理使用列表"></a>合理使用列表</h3>
<p>列表对象是一个查询效率高但更新效率低的数据结构。比如删除元素和插入元素的时候执行效率非常低，需要对剩下的元素进行移动。</p>
<figure class="highlight vim">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">people = [<span class="string">'xiaoming'</span>, <span class="string">'xiaohong'</span>, <span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>]</div><div class="line">people.<span class="keyword">pop</span>(<span class="number">0</span>)</div><div class="line">people.<span class="keyword">insert</span>(<span class="number">0</span>, <span class="string">'lihua'</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>更好的方法是使用 <code>deque</code>:</p>
<figure class="highlight xl">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">from collections <span class="keyword">import</span> deque</div><div class="line"><span class="keyword">name</span> = deque([<span class="string">'xiaoming'</span>, <span class="string">'xiaohong'</span>, <span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>])</div><div class="line"><span class="keyword">name</span>.popleft()</div><div class="line"><span class="keyword">name</span>.appendleft(<span class="string">'lihua'</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><code>deque</code> 是一个双向队列的数据结构，删除元素和插入元素会很快。</p>
<h3 id="遍历字典中的-key-和-value"><a href="#遍历字典中的-key-和-value" class="headerlink" title="遍历字典中的 key 和 value"></a>遍历字典中的 key 和 value</h3>
<p>普通方法：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">d = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d :</div><div class="line">	<span class="type">print</span>(k, '<span class="comment">---&gt;', d[k])</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>该方法效率较低，因为每次都需要重新进行 hash 查找 key 对应的 value 。</p>
<p>高效的方法是：</p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</div><div class="line">	<span class="built_in">print</span>(k, <span class="string">'---&gt;'</span>, d[k])</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><code>items</code> 返回迭代器对象，效率高，且节省内存。</p>
<h3 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h3>
<p>学了那么久 Python，最近才知道 Python 居然支持大多数编程语言都不支持的链式比较：</p>
<p>常规方法：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">age = <span class="number">18</span></div><div class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> <span class="keyword">and</span> age &lt; <span class="number">60</span> :</div><div class="line">	<span class="type">print</span>(<span class="symbol">'young</span> man')</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>事实上，在 Python 中，你可以这样写：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">if</span> <span class="number">18</span> &lt; age &lt; <span class="number">60</span> :</div><div class="line">	<span class="type">print</span>(<span class="symbol">'young</span> man')</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>理解了链式比较操作，那么你也就明白了下面这行代码为什么会返回 <code>False</code> :</p>
<figure class="highlight ini">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="attr">True</span> == <span class="literal">True</span> == <span class="literal">False</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="if-else-三目运算"><a href="#if-else-三目运算" class="headerlink" title="if/else 三目运算"></a>if/else 三目运算</h3>
<p>常规：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">if</span> gender == <span class="symbol">'male</span>' :</div><div class="line">	<span class="type">text</span> = <span class="symbol">'man</span>'</div><div class="line"><span class="keyword">else</span> :</div><div class="line">	<span class="type">text</span> = <span class="symbol">'women</span>'</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>pythonic:</p>
<figure class="highlight arduino">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="built_in">text</span> = <span class="string">'man'</span> <span class="built_in">if</span> gender == <span class="string">'male'</span> <span class="built_in">else</span> <span class="string">'women'</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="for-else-while-else-语句"><a href="#for-else-while-else-语句" class="headerlink" title="for/else, while/else 语句"></a>for/else, while/else 语句</h3>
<p><code>for/else, while/else</code> 语句是 Python 中最迷惑人的语法：如果以正常方式退出循环(非 <code>break&#39;, 非</code>return<code>, 程序异常)，那么</code>else` 分支将执行：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">10</span>) :</div><div class="line">	<span class="type">if</span> i == <span class="number">5</span> :</div><div class="line">		<span class="type">break</span></div><div class="line"><span class="keyword">else</span> :</div><div class="line">	<span class="type">print</span>(<span class="string">"hello, world."</span>) # 无输出</div></pre>
      </td>
    </tr>
  </table>
</figure>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">10</span>) :</div><div class="line">	<span class="type">print</span>(i)</div><div class="line"><span class="keyword">else</span> :</div><div class="line">	<span class="type">print</span>(<span class="string">"hello, world."</span>) # 有输出</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>当然，上面说到的例子没什么用，看下面一个：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">found = <span class="literal">false</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist :</div><div class="line">	<span class="type">if</span> i == theflag :</div><div class="line">		<span class="type">found</span> = <span class="literal">True</span></div><div class="line">		break</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> found :</div><div class="line">	<span class="type">print</span>(<span class="string">"Not found."</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>使用 <code>for/else</code> :</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> mylist :</div><div class="line">	<span class="keyword">if</span> <span class="selector-tag">i</span> == theflag :</div><div class="line">		break</div><div class="line"><span class="keyword">else</span> :</div><div class="line">	print(<span class="string">"Not found."</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录在学习过程掌握/学习到的一些 Python 编程的奇技淫巧，即如何写 Pythonic 的 Python 代码。因此，文章将会持续更新，更新时间不限。由于本人知识有限，文中难免会出现不足或错误的地方。文中提到的方法适用于 Python 3，对于 Python 2 不一定完全适用。&lt;/p&gt;
&lt;p&gt;2018 年 6 月 13 日更新。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ucasfl.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://ucasfl.me/tags/Python/"/>
    
  </entry>
  
</feed>
